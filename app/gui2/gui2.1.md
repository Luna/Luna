Source code edits are not currently easy in GUI2, and the implementation is currently broken. We could fix the current design, but not without increasing the complexity of the implementation. An alternative design could provide a better interface for application logic to build on and isolate the necessary complexity to a few independent mechanisms, improving development speed and application reliability.

The IDE must support graph-driven edits and text edits (codemirror, external file changes); this implies multiple representations of the edited program. To achieve consistent behavior, we choose a representation to use as the single source of truth. Currently, in GUI2 (as in GUI1) we use text as this canonical representation. At one time this design was well-suited to the architecture of GUI1. However, as the IDE has become more advanced our paradigm has shifted. Edits have gone from being essentially textual to being tree-driven. Translating tree edits to text edits is complex: maintaining the ID map correctly is difficult; text-pasting tree construction is messy; `Y.Text` conflict resolution is wrong for our purposes. To better support the modern widget-tree model of node edits, **we should change to a tree-structured canonical representation of programs**.

The parser-produced `Tree`s are not suitable for this working representation. The parser output describes the source code syntactically. It does so efficiently; it also provides a lot of redundant information for convenience (i.e. for each node it provides a span, which is equivalent to the recursive sum of the node's tokens). These goals of efficiency and convenient analysis are at odds with editability, which is a core requirement for the GUI. We are missing a step to reconcile them: **We should translate the parser's `Tree` to a GUI-specific representation.** Currently, we extend `Tree` by wrapping it. This bridges the gap partway, but cannot provide editability--for that, we must perform all our analysis up front and throw away the parsed `Tree` objects.

When we have an IDE-optimized tree structure, we can use it for GUI edits, and to synchronize the node graph. Tree edits can be kept simple by ensuring all data referenced by the tree is logically owned by the tree. (I.e. we should avoid the need to update external data structures in tandem, such as the id map and the document source.) Correct CRDT synchronization should be achieved mainly by careful selection of the concrete representation of the frontend AST graph. Text edits will take on some of the complexity that we are eliminating from node edits, as ID maps now needs to be maintained through text edits instead of for node edits. However, the diff algorithm that will support this is fairly straightforward. As a side-benefit, it will enable us to repair the metadata map after raw text edits.

I will post a PR to the design repo shortly, going into more detail on a design that will meet these goals.
