var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// ../ide-desktop/lib/project-manager-shim/src/projectManagement.ts
import * as crypto from "node:crypto";
import * as fs from "node:fs";
import * as os from "node:os";
import * as pathModule from "node:path";
import * as tar from "tar";
import * as common from "enso-common";
import * as buildUtils from "enso-common/src/buildUtils";
async function uploadBundle(bundle, directory, name = null) {
  directory ??= getProjectsDirectory();
  logger.log(`Uploading project from bundle${name != null ? ` as '${name}'` : ""}.`);
  const targetPath = generateDirectoryName(name ?? "Project", directory);
  fs.mkdirSync(targetPath, { recursive: true });
  await new Promise((resolve2) => {
    bundle.pipe(tar.extract({ cwd: targetPath })).on("finish", resolve2);
  });
  const entries = fs.readdirSync(targetPath);
  const firstEntry = entries[0];
  if (entries.length === 1 && firstEntry != null) {
    if (fs.statSync(pathModule.join(targetPath, firstEntry)).isDirectory()) {
      const temporaryDirectoryName = targetPath + `_${crypto.randomUUID().split("-")[0] ?? ""}`;
      fs.renameSync(targetPath, temporaryDirectoryName);
      fs.renameSync(pathModule.join(temporaryDirectoryName, firstEntry), targetPath);
      fs.rmdirSync(temporaryDirectoryName);
    }
  }
  return bumpMetadata(targetPath, name ?? null);
}
function isProjectMetadata(value) {
  return typeof value === "object" && value != null && "id" in value && typeof value.id === "string";
}
function updatePackageName(projectRoot, name) {
  const path2 = pathModule.join(projectRoot, PACKAGE_METADATA_RELATIVE_PATH);
  const contents = fs.readFileSync(path2, { encoding: "utf-8" });
  const newContents = contents.replace(/^name: .*/, `name: ${name}`);
  fs.writeFileSync(path2, newContents);
}
function createMetadata() {
  return {
    id: generateId(),
    kind: "UserProject",
    created: (/* @__PURE__ */ new Date()).toISOString(),
    lastOpened: (/* @__PURE__ */ new Date()).toISOString()
  };
}
function getMetadata(projectRoot) {
  const metadataPath = pathModule.join(projectRoot, PROJECT_METADATA_RELATIVE_PATH);
  try {
    const jsonText = fs.readFileSync(metadataPath, "utf8");
    const metadata2 = JSON.parse(jsonText);
    return isProjectMetadata(metadata2) ? metadata2 : null;
  } catch {
    return null;
  }
}
function writeMetadata(projectRoot, metadata2) {
  const metadataPath = pathModule.join(projectRoot, PROJECT_METADATA_RELATIVE_PATH);
  fs.mkdirSync(pathModule.dirname(metadataPath), { recursive: true });
  fs.writeFileSync(metadataPath, JSON.stringify(metadata2, null, buildUtils.INDENT_SIZE));
}
function updateMetadata(projectRoot, updater) {
  const metadata2 = getMetadata(projectRoot);
  const updatedMetadata = updater(metadata2 ?? createMetadata());
  writeMetadata(projectRoot, updatedMetadata);
  return updatedMetadata;
}
function generateDirectoryName(name, directory = getProjectsDirectory()) {
  name = pathModule.parse(name).name;
  const matches = name.match(/^(.*)_(\d+)$/);
  const initialSuffix = -1;
  let suffix = initialSuffix;
  const [matchedName, matchedSuffix] = matches?.slice(1) ?? [];
  if (typeof matchedName !== "undefined" && typeof matchedSuffix !== "undefined") {
    name = matchedName;
    suffix = parseInt(matchedSuffix);
  }
  let finalPath;
  while (true) {
    suffix++;
    const newName = `${name}${suffix === 0 ? "" : `_${suffix}`}`;
    const candidatePath = pathModule.join(directory, newName);
    if (!fs.existsSync(candidatePath)) {
      finalPath = candidatePath;
      break;
    }
  }
  return finalPath;
}
function getProjectsDirectory() {
  return pathModule.join(os.homedir(), "enso", "projects");
}
function generateId() {
  return crypto.randomUUID();
}
function bumpMetadata(projectRoot, name) {
  if (name != null) {
    updatePackageName(projectRoot, name);
  }
  return updateMetadata(projectRoot, (metadata2) => ({
    ...metadata2,
    id: generateId(),
    lastOpened: (/* @__PURE__ */ new Date()).toISOString()
  })).id;
}
var logger, PACKAGE_METADATA_RELATIVE_PATH, PROJECT_METADATA_RELATIVE_PATH;
var init_projectManagement = __esm({
  "../ide-desktop/lib/project-manager-shim/src/projectManagement.ts"() {
    "use strict";
    logger = console;
    PACKAGE_METADATA_RELATIVE_PATH = "package.yaml";
    PROJECT_METADATA_RELATIVE_PATH = ".enso/project.json";
  }
});

// ../ide-desktop/lib/project-manager-shim/src/projectManagerShimMiddleware.ts
var projectManagerShimMiddleware_exports = {};
__export(projectManagerShimMiddleware_exports, {
  FileSystemEntryType: () => FileSystemEntryType,
  default: () => projectManagerShimMiddleware
});
import * as fs2 from "node:fs/promises";
import * as fsSync from "node:fs";
import * as os2 from "node:os";
import * as path from "node:path";
import * as tar2 from "tar";
import * as yaml from "file:///C:/Projects/enso/enso/node_modules/.pnpm/yaml@2.4.1/node_modules/yaml/dist/index.js";
import * as common2 from "enso-common";
function projectManagerShimMiddleware(request, response, next) {
  const requestUrl = request.url;
  const requestPath = requestUrl?.split("?")[0]?.split("#")[0];
  if (request.method === "POST") {
    switch (requestPath) {
      case "/api/upload-file": {
        const url = new URL(`https://example.com/${requestUrl}`);
        const fileName = url.searchParams.get("file_name");
        const directory = url.searchParams.get("directory") ?? PROJECTS_ROOT_DIRECTORY;
        if (fileName == null) {
          response.writeHead(HTTP_STATUS_BAD_REQUEST, common2.COOP_COEP_CORP_HEADERS).end("Request is missing search parameter `file_name`.");
        } else {
          const filePath = path.join(directory, fileName);
          void fs2.writeFile(filePath, request).then(() => {
            response.writeHead(HTTP_STATUS_OK, [
              ["Content-Length", String(filePath.length)],
              ["Content-Type", "text/plain"],
              ...common2.COOP_COEP_CORP_HEADERS
            ]).end(filePath);
          }).catch((e) => {
            console.error(e);
            response.writeHead(HTTP_STATUS_BAD_REQUEST, common2.COOP_COEP_CORP_HEADERS).end();
          });
        }
        break;
      }
      case "/api/upload-project": {
        const url = new URL(`https://example.com/${requestUrl}`);
        const directory = url.searchParams.get("directory");
        const name = url.searchParams.get("name");
        void uploadBundle(request, directory, name).then((id) => {
          response.writeHead(HTTP_STATUS_OK, [
            ["Content-Length", String(id.length)],
            ["Content-Type", "text/plain"],
            ...common2.COOP_COEP_CORP_HEADERS
          ]).end(id);
        }).catch(() => {
          response.writeHead(HTTP_STATUS_BAD_REQUEST, common2.COOP_COEP_CORP_HEADERS).end();
        });
        break;
      }
      case "/api/run-project-manager-command": {
        const cliArguments = JSON.parse(
          new URL(`https://example.com/${requestUrl}`).searchParams.get(
            "cli-arguments"
          ) ?? "[]"
        );
        if (!Array.isArray(cliArguments) || !cliArguments.every((item) => typeof item === "string")) {
          response.writeHead(HTTP_STATUS_BAD_REQUEST, common2.COOP_COEP_CORP_HEADERS).end("Command arguments must be an array of strings.");
        } else {
          void (async () => {
            const toJSONRPCResult = (result2) => JSON.stringify({ jsonrpc: "2.0", id: 0, result: result2 });
            const toJSONRPCError = (message, data) => JSON.stringify({
              jsonrpc: "2.0",
              id: 0,
              error: { code: 0, message, ...data != null ? { data } : {} }
            });
            let result = toJSONRPCError(`Error running Project Manager command.`, {
              command: cliArguments
            });
            try {
              switch (cliArguments[0]) {
                case "--filesystem-list": {
                  const directoryPath = cliArguments[1];
                  if (directoryPath != null) {
                    const entryNames = await fs2.readdir(directoryPath);
                    const entries = [];
                    for (const entryName of entryNames) {
                      const entryPath = path.join(directoryPath, entryName);
                      const stat2 = await fs2.stat(entryPath);
                      const attributes = {
                        byteSize: stat2.size,
                        creationTime: new Date(stat2.ctimeMs).toISOString(),
                        lastAccessTime: new Date(
                          stat2.atimeMs
                        ).toISOString(),
                        lastModifiedTime: new Date(
                          stat2.mtimeMs
                        ).toISOString()
                      };
                      if (stat2.isFile()) {
                        entries.push({
                          type: "FileEntry" /* FileEntry */,
                          path: entryPath,
                          attributes
                        });
                      } else {
                        try {
                          const packageMetadataPath = path.join(
                            entryPath,
                            "package.yaml"
                          );
                          const projectMetadataPath = path.join(
                            entryPath,
                            PROJECT_METADATA_RELATIVE_PATH
                          );
                          const packageMetadataContents = await fs2.readFile(packageMetadataPath);
                          const projectMetadataContents = await fs2.readFile(projectMetadataPath);
                          const metadata2 = extractProjectMetadata(
                            yaml.parse(
                              packageMetadataContents.toString()
                            ),
                            JSON.parse(
                              projectMetadataContents.toString()
                            )
                          );
                          if (metadata2 != null) {
                            entries.push({
                              type: "ProjectEntry" /* ProjectEntry */,
                              path: entryPath,
                              attributes,
                              metadata: metadata2
                            });
                          } else {
                            throw new Error("Invalid project metadata.");
                          }
                        } catch {
                          entries.push({
                            type: "DirectoryEntry" /* DirectoryEntry */,
                            path: entryPath,
                            attributes
                          });
                        }
                      }
                    }
                    result = toJSONRPCResult({ entries });
                  }
                  break;
                }
                case "--filesystem-create-directory": {
                  const directoryPath = cliArguments[1];
                  if (directoryPath != null) {
                    await fs2.mkdir(directoryPath, { recursive: true });
                    result = toJSONRPCResult(null);
                  }
                  break;
                }
                case "--filesystem-write-path": {
                  const filePath = cliArguments[1];
                  if (filePath != null) {
                    await new Promise((resolve2, reject) => {
                      request.pipe(fsSync.createWriteStream(filePath), {
                        end: true
                      }).on("close", resolve2).on("error", reject);
                    });
                    result = toJSONRPCResult(null);
                  }
                  break;
                }
                case "--filesystem-move-from": {
                  const sourcePath = cliArguments[1];
                  const destinationPath = cliArguments[3];
                  if (sourcePath != null && cliArguments[2] === "--filesystem-move-to" && destinationPath != null) {
                    await fs2.rename(sourcePath, destinationPath);
                    result = toJSONRPCResult(null);
                  }
                  break;
                }
                case "--filesystem-delete": {
                  const fileOrDirectoryPath = cliArguments[1];
                  if (fileOrDirectoryPath != null) {
                    await fs2.rm(fileOrDirectoryPath, { recursive: true });
                    result = toJSONRPCResult(null);
                  }
                  break;
                }
                default: {
                }
              }
            } catch {
            }
            const buffer = Buffer.from(result);
            response.writeHead(HTTP_STATUS_OK, [
              ["Content-Length", String(buffer.byteLength)],
              ["Content-Type", "application/json"],
              ...common2.COOP_COEP_CORP_HEADERS
            ]).end(buffer);
          })();
        }
        break;
      }
      default: {
        const downloadProjectMatch = requestPath?.match(
          /^[/]api[/]project-manager[/]projects[/]([^/]+)[/]enso-project$/
        );
        if (downloadProjectMatch) {
          const uuid = downloadProjectMatch[1];
          void fs2.readdir(PROJECTS_ROOT_DIRECTORY).then(async (filenames) => {
            let success = false;
            for (const filename of filenames) {
              try {
                const projectRoot = path.join(PROJECTS_ROOT_DIRECTORY, filename);
                const stat2 = await fs2.stat(projectRoot);
                if (stat2.isDirectory()) {
                  const metadataPath = path.join(
                    projectRoot,
                    PROJECT_METADATA_RELATIVE_PATH
                  );
                  const metadataContents = await fs2.readFile(metadataPath);
                  const metadata2 = JSON.parse(
                    metadataContents.toString()
                  );
                  if (typeof metadata2 === "object" && metadata2 != null && "id" in metadata2 && metadata2.id === uuid) {
                    response.writeHead(HTTP_STATUS_OK, [
                      ["Content-Type", "application/gzip+x-enso-project"],
                      ...common2.COOP_COEP_CORP_HEADERS
                    ]);
                    tar2.create({ gzip: true, cwd: projectRoot }, [
                      projectRoot
                    ]).pipe(response, { end: true });
                    success = true;
                    break;
                  }
                }
              } catch {
              }
            }
            if (!success) {
              response.writeHead(HTTP_STATUS_NOT_FOUND, common2.COOP_COEP_CORP_HEADERS).end();
            }
          });
          break;
        }
        response.writeHead(HTTP_STATUS_NOT_FOUND, common2.COOP_COEP_CORP_HEADERS).end();
        break;
      }
    }
  } else if (request.method === "GET" && requestPath === "/api/root-directory") {
    response.writeHead(HTTP_STATUS_OK, [
      ["Content-Length", String(PROJECTS_ROOT_DIRECTORY.length)],
      ["Content-Type", "text/plain"],
      ...common2.COOP_COEP_CORP_HEADERS
    ]).end(PROJECTS_ROOT_DIRECTORY);
  } else {
    next();
  }
}
function extractProjectMetadata(yamlObj, jsonObj) {
  if (typeof yamlObj !== "object" || yamlObj == null || typeof jsonObj !== "object" || jsonObj == null) {
    return null;
  } else {
    const validDateString = (string) => {
      const date = new Date(string);
      return !Number.isNaN(Number(date)) ? date.toString() : null;
    };
    const name = "name" in yamlObj && typeof yamlObj.name === "string" ? yamlObj.name : null;
    const namespace = "namespace" in yamlObj && typeof yamlObj.namespace === "string" ? yamlObj.namespace : null;
    const engineVersion = "edition" in yamlObj && typeof yamlObj.edition === "string" ? yamlObj.edition : null;
    const id = "id" in jsonObj && typeof jsonObj.id === "string" ? jsonObj.id : null;
    const created = "created" in jsonObj && typeof jsonObj.created === "string" ? validDateString(jsonObj.created) : null;
    const lastOpened = "lastOpened" in jsonObj && typeof jsonObj.lastOpened === "string" ? validDateString(jsonObj.lastOpened) : null;
    if (name != null && namespace != null && id != null && created != null) {
      return {
        name,
        namespace,
        id,
        ...engineVersion != null ? { engineVersion } : {},
        created,
        ...lastOpened != null ? { lastOpened } : {}
      };
    } else {
      return null;
    }
  }
}
var HTTP_STATUS_OK, HTTP_STATUS_BAD_REQUEST, HTTP_STATUS_NOT_FOUND, PROJECTS_ROOT_DIRECTORY, FileSystemEntryType;
var init_projectManagerShimMiddleware = __esm({
  "../ide-desktop/lib/project-manager-shim/src/projectManagerShimMiddleware.ts"() {
    "use strict";
    init_projectManagement();
    HTTP_STATUS_OK = 200;
    HTTP_STATUS_BAD_REQUEST = 400;
    HTTP_STATUS_NOT_FOUND = 404;
    PROJECTS_ROOT_DIRECTORY = path.join(os2.homedir(), "enso/projects");
    FileSystemEntryType = /* @__PURE__ */ ((FileSystemEntryType2) => {
      FileSystemEntryType2["DirectoryEntry"] = "DirectoryEntry";
      FileSystemEntryType2["ProjectEntry"] = "ProjectEntry";
      FileSystemEntryType2["FileEntry"] = "FileEntry";
      return FileSystemEntryType2;
    })(FileSystemEntryType || {});
  }
});

// vitest.config.ts
import { fileURLToPath as fileURLToPath2 } from "node:url";
import { configDefaults, defineConfig as defineConfig2, mergeConfig } from "file:///C:/Projects/enso/enso/node_modules/.pnpm/vitest@1.5.0_@types+node@20.12.7_jsdom@22.1.0/node_modules/vitest/dist/config.js";

// vite.config.ts
import vue from "file:///C:/Projects/enso/enso/node_modules/.pnpm/@vitejs+plugin-vue@5.0.4_vite@5.2.9_vue@3.4.23/node_modules/@vitejs/plugin-vue/dist/index.mjs";
import { getDefines, readEnvironmentFromFile } from "file:///C:/Projects/enso/enso/app/ide-desktop/lib/common/src/appConfig.js";
import { fileURLToPath } from "node:url";
import postcssNesting from "file:///C:/Projects/enso/enso/node_modules/.pnpm/postcss-nesting@12.1.1_postcss@8.4.38/node_modules/postcss-nesting/dist/index.mjs";
import tailwindcss from "file:///C:/Projects/enso/enso/node_modules/.pnpm/tailwindcss@3.4.3/node_modules/tailwindcss/lib/index.js";
import tailwindcssNesting from "file:///C:/Projects/enso/enso/node_modules/.pnpm/tailwindcss@3.4.3/node_modules/tailwindcss/nesting/index.js";
import { defineConfig } from "file:///C:/Projects/enso/enso/node_modules/.pnpm/vite@5.2.9_@types+node@20.12.7/node_modules/vite/dist/node/index.js";
import * as tailwindConfig from "file:///C:/Projects/enso/enso/app/ide-desktop/lib/dashboard/tailwind.config.js";

// ydoc-server/index.ts
import { parse as parse4 } from "url";
import { WebSocketServer } from "file:///C:/Projects/enso/enso/node_modules/.pnpm/ws@8.16.0/node_modules/ws/wrapper.mjs";

// shared/ast/ffi.ts
import { createXXHash128 } from "file:///C:/Projects/enso/enso/node_modules/.pnpm/hash-wasm@4.11.0/node_modules/hash-wasm/dist/index.umd.js";

// rust-ffi/pkg/rust_ffi.js
var __vite_injected_original_import_meta_url = "file:///C:/Projects/enso/enso/app/gui2/rust-ffi/pkg/rust_ffi.js";
var wasm;
var heap = new Array(128).fill(void 0);
heap.push(void 0, null, true, false);
function getObject(idx) {
  return heap[idx];
}
var heap_next = heap.length;
function dropObject(idx) {
  if (idx < 132)
    return;
  heap[idx] = heap_next;
  heap_next = idx;
}
function takeObject(idx) {
  const ret = getObject(idx);
  dropObject(idx);
  return ret;
}
var WASM_VECTOR_LEN = 0;
var cachedUint8Memory0 = null;
function getUint8Memory0() {
  if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {
    cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachedUint8Memory0;
}
var cachedTextEncoder = typeof TextEncoder !== "undefined" ? new TextEncoder("utf-8") : { encode: () => {
  throw Error("TextEncoder not available");
} };
var encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
  return cachedTextEncoder.encodeInto(arg, view);
} : function(arg, view) {
  const buf = cachedTextEncoder.encode(arg);
  view.set(buf);
  return {
    read: arg.length,
    written: buf.length
  };
};
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf.length, 1) >>> 0;
    getUint8Memory0().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len, 1) >>> 0;
  const mem = getUint8Memory0();
  let offset = 0;
  for (; offset < len; offset++) {
    const code = arg.charCodeAt(offset);
    if (code > 127)
      break;
    mem[ptr + offset] = code;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
    const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
    const ret = encodeString(arg, view);
    offset += ret.written;
    ptr = realloc(ptr, len, offset, 1) >>> 0;
  }
  WASM_VECTOR_LEN = offset;
  return ptr;
}
var cachedInt32Memory0 = null;
function getInt32Memory0() {
  if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {
    cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
  }
  return cachedInt32Memory0;
}
var cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {
  throw Error("TextDecoder not available");
} };
if (typeof TextDecoder !== "undefined") {
  cachedTextDecoder.decode();
}
function getStringFromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
function getArrayU8FromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}
function parse(code) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm0(code, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    wasm.parse(retptr, ptr0, len0);
    var r0 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    var v2 = getArrayU8FromWasm0(r0, r1).slice();
    wasm.__wbindgen_free(r0, r1 * 1, 1);
    return v2;
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function is_ident_or_operator(code) {
  const ptr0 = passStringToWasm0(code, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len0 = WASM_VECTOR_LEN;
  const ret = wasm.is_ident_or_operator(ptr0, len0);
  return ret >>> 0;
}
function addHeapObject(obj) {
  if (heap_next === heap.length)
    heap.push(heap.length + 1);
  const idx = heap_next;
  heap_next = heap[idx];
  heap[idx] = obj;
  return idx;
}
async function __wbg_load(module, imports) {
  if (typeof Response === "function" && module instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming === "function") {
      try {
        return await WebAssembly.instantiateStreaming(module, imports);
      } catch (e) {
        if (module.headers.get("Content-Type") != "application/wasm") {
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);
        } else {
          throw e;
        }
      }
    }
    const bytes = await module.arrayBuffer();
    return await WebAssembly.instantiate(bytes, imports);
  } else {
    const instance = await WebAssembly.instantiate(module, imports);
    if (instance instanceof WebAssembly.Instance) {
      return { instance, module };
    } else {
      return instance;
    }
  }
}
function __wbg_get_imports() {
  const imports = {};
  imports.wbg = {};
  imports.wbg.__wbg_error_f851667af71bcfc6 = function(arg0, arg1) {
    let deferred0_0;
    let deferred0_1;
    try {
      deferred0_0 = arg0;
      deferred0_1 = arg1;
      console.error(getStringFromWasm0(arg0, arg1));
    } finally {
      wasm.__wbindgen_free(deferred0_0, deferred0_1, 1);
    }
  };
  imports.wbg.__wbg_new_abda76e883ba8a5f = function() {
    const ret = new Error();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_stack_658279fe44541cf6 = function(arg0, arg1) {
    const ret = getObject(arg1).stack;
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
  };
  imports.wbg.__wbindgen_object_drop_ref = function(arg0) {
    takeObject(arg0);
  };
  return imports;
}
function __wbg_init_memory(imports, maybe_memory) {
}
function __wbg_finalize_init(instance, module) {
  wasm = instance.exports;
  __wbg_init.__wbindgen_wasm_module = module;
  cachedInt32Memory0 = null;
  cachedUint8Memory0 = null;
  wasm.__wbindgen_start();
  return wasm;
}
async function __wbg_init(input) {
  if (wasm !== void 0)
    return wasm;
  if (typeof input === "undefined") {
    input = new URL("rust_ffi_bg.wasm", __vite_injected_original_import_meta_url);
  }
  const imports = __wbg_get_imports();
  if (typeof input === "string" || typeof Request === "function" && input instanceof Request || typeof URL === "function" && input instanceof URL) {
    input = fetch(input);
  }
  __wbg_init_memory(imports);
  const { instance, module } = await __wbg_load(await input, imports);
  return __wbg_finalize_init(instance, module);
}
var rust_ffi_default = __wbg_init;

// shared/util/assert.ts
function assert(condition, message) {
  if (!condition)
    bail(message ? `Assertion failed: ${message}` : "Assertion failed");
}
function assertEqual(actual, expected, message) {
  const messagePrefix = message ? message + " " : "";
  assert(actual === expected, `${messagePrefix}Expected ${expected}, got ${actual}.`);
}
function assertDefined(x, message) {
  const messagePrefix = message ? message + " " : "";
  assert(x !== void 0, `${messagePrefix}Expected value to be defined.`);
}
function assertUnreachable() {
  bail("Unreachable code");
}
function bail(message) {
  throw new Error(message);
}

// shared/util/detect.ts
var isNode = typeof global !== "undefined" && global[Symbol.toStringTag] === "global";
var isDevMode = process.env.NODE_ENV === "development";

// shared/ast/ffi.ts
var __vite_injected_original_import_meta_url2 = "file:///C:/Projects/enso/enso/app/gui2/shared/ast/ffi.ts";
var xxHasher128;
function xxHash128(input) {
  assertDefined(xxHasher128, "Module should have been loaded with `initializeFFI`.");
  xxHasher128.init();
  xxHasher128.update(input);
  return xxHasher128.digest();
}
async function initializeFFI(path2) {
  if (isNode) {
    const fs3 = await import("node:fs/promises");
    const { fileURLToPath: fileURLToPath3, URL: nodeURL } = await import("node:url");
    const buffer = fs3.readFile(
      path2 ?? fileURLToPath3(new nodeURL("../../rust-ffi/pkg/rust_ffi_bg.wasm", __vite_injected_original_import_meta_url2))
    );
    await rust_ffi_default(buffer);
  } else {
    await rust_ffi_default();
  }
  xxHasher128 = await createXXHash128();
}

// ydoc-server/ydoc.ts
import {
  applyAwarenessUpdate,
  Awareness,
  encodeAwarenessUpdate,
  removeAwarenessStates
} from "file:///C:/Projects/enso/enso/node_modules/.pnpm/y-protocols@1.0.6_yjs@13.6.14/node_modules/y-protocols/awareness.js";
import { readSyncMessage, writeSyncStep1, writeUpdate } from "file:///C:/Projects/enso/enso/node_modules/.pnpm/y-protocols@1.0.6_yjs@13.6.14/node_modules/y-protocols/sync.js";
import * as Y4 from "file:///C:/Projects/enso/enso/node_modules/.pnpm/yjs@13.6.14/node_modules/yjs/dist/yjs.mjs";
import * as decoding from "file:///C:/Projects/enso/enso/node_modules/.pnpm/lib0@0.2.93/node_modules/lib0/decoding.js";
import * as encoding from "file:///C:/Projects/enso/enso/node_modules/.pnpm/lib0@0.2.93/node_modules/lib0/encoding.js";
import { ObservableV2 as ObservableV23 } from "file:///C:/Projects/enso/enso/node_modules/.pnpm/lib0@0.2.93/node_modules/lib0/observable.js";
import { WebSocket } from "file:///C:/Projects/enso/enso/node_modules/.pnpm/ws@8.16.0/node_modules/ws/wrapper.mjs";

// ydoc-server/languageServerSession.ts
import { Client, RequestManager, WebSocketTransport } from "file:///C:/Projects/enso/enso/node_modules/.pnpm/@open-rpc+client-js@1.8.1/node_modules/@open-rpc/client-js/build/index.js";
import * as json3 from "file:///C:/Projects/enso/enso/node_modules/.pnpm/lib0@0.2.93/node_modules/lib0/json.js";
import * as map2 from "file:///C:/Projects/enso/enso/node_modules/.pnpm/lib0@0.2.93/node_modules/lib0/map.js";
import { ObservableV2 as ObservableV22 } from "file:///C:/Projects/enso/enso/node_modules/.pnpm/lib0@0.2.93/node_modules/lib0/observable.js";
import * as random4 from "file:///C:/Projects/enso/enso/node_modules/.pnpm/lib0@0.2.93/node_modules/lib0/random.js";
import * as Y3 from "file:///C:/Projects/enso/enso/node_modules/.pnpm/yjs@13.6.14/node_modules/yjs/dist/yjs.mjs";

// shared/ast/index.ts
import * as random3 from "file:///C:/Projects/enso/enso/node_modules/.pnpm/lib0@0.2.93/node_modules/lib0/random.js";

// shared/util/data/result.ts
function Ok(data) {
  return { ok: true, value: data };
}
function Err(error) {
  return { ok: false, error: new ResultError(error) };
}
var ResultError = class {
  payload;
  context;
  constructor(payload) {
    this.payload = payload;
    this.context = [];
  }
  log(preamble = "Error") {
    console.error(this.message(preamble));
  }
  message(preamble = "error") {
    const ctx = this.context.length > 0 ? `
${Array.from(this.context, (ctx2) => ctx2()).join("\n")}` : "";
    return `${preamble}: ${this.payload}${ctx}`;
  }
};

// shared/yjsModel.ts
import * as object from "file:///C:/Projects/enso/enso/node_modules/.pnpm/lib0@0.2.93/node_modules/lib0/object.js";
import * as random from "file:///C:/Projects/enso/enso/node_modules/.pnpm/lib0@0.2.93/node_modules/lib0/random.js";
import * as Y from "file:///C:/Projects/enso/enso/node_modules/.pnpm/yjs@13.6.14/node_modules/yjs/dist/yjs.mjs";
function visMetadataEquals(a, b) {
  return !a && !b || a && b && a.visible === b.visible && a.fullscreen == b.fullscreen && a.width == b.width && visIdentifierEquals(a.identifier, b.identifier);
}
function visIdentifierEquals(a, b) {
  return !a && !b || a && b && a.name === b.name && object.equalFlat(a.module, b.module);
}
var DistributedProject = class {
  doc;
  name;
  modules;
  settings;
  constructor(doc) {
    this.doc = doc;
    this.name = this.doc.getText("name");
    this.modules = this.doc.getMap("modules");
    this.settings = this.doc.getMap("settings");
  }
  moduleNames() {
    return Array.from(this.modules.keys());
  }
  findModuleByDocId(id) {
    for (const [name, doc] of this.modules.entries()) {
      if (doc.guid === id)
        return name;
    }
    return null;
  }
  async openModule(name) {
    const doc = this.modules.get(name);
    if (doc == null)
      return null;
    return await DistributedModule.load(doc);
  }
  openUnloadedModule(name) {
    const doc = this.modules.get(name);
    if (doc == null)
      return null;
    return new DistributedModule(doc);
  }
  createUnloadedModule(name, doc) {
    this.modules.set(name, doc);
    return new DistributedModule(doc);
  }
  createNewModule(name) {
    return this.createUnloadedModule(name, new Y.Doc());
  }
  deleteModule(name) {
    this.modules.delete(name);
  }
  dispose() {
    this.doc.destroy();
  }
};
var ModuleDoc = class {
  ydoc;
  nodes;
  constructor(ydoc) {
    this.ydoc = ydoc;
    this.nodes = ydoc.getMap("nodes");
  }
};
var DistributedModule = class _DistributedModule {
  doc;
  undoManager;
  static async load(ydoc) {
    ydoc.load();
    await ydoc.whenLoaded;
    return new _DistributedModule(ydoc);
  }
  constructor(ydoc) {
    this.doc = new ModuleDoc(ydoc);
    this.undoManager = new Y.UndoManager([this.doc.nodes]);
  }
  dispose() {
    this.doc.ydoc.destroy();
  }
};
var localUserActionOrigins = ["local:userAction", "local:userAction:CodeEditor"];
var defaultLocalOrigin = "local:userAction";
function isLocalUserActionOrigin(origin) {
  const localOriginNames = localUserActionOrigins;
  return localOriginNames.includes(origin);
}
function tryAsOrigin(origin) {
  if (isLocalUserActionOrigin(origin))
    return origin;
  if (origin === "local:autoLayout")
    return origin;
  if (origin === "remote")
    return origin;
}
function sourceRangeKey(range) {
  return `${range[0].toString(16)}:${range[1].toString(16)}`;
}
function sourceRangeFromKey(key) {
  return key.split(":").map((x) => parseInt(x, 16));
}
var IdMap = class _IdMap {
  rangeToExpr;
  constructor(entries) {
    this.rangeToExpr = new Map(entries ?? []);
  }
  static Mock() {
    return new _IdMap([]);
  }
  insertKnownId(range, id) {
    const key = sourceRangeKey(range);
    this.rangeToExpr.set(key, id);
  }
  getIfExist(range) {
    const key = sourceRangeKey(range);
    return this.rangeToExpr.get(key);
  }
  getOrInsertUniqueId(range) {
    const key = sourceRangeKey(range);
    const val = this.rangeToExpr.get(key);
    if (val !== void 0) {
      return val;
    } else {
      const newId = random.uuidv4();
      this.rangeToExpr.set(key, newId);
      return newId;
    }
  }
  entries() {
    return [...this.rangeToExpr];
  }
  get size() {
    return this.rangeToExpr.size;
  }
  clear() {
    this.rangeToExpr.clear();
  }
  isEqual(other) {
    if (other.size !== this.size)
      return false;
    for (const [key, value] of this.rangeToExpr.entries()) {
      const oldValue = other.rangeToExpr.get(key);
      if (oldValue !== value)
        return false;
    }
    return true;
  }
  validate() {
    const uniqueValues = new Set(this.rangeToExpr.values());
    if (uniqueValues.size < this.rangeToExpr.size) {
      console.warn(`Duplicate UUID in IdMap`);
    }
  }
  clone() {
    return new _IdMap(this.entries());
  }
  // Debugging.
  compare(other) {
    console.info(`IdMap.compare -------`);
    const allKeys2 = /* @__PURE__ */ new Set();
    for (const key of this.rangeToExpr.keys())
      allKeys2.add(key);
    for (const key of other.rangeToExpr.keys())
      allKeys2.add(key);
    for (const key of allKeys2) {
      const mine = this.rangeToExpr.get(key);
      const yours = other.rangeToExpr.get(key);
      if (mine !== yours) {
        console.info(`IdMap.compare[${key}]: ${mine} -> ${yours}`);
      }
    }
  }
};
var uuidRegex = /^[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/;
function isUuid(x) {
  return typeof x === "string" && x.length === 36 && uuidRegex.test(x);
}
function rangeLength(a) {
  return a[1] - a[0];
}
function rangeEncloses(a, b) {
  return a[0] <= b[0] && a[1] >= b[1];
}

// shared/ast/parserSupport.ts
var LazyObject = class {
  _v;
  constructor(view) {
    if (view == null)
      throw new Error("WTF?");
    this._v = view;
  }
  visitChildren(_visitor) {
    return false;
  }
  children() {
    const children = [];
    this.visitChildren((child) => {
      children.push(child);
    });
    return children;
  }
};
function makeDataView(buffer, address) {
  return new DataView(buffer, address);
}
function readU8(view, address) {
  return view.getUint8(address);
}
function readU32(view, address) {
  return view.getUint32(address, true);
}
function readI32(view, address) {
  return view.getInt32(address, true);
}
function readBool(view, address) {
  return readU8(view, address) !== 0;
}
function readOffset(view, offset) {
  return makeDataView(view.buffer, view.byteOffset + offset);
}
function readPointer(view, address) {
  return makeDataView(view.buffer, readU32(view, address));
}
var textDecoder = new TextDecoder();
function readOption(view, address, readElement) {
  let result = void 0;
  visitOption(view, address, (view2, address2) => {
    result = readElement(view2, address2);
  });
  return result;
}
function visitOption(view, address, visitor) {
  const discriminant = readU8(view, address);
  switch (discriminant) {
    case 0:
      return false;
    case 1:
      return !!visitor(readPointer(view, address + 1), 0);
    default:
      throw new Error(`Invalid Option discriminant: 0x${discriminant.toString(16)}.`);
  }
}
function readResult(view, address, readOk, readErr) {
  const data = readPointer(view, address);
  const discriminant = readU32(data, 0);
  switch (discriminant) {
    case 0:
      return Ok(readOk(data, 4));
    case 1:
      return Err(readErr(data, 4));
    default:
      throw new Error(`Invalid Result discriminant: 0x${discriminant.toString(16)}.`);
  }
}
function visitResult(view, address, visitOk, visitErr) {
  const data = readPointer(view, address);
  const discriminant = readU32(data, 0);
  switch (discriminant) {
    case 0:
      if (visitOk?.(data, 4))
        return true;
      return false;
    case 1:
      if (visitErr?.(data, 4))
        return true;
      return false;
    default:
      throw new Error(`Invalid Result discriminant: 0x${discriminant.toString(16)}.`);
  }
}
function visitSequence(view, address, size, visitor) {
  const data = readPointer(view, address);
  let offset = 4;
  const end = offset + size * readU32(data, 0);
  while (offset != end) {
    if (visitor(data, offset) === true)
      return true;
    offset += size;
  }
  return false;
}
function readSequence(view, address, size, reader) {
  const data = readPointer(view, address);
  const offset = 4;
  const end = offset + size * readU32(data, 0);
  return new LazySequence(offset, size, end, (offset2) => reader(data, offset2));
}
var LazySequence = class {
  offset;
  step;
  end;
  read;
  constructor(offset, step, end, read) {
    this.read = read;
    this.offset = offset;
    this.step = step;
    this.end = end;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    if (this.offset >= this.end) {
      return { done: true, value: void 0 };
    }
    const value = this.read(this.offset);
    this.offset += this.step;
    return { done: false, value };
  }
};
function readString(view, address) {
  const data = readPointer(view, address);
  const len = readU32(data, 0);
  const bytes = new Uint8Array(data.buffer, data.byteOffset + 4, len);
  return textDecoder.decode(bytes);
}
function readEnum(readers, view, address) {
  const data = readPointer(view, address);
  const discriminant = readU32(data, 0);
  const reader = readers[discriminant] ?? bail(`Invalid enum discriminant: ${discriminant}`);
  return reader(data, 4);
}

// shared/ast/generated/ast.ts
var Tree;
((Tree2) => {
  class AbstractBase extends LazyObject {
    constructor(view) {
      super(view);
    }
    get spanLeftOffsetVisible() {
      return readU32(this._v, 0);
    }
    get spanLeftOffsetCodeReprBegin() {
      return readU32(this._v, 4);
    }
    get spanLeftOffsetCodeReprLen() {
      return readU32(this._v, 8);
    }
    get spanLeftOffsetCodeStartUtf8() {
      return readU32(this._v, 12);
    }
    get whitespaceStartInCodeParsed() {
      return readU32(this._v, 16);
    }
    get spanLeftOffsetCodeStartLine() {
      return readU32(this._v, 20);
    }
    get spanLeftOffsetCodeStartCol16() {
      return readU32(this._v, 24);
    }
    get whitespaceLengthInCodeParsed() {
      return readU32(this._v, 28);
    }
    get spanLeftOffsetCodeLenNewlines() {
      return readU32(this._v, 32);
    }
    get spanLeftOffsetCodeLenLineChars16() {
      return readU32(this._v, 36);
    }
    get childrenLengthInCodeParsed() {
      return readU32(this._v, 40);
    }
    get spanCodeLengthNewlines() {
      return readU32(this._v, 44);
    }
    get spanCodeLengthLineChars16() {
      return readU32(this._v, 48);
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor);
    }
  }
  Tree2.AbstractBase = AbstractBase;
  let Type;
  ((Type2) => {
    Type2[Type2["Invalid"] = 0] = "Invalid";
    Type2[Type2["BodyBlock"] = 1] = "BodyBlock";
    Type2[Type2["ArgumentBlockApplication"] = 2] = "ArgumentBlockApplication";
    Type2[Type2["OperatorBlockApplication"] = 3] = "OperatorBlockApplication";
    Type2[Type2["Ident"] = 4] = "Ident";
    Type2[Type2["Private"] = 5] = "Private";
    Type2[Type2["Number"] = 6] = "Number";
    Type2[Type2["Wildcard"] = 7] = "Wildcard";
    Type2[Type2["SuspendedDefaultArguments"] = 8] = "SuspendedDefaultArguments";
    Type2[Type2["TextLiteral"] = 9] = "TextLiteral";
    Type2[Type2["App"] = 10] = "App";
    Type2[Type2["NamedApp"] = 11] = "NamedApp";
    Type2[Type2["OprApp"] = 12] = "OprApp";
    Type2[Type2["UnaryOprApp"] = 13] = "UnaryOprApp";
    Type2[Type2["AutoscopedIdentifier"] = 14] = "AutoscopedIdentifier";
    Type2[Type2["OprSectionBoundary"] = 15] = "OprSectionBoundary";
    Type2[Type2["TemplateFunction"] = 16] = "TemplateFunction";
    Type2[Type2["MultiSegmentApp"] = 17] = "MultiSegmentApp";
    Type2[Type2["TypeDef"] = 18] = "TypeDef";
    Type2[Type2["Assignment"] = 19] = "Assignment";
    Type2[Type2["Function"] = 20] = "Function";
    Type2[Type2["ForeignFunction"] = 21] = "ForeignFunction";
    Type2[Type2["Import"] = 22] = "Import";
    Type2[Type2["Export"] = 23] = "Export";
    Type2[Type2["Group"] = 24] = "Group";
    Type2[Type2["TypeSignature"] = 25] = "TypeSignature";
    Type2[Type2["TypeAnnotated"] = 26] = "TypeAnnotated";
    Type2[Type2["CaseOf"] = 27] = "CaseOf";
    Type2[Type2["Lambda"] = 28] = "Lambda";
    Type2[Type2["Array"] = 29] = "Array";
    Type2[Type2["Tuple"] = 30] = "Tuple";
    Type2[Type2["Annotated"] = 31] = "Annotated";
    Type2[Type2["AnnotatedBuiltin"] = 32] = "AnnotatedBuiltin";
    Type2[Type2["Documented"] = 33] = "Documented";
    Type2[Type2["ConstructorDefinition"] = 34] = "ConstructorDefinition";
  })(Type = Tree2.Type || (Tree2.Type = {}));
  Tree2.typeNames = ["Invalid", "BodyBlock", "ArgumentBlockApplication", "OperatorBlockApplication", "Ident", "Private", "Number", "Wildcard", "SuspendedDefaultArguments", "TextLiteral", "App", "NamedApp", "OprApp", "UnaryOprApp", "AutoscopedIdentifier", "OprSectionBoundary", "TemplateFunction", "MultiSegmentApp", "TypeDef", "Assignment", "Function", "ForeignFunction", "Import", "Export", "Group", "TypeSignature", "TypeAnnotated", "CaseOf", "Lambda", "Array", "Tuple", "Annotated", "AnnotatedBuiltin", "Documented", "ConstructorDefinition"];
  class Invalid2 extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 0 /* Invalid */;
    }
    static read(view, address) {
      return new Invalid2(readOffset(view, address));
    }
    get error() {
      return readString(this._v, 52);
    }
    get ast() {
      return Tree2.read(this._v, 56);
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!visitor(this.ast);
    }
  }
  Tree2.Invalid = Invalid2;
  class BodyBlock2 extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 1 /* BodyBlock */;
    }
    static read(view, address) {
      return new BodyBlock2(readOffset(view, address));
    }
    get statements() {
      return readSequence(this._v, 52, 81, Line.read);
    }
    visitStatements(visitor) {
      return visitSequence(this._v, 52, 81, (view, address) => visitor(Line.read(view, address)));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!this.visitStatements(visitor);
    }
  }
  Tree2.BodyBlock = BodyBlock2;
  class ArgumentBlockApplication extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 2 /* ArgumentBlockApplication */;
    }
    static read(view, address) {
      return new ArgumentBlockApplication(readOffset(view, address));
    }
    get lhs() {
      return readOption(this._v, 52, Tree2.read);
    }
    get arguments() {
      return readSequence(this._v, 57, 81, Line.read);
    }
    visitLhs(visitor) {
      return visitOption(this._v, 52, (view, address) => visitor(Tree2.read(view, address)));
    }
    visitArguments(visitor) {
      return visitSequence(this._v, 57, 81, (view, address) => visitor(Line.read(view, address)));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!this.visitLhs(visitor) || !!this.visitArguments(visitor);
    }
  }
  Tree2.ArgumentBlockApplication = ArgumentBlockApplication;
  class OperatorBlockApplication extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 3 /* OperatorBlockApplication */;
    }
    static read(view, address) {
      return new OperatorBlockApplication(readOffset(view, address));
    }
    get lhs() {
      return readOption(this._v, 52, Tree2.read);
    }
    get expressions() {
      return readSequence(this._v, 57, 81, OperatorLine.read);
    }
    get excess() {
      return readSequence(this._v, 61, 81, Line.read);
    }
    visitLhs(visitor) {
      return visitOption(this._v, 52, (view, address) => visitor(Tree2.read(view, address)));
    }
    visitExpressions(visitor) {
      return visitSequence(this._v, 57, 81, (view, address) => visitor(OperatorLine.read(view, address)));
    }
    visitExcess(visitor) {
      return visitSequence(this._v, 61, 81, (view, address) => visitor(Line.read(view, address)));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!this.visitLhs(visitor) || !!this.visitExpressions(visitor) || !!this.visitExcess(visitor);
    }
  }
  Tree2.OperatorBlockApplication = OperatorBlockApplication;
  class Ident2 extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 4 /* Ident */;
    }
    static read(view, address) {
      return new Ident2(readOffset(view, address));
    }
    get token() {
      return Token.Ident.read(this._v, 52);
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!visitor(this.token);
    }
  }
  Tree2.Ident = Ident2;
  class Private extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 5 /* Private */;
    }
    static read(view, address) {
      return new Private(readOffset(view, address));
    }
    get keyword() {
      return Token.Private.read(this._v, 52);
    }
    get body() {
      return readOption(this._v, 128, Tree2.read);
    }
    visitBody(visitor) {
      return visitOption(this._v, 128, (view, address) => visitor(Tree2.read(view, address)));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!visitor(this.keyword) || !!this.visitBody(visitor);
    }
  }
  Tree2.Private = Private;
  class Number2 extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 6 /* Number */;
    }
    static read(view, address) {
      return new Number2(readOffset(view, address));
    }
    get base() {
      return readOption(this._v, 52, Token.NumberBase.read);
    }
    get integer() {
      return readOption(this._v, 57, Token.Digits.read);
    }
    get fractionalDigits() {
      return readOption(this._v, 62, FractionalDigits.read);
    }
    visitBase(visitor) {
      return visitOption(this._v, 52, (view, address) => visitor(Token.NumberBase.read(view, address)));
    }
    visitInteger(visitor) {
      return visitOption(this._v, 57, (view, address) => visitor(Token.Digits.read(view, address)));
    }
    visitFractionalDigits(visitor) {
      return visitOption(this._v, 62, (view, address) => visitor(FractionalDigits.read(view, address)));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!this.visitBase(visitor) || !!this.visitInteger(visitor) || !!this.visitFractionalDigits(visitor);
    }
  }
  Tree2.Number = Number2;
  class Wildcard2 extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 7 /* Wildcard */;
    }
    static read(view, address) {
      return new Wildcard2(readOffset(view, address));
    }
    get token() {
      return Token.Wildcard.read(this._v, 52);
    }
    get deBruijnIndex() {
      return readI32(this._v, 132);
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!visitor(this.token);
    }
  }
  Tree2.Wildcard = Wildcard2;
  class SuspendedDefaultArguments extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 8 /* SuspendedDefaultArguments */;
    }
    static read(view, address) {
      return new SuspendedDefaultArguments(readOffset(view, address));
    }
    get token() {
      return Token.SuspendedDefaultArguments.read(this._v, 52);
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!visitor(this.token);
    }
  }
  Tree2.SuspendedDefaultArguments = SuspendedDefaultArguments;
  class TextLiteral2 extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 9 /* TextLiteral */;
    }
    static read(view, address) {
      return new TextLiteral2(readOffset(view, address));
    }
    get open() {
      return readOption(this._v, 52, Token.TextStart.read);
    }
    get newline() {
      return readOption(this._v, 57, Token.Newline.read);
    }
    get elements() {
      return readSequence(this._v, 62, 4, TextElement.read);
    }
    get close() {
      return readOption(this._v, 66, Token.TextEnd.read);
    }
    visitOpen(visitor) {
      return visitOption(this._v, 52, (view, address) => visitor(Token.TextStart.read(view, address)));
    }
    visitNewline(visitor) {
      return visitOption(this._v, 57, (view, address) => visitor(Token.Newline.read(view, address)));
    }
    visitElements(visitor) {
      return visitSequence(this._v, 62, 4, (view, address) => visitor(TextElement.read(view, address)));
    }
    visitClose(visitor) {
      return visitOption(this._v, 66, (view, address) => visitor(Token.TextEnd.read(view, address)));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!this.visitOpen(visitor) || !!this.visitNewline(visitor) || !!this.visitElements(visitor) || !!this.visitClose(visitor);
    }
  }
  Tree2.TextLiteral = TextLiteral2;
  class App2 extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 10 /* App */;
    }
    static read(view, address) {
      return new App2(readOffset(view, address));
    }
    get func() {
      return Tree2.read(this._v, 52);
    }
    get arg() {
      return Tree2.read(this._v, 56);
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!visitor(this.func) || !!visitor(this.arg);
    }
  }
  Tree2.App = App2;
  class NamedApp extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 11 /* NamedApp */;
    }
    static read(view, address) {
      return new NamedApp(readOffset(view, address));
    }
    get func() {
      return Tree2.read(this._v, 52);
    }
    get open() {
      return readOption(this._v, 56, Token.OpenSymbol.read);
    }
    get name() {
      return Token.Ident.read(this._v, 61);
    }
    get equals() {
      return Token.Operator.read(this._v, 144);
    }
    get arg() {
      return Tree2.read(this._v, 220);
    }
    get close() {
      return readOption(this._v, 224, Token.CloseSymbol.read);
    }
    visitOpen(visitor) {
      return visitOption(this._v, 56, (view, address) => visitor(Token.OpenSymbol.read(view, address)));
    }
    visitClose(visitor) {
      return visitOption(this._v, 224, (view, address) => visitor(Token.CloseSymbol.read(view, address)));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!visitor(this.func) || !!this.visitOpen(visitor) || !!visitor(this.name) || !!visitor(this.equals) || !!visitor(this.arg) || !!this.visitClose(visitor);
    }
  }
  Tree2.NamedApp = NamedApp;
  class OprApp2 extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 12 /* OprApp */;
    }
    static read(view, address) {
      return new OprApp2(readOffset(view, address));
    }
    get lhs() {
      return readOption(this._v, 52, Tree2.read);
    }
    get opr() {
      return readResult(this._v, 57, Token.Operator.read, MultipleOperatorError.read);
    }
    get rhs() {
      return readOption(this._v, 61, Tree2.read);
    }
    visitLhs(visitor) {
      return visitOption(this._v, 52, (view, address) => visitor(Tree2.read(view, address)));
    }
    visitOpr(visitor) {
      return visitResult(this._v, 57, (view, address) => visitor(Token.Operator.read(view, address)), (view, address) => visitor(MultipleOperatorError.read(view, address)));
    }
    visitRhs(visitor) {
      return visitOption(this._v, 61, (view, address) => visitor(Tree2.read(view, address)));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!this.visitLhs(visitor) || !!this.visitOpr(visitor) || !!this.visitRhs(visitor);
    }
  }
  Tree2.OprApp = OprApp2;
  class UnaryOprApp2 extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 13 /* UnaryOprApp */;
    }
    static read(view, address) {
      return new UnaryOprApp2(readOffset(view, address));
    }
    get opr() {
      return Token.Operator.read(this._v, 52);
    }
    get rhs() {
      return readOption(this._v, 128, Tree2.read);
    }
    visitRhs(visitor) {
      return visitOption(this._v, 128, (view, address) => visitor(Tree2.read(view, address)));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!visitor(this.opr) || !!this.visitRhs(visitor);
    }
  }
  Tree2.UnaryOprApp = UnaryOprApp2;
  class AutoscopedIdentifier extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 14 /* AutoscopedIdentifier */;
    }
    static read(view, address) {
      return new AutoscopedIdentifier(readOffset(view, address));
    }
    get opr() {
      return Token.Operator.read(this._v, 52);
    }
    get ident() {
      return Token.Ident.read(this._v, 128);
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!visitor(this.opr) || !!visitor(this.ident);
    }
  }
  Tree2.AutoscopedIdentifier = AutoscopedIdentifier;
  class OprSectionBoundary extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 15 /* OprSectionBoundary */;
    }
    static read(view, address) {
      return new OprSectionBoundary(readOffset(view, address));
    }
    get arguments() {
      return readU32(this._v, 52);
    }
    get ast() {
      return Tree2.read(this._v, 56);
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!visitor(this.ast);
    }
  }
  Tree2.OprSectionBoundary = OprSectionBoundary;
  class TemplateFunction extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 16 /* TemplateFunction */;
    }
    static read(view, address) {
      return new TemplateFunction(readOffset(view, address));
    }
    get arguments() {
      return readU32(this._v, 52);
    }
    get ast() {
      return Tree2.read(this._v, 56);
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!visitor(this.ast);
    }
  }
  Tree2.TemplateFunction = TemplateFunction;
  class MultiSegmentApp extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 17 /* MultiSegmentApp */;
    }
    static read(view, address) {
      return new MultiSegmentApp(readOffset(view, address));
    }
    get segments() {
      return readSequence(this._v, 52, 9, MultiSegmentAppSegment.read);
    }
    visitSegments(visitor) {
      return visitSequence(this._v, 52, 9, (view, address) => visitor(MultiSegmentAppSegment.read(view, address)));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!this.visitSegments(visitor);
    }
  }
  Tree2.MultiSegmentApp = MultiSegmentApp;
  class TypeDef extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 18 /* TypeDef */;
    }
    static read(view, address) {
      return new TypeDef(readOffset(view, address));
    }
    get keyword() {
      return Token.Ident.read(this._v, 52);
    }
    get name() {
      return Token.Ident.read(this._v, 135);
    }
    get params() {
      return readSequence(this._v, 218, 39, ArgumentDefinition.read);
    }
    get body() {
      return readSequence(this._v, 222, 81, Line.read);
    }
    visitParams(visitor) {
      return visitSequence(this._v, 218, 39, (view, address) => visitor(ArgumentDefinition.read(view, address)));
    }
    visitBody(visitor) {
      return visitSequence(this._v, 222, 81, (view, address) => visitor(Line.read(view, address)));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!visitor(this.keyword) || !!visitor(this.name) || !!this.visitParams(visitor) || !!this.visitBody(visitor);
    }
  }
  Tree2.TypeDef = TypeDef;
  class Assignment2 extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 19 /* Assignment */;
    }
    static read(view, address) {
      return new Assignment2(readOffset(view, address));
    }
    get pattern() {
      return Tree2.read(this._v, 52);
    }
    get equals() {
      return Token.Operator.read(this._v, 56);
    }
    get expr() {
      return Tree2.read(this._v, 132);
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!visitor(this.pattern) || !!visitor(this.equals) || !!visitor(this.expr);
    }
  }
  Tree2.Assignment = Assignment2;
  class Function2 extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 20 /* Function */;
    }
    static read(view, address) {
      return new Function2(readOffset(view, address));
    }
    get name() {
      return Tree2.read(this._v, 52);
    }
    get args() {
      return readSequence(this._v, 56, 39, ArgumentDefinition.read);
    }
    get returns() {
      return readOption(this._v, 60, ReturnSpecification.read);
    }
    get equals() {
      return Token.Operator.read(this._v, 65);
    }
    get body() {
      return readOption(this._v, 141, Tree2.read);
    }
    visitArgs(visitor) {
      return visitSequence(this._v, 56, 39, (view, address) => visitor(ArgumentDefinition.read(view, address)));
    }
    visitReturns(visitor) {
      return visitOption(this._v, 60, (view, address) => visitor(ReturnSpecification.read(view, address)));
    }
    visitBody(visitor) {
      return visitOption(this._v, 141, (view, address) => visitor(Tree2.read(view, address)));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!visitor(this.name) || !!this.visitArgs(visitor) || !!this.visitReturns(visitor) || !!visitor(this.equals) || !!this.visitBody(visitor);
    }
  }
  Tree2.Function = Function2;
  class ForeignFunction extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 21 /* ForeignFunction */;
    }
    static read(view, address) {
      return new ForeignFunction(readOffset(view, address));
    }
    get foreign() {
      return Token.Ident.read(this._v, 52);
    }
    get language() {
      return Token.Ident.read(this._v, 135);
    }
    get name() {
      return Token.Ident.read(this._v, 218);
    }
    get args() {
      return readSequence(this._v, 301, 39, ArgumentDefinition.read);
    }
    get equals() {
      return Token.Operator.read(this._v, 305);
    }
    get body() {
      return Tree2.read(this._v, 381);
    }
    visitArgs(visitor) {
      return visitSequence(this._v, 301, 39, (view, address) => visitor(ArgumentDefinition.read(view, address)));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!visitor(this.foreign) || !!visitor(this.language) || !!visitor(this.name) || !!this.visitArgs(visitor) || !!visitor(this.equals) || !!visitor(this.body);
    }
  }
  Tree2.ForeignFunction = ForeignFunction;
  class Import2 extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 22 /* Import */;
    }
    static read(view, address) {
      return new Import2(readOffset(view, address));
    }
    get polyglot() {
      return readOption(this._v, 52, MultiSegmentAppSegment.read);
    }
    get from() {
      return readOption(this._v, 57, MultiSegmentAppSegment.read);
    }
    get import() {
      return MultiSegmentAppSegment.read(this._v, 62);
    }
    get all() {
      return readOption(this._v, 71, Token.Ident.read);
    }
    get as() {
      return readOption(this._v, 76, MultiSegmentAppSegment.read);
    }
    get hiding() {
      return readOption(this._v, 81, MultiSegmentAppSegment.read);
    }
    visitPolyglot(visitor) {
      return visitOption(this._v, 52, (view, address) => visitor(MultiSegmentAppSegment.read(view, address)));
    }
    visitFrom(visitor) {
      return visitOption(this._v, 57, (view, address) => visitor(MultiSegmentAppSegment.read(view, address)));
    }
    visitAll(visitor) {
      return visitOption(this._v, 71, (view, address) => visitor(Token.Ident.read(view, address)));
    }
    visitAs(visitor) {
      return visitOption(this._v, 76, (view, address) => visitor(MultiSegmentAppSegment.read(view, address)));
    }
    visitHiding(visitor) {
      return visitOption(this._v, 81, (view, address) => visitor(MultiSegmentAppSegment.read(view, address)));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!this.visitPolyglot(visitor) || !!this.visitFrom(visitor) || !!visitor(this.import) || !!this.visitAll(visitor) || !!this.visitAs(visitor) || !!this.visitHiding(visitor);
    }
  }
  Tree2.Import = Import2;
  class Export extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 23 /* Export */;
    }
    static read(view, address) {
      return new Export(readOffset(view, address));
    }
    get from() {
      return readOption(this._v, 52, MultiSegmentAppSegment.read);
    }
    get export() {
      return MultiSegmentAppSegment.read(this._v, 57);
    }
    get all() {
      return readOption(this._v, 66, Token.Ident.read);
    }
    get as() {
      return readOption(this._v, 71, MultiSegmentAppSegment.read);
    }
    get hiding() {
      return readOption(this._v, 76, MultiSegmentAppSegment.read);
    }
    visitFrom(visitor) {
      return visitOption(this._v, 52, (view, address) => visitor(MultiSegmentAppSegment.read(view, address)));
    }
    visitAll(visitor) {
      return visitOption(this._v, 66, (view, address) => visitor(Token.Ident.read(view, address)));
    }
    visitAs(visitor) {
      return visitOption(this._v, 71, (view, address) => visitor(MultiSegmentAppSegment.read(view, address)));
    }
    visitHiding(visitor) {
      return visitOption(this._v, 76, (view, address) => visitor(MultiSegmentAppSegment.read(view, address)));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!this.visitFrom(visitor) || !!visitor(this.export) || !!this.visitAll(visitor) || !!this.visitAs(visitor) || !!this.visitHiding(visitor);
    }
  }
  Tree2.Export = Export;
  class Group2 extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 24 /* Group */;
    }
    static read(view, address) {
      return new Group2(readOffset(view, address));
    }
    get open() {
      return readOption(this._v, 52, Token.OpenSymbol.read);
    }
    get body() {
      return readOption(this._v, 57, Tree2.read);
    }
    get close() {
      return readOption(this._v, 62, Token.CloseSymbol.read);
    }
    visitOpen(visitor) {
      return visitOption(this._v, 52, (view, address) => visitor(Token.OpenSymbol.read(view, address)));
    }
    visitBody(visitor) {
      return visitOption(this._v, 57, (view, address) => visitor(Tree2.read(view, address)));
    }
    visitClose(visitor) {
      return visitOption(this._v, 62, (view, address) => visitor(Token.CloseSymbol.read(view, address)));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!this.visitOpen(visitor) || !!this.visitBody(visitor) || !!this.visitClose(visitor);
    }
  }
  Tree2.Group = Group2;
  class TypeSignature extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 25 /* TypeSignature */;
    }
    static read(view, address) {
      return new TypeSignature(readOffset(view, address));
    }
    get variable() {
      return Tree2.read(this._v, 52);
    }
    get operator() {
      return Token.Operator.read(this._v, 56);
    }
    get typeNode() {
      return Tree2.read(this._v, 132);
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!visitor(this.variable) || !!visitor(this.operator) || !!visitor(this.typeNode);
    }
  }
  Tree2.TypeSignature = TypeSignature;
  class TypeAnnotated extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 26 /* TypeAnnotated */;
    }
    static read(view, address) {
      return new TypeAnnotated(readOffset(view, address));
    }
    get expression() {
      return Tree2.read(this._v, 52);
    }
    get operator() {
      return Token.Operator.read(this._v, 56);
    }
    get typeNode() {
      return Tree2.read(this._v, 132);
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!visitor(this.expression) || !!visitor(this.operator) || !!visitor(this.typeNode);
    }
  }
  Tree2.TypeAnnotated = TypeAnnotated;
  class CaseOf extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 27 /* CaseOf */;
    }
    static read(view, address) {
      return new CaseOf(readOffset(view, address));
    }
    get case() {
      return Token.Ident.read(this._v, 52);
    }
    get expression() {
      return readOption(this._v, 135, Tree2.read);
    }
    get of() {
      return Token.Ident.read(this._v, 140);
    }
    get cases() {
      return readSequence(this._v, 223, 10, CaseLine.read);
    }
    visitExpression(visitor) {
      return visitOption(this._v, 135, (view, address) => visitor(Tree2.read(view, address)));
    }
    visitCases(visitor) {
      return visitSequence(this._v, 223, 10, (view, address) => visitor(CaseLine.read(view, address)));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!visitor(this.case) || !!this.visitExpression(visitor) || !!visitor(this.of) || !!this.visitCases(visitor);
    }
  }
  Tree2.CaseOf = CaseOf;
  class Lambda extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 28 /* Lambda */;
    }
    static read(view, address) {
      return new Lambda(readOffset(view, address));
    }
    get operator() {
      return Token.Operator.read(this._v, 52);
    }
    get arrow() {
      return readOption(this._v, 128, Tree2.read);
    }
    visitArrow(visitor) {
      return visitOption(this._v, 128, (view, address) => visitor(Tree2.read(view, address)));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!visitor(this.operator) || !!this.visitArrow(visitor);
    }
  }
  Tree2.Lambda = Lambda;
  class Array2 extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 29 /* Array */;
    }
    static read(view, address) {
      return new Array2(readOffset(view, address));
    }
    get left() {
      return Token.OpenSymbol.read(this._v, 52);
    }
    get first() {
      return readOption(this._v, 128, Tree2.read);
    }
    get rest() {
      return readSequence(this._v, 133, 81, OperatorDelimitedTree.read);
    }
    get right() {
      return Token.CloseSymbol.read(this._v, 137);
    }
    visitFirst(visitor) {
      return visitOption(this._v, 128, (view, address) => visitor(Tree2.read(view, address)));
    }
    visitRest(visitor) {
      return visitSequence(this._v, 133, 81, (view, address) => visitor(OperatorDelimitedTree.read(view, address)));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!visitor(this.left) || !!this.visitFirst(visitor) || !!this.visitRest(visitor) || !!visitor(this.right);
    }
  }
  Tree2.Array = Array2;
  class Tuple extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 30 /* Tuple */;
    }
    static read(view, address) {
      return new Tuple(readOffset(view, address));
    }
    get left() {
      return Token.OpenSymbol.read(this._v, 52);
    }
    get first() {
      return readOption(this._v, 128, Tree2.read);
    }
    get rest() {
      return readSequence(this._v, 133, 81, OperatorDelimitedTree.read);
    }
    get right() {
      return Token.CloseSymbol.read(this._v, 137);
    }
    visitFirst(visitor) {
      return visitOption(this._v, 128, (view, address) => visitor(Tree2.read(view, address)));
    }
    visitRest(visitor) {
      return visitSequence(this._v, 133, 81, (view, address) => visitor(OperatorDelimitedTree.read(view, address)));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!visitor(this.left) || !!this.visitFirst(visitor) || !!this.visitRest(visitor) || !!visitor(this.right);
    }
  }
  Tree2.Tuple = Tuple;
  class Annotated extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 31 /* Annotated */;
    }
    static read(view, address) {
      return new Annotated(readOffset(view, address));
    }
    get token() {
      return Token.Operator.read(this._v, 52);
    }
    get annotation() {
      return Token.Ident.read(this._v, 128);
    }
    get argument() {
      return readOption(this._v, 211, Tree2.read);
    }
    get newlines() {
      return readSequence(this._v, 216, 76, Token.Newline.read);
    }
    get expression() {
      return readOption(this._v, 220, Tree2.read);
    }
    visitArgument(visitor) {
      return visitOption(this._v, 211, (view, address) => visitor(Tree2.read(view, address)));
    }
    visitNewlines(visitor) {
      return visitSequence(this._v, 216, 76, (view, address) => visitor(Token.Newline.read(view, address)));
    }
    visitExpression(visitor) {
      return visitOption(this._v, 220, (view, address) => visitor(Tree2.read(view, address)));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!visitor(this.token) || !!visitor(this.annotation) || !!this.visitArgument(visitor) || !!this.visitNewlines(visitor) || !!this.visitExpression(visitor);
    }
  }
  Tree2.Annotated = Annotated;
  class AnnotatedBuiltin extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 32 /* AnnotatedBuiltin */;
    }
    static read(view, address) {
      return new AnnotatedBuiltin(readOffset(view, address));
    }
    get token() {
      return Token.Operator.read(this._v, 52);
    }
    get annotation() {
      return Token.Ident.read(this._v, 128);
    }
    get newlines() {
      return readSequence(this._v, 211, 76, Token.Newline.read);
    }
    get expression() {
      return readOption(this._v, 215, Tree2.read);
    }
    visitNewlines(visitor) {
      return visitSequence(this._v, 211, 76, (view, address) => visitor(Token.Newline.read(view, address)));
    }
    visitExpression(visitor) {
      return visitOption(this._v, 215, (view, address) => visitor(Tree2.read(view, address)));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!visitor(this.token) || !!visitor(this.annotation) || !!this.visitNewlines(visitor) || !!this.visitExpression(visitor);
    }
  }
  Tree2.AnnotatedBuiltin = AnnotatedBuiltin;
  class Documented2 extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 33 /* Documented */;
    }
    static read(view, address) {
      return new Documented2(readOffset(view, address));
    }
    get documentation() {
      return DocComment.read(this._v, 52);
    }
    get expression() {
      return readOption(this._v, 136, Tree2.read);
    }
    visitExpression(visitor) {
      return visitOption(this._v, 136, (view, address) => visitor(Tree2.read(view, address)));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!visitor(this.documentation) || !!this.visitExpression(visitor);
    }
  }
  Tree2.Documented = Documented2;
  class ConstructorDefinition extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 34 /* ConstructorDefinition */;
    }
    static read(view, address) {
      return new ConstructorDefinition(readOffset(view, address));
    }
    get ident() {
      return Token.Ident.read(this._v, 52);
    }
    get arguments() {
      return readSequence(this._v, 135, 39, ArgumentDefinition.read);
    }
    get block() {
      return readSequence(this._v, 139, 81, ArgumentDefinitionLine.read);
    }
    visitArguments(visitor) {
      return visitSequence(this._v, 135, 39, (view, address) => visitor(ArgumentDefinition.read(view, address)));
    }
    visitBlock(visitor) {
      return visitSequence(this._v, 139, 81, (view, address) => visitor(ArgumentDefinitionLine.read(view, address)));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!visitor(this.ident) || !!this.visitArguments(visitor) || !!this.visitBlock(visitor);
    }
  }
  Tree2.ConstructorDefinition = ConstructorDefinition;
  const VARIANT_READERS = [Invalid2.read, BodyBlock2.read, ArgumentBlockApplication.read, OperatorBlockApplication.read, Ident2.read, Private.read, Number2.read, Wildcard2.read, SuspendedDefaultArguments.read, TextLiteral2.read, App2.read, NamedApp.read, OprApp2.read, UnaryOprApp2.read, AutoscopedIdentifier.read, OprSectionBoundary.read, TemplateFunction.read, MultiSegmentApp.read, TypeDef.read, Assignment2.read, Function2.read, ForeignFunction.read, Import2.read, Export.read, Group2.read, TypeSignature.read, TypeAnnotated.read, CaseOf.read, Lambda.read, Array2.read, Tuple.read, Annotated.read, AnnotatedBuiltin.read, Documented2.read, ConstructorDefinition.read];
  function read(view, address) {
    return readEnum(VARIANT_READERS, view, address);
  }
  Tree2.read = read;
  function isInstance(obj) {
    return obj instanceof AbstractBase;
  }
  Tree2.isInstance = isInstance;
})(Tree || (Tree = {}));
var MultiSegmentAppSegment = class _MultiSegmentAppSegment extends LazyObject {
  constructor(view) {
    super(view);
  }
  static read(view, address) {
    return new _MultiSegmentAppSegment(readOffset(view, address));
  }
  get header() {
    return Token.read(this._v, 0);
  }
  get body() {
    return readOption(this._v, 4, Tree.read);
  }
  visitBody(visitor) {
    return visitOption(this._v, 4, (view, address) => visitor(Tree.read(view, address)));
  }
  visitChildren(visitor) {
    return super.visitChildren(visitor) || !!visitor(this.header) || !!this.visitBody(visitor);
  }
};
var CaseLine = class _CaseLine extends LazyObject {
  constructor(view) {
    super(view);
  }
  static read(view, address) {
    return new _CaseLine(readOffset(view, address));
  }
  get newline() {
    return readOption(this._v, 0, Token.Newline.read);
  }
  get case() {
    return readOption(this._v, 5, Case.read);
  }
  visitNewline(visitor) {
    return visitOption(this._v, 0, (view, address) => visitor(Token.Newline.read(view, address)));
  }
  visitCase(visitor) {
    return visitOption(this._v, 5, (view, address) => visitor(Case.read(view, address)));
  }
  visitChildren(visitor) {
    return super.visitChildren(visitor) || !!this.visitNewline(visitor) || !!this.visitCase(visitor);
  }
};
var Base;
((Base2) => {
  class AbstractBase extends LazyObject {
    constructor(view) {
      super(view);
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor);
    }
  }
  Base2.AbstractBase = AbstractBase;
  let Type;
  ((Type2) => {
    Type2[Type2["Binary"] = 0] = "Binary";
    Type2[Type2["Octal"] = 1] = "Octal";
    Type2[Type2["Hexadecimal"] = 2] = "Hexadecimal";
  })(Type = Base2.Type || (Base2.Type = {}));
  Base2.typeNames = ["Binary", "Octal", "Hexadecimal"];
  class Binary extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 0 /* Binary */;
    }
    static read(view, address) {
      return new Binary(readOffset(view, address));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor);
    }
  }
  Base2.Binary = Binary;
  class Octal extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 1 /* Octal */;
    }
    static read(view, address) {
      return new Octal(readOffset(view, address));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor);
    }
  }
  Base2.Octal = Octal;
  class Hexadecimal extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 2 /* Hexadecimal */;
    }
    static read(view, address) {
      return new Hexadecimal(readOffset(view, address));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor);
    }
  }
  Base2.Hexadecimal = Hexadecimal;
  const VARIANT_READERS = [Binary.read, Octal.read, Hexadecimal.read];
  function read(view, address) {
    return readEnum(VARIANT_READERS, view, address);
  }
  Base2.read = read;
  function isInstance(obj) {
    return obj instanceof AbstractBase;
  }
  Base2.isInstance = isInstance;
})(Base || (Base = {}));
var ArgumentDefinitionLine = class _ArgumentDefinitionLine extends LazyObject {
  constructor(view) {
    super(view);
  }
  static read(view, address) {
    return new _ArgumentDefinitionLine(readOffset(view, address));
  }
  get newline() {
    return Token.Newline.read(this._v, 0);
  }
  get argument() {
    return readOption(this._v, 76, ArgumentDefinition.read);
  }
  visitArgument(visitor) {
    return visitOption(this._v, 76, (view, address) => visitor(ArgumentDefinition.read(view, address)));
  }
  visitChildren(visitor) {
    return super.visitChildren(visitor) || !!visitor(this.newline) || !!this.visitArgument(visitor);
  }
};
var ArgumentDefault = class _ArgumentDefault extends LazyObject {
  constructor(view) {
    super(view);
  }
  static read(view, address) {
    return new _ArgumentDefault(readOffset(view, address));
  }
  get equals() {
    return Token.Operator.read(this._v, 0);
  }
  get expression() {
    return Tree.read(this._v, 76);
  }
  visitChildren(visitor) {
    return super.visitChildren(visitor) || !!visitor(this.equals) || !!visitor(this.expression);
  }
};
var OperatorBlockExpression = class _OperatorBlockExpression extends LazyObject {
  constructor(view) {
    super(view);
  }
  static read(view, address) {
    return new _OperatorBlockExpression(readOffset(view, address));
  }
  get operator() {
    return readResult(this._v, 0, Token.Operator.read, MultipleOperatorError.read);
  }
  get expression() {
    return Tree.read(this._v, 4);
  }
  visitOperator(visitor) {
    return visitResult(this._v, 0, (view, address) => visitor(Token.Operator.read(view, address)), (view, address) => visitor(MultipleOperatorError.read(view, address)));
  }
  visitChildren(visitor) {
    return super.visitChildren(visitor) || !!this.visitOperator(visitor) || !!visitor(this.expression);
  }
};
var ReturnSpecification = class _ReturnSpecification extends LazyObject {
  constructor(view) {
    super(view);
  }
  static read(view, address) {
    return new _ReturnSpecification(readOffset(view, address));
  }
  get arrow() {
    return Token.Operator.read(this._v, 0);
  }
  get typeNode() {
    return Tree.read(this._v, 76);
  }
  visitChildren(visitor) {
    return super.visitChildren(visitor) || !!visitor(this.arrow) || !!visitor(this.typeNode);
  }
};
var Line = class _Line extends LazyObject {
  constructor(view) {
    super(view);
  }
  static read(view, address) {
    return new _Line(readOffset(view, address));
  }
  get newline() {
    return Token.Newline.read(this._v, 0);
  }
  get expression() {
    return readOption(this._v, 76, Tree.read);
  }
  visitExpression(visitor) {
    return visitOption(this._v, 76, (view, address) => visitor(Tree.read(view, address)));
  }
  visitChildren(visitor) {
    return super.visitChildren(visitor) || !!visitor(this.newline) || !!this.visitExpression(visitor);
  }
};
var OperatorLine = class _OperatorLine extends LazyObject {
  constructor(view) {
    super(view);
  }
  static read(view, address) {
    return new _OperatorLine(readOffset(view, address));
  }
  get newline() {
    return Token.Newline.read(this._v, 0);
  }
  get expression() {
    return readOption(this._v, 76, OperatorBlockExpression.read);
  }
  visitExpression(visitor) {
    return visitOption(this._v, 76, (view, address) => visitor(OperatorBlockExpression.read(view, address)));
  }
  visitChildren(visitor) {
    return super.visitChildren(visitor) || !!visitor(this.newline) || !!this.visitExpression(visitor);
  }
};
var ArgumentType = class _ArgumentType extends LazyObject {
  constructor(view) {
    super(view);
  }
  static read(view, address) {
    return new _ArgumentType(readOffset(view, address));
  }
  get operator() {
    return Token.Operator.read(this._v, 0);
  }
  get typeNode() {
    return Tree.read(this._v, 76);
  }
  visitChildren(visitor) {
    return super.visitChildren(visitor) || !!visitor(this.operator) || !!visitor(this.typeNode);
  }
};
var Case = class _Case extends LazyObject {
  constructor(view) {
    super(view);
  }
  static read(view, address) {
    return new _Case(readOffset(view, address));
  }
  get documentation() {
    return readOption(this._v, 0, DocComment.read);
  }
  get pattern() {
    return readOption(this._v, 5, Tree.read);
  }
  get arrow() {
    return readOption(this._v, 10, Token.Operator.read);
  }
  get expression() {
    return readOption(this._v, 15, Tree.read);
  }
  visitDocumentation(visitor) {
    return visitOption(this._v, 0, (view, address) => visitor(DocComment.read(view, address)));
  }
  visitPattern(visitor) {
    return visitOption(this._v, 5, (view, address) => visitor(Tree.read(view, address)));
  }
  visitArrow(visitor) {
    return visitOption(this._v, 10, (view, address) => visitor(Token.Operator.read(view, address)));
  }
  visitExpression(visitor) {
    return visitOption(this._v, 15, (view, address) => visitor(Tree.read(view, address)));
  }
  visitChildren(visitor) {
    return super.visitChildren(visitor) || !!this.visitDocumentation(visitor) || !!this.visitPattern(visitor) || !!this.visitArrow(visitor) || !!this.visitExpression(visitor);
  }
};
var Token;
((Token3) => {
  class AbstractBase extends LazyObject {
    constructor(view) {
      super(view);
    }
    get leftOffsetVisible() {
      return readU32(this._v, 0);
    }
    get leftOffsetCodeReprBegin() {
      return readU32(this._v, 4);
    }
    get leftOffsetCodeReprLen() {
      return readU32(this._v, 8);
    }
    get leftOffsetCodeStartUtf8() {
      return readU32(this._v, 12);
    }
    get whitespaceStartInCodeBuffer() {
      return readU32(this._v, 16);
    }
    get leftOffsetCodeStartLine() {
      return readU32(this._v, 20);
    }
    get leftOffsetCodeStartCol16() {
      return readU32(this._v, 24);
    }
    get whitespaceLengthInCodeBuffer() {
      return readU32(this._v, 28);
    }
    get leftOffsetCodeLenNewlines() {
      return readU32(this._v, 32);
    }
    get leftOffsetCodeLenLineChars16() {
      return readU32(this._v, 36);
    }
    get codeReprBegin() {
      return readU32(this._v, 40);
    }
    get codeReprLen() {
      return readU32(this._v, 44);
    }
    get codeStartUtf8() {
      return readU32(this._v, 48);
    }
    get startInCodeBuffer() {
      return readU32(this._v, 52);
    }
    get codeStartLine() {
      return readU32(this._v, 56);
    }
    get codeStartCol16() {
      return readU32(this._v, 60);
    }
    get lengthInCodeBuffer() {
      return readU32(this._v, 64);
    }
    get codeLenNewlines() {
      return readU32(this._v, 68);
    }
    get codeLenLineChars16() {
      return readU32(this._v, 72);
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor);
    }
  }
  Token3.AbstractBase = AbstractBase;
  let Type;
  ((Type2) => {
    Type2[Type2["Newline"] = 0] = "Newline";
    Type2[Type2["OpenSymbol"] = 1] = "OpenSymbol";
    Type2[Type2["CloseSymbol"] = 2] = "CloseSymbol";
    Type2[Type2["BlockStart"] = 3] = "BlockStart";
    Type2[Type2["BlockEnd"] = 4] = "BlockEnd";
    Type2[Type2["Wildcard"] = 5] = "Wildcard";
    Type2[Type2["SuspendedDefaultArguments"] = 6] = "SuspendedDefaultArguments";
    Type2[Type2["Ident"] = 7] = "Ident";
    Type2[Type2["Operator"] = 8] = "Operator";
    Type2[Type2["Digits"] = 9] = "Digits";
    Type2[Type2["NumberBase"] = 10] = "NumberBase";
    Type2[Type2["Private"] = 11] = "Private";
    Type2[Type2["TextStart"] = 12] = "TextStart";
    Type2[Type2["TextEnd"] = 13] = "TextEnd";
    Type2[Type2["TextSection"] = 14] = "TextSection";
    Type2[Type2["TextEscape"] = 15] = "TextEscape";
    Type2[Type2["TextInitialNewline"] = 16] = "TextInitialNewline";
    Type2[Type2["TextNewline"] = 17] = "TextNewline";
    Type2[Type2["Invalid"] = 18] = "Invalid";
  })(Type = Token3.Type || (Token3.Type = {}));
  Token3.typeNames = ["Newline", "OpenSymbol", "CloseSymbol", "BlockStart", "BlockEnd", "Wildcard", "SuspendedDefaultArguments", "Ident", "Operator", "Digits", "NumberBase", "Private", "TextStart", "TextEnd", "TextSection", "TextEscape", "TextInitialNewline", "TextNewline", "Invalid"];
  class Newline extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 0 /* Newline */;
    }
    static read(view, address) {
      return new Newline(readOffset(view, address));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor);
    }
  }
  Token3.Newline = Newline;
  class OpenSymbol extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 1 /* OpenSymbol */;
    }
    static read(view, address) {
      return new OpenSymbol(readOffset(view, address));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor);
    }
  }
  Token3.OpenSymbol = OpenSymbol;
  class CloseSymbol extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 2 /* CloseSymbol */;
    }
    static read(view, address) {
      return new CloseSymbol(readOffset(view, address));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor);
    }
  }
  Token3.CloseSymbol = CloseSymbol;
  class BlockStart extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 3 /* BlockStart */;
    }
    static read(view, address) {
      return new BlockStart(readOffset(view, address));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor);
    }
  }
  Token3.BlockStart = BlockStart;
  class BlockEnd extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 4 /* BlockEnd */;
    }
    static read(view, address) {
      return new BlockEnd(readOffset(view, address));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor);
    }
  }
  Token3.BlockEnd = BlockEnd;
  class Wildcard2 extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 5 /* Wildcard */;
    }
    static read(view, address) {
      return new Wildcard2(readOffset(view, address));
    }
    get liftLevel() {
      return readU32(this._v, 76);
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor);
    }
  }
  Token3.Wildcard = Wildcard2;
  class SuspendedDefaultArguments extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 6 /* SuspendedDefaultArguments */;
    }
    static read(view, address) {
      return new SuspendedDefaultArguments(readOffset(view, address));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor);
    }
  }
  Token3.SuspendedDefaultArguments = SuspendedDefaultArguments;
  class Ident2 extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 7 /* Ident */;
    }
    static read(view, address) {
      return new Ident2(readOffset(view, address));
    }
    get isFree() {
      return readBool(this._v, 76);
    }
    get liftLevel() {
      return readU32(this._v, 77);
    }
    get isTypeOrConstructor() {
      return readBool(this._v, 81);
    }
    get isOperatorLexically() {
      return readBool(this._v, 82);
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor);
    }
  }
  Token3.Ident = Ident2;
  class Operator extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 8 /* Operator */;
    }
    static read(view, address) {
      return new Operator(readOffset(view, address));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor);
    }
  }
  Token3.Operator = Operator;
  class Digits extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 9 /* Digits */;
    }
    static read(view, address) {
      return new Digits(readOffset(view, address));
    }
    get base() {
      return readOption(this._v, 76, Base.read);
    }
    visitBase(visitor) {
      return visitOption(this._v, 76, (view, address) => visitor(Base.read(view, address)));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!this.visitBase(visitor);
    }
  }
  Token3.Digits = Digits;
  class NumberBase extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 10 /* NumberBase */;
    }
    static read(view, address) {
      return new NumberBase(readOffset(view, address));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor);
    }
  }
  Token3.NumberBase = NumberBase;
  class Private extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 11 /* Private */;
    }
    static read(view, address) {
      return new Private(readOffset(view, address));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor);
    }
  }
  Token3.Private = Private;
  class TextStart extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 12 /* TextStart */;
    }
    static read(view, address) {
      return new TextStart(readOffset(view, address));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor);
    }
  }
  Token3.TextStart = TextStart;
  class TextEnd extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 13 /* TextEnd */;
    }
    static read(view, address) {
      return new TextEnd(readOffset(view, address));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor);
    }
  }
  Token3.TextEnd = TextEnd;
  class TextSection extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 14 /* TextSection */;
    }
    static read(view, address) {
      return new TextSection(readOffset(view, address));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor);
    }
  }
  Token3.TextSection = TextSection;
  class TextEscape extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 15 /* TextEscape */;
    }
    static read(view, address) {
      return new TextEscape(readOffset(view, address));
    }
    get value() {
      return readU32(this._v, 76);
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor);
    }
  }
  Token3.TextEscape = TextEscape;
  class TextInitialNewline extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 16 /* TextInitialNewline */;
    }
    static read(view, address) {
      return new TextInitialNewline(readOffset(view, address));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor);
    }
  }
  Token3.TextInitialNewline = TextInitialNewline;
  class TextNewline extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 17 /* TextNewline */;
    }
    static read(view, address) {
      return new TextNewline(readOffset(view, address));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor);
    }
  }
  Token3.TextNewline = TextNewline;
  class Invalid2 extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 18 /* Invalid */;
    }
    static read(view, address) {
      return new Invalid2(readOffset(view, address));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor);
    }
  }
  Token3.Invalid = Invalid2;
  const VARIANT_READERS = [Newline.read, OpenSymbol.read, CloseSymbol.read, BlockStart.read, BlockEnd.read, Wildcard2.read, SuspendedDefaultArguments.read, Ident2.read, Operator.read, Digits.read, NumberBase.read, Private.read, TextStart.read, TextEnd.read, TextSection.read, TextEscape.read, TextInitialNewline.read, TextNewline.read, Invalid2.read];
  function read(view, address) {
    return readEnum(VARIANT_READERS, view, address);
  }
  Token3.read = read;
  function isInstance(obj) {
    return obj instanceof AbstractBase;
  }
  Token3.isInstance = isInstance;
})(Token || (Token = {}));
var TextElement;
((TextElement2) => {
  class AbstractBase extends LazyObject {
    constructor(view) {
      super(view);
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor);
    }
  }
  TextElement2.AbstractBase = AbstractBase;
  let Type;
  ((Type2) => {
    Type2[Type2["Section"] = 0] = "Section";
    Type2[Type2["Escape"] = 1] = "Escape";
    Type2[Type2["Newline"] = 2] = "Newline";
    Type2[Type2["Splice"] = 3] = "Splice";
  })(Type = TextElement2.Type || (TextElement2.Type = {}));
  TextElement2.typeNames = ["Section", "Escape", "Newline", "Splice"];
  class Section extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 0 /* Section */;
    }
    static read(view, address) {
      return new Section(readOffset(view, address));
    }
    get text() {
      return Token.TextSection.read(this._v, 0);
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!visitor(this.text);
    }
  }
  TextElement2.Section = Section;
  class Escape extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 1 /* Escape */;
    }
    static read(view, address) {
      return new Escape(readOffset(view, address));
    }
    get token() {
      return Token.TextEscape.read(this._v, 0);
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!visitor(this.token);
    }
  }
  TextElement2.Escape = Escape;
  class Newline extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 2 /* Newline */;
    }
    static read(view, address) {
      return new Newline(readOffset(view, address));
    }
    get newline() {
      return Token.Newline.read(this._v, 0);
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!visitor(this.newline);
    }
  }
  TextElement2.Newline = Newline;
  class Splice extends AbstractBase {
    type;
    constructor(view) {
      super(view);
      this.type = 3 /* Splice */;
    }
    static read(view, address) {
      return new Splice(readOffset(view, address));
    }
    get open() {
      return Token.OpenSymbol.read(this._v, 0);
    }
    get expression() {
      return readOption(this._v, 76, Tree.read);
    }
    get close() {
      return Token.CloseSymbol.read(this._v, 81);
    }
    visitExpression(visitor) {
      return visitOption(this._v, 76, (view, address) => visitor(Tree.read(view, address)));
    }
    visitChildren(visitor) {
      return super.visitChildren(visitor) || !!visitor(this.open) || !!this.visitExpression(visitor) || !!visitor(this.close);
    }
  }
  TextElement2.Splice = Splice;
  const VARIANT_READERS = [Section.read, Escape.read, Newline.read, Splice.read];
  function read(view, address) {
    return readEnum(VARIANT_READERS, view, address);
  }
  TextElement2.read = read;
  function isInstance(obj) {
    return obj instanceof AbstractBase;
  }
  TextElement2.isInstance = isInstance;
})(TextElement || (TextElement = {}));
var FractionalDigits = class _FractionalDigits extends LazyObject {
  constructor(view) {
    super(view);
  }
  static read(view, address) {
    return new _FractionalDigits(readOffset(view, address));
  }
  get dot() {
    return Token.Operator.read(this._v, 0);
  }
  get digits() {
    return Token.Digits.read(this._v, 76);
  }
  visitChildren(visitor) {
    return super.visitChildren(visitor) || !!visitor(this.dot) || !!visitor(this.digits);
  }
};
var MultipleOperatorError = class _MultipleOperatorError extends LazyObject {
  constructor(view) {
    super(view);
  }
  static read(view, address) {
    return new _MultipleOperatorError(readOffset(view, address));
  }
  get operators() {
    return readSequence(this._v, 0, 76, Token.Operator.read);
  }
  visitOperators(visitor) {
    return visitSequence(this._v, 0, 76, (view, address) => visitor(Token.Operator.read(view, address)));
  }
  visitChildren(visitor) {
    return super.visitChildren(visitor) || !!this.visitOperators(visitor);
  }
};
var OperatorDelimitedTree = class _OperatorDelimitedTree extends LazyObject {
  constructor(view) {
    super(view);
  }
  static read(view, address) {
    return new _OperatorDelimitedTree(readOffset(view, address));
  }
  get operator() {
    return Token.Operator.read(this._v, 0);
  }
  get body() {
    return readOption(this._v, 76, Tree.read);
  }
  visitBody(visitor) {
    return visitOption(this._v, 76, (view, address) => visitor(Tree.read(view, address)));
  }
  visitChildren(visitor) {
    return super.visitChildren(visitor) || !!visitor(this.operator) || !!this.visitBody(visitor);
  }
};
var ArgumentDefinition = class _ArgumentDefinition extends LazyObject {
  constructor(view) {
    super(view);
  }
  static read(view, address) {
    return new _ArgumentDefinition(readOffset(view, address));
  }
  get open() {
    return readOption(this._v, 0, Token.OpenSymbol.read);
  }
  get open2() {
    return readOption(this._v, 5, Token.OpenSymbol.read);
  }
  get suspension() {
    return readOption(this._v, 10, Token.Operator.read);
  }
  get pattern() {
    return Tree.read(this._v, 15);
  }
  get typeNode() {
    return readOption(this._v, 19, ArgumentType.read);
  }
  get close2() {
    return readOption(this._v, 24, Token.CloseSymbol.read);
  }
  get default() {
    return readOption(this._v, 29, ArgumentDefault.read);
  }
  get close() {
    return readOption(this._v, 34, Token.CloseSymbol.read);
  }
  visitOpen(visitor) {
    return visitOption(this._v, 0, (view, address) => visitor(Token.OpenSymbol.read(view, address)));
  }
  visitOpen2(visitor) {
    return visitOption(this._v, 5, (view, address) => visitor(Token.OpenSymbol.read(view, address)));
  }
  visitSuspension(visitor) {
    return visitOption(this._v, 10, (view, address) => visitor(Token.Operator.read(view, address)));
  }
  visitTypeNode(visitor) {
    return visitOption(this._v, 19, (view, address) => visitor(ArgumentType.read(view, address)));
  }
  visitClose2(visitor) {
    return visitOption(this._v, 24, (view, address) => visitor(Token.CloseSymbol.read(view, address)));
  }
  visitDefault(visitor) {
    return visitOption(this._v, 29, (view, address) => visitor(ArgumentDefault.read(view, address)));
  }
  visitClose(visitor) {
    return visitOption(this._v, 34, (view, address) => visitor(Token.CloseSymbol.read(view, address)));
  }
  visitChildren(visitor) {
    return super.visitChildren(visitor) || !!this.visitOpen(visitor) || !!this.visitOpen2(visitor) || !!this.visitSuspension(visitor) || !!visitor(this.pattern) || !!this.visitTypeNode(visitor) || !!this.visitClose2(visitor) || !!this.visitDefault(visitor) || !!this.visitClose(visitor);
  }
};
var DocComment = class _DocComment extends LazyObject {
  constructor(view) {
    super(view);
  }
  static read(view, address) {
    return new _DocComment(readOffset(view, address));
  }
  get open() {
    return Token.TextStart.read(this._v, 0);
  }
  get elements() {
    return readSequence(this._v, 76, 4, TextElement.read);
  }
  get newlines() {
    return readSequence(this._v, 80, 76, Token.Newline.read);
  }
  visitElements(visitor) {
    return visitSequence(this._v, 76, 4, (view, address) => visitor(TextElement.read(view, address)));
  }
  visitNewlines(visitor) {
    return visitSequence(this._v, 80, 76, (view, address) => visitor(Token.Newline.read(view, address)));
  }
  visitChildren(visitor) {
    return super.visitChildren(visitor) || !!visitor(this.open) || !!this.visitElements(visitor) || !!this.visitNewlines(visitor);
  }
};

// shared/ast/parse.ts
import * as map from "file:///C:/Projects/enso/enso/node_modules/.pnpm/lib0@0.2.93/node_modules/lib0/map.js";

// shared/util/data/iterable.ts
function* zip(left, right) {
  const leftIterator = left[Symbol.iterator]();
  const rightIterator = right[Symbol.iterator]();
  while (true) {
    const leftResult = leftIterator.next();
    const rightResult = rightIterator.next();
    if (leftResult.done || rightResult.done)
      break;
    yield [leftResult.value, rightResult.value];
  }
}
function tryGetSoleValue(iter) {
  const iterator = iter[Symbol.iterator]();
  const result = iterator.next();
  if (result.done)
    return;
  const excessResult = iterator.next();
  if (!excessResult.done)
    return;
  return result.value;
}
var Resumable = class {
  iterator;
  current;
  constructor(iterable) {
    this.iterator = iterable[Symbol.iterator]();
    this.current = this.iterator.next();
  }
  /** The given function peeks at the current value. If the function returns `true`, the current value will be advanced
   *  and the function called again; if it returns `false`, the peeked value remains current and `advanceWhile` returns.
   */
  advanceWhile(f) {
    while (!this.current.done && f(this.current.value)) {
      this.current = this.iterator.next();
    }
  }
  /** Apply the given function to all values remaining in the iterator. */
  forEach(f) {
    while (!this.current.done) {
      f(this.current.value);
      this.current = this.iterator.next();
    }
  }
};

// shared/util/data/text.ts
import diff from "file:///C:/Projects/enso/enso/node_modules/.pnpm/fast-diff@1.3.0/node_modules/fast-diff/diff.js";
function applyTextEdits(oldText, textEdits) {
  textEdits.sort((a, b) => a.range[0] - b.range[0]);
  let start = 0;
  let newText = "";
  for (const textEdit of textEdits) {
    newText += oldText.slice(start, textEdit.range[0]);
    newText += textEdit.insert;
    start = textEdit.range[1];
  }
  newText += oldText.slice(start);
  return newText;
}
function textChangeToEdits(before, after) {
  const textEdits = [];
  let nextEdit;
  let pos = 0;
  for (const [op, text] of diff(before, after)) {
    switch (op) {
      case diff.INSERT:
        if (!nextEdit)
          nextEdit = { range: [pos, pos], insert: "" };
        nextEdit.insert = text;
        break;
      case diff.EQUAL:
        if (nextEdit) {
          textEdits.push(nextEdit);
          nextEdit = void 0;
        }
        pos += text.length;
        break;
      case diff.DELETE: {
        if (nextEdit)
          textEdits.push(nextEdit);
        const endPos = pos + text.length;
        nextEdit = { range: [pos, endPos], insert: "" };
        pos = endPos;
        break;
      }
    }
  }
  if (nextEdit)
    textEdits.push(nextEdit);
  return textEdits;
}
function applyTextEditsToSpans(textEdits, spansBefore) {
  const numerically = (a, b) => a - b;
  const starts = new Resumable(spansBefore.map(([start, _end]) => start).sort(numerically));
  const ends = new Resumable(spansBefore.map(([_start, end]) => end).sort(numerically));
  const startMap = /* @__PURE__ */ new Map();
  const endMap = /* @__PURE__ */ new Map();
  let offset = 0;
  for (const { range, insert } of textEdits) {
    starts.advanceWhile((start) => {
      if (start < range[0]) {
        startMap.set(start, start + offset);
        return true;
      } else if (start <= range[1]) {
        startMap.set(start, range[0] + offset + insert.length);
        return true;
      }
      return false;
    });
    ends.advanceWhile((end) => {
      if (end <= range[0]) {
        endMap.set(end, end + offset);
        return true;
      } else if (end <= range[1]) {
        endMap.set(end, range[0] + offset);
        return true;
      }
      return false;
    });
    offset += insert.length - rangeLength(range);
  }
  starts.forEach((start) => startMap.set(start, start + offset));
  ends.forEach((end) => endMap.set(end, end + offset));
  const spansBeforeAndAfter = new Array();
  for (const spanBefore of spansBefore) {
    const startAfter = startMap.get(spanBefore[0]);
    const endAfter = endMap.get(spanBefore[1]);
    if (endAfter > startAfter)
      spansBeforeAndAfter.push([spanBefore, [startAfter, endAfter]]);
  }
  return spansBeforeAndAfter;
}
function enclosingSpans(tree, ranges, resultsOut) {
  const results = resultsOut ?? [];
  for (const child of tree.children()) {
    const childSpan = child.span();
    const childRanges = [];
    ranges = ranges.filter((range) => {
      if (rangeEncloses(childSpan, range)) {
        childRanges.push(range);
        return false;
      }
      return true;
    });
    if (childRanges.length)
      enclosingSpans(child, childRanges, results);
  }
  if (ranges.length)
    results.push([tree.id(), ranges]);
  return results;
}
function trimEnd(range, text) {
  const trimmedLength = text.slice(range[0], range[1]).search(/ +$/);
  return trimmedLength === -1 ? range : [range[0], range[0] + trimmedLength];
}

// shared/ast/debug.ts
function graphParentPointers(ast) {
  const sanitize = (id) => id.replace("ast:", "").replace(/[^A-Za-z0-9]/g, "");
  const parentToChild = new Array();
  const childToParent = new Array();
  ast.visitRecursiveAst((ast2) => {
    for (const child of ast2.children()) {
      if (child instanceof Ast)
        parentToChild.push({ child: sanitize(child.id), parent: sanitize(ast2.id) });
    }
    const parent = ast2.parentId;
    if (parent)
      childToParent.push({ child: sanitize(ast2.id), parent: sanitize(parent) });
  });
  let result = "digraph parentPointers {\n";
  for (const { parent, child } of parentToChild)
    result += `${parent} -> ${child};
`;
  for (const { child, parent } of childToParent)
    result += `${child} -> ${parent} [weight=0; color=red; style=dotted];
`;
  result += "}\n";
  return result;
}

// shared/ast/mutableModule.ts
import * as random2 from "file:///C:/Projects/enso/enso/node_modules/.pnpm/lib0@0.2.93/node_modules/lib0/random.js";
import * as Y2 from "file:///C:/Projects/enso/enso/node_modules/.pnpm/yjs@13.6.14/node_modules/yjs/dist/yjs.mjs";
var MutableModule = class _MutableModule {
  nodes;
  get ydoc() {
    const ydoc = this.nodes.doc;
    assert(ydoc != null);
    return ydoc;
  }
  /** Return this module's copy of `ast`, if this module was created by cloning `ast`'s module. */
  getVersion(ast) {
    const instance = this.get(ast.id);
    return instance;
  }
  edit() {
    const doc = new Y2.Doc();
    Y2.applyUpdateV2(doc, Y2.encodeStateAsUpdateV2(this.ydoc));
    return new _MutableModule(doc);
  }
  applyEdit(edit, origin = defaultLocalOrigin) {
    Y2.applyUpdateV2(this.ydoc, Y2.encodeStateAsUpdateV2(edit.ydoc), origin);
  }
  transact(f, origin = defaultLocalOrigin) {
    return this.ydoc.transact(f, origin);
  }
  root() {
    return this.rootPointer()?.expression;
  }
  replaceRoot(newRoot) {
    if (newRoot) {
      const rootPointer = this.rootPointer();
      if (rootPointer) {
        return rootPointer.expression.replace(newRoot);
      } else {
        invalidFields(this, this.baseObject("Invalid", void 0, ROOT_ID), {
          whitespace: "",
          node: newRoot
        });
        return void 0;
      }
    } else {
      const oldRoot = this.root();
      if (!oldRoot)
        return;
      this.nodes.delete(ROOT_ID);
      oldRoot.fields.set("parent", void 0);
      return asOwned(oldRoot);
    }
  }
  syncRoot(root) {
    this.replaceRoot(root);
    this.gc();
  }
  syncToCode(code) {
    const root = this.root();
    if (root) {
      root.syncToCode(code);
    } else {
      this.replaceRoot(Ast.parse(code, this));
    }
  }
  /** Update the module according to changes to its corresponding source code. */
  applyTextEdits(textEdits, metadataSource) {
    const root = this.root();
    assertDefined(root);
    root.applyTextEdits(textEdits, metadataSource);
  }
  gc() {
    const live = /* @__PURE__ */ new Set();
    const active = new Array();
    let next = this.root();
    while (next) {
      for (const child of next.children()) {
        if (child instanceof Ast)
          active.push(child);
      }
      live.add(next.id);
      next = active.pop();
    }
    const all = Array.from(this.nodes.keys());
    for (const id of all) {
      if (id === ROOT_ID)
        continue;
      assert(isAstId(id));
      if (!live.has(id))
        this.nodes.delete(id);
    }
  }
  /** Copy the given node into the module. */
  copy(ast) {
    const id = newAstId(ast.typeName());
    const fields = ast.fields.clone();
    this.nodes.set(id, fields);
    fields.set("id", id);
    fields.set("parent", void 0);
    const ast_ = materializeMutable(this, fields);
    ast_.importReferences(ast.module);
    return ast_;
  }
  static Transient() {
    return new this(new Y2.Doc());
  }
  observe(observer) {
    const handle = (events, transaction) => {
      observer(this.observeEvents(events, tryAsOrigin(transaction.origin)));
    };
    this.nodes.observeDeep(handle);
    observer(this.getStateAsUpdate());
    return handle;
  }
  unobserve(handle) {
    this.nodes.unobserveDeep(handle);
  }
  getStateAsUpdate() {
    const updateBuilder = new UpdateBuilder(this, this.nodes, void 0);
    for (const id of this.nodes.keys())
      updateBuilder.addNode(id);
    return updateBuilder.finish();
  }
  applyUpdate(update, origin) {
    let summary;
    const observer = (events) => {
      summary = this.observeEvents(events, origin);
    };
    this.nodes.observeDeep(observer);
    Y2.applyUpdate(this.ydoc, update, origin);
    this.nodes.unobserveDeep(observer);
    return summary;
  }
  observeEvents(events, origin) {
    const updateBuilder = new UpdateBuilder(this, this.nodes, origin);
    for (const event of events) {
      if (event.target === this.nodes) {
        for (const [key, change] of event.changes.keys) {
          const id = key;
          switch (change.action) {
            case "add":
              updateBuilder.addNode(id);
              break;
            case "update":
              updateBuilder.updateAllFields(id);
              break;
            case "delete":
              updateBuilder.deleteNode(id);
              break;
          }
        }
      } else if (event.target.parent === this.nodes) {
        assert(event.target instanceof Y2.Map);
        const id = event.target.get("id");
        const node = this.nodes.get(id);
        if (!node)
          continue;
        const changes = Array.from(event.changes.keys, ([key]) => [
          key,
          node.get(key)
        ]);
        updateBuilder.updateFields(id, changes);
      } else if (event.target.parent.parent === this.nodes) {
        const id = event.target.parent.get("id");
        const node = this.nodes.get(id);
        if (!node)
          continue;
        const metadata2 = node.get("metadata");
        const changes = Array.from(event.changes.keys, ([key]) => [
          key,
          metadata2.get(key)
        ]);
        updateBuilder.updateMetadata(id, changes);
      }
    }
    return updateBuilder.finish();
  }
  clear() {
    this.nodes.clear();
  }
  get(id) {
    if (!id)
      return void 0;
    const ast = this.tryGet(id);
    assert(ast !== void 0, "id in module");
    return ast;
  }
  tryGet(id) {
    if (!id)
      return void 0;
    const nodeData = this.nodes.get(id);
    if (!nodeData)
      return void 0;
    const fields = nodeData;
    return materializeMutable(this, fields);
  }
  replace(id, value) {
    return this.tryGet(id)?.replace(value);
  }
  replaceValue(id, value) {
    return this.tryGet(id)?.replaceValue(value);
  }
  take(id) {
    return this.replace(id, Wildcard.new(this)) || asOwned(this.get(id));
  }
  updateValue(id, f) {
    return this.tryGet(id)?.updateValue(f);
  }
  /////////////////////////////////////////////
  constructor(doc) {
    this.nodes = doc.getMap("nodes");
  }
  rootPointer() {
    const rootPointer = this.tryGet(ROOT_ID);
    if (rootPointer)
      return rootPointer;
  }
  /** @internal */
  baseObject(type, externalId, overrideId) {
    const map3 = new Y2.Map();
    const map_ = map3;
    const id = overrideId ?? newAstId(type);
    const metadata2 = new Y2.Map();
    const metadataFields = setAll(metadata2, {
      externalId: externalId ?? newExternalId()
    });
    const fields = setAll(map_, {
      id,
      type,
      parent: void 0,
      metadata: metadataFields
    });
    const fieldObject = composeFieldData(fields, {});
    this.nodes.set(id, fieldObject);
    return fieldObject;
  }
  getToken(token) {
    if (!token)
      return token;
    if (token instanceof Token2)
      return token;
    return Token2.withId(token.code_, token.tokenType_, token.id);
  }
  getAny(node) {
    return isTokenId(node) ? this.getToken(node) : this.get(node);
  }
  getConcrete(child) {
    if (isTokenId(child.node))
      return { whitespace: child.whitespace, node: this.getToken(child.node) };
    else
      return { whitespace: child.whitespace, node: this.get(child.node) };
  }
  copyIfForeign(ast) {
    if (!ast)
      return ast;
    if (ast.module === this)
      return ast;
    return this.copy(ast);
  }
  /** @internal */
  delete(id) {
    this.nodes.delete(id);
  }
  /** @internal */
  has(id) {
    return this.nodes.has(id);
  }
};
function newAstId(type) {
  return `ast:${type}#${random2.uint53()}`;
}
function isAstId(value) {
  return /ast:[A-Za-z]*#[0-9]*/.test(value);
}
var ROOT_ID = `Root`;
var UpdateBuilder = class {
  nodesAdded = /* @__PURE__ */ new Set();
  nodesDeleted = /* @__PURE__ */ new Set();
  nodesUpdated = /* @__PURE__ */ new Set();
  metadataUpdated = [];
  origin;
  module;
  nodes;
  constructor(module, nodes, origin) {
    this.module = module;
    this.nodes = nodes;
    this.origin = origin;
  }
  addNode(id) {
    this.nodesAdded.add(id);
  }
  updateAllFields(id) {
    this.updateFields(id, this.nodes.get(id).entries());
  }
  updateFields(id, changes) {
    let fieldsChanged = false;
    let metadataChanges = void 0;
    for (const entry of changes) {
      const [key, value] = entry;
      if (key === "metadata") {
        assert(value instanceof Y2.Map);
        metadataChanges = new Map(value.entries());
      } else {
        assert(!(value instanceof Y2.AbstractType));
        fieldsChanged = true;
      }
    }
    if (fieldsChanged)
      this.nodesUpdated.add(id);
    if (metadataChanges)
      this.metadataUpdated.push({ id, changes: metadataChanges });
  }
  updateMetadata(id, changes) {
    const changeMap = /* @__PURE__ */ new Map();
    for (const [key, value] of changes)
      changeMap.set(key, value);
    this.metadataUpdated.push({ id, changes: changeMap });
  }
  deleteNode(id) {
    this.nodesDeleted.add(id);
  }
  finish() {
    const dirtyNodes = new Set(this.nodesUpdated);
    this.nodesAdded.forEach((node) => dirtyNodes.add(node));
    const updateRoots = subtreeRoots(this.module, dirtyNodes);
    return { ...this, updateRoots };
  }
};

// shared/ast/parse.ts
function parseEnso(code) {
  const blob = parse(code);
  const tree = Tree.read(new DataView(blob.buffer), blob.byteLength - 4);
  assert(tree.type === Tree.Type.BodyBlock);
  return tree;
}
function abstract(module, tree, code, substitutor) {
  const abstractor = new Abstractor(module, code, substitutor);
  const root = abstractor.abstractTree(tree).node;
  const spans = { tokens: abstractor.tokens, nodes: abstractor.nodes };
  return { root, spans, toRaw: abstractor.toRaw };
}
var Abstractor = class {
  module;
  code;
  substitutor;
  nodes;
  tokens;
  toRaw;
  /**
   *  @param module - Where to allocate the new nodes.
   *  @param code - Source code that will be used to resolve references in any passed `RawAst` objects.
   *  @param substitutor - A function that can inject subtrees for some spans, instead of the abstractor producing them.
   *    This can be used for incremental abstraction.
   */
  constructor(module, code, substitutor) {
    this.module = module;
    this.code = code;
    this.substitutor = substitutor;
    this.nodes = /* @__PURE__ */ new Map();
    this.tokens = /* @__PURE__ */ new Map();
    this.toRaw = /* @__PURE__ */ new Map();
  }
  abstractTree(tree) {
    const whitespaceStart = tree.whitespaceStartInCodeParsed;
    const whitespaceEnd = whitespaceStart + tree.whitespaceLengthInCodeParsed;
    const whitespace = this.code.substring(whitespaceStart, whitespaceEnd);
    const codeStart = whitespaceEnd;
    const codeEnd = codeStart + tree.childrenLengthInCodeParsed;
    const spanKey = nodeKey(codeStart, codeEnd - codeStart);
    const substitute = this.substitutor?.(spanKey);
    if (substitute)
      return { node: substitute, whitespace };
    let node;
    switch (tree.type) {
      case Tree.Type.BodyBlock: {
        const lines = Array.from(tree.statements, (line) => {
          const newline = this.abstractToken(line.newline);
          const expression = line.expression ? this.abstractTree(line.expression) : void 0;
          return { newline, expression };
        });
        node = BodyBlock.concrete(this.module, lines);
        break;
      }
      case Tree.Type.Function: {
        const name = this.abstractTree(tree.name);
        const argumentDefinitions = Array.from(tree.args, (arg) => this.abstractChildren(arg));
        const equals = this.abstractToken(tree.equals);
        const body = tree.body !== void 0 ? this.abstractTree(tree.body) : void 0;
        node = Function.concrete(this.module, name, argumentDefinitions, equals, body);
        break;
      }
      case Tree.Type.Ident: {
        const token = this.abstractToken(tree.token);
        node = Ident.concrete(this.module, token);
        break;
      }
      case Tree.Type.Assignment: {
        const pattern = this.abstractTree(tree.pattern);
        const equals = this.abstractToken(tree.equals);
        const value = this.abstractTree(tree.expr);
        node = Assignment.concrete(this.module, pattern, equals, value);
        break;
      }
      case Tree.Type.App: {
        const func = this.abstractTree(tree.func);
        const arg = this.abstractTree(tree.arg);
        node = App.concrete(this.module, func, void 0, void 0, arg);
        break;
      }
      case Tree.Type.NamedApp: {
        const func = this.abstractTree(tree.func);
        const open = tree.open ? this.abstractToken(tree.open) : void 0;
        const name = this.abstractToken(tree.name);
        const equals = this.abstractToken(tree.equals);
        const arg = this.abstractTree(tree.arg);
        const close = tree.close ? this.abstractToken(tree.close) : void 0;
        const parens = open && close ? { open, close } : void 0;
        const nameSpecification2 = { name, equals };
        node = App.concrete(this.module, func, parens, nameSpecification2, arg);
        break;
      }
      case Tree.Type.UnaryOprApp: {
        const opr = this.abstractToken(tree.opr);
        const arg = tree.rhs ? this.abstractTree(tree.rhs) : void 0;
        if (arg && opr.node.code() === "-") {
          node = NegationApp.concrete(this.module, opr, arg);
        } else {
          node = UnaryOprApp.concrete(this.module, opr, arg);
        }
        break;
      }
      case Tree.Type.OprApp: {
        const lhs = tree.lhs ? this.abstractTree(tree.lhs) : void 0;
        const opr = tree.opr.ok ? [this.abstractToken(tree.opr.value)] : Array.from(tree.opr.error.payload.operators, this.abstractToken.bind(this));
        const rhs = tree.rhs ? this.abstractTree(tree.rhs) : void 0;
        const soleOpr = tryGetSoleValue(opr);
        if (soleOpr?.node.code() === "." && rhs?.node instanceof MutableIdent) {
          const rhs_ = { ...rhs, node: rhs.node };
          node = PropertyAccess.concrete(this.module, lhs, soleOpr, rhs_);
        } else {
          node = OprApp.concrete(this.module, lhs, opr, rhs);
        }
        break;
      }
      case Tree.Type.Number: {
        const tokens = [];
        if (tree.base)
          tokens.push(this.abstractToken(tree.base));
        if (tree.integer)
          tokens.push(this.abstractToken(tree.integer));
        if (tree.fractionalDigits) {
          tokens.push(this.abstractToken(tree.fractionalDigits.dot));
          tokens.push(this.abstractToken(tree.fractionalDigits.digits));
        }
        node = NumericLiteral.concrete(this.module, tokens);
        break;
      }
      case Tree.Type.Wildcard: {
        const token = this.abstractToken(tree.token);
        node = Wildcard.concrete(this.module, token);
        break;
      }
      case Tree.Type.OprSectionBoundary:
      case Tree.Type.TemplateFunction:
        return { whitespace, node: this.abstractTree(tree.ast).node };
      case Tree.Type.Invalid: {
        const expression = this.abstractTree(tree.ast);
        node = Invalid.concrete(this.module, expression);
        break;
      }
      case Tree.Type.Group: {
        const open = tree.open ? this.abstractToken(tree.open) : void 0;
        const expression = tree.body ? this.abstractTree(tree.body) : void 0;
        const close = tree.close ? this.abstractToken(tree.close) : void 0;
        node = Group.concrete(this.module, open, expression, close);
        break;
      }
      case Tree.Type.TextLiteral: {
        const open = tree.open ? this.abstractToken(tree.open) : void 0;
        const newline = tree.newline ? this.abstractToken(tree.newline) : void 0;
        const elements = Array.from(tree.elements, (raw) => this.abstractTextElement(raw));
        const close = tree.close ? this.abstractToken(tree.close) : void 0;
        node = TextLiteral.concrete(this.module, open, newline, elements, close);
        break;
      }
      case Tree.Type.Documented: {
        const open = this.abstractToken(tree.documentation.open);
        const elements = Array.from(
          tree.documentation.elements,
          (raw) => this.abstractTextToken(raw)
        );
        const newlines = Array.from(tree.documentation.newlines, this.abstractToken.bind(this));
        const expression = tree.expression ? this.abstractTree(tree.expression) : void 0;
        node = Documented.concrete(this.module, open, elements, newlines, expression);
        break;
      }
      case Tree.Type.Import: {
        const recurseBody = (tree2) => {
          const body = this.abstractTree(tree2);
          if (body.node instanceof Invalid && body.node.code() === "")
            return void 0;
          return body;
        };
        const recurseSegment = (segment) => ({
          header: this.abstractToken(segment.header),
          body: segment.body ? recurseBody(segment.body) : void 0
        });
        const polyglot = tree.polyglot ? recurseSegment(tree.polyglot) : void 0;
        const from = tree.from ? recurseSegment(tree.from) : void 0;
        const import_ = recurseSegment(tree.import);
        const all = tree.all ? this.abstractToken(tree.all) : void 0;
        const as = tree.as ? recurseSegment(tree.as) : void 0;
        const hiding = tree.hiding ? recurseSegment(tree.hiding) : void 0;
        node = Import.concrete(this.module, polyglot, from, import_, all, as, hiding);
        break;
      }
      case Tree.Type.Array: {
        const left = this.abstractToken(tree.left);
        const elements = [];
        if (tree.first)
          elements.push({ value: this.abstractTree(tree.first) });
        for (const rawElement of tree.rest) {
          elements.push({
            delimiter: this.abstractToken(rawElement.operator),
            value: rawElement.body && this.abstractTree(rawElement.body)
          });
        }
        const right = this.abstractToken(tree.right);
        node = Vector.concrete(this.module, left, elements, right);
        break;
      }
      default: {
        node = Generic.concrete(this.module, this.abstractChildren(tree));
      }
    }
    this.toRaw.set(node.id, tree);
    map.setIfUndefined(this.nodes, spanKey, () => []).unshift(node);
    return { node, whitespace };
  }
  abstractToken(token) {
    const whitespaceStart = token.whitespaceStartInCodeBuffer;
    const whitespaceEnd = whitespaceStart + token.whitespaceLengthInCodeBuffer;
    const whitespace = this.code.substring(whitespaceStart, whitespaceEnd);
    const codeStart = token.startInCodeBuffer;
    const codeEnd = codeStart + token.lengthInCodeBuffer;
    const tokenCode = this.code.substring(codeStart, codeEnd);
    const key = tokenKey(codeStart, codeEnd - codeStart);
    const node = Token2.new(tokenCode, token.type);
    this.tokens.set(key, node);
    return { whitespace, node };
  }
  abstractChildren(tree) {
    const children = [];
    const visitor = (child) => {
      if (Tree.isInstance(child)) {
        children.push(this.abstractTree(child));
      } else if (Token.isInstance(child)) {
        children.push(this.abstractToken(child));
      } else {
        child.visitChildren(visitor);
      }
    };
    tree.visitChildren(visitor);
    return children;
  }
  abstractTextElement(raw) {
    switch (raw.type) {
      case TextElement.Type.Newline:
      case TextElement.Type.Escape:
      case TextElement.Type.Section:
        return this.abstractTextToken(raw);
      case TextElement.Type.Splice:
        return {
          type: "splice",
          open: this.abstractToken(raw.open),
          expression: raw.expression && this.abstractTree(raw.expression),
          close: this.abstractToken(raw.close)
        };
    }
  }
  abstractTextToken(raw) {
    switch (raw.type) {
      case TextElement.Type.Newline:
        return { type: "token", token: this.abstractToken(raw.newline) };
      case TextElement.Type.Escape: {
        const negativeOneU32 = 4294967295;
        return {
          type: "token",
          token: this.abstractToken(raw.token),
          interpreted: raw.token.value !== negativeOneU32 ? String.fromCodePoint(raw.token.value) : void 0
        };
      }
      case TextElement.Type.Section:
        return { type: "token", token: this.abstractToken(raw.text) };
      case TextElement.Type.Splice:
        throw new Error("Unreachable: Splice in non-interpolated text field");
    }
  }
};
function nodeKey(start, length2) {
  return sourceRangeKey([start, start + length2]);
}
function tokenKey(start, length2) {
  return sourceRangeKey([start, start + length2]);
}
function spanMapToIdMap(spans) {
  const idMap2 = new IdMap();
  for (const [key, token] of spans.tokens.entries()) {
    assert(isUuid(token.id));
    idMap2.insertKnownId(sourceRangeFromKey(key), token.id);
  }
  for (const [key, asts] of spans.nodes.entries()) {
    for (const ast of asts) {
      assert(isUuid(ast.externalId));
      idMap2.insertKnownId(sourceRangeFromKey(key), ast.externalId);
    }
  }
  return idMap2;
}
function print(ast) {
  const info = {
    nodes: /* @__PURE__ */ new Map(),
    tokens: /* @__PURE__ */ new Map()
  };
  const code = ast.printSubtree(info, 0, void 0);
  return { info, code };
}
function printAst(ast, info, offset, parentIndent, verbatim) {
  let code = "";
  for (const child of ast.concreteChildren(verbatim)) {
    if (!isTokenId(child.node) && ast.module.get(child.node) === void 0)
      continue;
    if (child.whitespace != null) {
      code += child.whitespace;
    } else if (code.length != 0) {
      code += " ";
    }
    if (isTokenId(child.node)) {
      const tokenStart = offset + code.length;
      const token = ast.module.getToken(child.node);
      const span2 = tokenKey(tokenStart, token.code().length);
      info.tokens.set(span2, token);
      code += token.code();
    } else {
      const childNode = ast.module.get(child.node);
      code += childNode.printSubtree(info, offset + code.length, parentIndent, verbatim);
      assertEqual(childNode.id, child.node);
      if (parentId(childNode) !== ast.id) {
        console.error(
          `Inconsistent parent pointer (expected ${ast.id})`,
          childNode,
          graphParentPointers(ast.module.root())
        );
      }
      assertEqual(parentId(childNode), ast.id);
    }
  }
  const span = nodeKey(offset, code.length);
  map.setIfUndefined(info.nodes, span, () => []).unshift(ast);
  return code;
}
function printBlock(block, info, offset, parentIndent, verbatim) {
  let blockIndent;
  let code = "";
  for (const line of block.fields.get("lines")) {
    code += line.newline.whitespace ?? "";
    const newlineCode = block.module.getToken(line.newline.node).code();
    if (offset || code || newlineCode.startsWith("#")) {
      code += newlineCode || "\n";
    }
    if (line.expression) {
      if (blockIndent === void 0) {
        if ((line.expression.whitespace?.length ?? 0) > (parentIndent?.length ?? 0)) {
          blockIndent = line.expression.whitespace;
        } else if (parentIndent !== void 0) {
          blockIndent = parentIndent + "    ";
        } else {
          blockIndent = "";
        }
      }
      const validIndent = (line.expression.whitespace?.length ?? 0) > (parentIndent?.length ?? 0);
      code += validIndent ? line.expression.whitespace : blockIndent;
      const lineNode = block.module.get(line.expression.node);
      assertEqual(lineNode.id, line.expression.node);
      assertEqual(parentId(lineNode), block.id);
      code += lineNode.printSubtree(info, offset + code.length, blockIndent, verbatim);
    }
  }
  const span = nodeKey(offset, code.length);
  map.setIfUndefined(info.nodes, span, () => []).unshift(block);
  return code;
}
function printDocumented(documented, info, offset, parentIndent, verbatim) {
  const open = documented.fields.get("open");
  const topIndent = parentIndent ?? open.whitespace ?? "";
  let code = "";
  code += open.node.code_;
  const minWhitespaceLength = topIndent.length + 1;
  let preferredWhitespace = topIndent + "  ";
  documented.fields.get("elements").forEach(({ token }, i) => {
    if (i === 0) {
      const whitespace = token.whitespace ?? " ";
      code += whitespace;
      code += token.node.code_;
      preferredWhitespace += whitespace;
    } else if (token.node.tokenType_ === Token.Type.TextSection) {
      if (token.whitespace && (verbatim || token.whitespace.length >= minWhitespaceLength))
        code += token.whitespace;
      else
        code += preferredWhitespace;
      code += token.node.code_;
    } else {
      code += token.whitespace ?? "";
      code += token.node.code_;
    }
  });
  code += documented.fields.get("newlines").map(({ whitespace, node }) => (whitespace ?? "") + node.code_).join("");
  if (documented.expression) {
    code += documented.fields.get("expression")?.whitespace ?? topIndent;
    code += documented.expression.printSubtree(info, offset + code.length, topIndent, verbatim);
  }
  const span = nodeKey(offset, code.length);
  map.setIfUndefined(info.nodes, span, () => []).unshift(documented);
  return code;
}
function parseBlock(code, inModule) {
  return parseBlockWithSpans(code, inModule).root;
}
function parse2(code, module) {
  const module_ = module ?? MutableModule.Transient();
  const ast = parseBlock(code, module_);
  const soleStatement = tryGetSoleValue(ast.statements());
  if (!soleStatement)
    return ast;
  const parent = parentId(soleStatement);
  if (parent)
    module_.delete(parent);
  soleStatement.fields.set("parent", void 0);
  return asOwned(soleStatement);
}
function parseBlockWithSpans(code, inModule) {
  const tree = parseEnso(code);
  const module = inModule ?? MutableModule.Transient();
  return abstract(module, tree, code);
}
function astCount(ast) {
  let count = 0;
  ast.visitRecursiveAst((_subtree) => {
    count += 1;
  });
  return count;
}
function setExternalIds(edit, spans, ids) {
  let astsMatched = 0;
  for (const [key, externalId] of ids.entries()) {
    const asts = spans.nodes.get(key);
    if (asts) {
      for (const ast of asts) {
        astsMatched += 1;
        const editAst = edit.getVersion(ast);
        if (editAst.externalId !== externalId)
          editAst.setExternalId(externalId);
      }
    }
  }
  return astsMatched;
}
function checkSpans(expected, encountered, code) {
  const lost = new Array();
  for (const [key, asts] of expected) {
    const outermostPrinted = asts[0];
    if (!outermostPrinted)
      continue;
    for (let i = 1; i < asts.length; ++i)
      assertEqual(asts[i]?.parentId, asts[i - 1]?.id);
    const encounteredAsts = encountered.get(key);
    if (encounteredAsts === void 0)
      lost.push([key, outermostPrinted]);
  }
  const lostInline = new Array();
  const lostBlock = new Array();
  for (const [key, ast] of lost) {
    const [start, end] = sourceRangeFromKey(key);
    (code.substring(start, end).match(/[\r\n]/) ? lostBlock : lostInline).push(ast);
  }
  return { lostInline, lostBlock };
}
function repair(root, module) {
  const printed = print(root);
  const reparsed = parseBlockWithSpans(printed.code);
  const { lostInline, lostBlock } = checkSpans(
    printed.info.nodes,
    reparsed.spans.nodes,
    printed.code
  );
  if (lostInline.length === 0) {
    if (lostBlock.length !== 0) {
      console.warn(`repair: Bad block elements, but all inline elements OK?`);
      const fixes2 = module ?? root.module.edit();
      resync(lostBlock, printed.info.nodes, reparsed.spans.nodes, fixes2);
      return { code: printed.code, fixes: fixes2 };
    }
    return { code: printed.code, fixes: void 0 };
  }
  const fixes = module ?? root.module.edit();
  for (const ast of lostInline) {
    if (ast instanceof Group)
      continue;
    fixes.getVersion(ast).update((ast2) => Group.new(fixes, ast2));
  }
  const printed2 = print(fixes.getVersion(root));
  const reparsed2 = parseBlockWithSpans(printed2.code);
  const { lostInline: lostInline2, lostBlock: lostBlock2 } = checkSpans(
    printed2.info.nodes,
    reparsed2.spans.nodes,
    printed2.code
  );
  if (lostInline2.length !== 0 || lostBlock2.length !== 0)
    resync([...lostInline2, ...lostBlock2], printed2.info.nodes, reparsed2.spans.nodes, fixes);
  return { code: printed2.code, fixes };
}
function resync(badAsts, badSpans, goodSpans, edit) {
  const parentsOfBadSubtrees = /* @__PURE__ */ new Set();
  const badAstIds = new Set(Array.from(badAsts, (ast) => ast.id));
  for (const id of subtreeRoots(edit, badAstIds)) {
    const parent = edit.get(id)?.parentId;
    if (parent)
      parentsOfBadSubtrees.add(parent);
  }
  const spanOfBadParent = new Array();
  for (const [span, asts] of badSpans) {
    for (const ast of asts) {
      if (parentsOfBadSubtrees.has(ast.id))
        spanOfBadParent.push([ast.id, span]);
    }
  }
  assertEqual(spanOfBadParent.length, parentsOfBadSubtrees.size);
  for (const [id, span] of spanOfBadParent) {
    const parent = edit.get(id);
    const goodAst = goodSpans.get(span)?.[0];
    assertDefined(goodAst);
    parent.syncToCode(goodAst.code());
  }
  console.warn(
    `repair: Replaced ${parentsOfBadSubtrees.size} subtrees with their reparsed equivalents.`,
    parentsOfBadSubtrees
  );
}
function hashSubtreeSyntax(ast, hashesOut) {
  let content = "";
  content += ast.typeName + ":";
  for (const child of ast.concreteChildren()) {
    content += child.whitespace ?? "?";
    if (isTokenId(child.node)) {
      content += "Token:" + hashString(ast.module.getToken(child.node).code());
    } else {
      content += hashSubtreeSyntax(ast.module.get(child.node), hashesOut);
    }
  }
  const astHash = hashString(content);
  map.setIfUndefined(hashesOut, astHash, () => []).unshift(ast);
  return astHash;
}
function hashString(input) {
  return xxHash128(input);
}
function syntaxHash(root) {
  const hashes = /* @__PURE__ */ new Map();
  const rootHash = hashSubtreeSyntax(root, hashes);
  return { root: rootHash, hashes };
}
function rawBlockToInline(tree) {
  if (tree.type !== Tree.Type.BodyBlock)
    return tree;
  return tryGetSoleValue(tree.statements)?.expression ?? tree;
}
function syncToCode(ast, code, metadataSource) {
  const codeBefore = ast.code();
  const textEdits = textChangeToEdits(codeBefore, code);
  applyTextEditsToAst(ast, textEdits, metadataSource ?? ast.module);
}
function calculateCorrespondence(ast, astSpans, parsedRoot, parsedSpans, textEdits, codeAfter) {
  const newSpans = /* @__PURE__ */ new Map();
  for (const [key, asts] of parsedSpans) {
    for (const ast2 of asts)
      newSpans.set(ast2.id, sourceRangeFromKey(key));
  }
  const toSync = /* @__PURE__ */ new Map();
  const candidates = /* @__PURE__ */ new Map();
  const allSpansBefore = Array.from(astSpans.keys(), sourceRangeFromKey);
  const spansBeforeAndAfter = applyTextEditsToSpans(textEdits, allSpansBefore).map(
    ([before, after]) => [before, trimEnd(after, codeAfter)]
  );
  const partAfterToAstBefore = /* @__PURE__ */ new Map();
  for (const [spanBefore, partAfter] of spansBeforeAndAfter) {
    const astBefore = astSpans.get(sourceRangeKey(spanBefore))?.[0];
    partAfterToAstBefore.set(sourceRangeKey(partAfter), astBefore);
  }
  const matchingPartsAfter = spansBeforeAndAfter.map(([_before, after]) => after);
  const parsedSpanTree = new AstWithSpans(parsedRoot, (id) => newSpans.get(id));
  const astsMatchingPartsAfter = enclosingSpans(parsedSpanTree, matchingPartsAfter);
  for (const [astAfter, partsAfter] of astsMatchingPartsAfter) {
    for (const partAfter of partsAfter) {
      const astBefore = partAfterToAstBefore.get(sourceRangeKey(partAfter));
      if (astBefore.typeName() === astAfter.typeName()) {
        ;
        (rangeLength(newSpans.get(astAfter.id)) === rangeLength(partAfter) ? toSync : candidates).set(astBefore.id, astAfter);
        break;
      }
    }
  }
  const oldIdsMatched = /* @__PURE__ */ new Set();
  const newIdsMatched = /* @__PURE__ */ new Set();
  for (const [oldId, newAst] of toSync) {
    oldIdsMatched.add(oldId);
    newIdsMatched.add(newAst.id);
  }
  const newHashes = syntaxHash(parsedRoot).hashes;
  const oldHashes = syntaxHash(ast).hashes;
  for (const [hash, newAsts] of newHashes) {
    const unmatchedNewAsts = newAsts.filter((ast2) => !newIdsMatched.has(ast2.id));
    const unmatchedOldAsts = oldHashes.get(hash)?.filter((ast2) => !oldIdsMatched.has(ast2.id)) ?? [];
    for (const [unmatchedNew, unmatchedOld] of zip(unmatchedNewAsts, unmatchedOldAsts)) {
      toSync.set(unmatchedOld.id, unmatchedNew);
      oldIdsMatched.add(unmatchedOld.id);
      newIdsMatched.add(unmatchedNew.id);
    }
  }
  for (const [beforeId, after] of candidates) {
    if (oldIdsMatched.has(beforeId) || newIdsMatched.has(after.id))
      continue;
    toSync.set(beforeId, after);
  }
  return toSync;
}
function applyTextEditsToAst(ast, textEdits, metadataSource) {
  const printed = print(ast);
  const code = applyTextEdits(printed.code, textEdits);
  const rawParsedBlock = parseEnso(code);
  const rawParsed = ast instanceof MutableBodyBlock ? rawParsedBlock : rawBlockToInline(rawParsedBlock);
  const parsed = abstract(ast.module, rawParsed, code);
  const toSync = calculateCorrespondence(
    ast,
    printed.info.nodes,
    parsed.root,
    parsed.spans.nodes,
    textEdits,
    code
  );
  syncTree(ast, parsed.root, toSync, ast.module, metadataSource);
}
function syncTree(target, newContent, toSync, edit, metadataSource) {
  const newIdToEquivalent = /* @__PURE__ */ new Map();
  for (const [beforeId, after] of toSync)
    newIdToEquivalent.set(after.id, beforeId);
  const childReplacerFor = (parentId3) => (id) => {
    const original = newIdToEquivalent.get(id);
    if (original) {
      const replacement = edit.get(original);
      if (replacement.parentId !== parentId3)
        replacement.fields.set("parent", parentId3);
      return original;
    } else {
      const child = edit.get(id);
      if (child.parentId !== parentId3)
        child.fields.set("parent", parentId3);
    }
  };
  const parentId2 = target.fields.get("parent");
  assertDefined(parentId2);
  const parent = edit.get(parentId2);
  const targetSyncEquivalent = toSync.get(target.id);
  const syncRoot = targetSyncEquivalent?.id === newContent.id ? targetSyncEquivalent : void 0;
  if (!syncRoot) {
    parent.replaceChild(target.id, newContent);
    newContent.fields.set("metadata", target.fields.get("metadata").clone());
    target.fields.get("metadata").set("externalId", newExternalId());
  }
  const newRoot = syncRoot ? target : newContent;
  newRoot.visitRecursiveAst((ast) => {
    const syncFieldsFrom = toSync.get(ast.id);
    const editAst = edit.getVersion(ast);
    if (syncFieldsFrom) {
      const originalAssignmentExpression = ast instanceof Assignment ? metadataSource.get(ast.fields.get("expression").node) : void 0;
      syncFields(edit.getVersion(ast), syncFieldsFrom, childReplacerFor(ast.id));
      if (editAst instanceof MutableAssignment && originalAssignmentExpression) {
        if (editAst.expression.externalId !== originalAssignmentExpression.externalId)
          editAst.expression.setExternalId(originalAssignmentExpression.externalId);
        syncNodeMetadata(
          editAst.expression.mutableNodeMetadata(),
          originalAssignmentExpression.nodeMetadata
        );
      }
    } else {
      rewriteRefs(editAst, childReplacerFor(ast.id));
    }
    return true;
  });
  return newRoot;
}
var AstWithSpans = class _AstWithSpans {
  ast;
  getSpan;
  constructor(ast, getSpan) {
    this.ast = ast;
    this.getSpan = getSpan;
  }
  id() {
    return this.ast;
  }
  span() {
    return this.getSpan(this.ast.id);
  }
  *children() {
    for (const child of this.ast.children()) {
      if (child instanceof Ast)
        yield new _AstWithSpans(child, this.getSpan);
    }
  }
};

// shared/ast/tree.ts
function allKeys(keys) {
  return Object.keys(keys);
}
var astFieldKeys = allKeys({
  id: null,
  type: null,
  parent: null,
  metadata: null
});
var Ast = class {
  module;
  /** @internal */
  fields;
  get id() {
    return this.fields.get("id");
  }
  get externalId() {
    const id = this.fields.get("metadata").get("externalId");
    assert(id != null);
    return id;
  }
  get nodeMetadata() {
    const metadata2 = this.fields.get("metadata");
    return metadata2;
  }
  typeName() {
    return this.fields.get("type");
  }
  /**
   * Return whether `this` and `other` are the same object, possibly in different modules.
   */
  is(other) {
    return this.id === other.id;
  }
  innerExpression() {
    return this;
  }
  code() {
    return print(this).code;
  }
  visitRecursive(visit) {
    visit(this);
    for (const child of this.children()) {
      if (isToken(child)) {
        visit(child);
      } else {
        child.visitRecursive(visit);
      }
    }
  }
  visitRecursiveAst(visit) {
    if (visit(this) === false)
      return;
    for (const child of this.children()) {
      if (!isToken(child))
        child.visitRecursiveAst(visit);
    }
  }
  printSubtree(info, offset, parentIndent, verbatim) {
    return printAst(this, info, offset, parentIndent, verbatim);
  }
  /** Returns child subtrees, without information about the whitespace between them. */
  *children() {
    for (const child of this.concreteChildren()) {
      if (isTokenId(child.node)) {
        yield this.module.getToken(child.node);
      } else {
        const node = this.module.get(child.node);
        if (node)
          yield node;
      }
    }
  }
  get parentId() {
    const parentId2 = this.fields.get("parent");
    if (parentId2 !== ROOT_ID)
      return parentId2;
  }
  parent() {
    return this.module.get(this.parentId);
  }
  static parseBlock(source, inModule) {
    return parseBlock(source, inModule);
  }
  static parse(source, module) {
    return parse2(source, module);
  }
  ////////////////////
  constructor(module, fields) {
    this.module = module;
    this.fields = fields;
  }
};
var MutableAst3 = class extends Ast {
  setExternalId(id) {
    this.fields.get("metadata").set("externalId", id);
  }
  mutableNodeMetadata() {
    const metadata2 = this.fields.get("metadata");
    return metadata2;
  }
  setNodeMetadata(nodeMeta) {
    const metadata2 = this.fields.get("metadata");
    for (const [key, value] of Object.entries(nodeMeta))
      if (value !== void 0)
        metadata2.set(key, value);
  }
  /** Modify the parent of this node to refer to a new object instead. Return the object, which now has no parent. */
  replace(replacement) {
    const parentId2 = this.fields.get("parent");
    if (parentId2) {
      const parent = this.module.get(parentId2);
      parent.replaceChild(this.id, replacement);
      this.fields.set("parent", void 0);
    }
    return asOwned(this);
  }
  /** Change the value of the object referred to by the `target` ID. (The initial ID of `replacement` will be ignored.)
   *  Returns the old value, with a new (unreferenced) ID.
   */
  replaceValue(replacement) {
    const replacement_ = this.module.copyIfForeign(replacement);
    const old = this.replace(replacement_);
    replacement_.fields.set("metadata", old.fields.get("metadata").clone());
    old.setExternalId(newExternalId());
    return old;
  }
  replaceValueChecked(replacement) {
    const parentId2 = this.fields.get("parent");
    assertDefined(parentId2);
    return this.replaceValue(replacement);
  }
  /** Replace the parent of this object with a reference to a new placeholder object.
   *  Returns the object, now parentless, and the placeholder. */
  takeToReplace() {
    if (parentId(this)) {
      const placeholder = Wildcard.new(this.module);
      const node = this.replace(placeholder);
      return { node, placeholder };
    } else {
      return { node: asOwned(this), placeholder: void 0 };
    }
  }
  /** Replace the parent of this object with a reference to a new placeholder object.
   *  Returns the object, now parentless. */
  take() {
    return this.replace(Wildcard.new(this.module));
  }
  takeIfParented() {
    const parent = parentId(this);
    if (parent) {
      const parentAst = this.module.get(parent);
      const placeholder = Wildcard.new(this.module);
      parentAst.replaceChild(this.id, placeholder);
      this.fields.set("parent", void 0);
    }
    return asOwned(this);
  }
  /** Replace the value assigned to the given ID with a placeholder.
   *  Returns the removed value, with a new unreferenced ID.
   **/
  takeValue() {
    const placeholder = Wildcard.new(this.module);
    const node = this.replaceValue(placeholder);
    return { node, placeholder };
  }
  /** Take this node from the tree, and replace it with the result of applying the given function to it.
   *
   *  Note that this is a modification of the *parent* node. Any `Ast` objects or `AstId`s that pointed to the old value
   *  will still point to the old value.
   */
  update(f) {
    const taken = this.takeToReplace();
    assertDefined(taken.placeholder, "To replace an `Ast`, it must have a parent.");
    const replacement = f(taken.node);
    taken.placeholder.replace(replacement);
    return replacement;
  }
  /** Take this node from the tree, and replace it with the result of applying the given function to it; transfer the
   *  metadata from this node to the replacement.
   *
   *  Note that this is a modification of the *parent* node. Any `Ast` objects or `AstId`s that pointed to the old value
   *  will still point to the old value.
   */
  updateValue(f) {
    const taken = this.takeValue();
    assertDefined(taken.placeholder, "To replace an `Ast`, it must have a parent.");
    const replacement = f(taken.node);
    taken.placeholder.replaceValue(replacement);
    return replacement;
  }
  mutableParent() {
    const parentId2 = this.fields.get("parent");
    if (parentId2 === "ROOT_ID")
      return;
    return this.module.get(parentId2);
  }
  /** Modify this tree to represent the given code, while minimizing changes from the current set of `Ast`s. */
  syncToCode(code, metadataSource) {
    syncToCode(this, code, metadataSource);
  }
  /** Update the AST according to changes to its corresponding source code. */
  applyTextEdits(textEdits, metadataSource) {
    applyTextEditsToAst(this, textEdits, metadataSource ?? this.module);
  }
  ///////////////////
  /** @internal */
  importReferences(module) {
    if (module === this.module)
      return;
    for (const child of this.concreteChildren()) {
      if (!isTokenId(child.node)) {
        const childInForeignModule = module.get(child.node);
        assert(childInForeignModule !== void 0);
        const importedChild = this.module.copy(childInForeignModule);
        importedChild.fields.set("parent", void 0);
        this.replaceChild(child.node, asOwned(importedChild));
      }
    }
  }
  /** @internal */
  replaceChild(target, replacement) {
    const replacementId = this.claimChild(replacement);
    const changes = rewriteRefs(this, (id) => id === target ? replacementId : void 0);
    assertEqual(changes, 1);
  }
  claimChild(child) {
    return child ? claimChild(this.module, child, this.id) : void 0;
  }
};
function* fieldDataEntries(map3) {
  for (const entry of map3.entries()) {
    if (!astFieldKeys.includes(entry[0]))
      yield entry;
  }
}
function idRewriter(f) {
  return (field) => {
    if (typeof field !== "object")
      return;
    if (!("node" in field))
      return;
    if (isTokenId(field.node))
      return;
    const newId = f(field.node);
    if (!newId)
      return;
    return { whitespace: field.whitespace, node: newId };
  };
}
function rewriteRefs(ast, f) {
  let fieldsChanged = 0;
  for (const [key, value] of fieldDataEntries(ast.fields)) {
    const newValue = rewriteFieldRefs(value, idRewriter(f));
    if (newValue !== void 0) {
      ast.fields.set(key, newValue);
      fieldsChanged += 1;
    }
  }
  return fieldsChanged;
}
function syncFields(ast1, ast2, f) {
  for (const [key, value] of fieldDataEntries(ast2.fields)) {
    const newValue = mapRefs(value, idRewriter(f));
    if (!fieldEqual(ast1.fields.get(key), newValue))
      ast1.fields.set(key, newValue);
  }
}
function syncNodeMetadata(target, source) {
  const oldPos = target.get("position");
  const newPos = source.get("position");
  if (oldPos?.x !== newPos?.x || oldPos?.y !== newPos?.y)
    target.set("position", newPos);
  const newVis = source.get("visualization");
  if (!visMetadataEquals(target.get("visualization"), newVis))
    target.set("visualization", newVis);
}
function rewriteFieldRefs(field, f) {
  const newValue = f(field);
  if (newValue)
    return newValue;
  if (typeof field !== "object")
    return;
  if ("forEach" in field) {
    const newValues = /* @__PURE__ */ new Map();
    field.forEach((subfield, i) => {
      const newValue2 = rewriteFieldRefs(subfield, f);
      if (newValue2 !== void 0)
        newValues.set(i, newValue2);
    });
    if (newValues.size)
      return Array.from(field, (oldValue, i) => newValues.get(i) ?? oldValue);
  } else {
    const fieldObject = field;
    const newValues = /* @__PURE__ */ new Map();
    for (const [key, value] of Object.entries(fieldObject)) {
      const newValue2 = rewriteFieldRefs(value, f);
      if (newValue2 !== void 0)
        newValues.set(key, newValue2);
    }
    if (newValues.size)
      return Object.fromEntries(
        Object.entries(fieldObject).map(([key, oldValue]) => [key, newValues.get(key) ?? oldValue])
      );
  }
}
function mapRefs(field, f) {
  return rewriteFieldRefs(field, f) ?? field;
}
function fieldEqual(field1, field2) {
  if (typeof field1 !== "object")
    return field1 === field2;
  if (typeof field2 !== "object")
    return false;
  if ("node" in field1 && "node" in field2) {
    if (field1["whitespace"] !== field2["whitespace"])
      return false;
    if (isTokenId(field1.node) && isTokenId(field2.node))
      return Token2.equal(field1.node, field2.node);
    else
      return field1.node === field2.node;
  } else if ("node" in field1 || "node" in field2) {
    return false;
  } else if (Array.isArray(field1) && Array.isArray(field2)) {
    return field1.length === field2.length && field1.every((value1, i) => fieldEqual(value1, field2[i]));
  } else if (Array.isArray(field1) || Array.isArray(field2)) {
    return false;
  } else {
    const fieldObject1 = field1;
    const fieldObject2 = field2;
    const keys = /* @__PURE__ */ new Set();
    for (const key of Object.keys(fieldObject1))
      keys.add(key);
    for (const key of Object.keys(fieldObject2))
      keys.add(key);
    for (const key of keys)
      if (!fieldEqual(fieldObject1[key], fieldObject2[key]))
        return false;
    return true;
  }
}
function applyMixins(derivedCtor, constructors) {
  constructors.forEach((baseCtor) => {
    Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {
      Object.defineProperty(
        derivedCtor.prototype,
        name,
        Object.getOwnPropertyDescriptor(baseCtor.prototype, name) || /* @__PURE__ */ Object.create(null)
      );
    });
  });
}
var App = class _App extends Ast {
  constructor(module, fields) {
    super(module, fields);
  }
  static tryParse(source, module) {
    const parsed = parse2(source, module);
    if (parsed instanceof MutableApp)
      return parsed;
  }
  static concrete(module, func, parens, nameSpecification2, argument) {
    const base = module.baseObject("App");
    const id_ = base.get("id");
    const fields = composeFieldData(base, {
      function: concreteChild(module, func, id_),
      parens,
      nameSpecification: nameSpecification2,
      argument: concreteChild(module, argument, id_)
    });
    return asOwned(new MutableApp(module, fields));
  }
  static new(module, func, argumentName, argument) {
    return _App.concrete(
      module,
      autospaced(func),
      void 0,
      nameSpecification(argumentName),
      autospaced(argument)
    );
  }
  static positional(func, argument, module) {
    return _App.new(module ?? MutableModule.Transient(), func, void 0, argument);
  }
  static PositionalSequence(func, args) {
    return args.reduce(
      (expression, argument) => _App.new(func.module, expression, void 0, argument),
      func
    );
  }
  get function() {
    return this.module.get(this.fields.get("function").node);
  }
  get argumentName() {
    return this.module.getToken(this.fields.get("nameSpecification")?.name.node);
  }
  get argument() {
    return this.module.get(this.fields.get("argument").node);
  }
  *concreteChildren(verbatim) {
    const { function: function_, parens, nameSpecification: nameSpecification2, argument } = getAll(this.fields);
    yield ensureUnspaced(function_, verbatim);
    const useParens = !!(parens && (nameSpecification2 || verbatim));
    const spacedEquals = useParens && !!nameSpecification2?.equals.whitespace;
    if (useParens)
      yield ensureSpaced(parens.open, verbatim);
    if (nameSpecification2) {
      yield useParens ? preferUnspaced(nameSpecification2.name) : ensureSpaced(nameSpecification2.name, verbatim);
      yield ensureSpacedOnlyIf(nameSpecification2.equals, spacedEquals, verbatim);
    }
    yield ensureSpacedOnlyIf(argument, !nameSpecification2 || spacedEquals, verbatim);
    if (useParens)
      yield preferUnspaced(parens.close);
  }
  printSubtree(info, offset, parentIndent, verbatim) {
    const verbatim_ = verbatim ?? (this.function instanceof Invalid || this.argument instanceof Invalid);
    return super.printSubtree(info, offset, parentIndent, verbatim_);
  }
};
function ensureSpacedOnlyIf(child, condition, verbatim) {
  return condition ? ensureSpaced(child, verbatim) : ensureUnspaced(child, verbatim);
}
function isConcrete(child) {
  return child.whitespace !== void 0;
}
function tryAsConcrete(child) {
  return isConcrete(child) ? child : void 0;
}
function ensureSpaced(child, verbatim) {
  const concreteInput = tryAsConcrete(child);
  if (verbatim && concreteInput)
    return concreteInput;
  return concreteInput?.whitespace ? concreteInput : { ...child, whitespace: " " };
}
function ensureUnspaced(child, verbatim) {
  const concreteInput = tryAsConcrete(child);
  if (verbatim && concreteInput)
    return concreteInput;
  return concreteInput?.whitespace === "" ? concreteInput : { ...child, whitespace: "" };
}
function preferSpacedIf(child, condition) {
  return condition ? preferSpaced(child) : preferUnspaced(child);
}
function preferUnspaced(child) {
  return tryAsConcrete(child) ?? { ...child, whitespace: "" };
}
function preferSpaced(child) {
  return tryAsConcrete(child) ?? { ...child, whitespace: " " };
}
var MutableApp = class extends App {
  setFunction(value) {
    setNode(this.fields, "function", this.claimChild(value));
  }
  setArgumentName(name) {
    this.fields.set("nameSpecification", nameSpecification(name));
  }
  setArgument(value) {
    setNode(this.fields, "argument", this.claimChild(value));
  }
};
applyMixins(MutableApp, [MutableAst3]);
var UnaryOprApp = class extends Ast {
  constructor(module, fields) {
    super(module, fields);
  }
  static tryParse(source, module) {
    const parsed = parse2(source, module);
    if (parsed instanceof MutableUnaryOprApp)
      return parsed;
  }
  static concrete(module, operator, argument) {
    const base = module.baseObject("UnaryOprApp");
    const id_ = base.get("id");
    const fields = composeFieldData(base, {
      operator,
      argument: concreteChild(module, argument, id_)
    });
    return asOwned(new MutableUnaryOprApp(module, fields));
  }
  static new(module, operator, argument) {
    return this.concrete(module, unspaced(operator), argument ? autospaced(argument) : void 0);
  }
  get operator() {
    return this.module.getToken(this.fields.get("operator").node);
  }
  get argument() {
    return this.module.get(this.fields.get("argument")?.node);
  }
  *concreteChildren(_verbatim) {
    const { operator, argument } = getAll(this.fields);
    yield operator;
    if (argument)
      yield argument;
  }
};
var MutableUnaryOprApp = class extends UnaryOprApp {
  setOperator(value) {
    this.fields.set("operator", unspaced(value));
  }
  setArgument(argument) {
    setNode(this.fields, "argument", this.claimChild(argument));
  }
};
applyMixins(MutableUnaryOprApp, [MutableAst3]);
var NegationApp = class extends Ast {
  constructor(module, fields) {
    super(module, fields);
  }
  static tryParse(source, module) {
    const parsed = parse2(source, module);
    if (parsed instanceof MutableNegationApp)
      return parsed;
  }
  static concrete(module, operator, argument) {
    const base = module.baseObject("NegationApp");
    const id_ = base.get("id");
    const fields = composeFieldData(base, {
      operator,
      argument: concreteChild(module, argument, id_)
    });
    return asOwned(new MutableNegationApp(module, fields));
  }
  static new(module, operator, argument) {
    return this.concrete(module, unspaced(operator), autospaced(argument));
  }
  get operator() {
    return this.module.getToken(this.fields.get("operator").node);
  }
  get argument() {
    return this.module.get(this.fields.get("argument").node);
  }
  *concreteChildren(_verbatim) {
    const { operator, argument } = getAll(this.fields);
    yield operator;
    if (argument)
      yield argument;
  }
};
var MutableNegationApp = class extends NegationApp {
  setArgument(value) {
    setNode(this.fields, "argument", this.claimChild(value));
  }
};
applyMixins(MutableNegationApp, [MutableAst3]);
var OprApp = class _OprApp extends Ast {
  constructor(module, fields) {
    super(module, fields);
  }
  static tryParse(source, module) {
    const parsed = parse2(source, module);
    if (parsed instanceof MutableOprApp)
      return parsed;
  }
  static concrete(module, lhs, operators, rhs) {
    const base = module.baseObject("OprApp");
    const id_ = base.get("id");
    const fields = composeFieldData(base, {
      lhs: concreteChild(module, lhs, id_),
      operators,
      rhs: concreteChild(module, rhs, id_)
    });
    return asOwned(new MutableOprApp(module, fields));
  }
  static new(module, lhs, operator, rhs) {
    const operatorToken = operator instanceof Token2 ? operator : Token2.new(operator, Token.Type.Operator);
    return _OprApp.concrete(module, unspaced(lhs), [autospaced(operatorToken)], autospaced(rhs));
  }
  get lhs() {
    return this.module.get(this.fields.get("lhs")?.node);
  }
  get operator() {
    const operators = this.fields.get("operators");
    const operators_ = operators.map((child) => ({
      ...child,
      node: this.module.getToken(child.node)
    }));
    const [opr] = operators_;
    return opr ? Ok(opr.node) : Err(operators_);
  }
  get rhs() {
    return this.module.get(this.fields.get("rhs")?.node);
  }
  *concreteChildren(_verbatim) {
    const { lhs, operators, rhs } = getAll(this.fields);
    if (lhs)
      yield lhs;
    yield* operators;
    if (rhs)
      yield rhs;
  }
};
var MutableOprApp = class extends OprApp {
  setLhs(value) {
    setNode(this.fields, "lhs", this.claimChild(value));
  }
  setOperator(value) {
    this.fields.set("operators", [unspaced(value)]);
  }
  setRhs(value) {
    setNode(this.fields, "rhs", this.claimChild(value));
  }
};
applyMixins(MutableOprApp, [MutableAst3]);
var PropertyAccess = class extends Ast {
  constructor(module, fields) {
    super(module, fields);
  }
  static tryParse(source, module) {
    const parsed = parse2(source, module);
    if (parsed instanceof MutablePropertyAccess)
      return parsed;
  }
  static new(module, lhs, rhs, style) {
    const dot = Token2.new(".", Token.Type.Operator);
    const whitespace = style?.spaced ? " " : "";
    return this.concrete(
      module,
      unspaced(lhs),
      { whitespace, node: dot },
      { whitespace, node: Ident.newAllowingOperators(module, toIdent(rhs)) }
    );
  }
  static Sequence(segments, module) {
    let path2;
    let operatorInNonFinalSegment = false;
    segments.forEach((s, i) => {
      const t = toIdent(s);
      if (i !== segments.length - 1 && !isIdentifier(t.code()))
        operatorInNonFinalSegment = true;
      path2 = path2 ? this.new(module, path2, t) : Ident.newAllowingOperators(module, t);
    });
    if (!operatorInNonFinalSegment)
      return path2;
  }
  static concrete(module, lhs, operator, rhs) {
    const base = module.baseObject("PropertyAccess");
    const id_ = base.get("id");
    const fields = composeFieldData(base, {
      lhs: concreteChild(module, lhs, id_),
      operator,
      rhs: concreteChild(module, rhs, id_)
    });
    return asOwned(new MutablePropertyAccess(module, fields));
  }
  get lhs() {
    return this.module.get(this.fields.get("lhs")?.node);
  }
  get operator() {
    return this.module.getToken(this.fields.get("operator").node);
  }
  get rhs() {
    const ast = this.module.get(this.fields.get("rhs").node);
    assert(ast instanceof Ident);
    return ast.token;
  }
  *concreteChildren(_verbatim) {
    const { lhs, operator, rhs } = getAll(this.fields);
    if (lhs)
      yield lhs;
    yield operator;
    yield rhs;
  }
};
var MutablePropertyAccess = class extends PropertyAccess {
  setLhs(value) {
    setNode(this.fields, "lhs", this.claimChild(value));
  }
  setRhs(ident) {
    const node = this.claimChild(Ident.newAllowingOperators(this.module, ident));
    const old = this.fields.get("rhs");
    this.fields.set("rhs", old ? { ...old, node } : unspaced(node));
  }
};
applyMixins(MutablePropertyAccess, [MutableAst3]);
var Generic = class extends Ast {
  constructor(module, fields) {
    super(module, fields);
  }
  static concrete(module, children) {
    const base = module.baseObject("Generic");
    const id_ = base.get("id");
    const fields = composeFieldData(base, {
      children: children.map((child) => concreteChild(module, child, id_))
    });
    return asOwned(new MutableGeneric(module, fields));
  }
  concreteChildren(_verbatim) {
    return this.fields.get("children")[Symbol.iterator]();
  }
};
var MutableGeneric = class extends Generic {
};
applyMixins(MutableGeneric, [MutableAst3]);
function multiSegmentAppSegment(header, body) {
  return {
    header: autospaced(Token2.new(header, Token.Type.Ident)),
    body: spaced(body ? body : void 0)
  };
}
function multiSegmentAppSegmentToRaw(module, msas, parent) {
  if (!msas)
    return void 0;
  return {
    ...msas,
    body: concreteChild(module, msas.body, parent)
  };
}
var Import = class extends Ast {
  constructor(module, fields) {
    super(module, fields);
  }
  static tryParse(source, module) {
    const parsed = parse2(source, module);
    if (parsed instanceof MutableImport)
      return parsed;
  }
  get polyglot() {
    return this.module.get(this.fields.get("polyglot")?.body?.node);
  }
  get from() {
    return this.module.get(this.fields.get("from")?.body?.node);
  }
  get import_() {
    return this.module.get(this.fields.get("import").body?.node);
  }
  get all() {
    return this.module.getToken(this.fields.get("all")?.node);
  }
  get as() {
    return this.module.get(this.fields.get("as")?.body?.node);
  }
  get hiding() {
    return this.module.get(this.fields.get("hiding")?.body?.node);
  }
  static concrete(module, polyglot, from, import_, all, as, hiding) {
    const base = module.baseObject("Import");
    const id_ = base.get("id");
    const ownedFields = {
      polyglot,
      from,
      import: import_,
      all,
      as,
      hiding
    };
    const rawFields = mapRefs(ownedFields, ownedToRaw(module, id_));
    const fields = composeFieldData(base, rawFields);
    return asOwned(new MutableImport(module, fields));
  }
  static Qualified(path2, module) {
    const path_ = PropertyAccess.Sequence(path2, module);
    if (!path_)
      return;
    return MutableImport.concrete(
      module,
      void 0,
      void 0,
      multiSegmentAppSegment("import", path_),
      void 0,
      void 0,
      void 0
    );
  }
  static Unqualified(path2, name, module) {
    const path_ = PropertyAccess.Sequence(path2, module);
    if (!path_)
      return;
    const name_ = Ident.newAllowingOperators(module, name);
    return MutableImport.concrete(
      module,
      void 0,
      multiSegmentAppSegment("from", path_),
      multiSegmentAppSegment("import", name_),
      void 0,
      void 0,
      void 0
    );
  }
  *concreteChildren(_verbatim) {
    const segment = (segment2) => {
      const parts = [];
      if (segment2)
        parts.push(segment2.header);
      if (segment2?.body)
        parts.push(segment2.body);
      return parts;
    };
    const { polyglot, from, import: import_, all, as, hiding } = getAll(this.fields);
    yield* segment(polyglot);
    yield* segment(from);
    yield* segment(import_);
    if (all)
      yield all;
    yield* segment(as);
    yield* segment(hiding);
  }
};
var MutableImport = class extends Import {
  toRaw(msas) {
    return multiSegmentAppSegmentToRaw(this.module, msas, this.id);
  }
  setPolyglot(value) {
    this.fields.set(
      "polyglot",
      value ? this.toRaw(multiSegmentAppSegment("polyglot", value)) : void 0
    );
  }
  setFrom(value) {
    this.fields.set("from", value ? this.toRaw(multiSegmentAppSegment("from", value)) : value);
  }
  setImport(value) {
    this.fields.set("import", this.toRaw(multiSegmentAppSegment("import", value)));
  }
  setAll(value) {
    this.fields.set("all", spaced(value));
  }
  setAs(value) {
    this.fields.set("as", this.toRaw(multiSegmentAppSegment("as", value)));
  }
  setHiding(value) {
    this.fields.set("hiding", this.toRaw(multiSegmentAppSegment("hiding", value)));
  }
};
applyMixins(MutableImport, [MutableAst3]);
function ownedToRaw(module, parentId2) {
  return (child) => {
    if (typeof child !== "object")
      return;
    if (!("node" in child))
      return;
    if (isToken(child.node))
      return;
    return { ...child, node: claimChild(module, child.node, parentId2) };
  };
}
function rawToConcrete(module) {
  return (child) => {
    if (typeof child !== "object")
      return;
    if (!("node" in child))
      return;
    if (isTokenId(child.node))
      return { ...child, node: module.getToken(child.node) };
    else
      return { ...child, node: module.get(child.node) };
  };
}
function concreteToOwned(module) {
  return (child) => {
    if (typeof child !== "object")
      return;
    if (!("node" in child))
      return;
    if (isTokenChild(child))
      return child;
    else
      return { ...child, node: module.copy(child.node) };
  };
}
function textElementValue(element) {
  switch (element.type) {
    case "token": {
      if (element.interpreted != null)
        return element.interpreted;
      if (element.token.node.tokenType_ === Token.Type.TextNewline)
        return "\n";
      return element.token.node.code();
    }
    case "splice": {
      let s = "";
      s += element.open.node.code();
      if (element.expression) {
        s += element.expression.whitespace ?? "";
        s += element.expression.node.code();
      }
      s += element.close.whitespace ?? "";
      s += element.close.node.code();
      return s;
    }
  }
}
function rawTextElementValue(raw, module) {
  return textElementValue(mapRefs(raw, rawToConcrete(module)));
}
function uninterpolatedText(elements, module) {
  return elements.reduce((s, e) => s + rawTextElementValue(e, module), "");
}
function fieldConcreteChildren(field) {
  const children = new Array();
  rewriteFieldRefs(field, (subfield) => {
    if (typeof subfield === "object" && "node" in subfield)
      children.push(subfield);
  });
  return children;
}
var TextLiteral = class _TextLiteral extends Ast {
  constructor(module, fields) {
    super(module, fields);
  }
  static tryParse(source, module) {
    const parsed = parse2(source, module);
    if (parsed instanceof MutableTextLiteral)
      return parsed;
  }
  static concrete(module, open, newline, elements, close) {
    const base = module.baseObject("TextLiteral");
    const id_ = base.get("id");
    const fields = composeFieldData(base, {
      open,
      newline,
      elements: elements.map((e) => mapRefs(e, ownedToRaw(module, id_))),
      close
    });
    return asOwned(new MutableTextLiteral(module, fields));
  }
  static new(rawText, module) {
    const escaped = escapeTextLiteral(rawText);
    const parsed = parse2(`'${escaped}'`, module);
    if (!(parsed instanceof MutableTextLiteral)) {
      console.error(`Failed to escape string for interpolated text`, rawText, escaped, parsed);
      const safeText = rawText.replaceAll(/[^-+A-Za-z0-9_. ]/g, "");
      return _TextLiteral.new(safeText, module);
    }
    return parsed;
  }
  /**
   * Return the literal value of the string with all escape sequences applied, but without
   * evaluating any interpolated expressions.
   */
  get rawTextContent() {
    return uninterpolatedText(this.fields.get("elements"), this.module);
  }
  *concreteChildren(_verbatim) {
    const { open, newline, elements, close } = getAll(this.fields);
    if (open)
      yield open;
    if (newline)
      yield newline;
    for (const e of elements)
      yield* fieldConcreteChildren(e);
    if (close)
      yield close;
  }
  boundaryTokenCode() {
    return (this.open || this.close)?.code();
  }
  isInterpolated() {
    const token = this.boundaryTokenCode();
    return token === "'" || token === "'''";
  }
  get open() {
    return this.module.getToken(this.fields.get("open")?.node);
  }
  get close() {
    return this.module.getToken(this.fields.get("close")?.node);
  }
  get elements() {
    return this.fields.get("elements").map((e) => mapRefs(e, rawToConcrete(this.module)));
  }
};
var MutableTextLiteral = class extends TextLiteral {
  setBoundaries(code) {
    this.fields.set("open", unspaced(Token2.new(code)));
    this.fields.set("close", unspaced(Token2.new(code)));
  }
  setElements(elements) {
    this.fields.set(
      "elements",
      elements.map((e) => mapRefs(e, ownedToRaw(this.module, this.id)))
    );
  }
  /**
   * Set literal value of the string. The code representation of assigned text will be automatically
   * transformed to use escape sequences when necessary.
   */
  setRawTextContent(rawText) {
    let boundary = this.boundaryTokenCode();
    const isInterpolated = this.isInterpolated();
    const mustBecomeInterpolated = !isInterpolated && (!boundary || rawText.match(/["\n\r]/));
    if (mustBecomeInterpolated) {
      boundary = "'";
      this.setBoundaries(boundary);
    }
    const literalContents = isInterpolated || mustBecomeInterpolated ? escapeTextLiteral(rawText) : rawText;
    const parsed = parse2(`${boundary}${literalContents}${boundary}`);
    assert(parsed instanceof TextLiteral);
    const elements = parsed.elements.map((e) => mapRefs(e, concreteToOwned(this.module)));
    this.setElements(elements);
  }
};
applyMixins(MutableTextLiteral, [MutableAst3]);
var Documented = class extends Ast {
  constructor(module, fields) {
    super(module, fields);
  }
  static tryParse(source, module) {
    const parsed = parse2(source, module);
    if (parsed instanceof MutableDocumented)
      return parsed;
  }
  static new(text, expression) {
    return this.concrete(
      expression.module,
      void 0,
      textToUninterpolatedElements(text),
      void 0,
      autospaced(expression)
    );
  }
  static concrete(module, open, elements, newlines, expression) {
    const base = module.baseObject("Documented");
    const id_ = base.get("id");
    const fields = composeFieldData(base, {
      open: open ?? unspaced(Token2.new("##", Token.Type.Operator)),
      elements: elements.map((e) => mapRefs(e, ownedToRaw(module, id_))),
      newlines: newlines ?? [unspaced(Token2.new("\n", Token.Type.Newline))],
      expression: concreteChild(module, expression, id_)
    });
    return asOwned(new MutableDocumented(module, fields));
  }
  get expression() {
    return this.module.get(this.fields.get("expression")?.node);
  }
  /** Return the string value of the documentation. */
  documentation() {
    const raw = uninterpolatedText(this.fields.get("elements"), this.module);
    return raw.startsWith(" ") ? raw.slice(1) : raw;
  }
  *concreteChildren(_verbatim) {
    const { open, elements, newlines, expression } = getAll(this.fields);
    yield open;
    for (const { token } of elements)
      yield token;
    yield* newlines;
    if (expression)
      yield expression;
  }
  printSubtree(info, offset, parentIndent, verbatim) {
    return printDocumented(this, info, offset, parentIndent, verbatim);
  }
};
var MutableDocumented = class extends Documented {
  setDocumentationText(text) {
    this.fields.set(
      "elements",
      textToUninterpolatedElements(text).map(
        (owned) => mapRefs(owned, ownedToRaw(this.module, this.id))
      )
    );
  }
  setExpression(value) {
    this.fields.set("expression", unspaced(this.claimChild(value)));
  }
};
applyMixins(MutableDocumented, [MutableAst3]);
function textToUninterpolatedElements(text) {
  const elements = new Array();
  text.split("\n").forEach((line, i) => {
    if (i)
      elements.push({
        type: "token",
        token: unspaced(Token2.new("\n", Token.Type.TextNewline))
      });
    elements.push({
      type: "token",
      token: autospaced(Token2.new(line, Token.Type.TextSection))
    });
  });
  return elements;
}
var Invalid = class extends Ast {
  constructor(module, fields) {
    super(module, fields);
  }
  static concrete(module, expression) {
    const base = module.baseObject("Invalid");
    return asOwned(new MutableInvalid2(module, invalidFields(module, base, expression)));
  }
  get expression() {
    return this.module.get(this.fields.get("expression").node);
  }
  *concreteChildren(_verbatim) {
    yield this.fields.get("expression");
  }
  printSubtree(info, offset, parentIndent, _verbatim) {
    return super.printSubtree(info, offset, parentIndent, true);
  }
};
function invalidFields(module, base, expression) {
  const id_ = base.get("id");
  return composeFieldData(base, { expression: concreteChild(module, expression, id_) });
}
var MutableInvalid2 = class extends Invalid {
};
applyMixins(MutableInvalid2, [MutableAst3]);
var Group = class extends Ast {
  constructor(module, fields) {
    super(module, fields);
  }
  static tryParse(source, module) {
    const parsed = parse2(source, module);
    if (parsed instanceof MutableGroup)
      return parsed;
  }
  static concrete(module, open, expression, close) {
    const base = module.baseObject("Group");
    const id_ = base.get("id");
    const fields = composeFieldData(base, {
      open,
      expression: concreteChild(module, expression, id_),
      close
    });
    return asOwned(new MutableGroup(module, fields));
  }
  static new(module, expression) {
    const open = unspaced(Token2.new("(", Token.Type.OpenSymbol));
    const close = unspaced(Token2.new(")", Token.Type.CloseSymbol));
    return this.concrete(module, open, unspaced(expression), close);
  }
  get expression() {
    return this.module.get(this.fields.get("expression")?.node);
  }
  *concreteChildren(_verbatim) {
    const { open, expression, close } = getAll(this.fields);
    if (open)
      yield open;
    if (expression)
      yield expression;
    if (close)
      yield close;
  }
};
var MutableGroup = class extends Group {
  setExpression(value) {
    this.fields.set("expression", unspaced(this.claimChild(value)));
  }
};
applyMixins(MutableGroup, [MutableAst3]);
var NumericLiteral = class extends Ast {
  constructor(module, fields) {
    super(module, fields);
  }
  static tryParse(source, module) {
    const parsed = parse2(source, module);
    if (parsed instanceof MutableNumericLiteral)
      return parsed;
  }
  static concrete(module, tokens) {
    const base = module.baseObject("NumericLiteral");
    const fields = composeFieldData(base, { tokens });
    return asOwned(new MutableNumericLiteral(module, fields));
  }
  concreteChildren(_verbatim) {
    return this.fields.get("tokens")[Symbol.iterator]();
  }
};
var MutableNumericLiteral = class extends NumericLiteral {
};
applyMixins(MutableNumericLiteral, [MutableAst3]);
var Function = class extends Ast {
  constructor(module, fields) {
    super(module, fields);
  }
  static tryParse(source, module) {
    const parsed = parse2(source, module);
    if (parsed instanceof MutableFunction)
      return parsed;
  }
  get name() {
    return this.module.get(this.fields.get("name").node);
  }
  get body() {
    return this.module.get(this.fields.get("body")?.node);
  }
  get argumentDefinitions() {
    return this.fields.get("argumentDefinitions").map((raw) => raw.map((part) => this.module.getConcrete(part)));
  }
  static concrete(module, name, argumentDefinitions, equals, body) {
    const base = module.baseObject("Function");
    const id_ = base.get("id");
    const fields = composeFieldData(base, {
      name: concreteChild(module, name, id_),
      argumentDefinitions: argumentDefinitions.map((def) => mapRefs(def, ownedToRaw(module, id_))),
      equals,
      body: concreteChild(module, body, id_)
    });
    return asOwned(new MutableFunction(module, fields));
  }
  static new(module, name, argumentDefinitions, body) {
    return MutableFunction.concrete(
      module,
      unspaced(Ident.newAllowingOperators(module, name)),
      argumentDefinitions,
      spaced(makeEquals()),
      autospaced(body)
    );
  }
  /** Construct a function with simple (name-only) arguments and a body block. */
  static fromStatements(module, name, argumentNames, statements) {
    const statements_ = statements.map((statement) => ({
      expression: unspaced(statement)
    }));
    const argumentDefinitions = argumentNames.map((name2) => [spaced(Ident.new(module, name2))]);
    const body = BodyBlock.new(statements_, module);
    return MutableFunction.new(module, name, argumentDefinitions, body);
  }
  *bodyExpressions() {
    const body = this.body;
    if (body instanceof BodyBlock) {
      yield* body.statements();
    } else if (body) {
      yield body;
    }
  }
  *concreteChildren(_verbatim) {
    const { name, argumentDefinitions, equals, body } = getAll(this.fields);
    yield name;
    for (const def of argumentDefinitions)
      yield* def;
    yield { whitespace: equals.whitespace ?? " ", node: this.module.getToken(equals.node) };
    if (body)
      yield preferSpacedIf(body, this.module.tryGet(body.node) instanceof BodyBlock);
  }
};
var MutableFunction = class extends Function {
  setName(value) {
    this.fields.set("name", unspaced(this.claimChild(value)));
  }
  setBody(value) {
    this.fields.set("body", unspaced(this.claimChild(value)));
  }
  setArgumentDefinitions(defs) {
    this.fields.set(
      "argumentDefinitions",
      defs.map((def) => mapRefs(def, ownedToRaw(this.module, this.id)))
    );
  }
  /** Returns the body, after converting it to a block if it was empty or an inline expression. */
  bodyAsBlock() {
    const oldBody = this.body;
    if (oldBody instanceof MutableBodyBlock)
      return oldBody;
    const newBody = BodyBlock.new([], this.module);
    if (oldBody)
      newBody.push(oldBody.take());
    return newBody;
  }
};
applyMixins(MutableFunction, [MutableAst3]);
var Assignment = class _Assignment extends Ast {
  constructor(module, fields) {
    super(module, fields);
  }
  static tryParse(source, module) {
    const parsed = parse2(source, module);
    if (parsed instanceof MutableAssignment)
      return parsed;
  }
  static concrete(module, pattern, equals, expression) {
    const base = module.baseObject("Assignment");
    const id_ = base.get("id");
    const fields = composeFieldData(base, {
      pattern: concreteChild(module, pattern, id_),
      equals,
      expression: concreteChild(module, expression, id_)
    });
    return asOwned(new MutableAssignment(module, fields));
  }
  static new(module, ident, expression) {
    return _Assignment.concrete(
      module,
      unspaced(Ident.new(module, ident)),
      spaced(makeEquals()),
      spaced(expression)
    );
  }
  get pattern() {
    return this.module.get(this.fields.get("pattern").node);
  }
  get expression() {
    return this.module.get(this.fields.get("expression").node);
  }
  *concreteChildren(verbatim) {
    const { pattern, equals, expression } = getAll(this.fields);
    yield ensureUnspaced(pattern, verbatim);
    yield ensureSpacedOnlyIf(equals, expression.whitespace !== "", verbatim);
    yield preferSpaced(expression);
  }
};
var MutableAssignment = class extends Assignment {
  setPattern(value) {
    this.fields.set("pattern", unspaced(this.claimChild(value)));
  }
  setExpression(value) {
    setNode(this.fields, "expression", this.claimChild(value));
  }
};
applyMixins(MutableAssignment, [MutableAst3]);
var BodyBlock = class _BodyBlock extends Ast {
  constructor(module, fields) {
    super(module, fields);
  }
  static tryParse(source, module) {
    const parsed = parse2(source, module);
    if (parsed instanceof MutableBodyBlock)
      return parsed;
  }
  static concrete(module, lines) {
    const base = module.baseObject("BodyBlock");
    const id_ = base.get("id");
    const fields = composeFieldData(base, {
      lines: lines.map((line) => lineToRaw(line, module, id_))
    });
    return asOwned(new MutableBodyBlock(module, fields));
  }
  static new(lines, module) {
    return _BodyBlock.concrete(module, lines);
  }
  get lines() {
    return this.fields.get("lines").map((line) => lineFromRaw(line, this.module));
  }
  *statements() {
    for (const line of this.lines) {
      if (line.expression)
        yield line.expression.node;
    }
  }
  *concreteChildren(_verbatim) {
    for (const line of this.fields.get("lines")) {
      yield preferUnspaced(line.newline);
      if (line.expression)
        yield line.expression;
    }
  }
  printSubtree(info, offset, parentIndent, verbatim) {
    return printBlock(this, info, offset, parentIndent, verbatim);
  }
};
var MutableBodyBlock = class extends BodyBlock {
  updateLines(map3) {
    return this.setLines(map3(this.takeLines()));
  }
  takeLines() {
    return this.fields.get("lines").map((line) => ownedLineFromRaw(line, this.module));
  }
  setLines(lines) {
    this.fields.set(
      "lines",
      lines.map((line) => lineToRaw(line, this.module, this.id))
    );
  }
  /** Insert the given statement(s) starting at the specified line index. */
  insert(index, ...statements) {
    const before = this.fields.get("lines").slice(0, index);
    const insertions = statements.map((statement) => ({
      newline: unspaced(Token2.new("\n", Token.Type.Newline)),
      expression: statement && unspaced(this.claimChild(statement))
    }));
    const after = this.fields.get("lines").slice(index);
    this.fields.set("lines", [...before, ...insertions, ...after]);
  }
  push(statement) {
    const oldLines = this.fields.get("lines");
    const newLine = {
      newline: unspaced(Token2.new("\n", Token.Type.Newline)),
      expression: unspaced(this.claimChild(statement))
    };
    this.fields.set("lines", [...oldLines, newLine]);
  }
  filter(keep) {
    const oldLines = this.fields.get("lines");
    const filteredLines = oldLines.filter((line) => {
      if (!line.expression)
        return true;
      return keep(this.module.get(line.expression.node));
    });
    this.fields.set("lines", filteredLines);
  }
};
applyMixins(MutableBodyBlock, [MutableAst3]);
function lineFromRaw(raw, module) {
  const expression = raw.expression ? module.get(raw.expression.node) : void 0;
  return {
    newline: { ...raw.newline, node: module.getToken(raw.newline.node) },
    expression: expression ? {
      whitespace: raw.expression?.whitespace,
      node: expression
    } : void 0
  };
}
function ownedLineFromRaw(raw, module) {
  const expression = raw.expression ? module.get(raw.expression.node).takeIfParented() : void 0;
  return {
    newline: { ...raw.newline, node: module.getToken(raw.newline.node) },
    expression: expression ? {
      whitespace: raw.expression?.whitespace,
      node: expression
    } : void 0
  };
}
function lineToRaw(line, module, block) {
  return {
    newline: line.newline ?? unspaced(Token2.new("\n", Token.Type.Newline)),
    expression: line.expression ? {
      whitespace: line.expression?.whitespace,
      node: claimChild(module, line.expression.node, block)
    } : void 0
  };
}
var Ident = class _Ident extends Ast {
  constructor(module, fields) {
    super(module, fields);
  }
  static tryParse(source, module) {
    const parsed = parse2(source, module);
    if (parsed instanceof MutableIdent)
      return parsed;
  }
  get token() {
    return this.module.getToken(this.fields.get("token").node);
  }
  static concrete(module, token) {
    const base = module.baseObject("Ident");
    const fields = composeFieldData(base, { token });
    return asOwned(new MutableIdent(module, fields));
  }
  static new(module, ident) {
    return _Ident.concrete(module, unspaced(toIdentStrict(ident)));
  }
  /** @internal */
  static newAllowingOperators(module, ident) {
    return _Ident.concrete(module, unspaced(toIdent(ident)));
  }
  *concreteChildren(_verbatim) {
    yield this.fields.get("token");
  }
  code() {
    return this.token.code();
  }
};
var MutableIdent = class extends Ident {
  setToken(ident) {
    this.fields.set("token", unspaced(toIdent(ident)));
  }
  code() {
    return this.token.code();
  }
};
applyMixins(MutableIdent, [MutableAst3]);
var Wildcard = class extends Ast {
  constructor(module, fields) {
    super(module, fields);
  }
  static tryParse(source, module) {
    const parsed = parse2(source, module);
    if (parsed instanceof MutableWildcard)
      return parsed;
  }
  get token() {
    return this.module.getToken(this.fields.get("token").node);
  }
  static concrete(module, token) {
    const base = module.baseObject("Wildcard");
    const fields = composeFieldData(base, { token });
    return asOwned(new MutableWildcard(module, fields));
  }
  static new(module) {
    const token = Token2.new("_", Token.Type.Wildcard);
    return this.concrete(module ?? MutableModule.Transient(), unspaced(token));
  }
  *concreteChildren(_verbatim) {
    yield this.fields.get("token");
  }
};
var MutableWildcard = class extends Wildcard {
};
applyMixins(MutableWildcard, [MutableAst3]);
function delimitVectorElement(element) {
  return {
    ...element,
    delimiter: element.delimiter ?? unspaced(Token2.new(",", Token.Type.Operator))
  };
}
var Vector = class _Vector extends Ast {
  constructor(module, fields) {
    super(module, fields);
  }
  static tryParse(source, module) {
    const parsed = parse2(source, module);
    if (parsed instanceof MutableVector)
      return parsed;
  }
  static concrete(module, open, elements, close) {
    const base = module.baseObject("Vector");
    const id_ = base.get("id");
    const fields = composeFieldData(base, {
      open: open ?? unspaced(Token2.new("[", Token.Type.OpenSymbol)),
      elements: elements.map(delimitVectorElement).map((e) => mapRefs(e, ownedToRaw(module, id_))),
      close: close ?? unspaced(Token2.new("]", Token.Type.CloseSymbol))
    });
    return asOwned(new MutableVector(module, fields));
  }
  static new(module, elements) {
    return this.concrete(
      module,
      void 0,
      elements.map((value) => ({ value: autospaced(value) })),
      void 0
    );
  }
  static tryBuild(inputs, valueBuilder, edit) {
    const module = edit ?? MutableModule.Transient();
    const elements = new Array();
    for (const input of inputs) {
      const value = valueBuilder(input, module);
      if (!value)
        return;
      elements.push({ value: autospaced(value) });
    }
    return _Vector.concrete(module, void 0, elements, void 0);
  }
  static build(inputs, elementBuilder, edit) {
    return _Vector.tryBuild(inputs, elementBuilder, edit);
  }
  *concreteChildren(verbatim) {
    const { open, elements, close } = getAll(this.fields);
    yield ensureUnspaced(open, verbatim);
    let isFirst = true;
    for (const { delimiter, value } of elements) {
      if (isFirst && value) {
        yield preferUnspaced(value);
      } else {
        yield preferUnspaced(delimiter);
        if (value)
          yield preferSpaced(value);
      }
      isFirst = false;
    }
    yield preferUnspaced(close);
  }
  *values() {
    for (const element of this.fields.get("elements"))
      if (element.value)
        yield this.module.get(element.value.node);
  }
};
var MutableVector = class extends Vector {
  push(value) {
    const elements = this.fields.get("elements");
    const element = mapRefs(
      delimitVectorElement({ value: autospaced(value) }),
      ownedToRaw(this.module, this.id)
    );
    this.fields.set("elements", [...elements, element]);
  }
  keep(predicate) {
    const elements = this.fields.get("elements");
    const filtered = elements.filter(
      (element) => element.value && predicate(this.module.get(element.value.node))
    );
    this.fields.set("elements", filtered);
  }
};
applyMixins(MutableVector, [MutableAst3]);
function materializeMutable(module, fields) {
  const type = fields.get("type");
  const fieldsForType = fields;
  switch (type) {
    case "App":
      return new MutableApp(module, fieldsForType);
    case "Assignment":
      return new MutableAssignment(module, fieldsForType);
    case "BodyBlock":
      return new MutableBodyBlock(module, fieldsForType);
    case "Documented":
      return new MutableDocumented(module, fieldsForType);
    case "Function":
      return new MutableFunction(module, fieldsForType);
    case "Generic":
      return new MutableGeneric(module, fieldsForType);
    case "Group":
      return new MutableGroup(module, fieldsForType);
    case "Ident":
      return new MutableIdent(module, fieldsForType);
    case "Import":
      return new MutableImport(module, fieldsForType);
    case "Invalid":
      return new MutableInvalid2(module, fieldsForType);
    case "NegationApp":
      return new MutableNegationApp(module, fieldsForType);
    case "NumericLiteral":
      return new MutableNumericLiteral(module, fieldsForType);
    case "OprApp":
      return new MutableOprApp(module, fieldsForType);
    case "PropertyAccess":
      return new MutablePropertyAccess(module, fieldsForType);
    case "TextLiteral":
      return new MutableTextLiteral(module, fieldsForType);
    case "UnaryOprApp":
      return new MutableUnaryOprApp(module, fieldsForType);
    case "Vector":
      return new MutableVector(module, fieldsForType);
    case "Wildcard":
      return new MutableWildcard(module, fieldsForType);
  }
  bail(`Invalid type: ${type}`);
}
function getAll(map3) {
  return Object.fromEntries(map3.entries());
}
function setAll(map3, fields) {
  const map_ = map3;
  for (const [k, v] of Object.entries(fields)) {
    const k_ = k;
    map_.set(k_, v);
  }
  return map_;
}
function composeFieldData(map3, fields) {
  return setAll(map3, fields);
}
function claimChild(module, child, parent) {
  if (child.module === module)
    assertEqual(child.fields.get("parent"), void 0);
  const child_ = module.copyIfForeign(child);
  child_.fields.set("parent", parent);
  return child_.id;
}
function concreteChild(module, child, parent) {
  if (!child)
    return void 0;
  if (isTokenId(child.node))
    return child;
  return { ...child, node: claimChild(module, child.node, parent) };
}
function toIdentStrict(ident) {
  return ident ? isToken(ident) ? ident : Token2.new(ident, Token.Type.Ident) : void 0;
}
function toIdent(ident) {
  return ident ? isToken(ident) ? ident : Token2.new(ident, Token.Type.Ident) : void 0;
}
function makeEquals() {
  return Token2.new("=", Token.Type.Operator);
}
function nameSpecification(name) {
  return name && { name: autospaced(toIdentStrict(name)), equals: unspaced(makeEquals()) };
}
function setNode(map3, key, node) {
  const old = map3.get(key);
  const updated = old ? { ...old, node } : autospaced(node);
  map3.set(key, updated);
}
function spaced(node) {
  if (node === void 0)
    return node;
  return { whitespace: " ", node };
}
function unspaced(node) {
  if (node === void 0)
    return node;
  return { whitespace: "", node };
}
function autospaced(node) {
  if (node === void 0)
    return node;
  return { whitespace: void 0, node };
}

// shared/ast/text.ts
var escapeSequences = [
  ["0", "\0"],
  ["a", "\x07"],
  ["b", "\b"],
  ["f", "\f"],
  ["n", "\n"],
  ["r", "\r"],
  ["t", "	"],
  ["v", "\v"],
  ["e", "\x1B"],
  ["\\", "\\"],
  ['"', '"'],
  ["'", "'"],
  ["`", "`"]
];
function escapeAsCharCodes(str) {
  let out = "";
  for (let i = 0; i < str.length; i += 1)
    out += `\\u{${str?.charCodeAt(i).toString(16)}}`;
  return out;
}
var escapeRegex = new RegExp(
  `${escapeSequences.map(([_, raw]) => escapeAsCharCodes(raw)).join("|")}`,
  "gu"
);
var unescapeRegex = new RegExp(
  `\\\\(?:${escapeSequences.map(([escape]) => escapeAsCharCodes(escape)).join("|")}|x[0-9a-fA-F]{0,2}|u\\{[0-9a-fA-F]{0,4}\\}?|u[0-9a-fA-F]{0,4}|U[0-9a-fA-F]{0,8})`,
  "gu"
);
var escapeMapping = Object.fromEntries(
  escapeSequences.map(([escape, raw]) => [raw, `\\${escape}`])
);
var unescapeMapping = Object.fromEntries(
  escapeSequences.map(([escape, raw]) => [`\\${escape}`, raw])
);
function escapeTextLiteral(rawString) {
  return rawString.replace(escapeRegex, (match) => escapeMapping[match] ?? assertUnreachable());
}

// shared/ast/token.ts
function isToken(t) {
  return t instanceof Token2;
}
function isTokenChild(child) {
  return isToken(child.node);
}
function newTokenId() {
  return newExternalId();
}
var Token2 = class {
  id;
  code_;
  tokenType_;
  constructor(code, type, id) {
    this.id = id;
    this.code_ = code;
    this.tokenType_ = type;
  }
  get externalId() {
    return this.id;
  }
  static new(code, type) {
    return new this(code, type, newTokenId());
  }
  static withId(code, type, id) {
    assert(isUuid(id));
    return new this(code, type, id);
  }
  static equal(a, b) {
    return a.tokenType_ === b.tokenType_ && a.code_ === b.code_;
  }
  code() {
    return this.code_;
  }
  typeName() {
    if (this.tokenType_)
      return Token.typeNames[this.tokenType_];
    else
      return "Raw";
  }
};
function isIdentifier(code) {
  return is_ident_or_operator(code) === 1;
}
function isTokenId(t) {
  return typeof t === "object" && !(t instanceof Ast);
}

// shared/ast/index.ts
function asOwned(t) {
  return t;
}
function newExternalId() {
  return random3.uuidv4();
}
function parentId(ast) {
  return ast.fields.get("parent");
}
function subtreeRoots(module, ids) {
  const roots = /* @__PURE__ */ new Set();
  for (const id of ids) {
    const astInModule = module.tryGet(id);
    if (!astInModule)
      continue;
    let ast = astInModule.parent();
    let hasParentInSet;
    while (ast != null) {
      if (ids.has(ast.id)) {
        hasParentInSet = true;
        break;
      }
      ast = ast.parent();
    }
    if (!hasParentInSet)
      roots.add(id);
  }
  return roots;
}

// shared/ensoFile.ts
var META_TAG = "\n\n\n#### METADATA ####";
function splitFileContents(content) {
  const splitPoint = content.lastIndexOf(META_TAG);
  if (splitPoint < 0) {
    return {
      code: content,
      idMapJson: null,
      metadataJson: null
    };
  }
  const code = content.slice(0, splitPoint);
  const metadataString = content.slice(splitPoint + META_TAG.length);
  const metaLines = metadataString.trim().split("\n");
  const idMapJson = metaLines[0] ?? null;
  const metadataJson = metaLines[1] ?? null;
  return { code, idMapJson, metadataJson };
}
function combineFileParts(parts) {
  const hasMeta = parts.idMapJson != null || parts.metadataJson != null;
  if (hasMeta) {
    return `${parts.code}${META_TAG}
${parts.idMapJson ?? ""}
${parts.metadataJson ?? ""}`;
  } else {
    if (parts.code.includes(META_TAG)) {
      return `${parts.code}${META_TAG}`;
    } else {
      return parts.code;
    }
  }
}

// shared/languageServer.ts
import { sha3_224 as SHA3 } from "file:///C:/Projects/enso/enso/node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/esm/sha3.js";
import { bytesToHex } from "file:///C:/Projects/enso/enso/node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/esm/utils.js";
import { ObservableV2 } from "file:///C:/Projects/enso/enso/node_modules/.pnpm/lib0@0.2.93/node_modules/lib0/observable.js";
import { uuidv4 as uuidv43 } from "file:///C:/Projects/enso/enso/node_modules/.pnpm/lib0@0.2.93/node_modules/lib0/random.js";
import { z } from "file:///C:/Projects/enso/enso/node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/index.mjs";

// shared/languageServer/files.ts
async function walkFs(ls, path2, cb) {
  for (const file of (await ls.listFiles(path2)).paths) {
    const filePath = {
      rootId: file.path.rootId,
      segments: [...file.path.segments, file.name]
    };
    cb(file.type, filePath);
    switch (file.type) {
      case "Directory":
      case "DirectoryTruncated": {
        walkFs(ls, filePath, cb);
        break;
      }
      case "File":
      case "Other":
      case "SymlinkLoop": {
        break;
      }
      default: {
        const unexpected = file;
        throw new Error("Unexpected object: " + JSON.stringify(unexpected));
      }
    }
  }
}

// shared/languageServer.ts
var DEBUG_LOG_RPC = false;
var RPC_TIMEOUT_MS = 15e3;
var ErrorCode = /* @__PURE__ */ ((ErrorCode2) => {
  ErrorCode2[ErrorCode2["ACCESS_DENIED"] = 100] = "ACCESS_DENIED";
  ErrorCode2[ErrorCode2["FILE_SYSTEM_ERROR"] = 1e3] = "FILE_SYSTEM_ERROR";
  ErrorCode2[ErrorCode2["CONTENT_ROOT_NOT_FOUND"] = 1001] = "CONTENT_ROOT_NOT_FOUND";
  ErrorCode2[ErrorCode2["FILE_NOT_FOUND"] = 1003] = "FILE_NOT_FOUND";
  ErrorCode2[ErrorCode2["FILE_EXISTS"] = 1004] = "FILE_EXISTS";
  ErrorCode2[ErrorCode2["OPERATION_TIMEOUT"] = 1005] = "OPERATION_TIMEOUT";
  ErrorCode2[ErrorCode2["NOT_DIRECTORY"] = 1006] = "NOT_DIRECTORY";
  ErrorCode2[ErrorCode2["NOT_FILE"] = 1007] = "NOT_FILE";
  ErrorCode2[ErrorCode2["CANNOT_OVERWRITE"] = 1008] = "CANNOT_OVERWRITE";
  ErrorCode2[ErrorCode2["READ_OUT_OF_BOUNDS"] = 1009] = "READ_OUT_OF_BOUNDS";
  ErrorCode2[ErrorCode2["CANNOT_DECODE"] = 1010] = "CANNOT_DECODE";
  ErrorCode2[ErrorCode2["STACK_ITEM_NOT_FOUND"] = 2001] = "STACK_ITEM_NOT_FOUND";
  ErrorCode2[ErrorCode2["CONTEXT_NOT_FOUND"] = 2002] = "CONTEXT_NOT_FOUND";
  ErrorCode2[ErrorCode2["EMPTY_STACK"] = 2003] = "EMPTY_STACK";
  ErrorCode2[ErrorCode2["INVALID_STACK_ITEM"] = 2004] = "INVALID_STACK_ITEM";
  ErrorCode2[ErrorCode2["MODULE_NOT_FOUND"] = 2005] = "MODULE_NOT_FOUND";
  ErrorCode2[ErrorCode2["VISUALIZATION_NOT_FOUND"] = 2006] = "VISUALIZATION_NOT_FOUND";
  ErrorCode2[ErrorCode2["VISUALIZATION_EXPRESSION_ERROR"] = 2007] = "VISUALIZATION_EXPRESSION_ERROR";
  ErrorCode2[ErrorCode2["FILE_NOT_OPENED"] = 3001] = "FILE_NOT_OPENED";
  ErrorCode2[ErrorCode2["TEXT_EDIT_VALIDATION_ERROR"] = 3002] = "TEXT_EDIT_VALIDATION_ERROR";
  ErrorCode2[ErrorCode2["INVALID_VERSION"] = 3003] = "INVALID_VERSION";
  ErrorCode2[ErrorCode2["WRITE_DENIED"] = 3004] = "WRITE_DENIED";
  ErrorCode2[ErrorCode2["CAPABILITY_NOT_ACQUIRED"] = 5001] = "CAPABILITY_NOT_ACQUIRED";
  ErrorCode2[ErrorCode2["SESSION_NOT_INITIALIZED"] = 6001] = "SESSION_NOT_INITIALIZED";
  ErrorCode2[ErrorCode2["SESSION_ALREADY_INITIALIZED"] = 6002] = "SESSION_ALREADY_INITIALIZED";
  ErrorCode2[ErrorCode2["RESOURCES_INITIALIZATION_ERROR"] = 6003] = "RESOURCES_INITIALIZATION_ERROR";
  ErrorCode2[ErrorCode2["SUGGESTION_DATABASE_ERROR"] = 7001] = "SUGGESTION_DATABASE_ERROR";
  ErrorCode2[ErrorCode2["PROJECT_NOT_FOUND"] = 7002] = "PROJECT_NOT_FOUND";
  ErrorCode2[ErrorCode2["MODULE_NAME_NOT_RESOLVED"] = 7003] = "MODULE_NAME_NOT_RESOLVED";
  ErrorCode2[ErrorCode2["SUGGESTION_NOT_FOUND"] = 7004] = "SUGGESTION_NOT_FOUND";
  ErrorCode2[ErrorCode2["EDITION_NOT_FOUND"] = 8001] = "EDITION_NOT_FOUND";
  ErrorCode2[ErrorCode2["LIBRARY_ALREADY_EXISTS"] = 8002] = "LIBRARY_ALREADY_EXISTS";
  ErrorCode2[ErrorCode2["LIBRARY_REPOSITORY_AUTHENTICATION_ERROR"] = 8003] = "LIBRARY_REPOSITORY_AUTHENTICATION_ERROR";
  ErrorCode2[ErrorCode2["LIBRARY_PUBLISH_ERROR"] = 8004] = "LIBRARY_PUBLISH_ERROR";
  ErrorCode2[ErrorCode2["LIBRARY_UPLOAD_ERROR"] = 8005] = "LIBRARY_UPLOAD_ERROR";
  ErrorCode2[ErrorCode2["LIBRARY_DOWNLOAD_ERROR"] = 8006] = "LIBRARY_DOWNLOAD_ERROR";
  ErrorCode2[ErrorCode2["LOCAL_LIBRARY_NOT_FOUND"] = 8007] = "LOCAL_LIBRARY_NOT_FOUND";
  ErrorCode2[ErrorCode2["LIBRARY_NOT_RESOLVED"] = 8008] = "LIBRARY_NOT_RESOLVED";
  ErrorCode2[ErrorCode2["INVALID_LIBRARY_NAME"] = 8009] = "INVALID_LIBRARY_NAME";
  ErrorCode2[ErrorCode2["DEPENDENCY_DISCOVERY_ERROR"] = 8010] = "DEPENDENCY_DISCOVERY_ERROR";
  ErrorCode2[ErrorCode2["INVALID_SEMVER_VERSION"] = 8011] = "INVALID_SEMVER_VERSION";
  ErrorCode2[ErrorCode2["EXPRESSION_NOT_FOUND"] = 9001] = "EXPRESSION_NOT_FOUND";
  ErrorCode2[ErrorCode2["FAILED_TO_APPLY_EDITS"] = 9002] = "FAILED_TO_APPLY_EDITS";
  ErrorCode2[ErrorCode2["REFACTORING_NOT_SUPPORTED"] = 9003] = "REFACTORING_NOT_SUPPORTED";
  return ErrorCode2;
})(ErrorCode || {});
var RemoteRpcErrorSchema = z.object({
  code: z.nativeEnum(ErrorCode),
  message: z.string(),
  data: z.optional(z.any())
});
var RemoteRpcError = class {
  code;
  message;
  data;
  constructor(error) {
    this.code = error.code;
    this.message = error.message;
    this.data = error.data;
  }
};
var LsRpcError = class extends Error {
  cause;
  request;
  params;
  constructor(cause, request, params) {
    super(`Language server request '${request}' failed.`);
    this.cause = cause;
    this.request = request;
    this.params = params;
  }
};
var LanguageServer = class extends ObservableV2 {
  client;
  handlers;
  retainCount = 1;
  constructor(client) {
    super();
    this.client = client;
    this.handlers = /* @__PURE__ */ new Map();
    client.onNotification((notification) => {
      this.emit(notification.method, [notification.params]);
    });
    client.onError((error) => {
      console.error(`Unexpected LS connection error:`, error);
    });
  }
  // The "magic bag of holding" generic that is only present in the return type is UNSOUND.
  // However, it is SAFE, as the return type of the API is statically known.
  async request(method, params) {
    if (this.retainCount === 0)
      return Promise.reject(new Error("LanguageServer disposed"));
    const uuid = uuidv43();
    const now = performance.now();
    try {
      if (DEBUG_LOG_RPC) {
        console.log(`LS [${uuid}] ${method}:`);
        console.dir(params);
      }
      return await this.client.request({ method, params }, RPC_TIMEOUT_MS);
    } catch (error) {
      const remoteError = RemoteRpcErrorSchema.safeParse(error);
      if (remoteError.success) {
        throw new LsRpcError(new RemoteRpcError(remoteError.data), method, params);
      } else if (error instanceof Error) {
        throw new LsRpcError(error, method, params);
      }
      throw error;
    } finally {
      if (DEBUG_LOG_RPC) {
        console.log(`LS [${uuid}] ${method} took ${performance.now() - now}ms`);
      }
    }
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#capabilityacquire) */
  acquireCapability(method, registerOptions) {
    return this.request("capability/acquire", { method, registerOptions });
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#filereceivestreeupdates) */
  acquireReceivesTreeUpdates(path2) {
    return this.acquireCapability("file/receivesTreeUpdates", { path: path2 });
  }
  acquireExecutionContextCanModify(contextId) {
    return this.acquireCapability("executionContext/canModify", { contextId });
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#sessioninitprotocolconnection) */
  initProtocolConnection(clientId) {
    return this.request("session/initProtocolConnection", { clientId });
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#textopenfile) */
  openTextFile(path2) {
    return this.request("text/openFile", { path: path2 });
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#textclosefile) */
  closeTextFile(path2) {
    return this.request("text/closeFile", { path: path2 });
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#textsave) */
  saveTextFile(path2, currentVersion) {
    return this.request("text/save", { path: path2, currentVersion });
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#textapplyedit) */
  applyEdit(edit, execute) {
    return this.request("text/applyEdit", { edit, execute });
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#filewrite) */
  writeFile(path2, contents) {
    return this.request("file/write", { path: path2, contents });
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#fileread) */
  readFile(path2) {
    return this.request("file/read", { path: path2 });
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#filecreate) */
  createFile(object2) {
    return this.request("file/create", { object: object2 });
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#filedelete) */
  deleteFile(path2) {
    return this.request("file/delete", { path: path2 });
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#filecopy) */
  copyFile(from, to) {
    return this.request("file/copy", { from, to });
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#filemove) */
  moveFile(from, to) {
    return this.request("file/move", { from, to });
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#fileexists) */
  fileExists(path2) {
    return this.request("file/exists", { path: path2 });
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#filetree) */
  fileTree(path2, depth) {
    return this.request("file/tree", { path: path2, depth });
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#filelist) */
  listFiles(path2) {
    return this.request("file/list", { path: path2 });
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#fileinfo) */
  fileInfo(path2) {
    return this.request("file/info", { path: path2 });
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#filechecksum) */
  fileChecksum(path2) {
    return this.request("file/checksum", { path: path2 });
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#vcsinit) */
  vcsInit(root) {
    return this.request("vcs/init", { root });
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#vcssave) */
  vcsSave(root, name) {
    return this.request("vcs/save", { root, name });
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#vcsstatus) */
  vcsStatus(root) {
    return this.request("vcs/status", { root });
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#vcsrestore) */
  vcsRestore(root, commitId) {
    return this.request("vcs/restore", { root, commitId });
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#vcslist) */
  vcsList(root, limit) {
    return this.request("vcs/list", { root, limit });
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#executioncontextcreate) */
  createExecutionContext(contextId) {
    return this.request("executionContext/create", { contextId });
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#executioncontextdestroy) */
  destroyExecutionContext(contextId) {
    return this.request("executionContext/destroy", { contextId });
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#executioncontextfork) */
  forkExecutionContext(contextId) {
    return this.request("executionContext/fork", { contextId });
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#executioncontextpush) */
  pushExecutionContextItem(contextId, stackItem) {
    return this.request("executionContext/push", { contextId, stackItem });
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#executioncontextpop) */
  popExecutionContextItem(contextId) {
    return this.request("executionContext/pop", { contextId });
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#executioncontextrecompute) */
  recomputeExecutionContext(contextId, invalidatedExpressions, executionEnvironment) {
    return this.request("executionContext/recompute", {
      contextId,
      invalidatedExpressions,
      executionEnvironment
    });
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#executioncontextinterrupt) */
  interruptExecutionContext(contextId) {
    return this.request("executionContext/interrupt", { contextId });
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#executioncontextsetexecutionenvironment) */
  setExecutionEnvironment(contextId, executionEnvironment) {
    return this.request("executionContext/setExecutionEnvironment", {
      contextId,
      executionEnvironment
    });
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#executioncontextexecuteexpression) */
  executeExpression(executionContextId, visualizationId, expressionId, expression) {
    return this.request("executionContext/executeExpression", {
      executionContextId,
      visualizationId,
      expressionId,
      expression
    });
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#executioncontextattachvisualization) */
  attachVisualization(visualizationId, expressionId, visualizationConfig) {
    return this.request("executionContext/attachVisualization", {
      visualizationId,
      expressionId,
      visualizationConfig
    });
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#executioncontextdetachvisualization) */
  detachVisualization(visualizationId, expressionId, contextId) {
    return this.request("executionContext/detachVisualization", {
      visualizationId,
      expressionId,
      contextId
    });
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#executioncontextmodifyvisualization) */
  modifyVisualization(visualizationId, visualizationConfig) {
    return this.request("executionContext/modifyVisualization", {
      visualizationId,
      visualizationConfig
    });
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#searchgetsuggestionsdatabase) */
  getSuggestionsDatabase() {
    return this.request("search/getSuggestionsDatabase", {});
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#runtimegetcomponentgroups) */
  getComponentGroups() {
    return this.request("runtime/getComponentGroups", {});
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#profilingstart) */
  profilingStart(memorySnapshot) {
    return this.request("profiling/start", { memorySnapshot });
  }
  /** [Documentation](https://github.com/enso-org/enso/blob/develop/docs/language-server/protocol-language-server.md#profilingstop) */
  profilingStop() {
    return this.request("profiling/stop", {});
  }
  aiCompletion(prompt, stopSequence) {
    return this.request("ai/completion", { prompt, stopSequence });
  }
  /** A helper function to subscribe to file updates.
   * Please use `ls.on('file/event')` directly if the initial `'Added'` notifications are not
   * needed. */
  watchFiles(rootId, segments, callback, retry = (f) => f()) {
    let running = true;
    const self = this;
    return {
      promise: (async () => {
        self.on("file/event", callback);
        await retry(async () => running && self.acquireReceivesTreeUpdates({ rootId, segments }));
        await walkFs(self, { rootId, segments }, (type, path2) => {
          if (!running || type !== "File" || path2.segments.length < segments.length || segments.some((segment, i) => segment !== path2.segments[i]))
            return;
          callback({
            path: { rootId: path2.rootId, segments: path2.segments.slice(segments.length) },
            kind: "Added"
          });
        });
      })(),
      unsubscribe() {
        running = false;
        self.off("file/event", callback);
      }
    };
  }
  retain() {
    if (this.retainCount === 0) {
      throw new Error("Trying to retain already disposed language server.");
    }
    this.retainCount += 1;
  }
  release() {
    if (this.retainCount > 0) {
      this.retainCount -= 1;
      if (this.retainCount === 0) {
        this.client.close();
      }
    } else {
      throw new Error("Released already disposed language server.");
    }
  }
};
function computeTextChecksum(text) {
  return bytesToHex(SHA3.create().update(text).digest());
}

// shared/retry.ts
import { wait } from "file:///C:/Projects/enso/enso/node_modules/.pnpm/lib0@0.2.93/node_modules/lib0/promise.js";
var defaultBackoffOptions = {
  maxRetries: 3,
  retryDelay: 1e3,
  retryDelayMultiplier: 2,
  retryDelayMax: 1e4,
  onBeforeRetry: () => {
  },
  onSuccess: () => {
  },
  onFailure: () => {
  }
};
async function exponentialBackoff(f, backoffOptions) {
  const {
    maxRetries,
    retryDelay,
    retryDelayMultiplier,
    retryDelayMax,
    onBeforeRetry,
    onSuccess,
    onFailure
  } = {
    ...defaultBackoffOptions,
    ...backoffOptions
  };
  for (let retries = 0, delay = retryDelay; ; retries += 1, delay = Math.min(retryDelayMax, delay * retryDelayMultiplier)) {
    try {
      const result = await f();
      onSuccess(retries);
      return result;
    } catch (error) {
      if (retries >= maxRetries) {
        onFailure(error, retries);
        throw error;
      }
      if (onBeforeRetry(error, retries, maxRetries, delay) === false)
        throw error;
      await wait(delay);
    }
  }
}
function defaultOnBeforeRetry(description) {
  return (error, retryCount, maxRetries, delay) => {
    console.error(
      "Could not " + description + ` (${retryCount}/${maxRetries} retries), retrying after ${delay}ms...`
    );
    console.error(error);
  };
}
function defaultOnFailure(description) {
  return (error, retryCount) => {
    console.error(
      "Could not " + description + ` (${retryCount}/${retryCount} retries), throwing error.`
    );
    console.error(error);
  };
}
function defaultOnSuccess(description) {
  return (retryCount) => {
    if (retryCount === 0)
      return;
    console.info(
      "Successfully " + description + ` after ${retryCount} ${retryCount === 1 ? "failure" : "failures"}.`
    );
  };
}
function printingCallbacks(successDescription, errorDescription) {
  return {
    onBeforeRetry: defaultOnBeforeRetry(errorDescription),
    onSuccess: defaultOnSuccess(successDescription),
    onFailure: defaultOnFailure(errorDescription)
  };
}

// shared/util/net.ts
var AbortScope = class {
  ctrl = new AbortController();
  get signal() {
    return this.ctrl.signal;
  }
  dispose(reason) {
    this.ctrl.abort(reason);
  }
  handleDispose(disposable) {
    this.signal.throwIfAborted();
    this.onAbort(disposable.dispose.bind(disposable));
  }
  onAbort(listener) {
    if (this.signal.aborted) {
      setTimeout(listener, 0);
    } else {
      this.signal.addEventListener("abort", listener, { once: true });
    }
  }
  handleObserve(observable, name, f) {
    if (this.signal.aborted)
      return;
    observable.on(name, f);
    this.onAbort(() => observable.off(name, f));
    return f;
  }
};

// ydoc-server/edits.ts
import diff2 from "file:///C:/Projects/enso/enso/node_modules/.pnpm/fast-diff@1.3.0/node_modules/fast-diff/diff.js";
var MAX_SIZE_FOR_NORMAL_DIFF = 3e4;
function applyDocumentUpdates(doc, synced, update) {
  const codeChanged = update.nodesUpdated.size || update.nodesAdded.size || update.nodesDeleted.size;
  let idsChanged = false;
  let metadataChanged = false;
  for (const { changes } of update.metadataUpdated) {
    for (const [key] of changes) {
      if (key === "externalId") {
        idsChanged = true;
      } else {
        metadataChanged = true;
      }
    }
    if (idsChanged && metadataChanged)
      break;
  }
  let newIdMap = void 0;
  let newCode = void 0;
  let newMetadata = void 0;
  const syncModule = new MutableModule(doc.ydoc);
  const root = syncModule.root();
  assert(root != null);
  if (codeChanged || idsChanged || synced.idMapJson == null) {
    const { code, info } = print(root);
    if (codeChanged)
      newCode = code;
    newIdMap = spanMapToIdMap(info);
  }
  if (codeChanged || idsChanged || metadataChanged) {
    newMetadata = {};
    root.visitRecursiveAst((ast) => {
      let pos = ast.nodeMetadata.get("position");
      const vis = ast.nodeMetadata.get("visualization");
      const colorOverride = ast.nodeMetadata.get("colorOverride");
      if (vis && !pos)
        pos = { x: 0, y: 0 };
      if (pos) {
        newMetadata[ast.externalId] = {
          position: { vector: [Math.round(pos.x), Math.round(-pos.y)] },
          visualization: vis && translateVisualizationToFile(vis),
          colorOverride
        };
      }
    });
  }
  return { newCode, newIdMap, newMetadata };
}
function translateVisualizationToFile(vis) {
  let project = void 0;
  switch (vis.identifier?.module.kind) {
    case "Builtin":
      project = { project: "Builtin" };
      break;
    case "CurrentProject":
      project = { project: "CurrentProject" };
      break;
    case "Library":
      project = { project: "Library", contents: vis.identifier.module.name };
      break;
  }
  return {
    show: vis.visible,
    fullscreen: vis.fullscreen,
    width: vis.width ?? void 0,
    ...project == null || vis.identifier == null ? {} : {
      project,
      name: vis.identifier.name
    }
  };
}
function translateVisualizationFromFile(vis) {
  let module;
  switch (vis.project?.project) {
    case "Builtin":
      module = { kind: "Builtin" };
      break;
    case "CurrentProject":
      module = { kind: "CurrentProject" };
      break;
    case "Library":
      module = { kind: "Library", name: vis.project.contents };
      break;
    default:
      module = null;
  }
  return {
    identifier: module && vis.name ? { name: vis.name, module } : null,
    visible: vis.show,
    fullscreen: vis.fullscreen ?? false,
    width: vis.width ?? null
  };
}
function stupidFastDiff(oldString, newString) {
  const minLength = Math.min(oldString.length, newString.length);
  let commonPrefixLen, commonSuffixLen;
  for (commonPrefixLen = 0; commonPrefixLen < minLength; ++commonPrefixLen)
    if (oldString[commonPrefixLen] !== newString[commonPrefixLen])
      break;
  if (oldString.length === newString.length && oldString.length === commonPrefixLen)
    return [[0, oldString]];
  for (commonSuffixLen = 0; commonSuffixLen < minLength - commonPrefixLen; ++commonSuffixLen)
    if (oldString.at(-1 - commonSuffixLen) !== newString.at(-1 - commonSuffixLen))
      break;
  const commonPrefix = oldString.substring(0, commonPrefixLen);
  const removed = oldString.substring(commonPrefixLen, oldString.length - commonSuffixLen);
  const added = newString.substring(commonPrefixLen, newString.length - commonSuffixLen);
  const commonSuffix = oldString.substring(oldString.length - commonSuffixLen, oldString.length);
  return (commonPrefix ? [[0, commonPrefix]] : []).concat(removed ? [[-1, removed]] : []).concat(added ? [[1, added]] : []).concat(commonSuffix ? [[0, commonSuffix]] : []);
}
function applyDiffAsTextEdits(lineOffset, oldString, newString) {
  const changes = oldString.length + newString.length > MAX_SIZE_FOR_NORMAL_DIFF ? stupidFastDiff(oldString, newString) : diff2(oldString, newString);
  let newIndex = 0;
  let lineNum = lineOffset;
  let lineStartIdx = 0;
  const edits = [];
  for (const [op, text] of changes) {
    if (op === 1) {
      const pos = {
        character: newIndex - lineStartIdx,
        line: lineNum
      };
      edits.push({ range: { start: pos, end: pos }, text });
      const numLineBreaks = (text.match(/\n/g) ?? []).length;
      if (numLineBreaks > 0) {
        lineNum += numLineBreaks;
        lineStartIdx = newIndex + text.lastIndexOf("\n") + 1;
      }
      newIndex += text.length;
    } else if (op === -1) {
      const start = {
        character: newIndex - lineStartIdx,
        line: lineNum
      };
      const numLineBreaks = (text.match(/\n/g) ?? []).length;
      const character = numLineBreaks > 0 ? text.length - (text.lastIndexOf("\n") + 1) : newIndex - lineStartIdx + text.length;
      const end = {
        character,
        line: lineNum + numLineBreaks
      };
      edits.push({ range: { start, end }, text: "" });
    } else if (op === 0) {
      const numLineBreaks = (text.match(/\n/g) ?? []).length;
      lineNum += numLineBreaks;
      if (numLineBreaks > 0) {
        lineStartIdx = newIndex + text.lastIndexOf("\n") + 1;
      }
      newIndex += text.length;
    }
  }
  return edits;
}
function prettyPrintDiff(from, to) {
  const colReset = "\x1B[0m";
  const colRed = "\x1B[31m";
  const colGreen = "\x1B[32m";
  const diffs = from.length + to.length > MAX_SIZE_FOR_NORMAL_DIFF ? stupidFastDiff(from, to) : diff2(from, to);
  if (diffs.length === 1 && diffs[0][0] === 0)
    return "No changes";
  let content = "";
  for (let i = 0; i < diffs.length; i++) {
    const [op, text] = diffs[i];
    if (op === 1) {
      content += colGreen + text;
    } else if (op === -1) {
      content += colRed + text;
    } else if (op === 0) {
      content += colReset;
      const numNewlines = (text.match(/\n/g) ?? []).length;
      if (numNewlines < 2) {
        content += text;
      } else {
        const firstNewline = text.indexOf("\n");
        const lastNewline = text.lastIndexOf("\n");
        const firstLine = text.slice(0, firstNewline + 1);
        const lastLine = text.slice(lastNewline + 1);
        const isFirst = i === 0;
        const isLast = i === diffs.length - 1;
        if (!isFirst)
          content += firstLine;
        if (!isFirst && !isLast)
          content += "...\n";
        if (!isLast)
          content += lastLine;
      }
    }
  }
  content += colReset;
  return content;
}
if (import.meta.vitest) {
  const { test, expect } = import.meta.vitest;
  test.each`
    oldStr     | newStr      | expected
    ${""}      | ${"foo"}    | ${[[1, "foo"]]}
    ${"foo"}   | ${""}       | ${[[-1, "foo"]]}
    ${"foo"}   | ${"foo"}    | ${[[0, "foo"]]}
    ${"foo"}   | ${"bar"}    | ${[[-1, "foo"], [1, "bar"]]}
    ${"ababx"} | ${"acacx"}  | ${[[0, "a"], [-1, "bab"], [1, "cac"], [0, "x"]]}
    ${"ax"}    | ${"acacx"}  | ${[[0, "a"], [1, "cac"], [0, "x"]]}
    ${"ababx"} | ${"ax"}     | ${[[0, "a"], [-1, "bab"], [0, "x"]]}
    ${"ababx"} | ${"abacax"} | ${[[0, "aba"], [-1, "b"], [1, "ca"], [0, "x"]]}
    ${"axxxa"} | ${"a"}      | ${[[0, "a"], [-1, "xxxa"]]}
  `("Stupid diff of $oldStr and $newStr", ({ oldStr, newStr, expected }) => {
    expect(stupidFastDiff(oldStr, newStr)).toEqual(expected);
  });
}

// ydoc-server/fileFormat.ts
import * as json from "file:///C:/Projects/enso/enso/node_modules/.pnpm/lib0@0.2.93/node_modules/lib0/json.js";
import z2 from "file:///C:/Projects/enso/enso/node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/index.mjs";
var vector = z2.tuple([z2.number(), z2.number()]);
var visualizationProject = z2.discriminatedUnion("project", [
  z2.object({ project: z2.literal("Builtin") }),
  z2.object({ project: z2.literal("CurrentProject") }),
  z2.object({ project: z2.literal("Library"), contents: z2.string() })
]);
var visualizationMetadata = z2.object({
  show: z2.boolean().default(true),
  width: z2.number().optional(),
  fullscreen: z2.boolean().optional(),
  project: visualizationProject.optional(),
  name: z2.string().optional()
}).passthrough();
var nodeMetadata = z2.object({
  position: z2.object({ vector }).catch((ctx) => {
    printError(ctx);
    return { vector: [0, 0] };
  }),
  visualization: visualizationMetadata.optional().catch(() => void 0),
  colorOverride: z2.string().optional()
}).passthrough();
var importMetadata = z2.object({}).passthrough();
var ideMetadata = z2.object({
  node: z2.record(z2.string().uuid(), nodeMetadata),
  import: z2.record(z2.string(), importMetadata)
}).passthrough().default(() => defaultMetadata().ide).catch((ctx) => {
  printError(ctx);
  return defaultMetadata().ide;
});
var metadata = z2.object({
  ide: ideMetadata
}).passthrough().catch((ctx) => {
  printError(ctx);
  return defaultMetadata();
});
var idMapValue = z2.object({
  value: z2.number()
});
var idMapRange = z2.object({
  index: idMapValue,
  size: idMapValue
});
var idMapEntry = z2.tuple([idMapRange, z2.string().uuid()]);
var idMap = z2.array(idMapEntry).catch((ctx) => {
  printError(ctx);
  return [];
});
function defaultMetadata() {
  return {
    ide: {
      node: {},
      import: {}
    }
  };
}
function printError(ctx) {
  console.error("=== METADATA PARSE ERROR ===");
  console.error("Error:", ctx.error.issues);
  console.error("Input:", ctx.input);
  console.error("============================");
}
function tryParseMetadataOrFallback(metadataJson) {
  if (metadataJson == null)
    return defaultMetadata();
  const parsedMeta = tryParseJson(metadataJson);
  return metadata.parse(parsedMeta);
}
function tryParseIdMapOrFallback(idMapJson) {
  if (idMapJson == null)
    return [];
  const parsedIdMap = tryParseJson(idMapJson);
  return idMap.parse(parsedIdMap);
}
function tryParseJson(jsonString) {
  try {
    return json.parse(jsonString);
  } catch (e) {
    console.error("Failed to parse metadata JSON:");
    console.error(e);
    return null;
  }
}

// ydoc-server/serialization.ts
import * as json2 from "file:///C:/Projects/enso/enso/node_modules/.pnpm/lib0@0.2.93/node_modules/lib0/json.js";
function deserializeIdMap(idMapJson) {
  const idMapMeta = tryParseIdMapOrFallback(idMapJson);
  const idMap2 = new IdMap();
  for (const [{ index, size }, id] of idMapMeta) {
    const range = [index.value, index.value + size.value];
    if (typeof range[0] !== "number" || typeof range[1] !== "number") {
      console.error(`Invalid range for id ${id}:`, range);
      continue;
    }
    idMap2.insertKnownId([index.value, index.value + size.value], id);
  }
  return idMap2;
}
function serializeIdMap(map3) {
  map3.validate();
  return json2.stringify(idMapToArray(map3));
}
function idMapToArray(map3) {
  const entries = [];
  map3.entries().forEach(([rangeBuffer, id]) => {
    const decoded = sourceRangeFromKey(rangeBuffer);
    const index = decoded[0];
    const endIndex = decoded[1];
    if (index == null || endIndex == null)
      return;
    const size = endIndex - index;
    entries.push([{ index: { value: index }, size: { value: size } }, id]);
  });
  entries.sort(idMapCmp);
  return entries;
}
function idMapCmp(a, b) {
  const val1 = a[0]?.index?.value ?? 0;
  const val2 = b[0]?.index?.value ?? 0;
  if (val1 === val2) {
    const size1 = a[0]?.size.value ?? 0;
    const size2 = b[0]?.size.value ?? 0;
    return size1 - size2;
  }
  return val1 - val2;
}

// ydoc-server/languageServerSession.ts
var SOURCE_DIR = "src";
var EXTENSION = ".enso";
var DEBUG_LOG_SYNC = false;
function createOpenRPCClient(url) {
  const transport = new WebSocketTransport(url);
  const requestManager = new RequestManager([transport]);
  transport.connection.on(
    "error",
    (error) => console.error("Language Server transport error:", error)
  );
  return new Client(requestManager);
}
var LanguageServerSession = class _LanguageServerSession {
  clientId;
  indexDoc;
  docs;
  retainCount;
  url;
  client;
  ls;
  connection;
  model;
  projectRootId;
  authoritativeModules;
  clientScope;
  constructor(url) {
    this.clientScope = new AbortScope();
    this.clientId = random4.uuidv4();
    this.docs = /* @__PURE__ */ new Map();
    this.retainCount = 0;
    this.url = url;
    console.log("new session with", url);
    this.indexDoc = new WSSharedDoc();
    this.docs.set("index", this.indexDoc);
    this.model = new DistributedProject(this.indexDoc.doc);
    this.projectRootId = null;
    this.authoritativeModules = /* @__PURE__ */ new Map();
    this.indexDoc.doc.on("subdocs", (subdocs) => {
      for (const doc of subdocs.loaded) {
        const name = this.model.findModuleByDocId(doc.guid);
        if (!name)
          continue;
        const persistence = this.authoritativeModules.get(name);
        if (!persistence)
          continue;
      }
    });
    const { client, ls } = this.setupClient();
    this.client = client;
    this.ls = ls;
  }
  static sessions = /* @__PURE__ */ new Map();
  static get(url) {
    const session = map2.setIfUndefined(
      _LanguageServerSession.sessions,
      url,
      () => new _LanguageServerSession(url)
    );
    session.retain();
    return session;
  }
  restartClient() {
    this.clientScope.dispose("Client restarted.");
    this.clientScope = new AbortScope();
    this.connection = void 0;
    this.setupClient();
  }
  setupClient() {
    this.client = createOpenRPCClient(this.url);
    this.ls = new LanguageServer(this.client);
    this.clientScope.onAbort(() => this.ls.release());
    this.ls.on("file/event", async (event) => {
      if (DEBUG_LOG_SYNC) {
        console.log("file/event", event);
      }
      const path2 = event.path.segments.join("/");
      try {
        switch (event.kind) {
          case "Added": {
            if (isSourceFile(event.path)) {
              const fileInfo = await this.ls.fileInfo(event.path);
              if (fileInfo.attributes.kind.type == "File") {
                await exponentialBackoff(
                  () => this.getModuleModel(event.path).open(),
                  printingCallbacks(`opened new file '${path2}'`, `open new file '${path2}'`)
                );
              }
            }
            break;
          }
          case "Modified": {
            await exponentialBackoff(
              async () => this.tryGetExistingModuleModel(event.path)?.reload(),
              printingCallbacks(`reloaded file '${path2}'`, `reload file '${path2}'`)
            );
            break;
          }
        }
      } catch {
        this.restartClient();
      }
    });
    this.ls.on("text/fileModifiedOnDisk", async (event) => {
      const path2 = event.path.segments.join("/");
      try {
        await exponentialBackoff(
          async () => this.tryGetExistingModuleModel(event.path)?.reload(),
          printingCallbacks(`reloaded file '${path2}'`, `reload file '${path2}'`)
        );
      } catch {
        this.restartClient();
      }
    });
    exponentialBackoff(
      () => this.readInitialState(),
      printingCallbacks("read initial state", "read initial state")
    ).catch((error) => {
      console.error("Could not read initial state.");
      console.error(error);
      exponentialBackoff(
        async () => this.restartClient(),
        printingCallbacks("restarted RPC client", "restart RPC client")
      );
    });
    return { client: this.client, ls: this.ls };
  }
  assertProjectRoot() {
    if (this.projectRootId == null)
      throw new Error("Missing project root");
  }
  async readInitialState() {
    let moduleOpenPromises = [];
    try {
      const connection = this.connection ?? await this.ls.initProtocolConnection(this.clientId);
      this.connection = connection;
      const projectRoot = connection.contentRoots.find((root) => root.type === "Project");
      if (!projectRoot)
        throw new Error("Missing project root");
      this.projectRootId = projectRoot.id;
      await this.ls.acquireReceivesTreeUpdates({ rootId: this.projectRootId, segments: [] });
      const files = await this.scanSourceFiles();
      moduleOpenPromises = this.indexDoc.doc.transact(
        () => files.map((file) => this.getModuleModel(pushPathSegment(file.path, file.name)).open()),
        this
      );
      await Promise.all(moduleOpenPromises);
    } catch (error) {
      console.error("LS initialization failed.");
      throw error;
    }
    console.log("LS connection initialized.");
  }
  async scanSourceFiles() {
    this.assertProjectRoot();
    const sourceDir = { rootId: this.projectRootId, segments: [SOURCE_DIR] };
    const srcModules = await this.ls.listFiles(sourceDir);
    return srcModules.paths.filter((file) => file.type === "File" && file.name.endsWith(EXTENSION));
  }
  tryGetExistingModuleModel(path2) {
    const name = pathToModuleName(path2);
    return this.authoritativeModules.get(name);
  }
  getModuleModel(path2) {
    const name = pathToModuleName(path2);
    return map2.setIfUndefined(this.authoritativeModules, name, () => {
      const wsDoc = new WSSharedDoc();
      this.docs.set(wsDoc.doc.guid, wsDoc);
      this.model.createUnloadedModule(name, wsDoc.doc);
      const mod = new ModulePersistence(this.ls, path2, wsDoc.doc);
      mod.once("removed", () => {
        const index = this.model.findModuleByDocId(wsDoc.doc.guid);
        this.docs.delete(wsDoc.doc.guid);
        this.authoritativeModules.delete(name);
        if (index != null)
          this.model.deleteModule(index);
      });
      return mod;
    });
  }
  retain() {
    this.retainCount += 1;
  }
  async release() {
    this.retainCount -= 1;
    if (this.retainCount !== 0)
      return;
    const modules = this.authoritativeModules.values();
    const moduleDisposePromises = Array.from(modules, (mod) => mod.dispose());
    this.authoritativeModules.clear();
    this.model.doc.destroy();
    this.clientScope.dispose("LangueServerSession disposed.");
    _LanguageServerSession.sessions.delete(this.url);
    await Promise.all(moduleDisposePromises);
  }
  getYDoc(guid) {
    return this.docs.get(guid);
  }
};
function isSourceFile(path2) {
  return path2.segments[0] === SOURCE_DIR && path2.segments[path2.segments.length - 1].endsWith(EXTENSION);
}
function pathToModuleName(path2) {
  if (path2.segments[0] === SOURCE_DIR)
    return path2.segments.slice(1).join("/");
  else
    return "//" + path2.segments.join("/");
}
function pushPathSegment(path2, segment) {
  return { rootId: path2.rootId, segments: [...path2.segments, segment] };
}
var LsSyncState = /* @__PURE__ */ ((LsSyncState2) => {
  LsSyncState2[LsSyncState2["Closed"] = 0] = "Closed";
  LsSyncState2[LsSyncState2["Opening"] = 1] = "Opening";
  LsSyncState2[LsSyncState2["Synchronized"] = 2] = "Synchronized";
  LsSyncState2[LsSyncState2["WritingFile"] = 3] = "WritingFile";
  LsSyncState2[LsSyncState2["WriteError"] = 4] = "WriteError";
  LsSyncState2[LsSyncState2["Reloading"] = 5] = "Reloading";
  LsSyncState2[LsSyncState2["Closing"] = 6] = "Closing";
  LsSyncState2[LsSyncState2["Disposed"] = 7] = "Disposed";
  return LsSyncState2;
})(LsSyncState || {});
var ModulePersistence = class extends ObservableV22 {
  ls;
  path;
  doc = new ModuleDoc(new Y3.Doc());
  state = 0 /* Closed */;
  lastAction = Promise.resolve();
  updateToApply = null;
  syncedCode = null;
  syncedIdMap = null;
  syncedMetaJson = null;
  syncedContent = null;
  syncedVersion = null;
  syncedMeta = tryParseMetadataOrFallback(null);
  queuedAction = null;
  cleanup = () => {
  };
  constructor(ls, path2, sharedDoc) {
    super();
    this.ls = ls;
    this.path = path2;
    const onRemoteUpdate = this.queueRemoteUpdate.bind(this);
    const onLocalUpdate = (update, origin) => {
      if (origin === "file")
        Y3.applyUpdate(sharedDoc, update, this);
    };
    const onFileModified = this.handleFileModified.bind(this);
    const onFileRemoved = this.handleFileRemoved.bind(this);
    this.doc.ydoc.on("update", onLocalUpdate);
    sharedDoc.on("update", onRemoteUpdate);
    this.ls.on("text/fileModifiedOnDisk", onFileModified);
    this.ls.on("file/rootRemoved", onFileRemoved);
    this.cleanup = () => {
      this.doc.ydoc.off("update", onLocalUpdate);
      sharedDoc.off("update", onRemoteUpdate);
      this.ls.off("text/fileModifiedOnDisk", onFileModified);
      this.ls.off("file/rootRemoved", onFileRemoved);
    };
  }
  inState(...states) {
    return states.includes(this.state);
  }
  setState(state) {
    if (this.state !== 7 /* Disposed */) {
      if (DEBUG_LOG_SYNC) {
        console.debug("State change:", LsSyncState[this.state], "->", LsSyncState[state]);
      }
      this.state = state;
      if (state === 2 /* Synchronized */)
        this.trySyncRemoveUpdates();
    } else {
      throw new Error("LsSync disposed");
    }
  }
  setLastAction(lastAction) {
    this.lastAction = lastAction.then(
      () => {
      },
      () => {
      }
    );
    return lastAction;
  }
  /** Set the current state to the given state while the callback is running.
   * Set the current state back to {@link LsSyncState.Synchronized} when the callback finishes. */
  async withState(state, callback) {
    this.setState(state);
    await callback();
    this.setState(2 /* Synchronized */);
  }
  async open() {
    this.queuedAction = 0 /* Open */;
    switch (this.state) {
      case 7 /* Disposed */:
      case 3 /* WritingFile */:
      case 2 /* Synchronized */:
      case 4 /* WriteError */:
      case 5 /* Reloading */: {
        return;
      }
      case 6 /* Closing */: {
        await this.lastAction;
        if (this.queuedAction === 0 /* Open */)
          await this.open();
        return;
      }
      case 1 /* Opening */: {
        await this.lastAction;
        return;
      }
      case 0 /* Closed */: {
        await this.withState(1 /* Opening */, async () => {
          const promise = this.ls.openTextFile(this.path);
          this.setLastAction(promise.catch(() => this.setState(0 /* Closed */)));
          const result = await promise;
          if (!result.writeCapability) {
            console.error("Could not acquire write capability for module:", this.path);
            throw new Error(
              `Could not acquire write capability for module '${this.path.segments.join("/")}'`
            );
          }
          this.syncFileContents(result.content, result.currentVersion);
        });
        return;
      }
      default: {
        this.state;
        return;
      }
    }
  }
  handleFileRemoved() {
    if (this.inState(0 /* Closed */))
      return;
    this.close();
  }
  handleFileModified() {
    if (this.inState(0 /* Closed */))
      return;
  }
  queueRemoteUpdate(update, origin) {
    if (origin === this)
      return;
    if (this.updateToApply != null) {
      this.updateToApply = Y3.mergeUpdates([this.updateToApply, update]);
    } else {
      this.updateToApply = update;
    }
    this.trySyncRemoveUpdates();
  }
  trySyncRemoveUpdates() {
    if (this.updateToApply == null)
      return;
    if (!this.inState(2 /* Synchronized */))
      return;
    const update = this.updateToApply;
    this.updateToApply = null;
    const syncModule = new MutableModule(this.doc.ydoc);
    const moduleUpdate = syncModule.applyUpdate(update, "remote");
    if (moduleUpdate && this.syncedContent) {
      const synced = splitFileContents(this.syncedContent);
      const { newCode, newIdMap, newMetadata } = applyDocumentUpdates(
        this.doc,
        synced,
        moduleUpdate
      );
      this.sendLsUpdate(synced, newCode, newIdMap, newMetadata);
    }
  }
  sendLsUpdate(synced, newCode, newIdMap, newMetadata) {
    if (this.syncedContent == null || this.syncedVersion == null)
      return;
    const code = newCode ?? synced.code;
    const newMetadataJson = newMetadata && json3.stringify({ ...this.syncedMeta, ide: { ...this.syncedMeta.ide, node: newMetadata } });
    const newIdMapJson = newIdMap && serializeIdMap(newIdMap);
    const newContent = combineFileParts({
      code,
      idMapJson: newIdMapJson ?? synced.idMapJson ?? "[]",
      metadataJson: newMetadataJson ?? synced.metadataJson ?? "{}"
    });
    const edits = [];
    if (newCode)
      edits.push(...applyDiffAsTextEdits(0, synced.code, newCode));
    if (newIdMap || newMetadata) {
      const oldMetaContent = this.syncedContent.slice(synced.code.length);
      const metaContent = newContent.slice(code.length);
      const metaStartLine = (code.match(/\n/g) ?? []).length;
      edits.push(...applyDiffAsTextEdits(metaStartLine, oldMetaContent, metaContent));
    }
    const newVersion = computeTextChecksum(newContent);
    if (DEBUG_LOG_SYNC) {
      console.debug(" === changes === ");
      console.debug("number of edits:", edits.length);
      if (edits.length > 0) {
        console.debug("version:", this.syncedVersion, "->", newVersion);
        console.debug("Content diff:");
        console.debug(prettyPrintDiff(this.syncedContent, newContent));
      }
      console.debug(" =============== ");
    }
    this.setState(3 /* WritingFile */);
    const execute = newCode != null || newIdMap != null;
    const edit = { path: this.path, edits, oldVersion: this.syncedVersion, newVersion };
    const apply = this.ls.applyEdit(edit, execute);
    const promise = apply.then(
      () => {
        this.syncedContent = newContent;
        this.syncedVersion = newVersion;
        if (newMetadata)
          this.syncedMeta.ide.node = newMetadata;
        if (newCode)
          this.syncedCode = newCode;
        if (newIdMapJson)
          this.syncedIdMap = newIdMapJson;
        if (newMetadataJson)
          this.syncedMetaJson = newMetadataJson;
        this.setState(2 /* Synchronized */);
      },
      (error) => {
        console.error("Could not apply edit:", error);
        this.setState(4 /* WriteError */);
        this.syncedContent = null;
        this.syncedVersion = null;
        this.syncedCode = null;
        this.syncedIdMap = null;
        this.syncedMetaJson = null;
        return this.reload();
      }
    );
    this.setLastAction(promise);
    return promise;
  }
  syncFileContents(content, version) {
    const contentsReceived = splitFileContents(content);
    let unsyncedIdMap;
    this.doc.ydoc.transact(() => {
      const { code, idMapJson, metadataJson } = contentsReceived;
      const metadata2 = tryParseMetadataOrFallback(metadataJson);
      const nodeMeta = Object.entries(metadata2.ide.node);
      let parsedSpans;
      const syncModule = new MutableModule(this.doc.ydoc);
      if (code !== this.syncedCode) {
        const syncRoot = syncModule.root();
        if (syncRoot) {
          const edit = syncModule.edit();
          edit.getVersion(syncRoot).syncToCode(code);
          const editedRoot = edit.root();
          if (editedRoot instanceof BodyBlock)
            repair(editedRoot, edit);
          syncModule.applyEdit(edit);
        } else {
          const { root, spans } = parseBlockWithSpans(code, syncModule);
          syncModule.syncRoot(root);
          parsedSpans = spans;
        }
      }
      const astRoot = syncModule.root();
      if (!astRoot)
        return;
      if ((code !== this.syncedCode || idMapJson !== this.syncedIdMap) && idMapJson) {
        const idMap2 = deserializeIdMap(idMapJson);
        const spans = parsedSpans ?? print(astRoot).info;
        const idsAssigned = setExternalIds(syncModule, spans, idMap2);
        const numberOfAsts = astCount(astRoot);
        const idsNotSetByMap = numberOfAsts - idsAssigned;
        if (idsNotSetByMap > 0) {
          if (code !== this.syncedCode) {
            unsyncedIdMap = spanMapToIdMap(spans);
          } else {
            console.warn(
              `The LS sent an IdMap-only edit that is missing ${idsNotSetByMap} of our expected ASTs.`
            );
          }
        }
      }
      if ((code !== this.syncedCode || idMapJson !== this.syncedIdMap || metadataJson !== this.syncedMetaJson) && nodeMeta.length !== 0) {
        const externalIdToAst = /* @__PURE__ */ new Map();
        astRoot.visitRecursiveAst((ast) => {
          if (!externalIdToAst.has(ast.externalId))
            externalIdToAst.set(ast.externalId, ast);
        });
        const missing = /* @__PURE__ */ new Set();
        for (const [id, meta] of nodeMeta) {
          if (typeof id !== "string")
            continue;
          const ast = externalIdToAst.get(id);
          if (!ast) {
            missing.add(id);
            continue;
          }
          const metadata3 = syncModule.getVersion(ast).mutableNodeMetadata();
          const oldPos = metadata3.get("position");
          const newPos = { x: meta.position.vector[0], y: -meta.position.vector[1] };
          if (oldPos?.x !== newPos.x || oldPos?.y !== newPos.y)
            metadata3.set("position", newPos);
          const oldVis = metadata3.get("visualization");
          const newVis = meta.visualization && translateVisualizationFromFile(meta.visualization);
          if (!visMetadataEquals(newVis, oldVis))
            metadata3.set("visualization", newVis);
          const oldColorOverride = metadata3.get("colorOverride");
          const newColorOverride = meta.colorOverride;
          if (oldColorOverride !== newColorOverride)
            metadata3.set("colorOverride", newColorOverride);
        }
      }
      this.syncedCode = code;
      this.syncedIdMap = unsyncedIdMap ? null : idMapJson;
      this.syncedContent = content;
      this.syncedVersion = version;
      this.syncedMeta = metadata2;
      this.syncedMetaJson = metadataJson;
    }, "file");
    if (unsyncedIdMap)
      this.sendLsUpdate(contentsReceived, void 0, unsyncedIdMap, void 0);
  }
  async close() {
    this.queuedAction = 1 /* Close */;
    switch (this.state) {
      case 7 /* Disposed */:
      case 0 /* Closed */: {
        return;
      }
      case 6 /* Closing */: {
        await this.lastAction;
        return;
      }
      case 1 /* Opening */:
      case 3 /* WritingFile */:
      case 5 /* Reloading */: {
        await this.lastAction;
        if (this.queuedAction === 1 /* Close */) {
          await this.close();
        }
        return;
      }
      case 4 /* WriteError */:
      case 2 /* Synchronized */: {
        this.setState(6 /* Closing */);
        const promise = this.ls.closeTextFile(this.path);
        const state = this.state;
        this.setLastAction(promise.catch(() => this.setState(state)));
        await promise;
        this.setState(0 /* Closed */);
        return;
      }
      default: {
        this.state;
        return;
      }
    }
  }
  async reload() {
    this.queuedAction = 2 /* Reload */;
    switch (this.state) {
      case 1 /* Opening */:
      case 7 /* Disposed */:
      case 0 /* Closed */:
      case 6 /* Closing */: {
        return;
      }
      case 5 /* Reloading */: {
        await this.lastAction;
        return;
      }
      case 3 /* WritingFile */: {
        await this.lastAction;
        if (this.queuedAction === 2 /* Reload */)
          await this.reload();
        return;
      }
      case 2 /* Synchronized */: {
        this.withState(5 /* Reloading */, async () => {
          const promise = Promise.all([
            this.ls.readFile(this.path),
            this.ls.fileChecksum(this.path)
          ]);
          this.setLastAction(promise);
          const [contents, checksum] = await promise;
          this.syncFileContents(contents.contents, checksum.checksum);
        });
        return;
      }
      case 4 /* WriteError */: {
        this.withState(5 /* Reloading */, async () => {
          const path2 = this.path.segments.join("/");
          const reloading = this.ls.closeTextFile(this.path).catch((error) => {
            console.error("Could not close file after write error:");
            console.error(error);
          }).then(
            () => exponentialBackoff(
              async () => {
                const result2 = await this.ls.openTextFile(this.path);
                if (!result2.writeCapability) {
                  const message = `Could not acquire write capability for module '${this.path.segments.join(
                    "/"
                  )}'`;
                  console.error(message);
                  throw new Error(message);
                }
                return result2;
              },
              printingCallbacks(
                `opened file '${path2}' for writing`,
                `open file '${path2}' for writing`
              )
            ),
            (error) => {
              console.error("Could not reopen file after write error:");
              console.error(error);
              throw error;
            }
          );
          this.setLastAction(reloading);
          const result = await reloading;
          this.syncFileContents(result.content, result.currentVersion);
        });
        return;
      }
      default: {
        this.state;
        return;
      }
    }
  }
  async dispose() {
    this.cleanup();
    const alreadyClosed = this.inState(6 /* Closing */, 0 /* Closed */);
    this.setState(7 /* Disposed */);
    if (alreadyClosed)
      return Promise.resolve();
    return this.ls.closeTextFile(this.path);
  }
};

// ydoc-server/ydoc.ts
var pingTimeout = 3e4;
var messageSync = 0;
var messageAwareness = 1;
var WSSharedDoc = class {
  doc;
  /**
   * Maps from connection id to set of controlled user ids.
   * Delete all user ids from awareness when this conn is closed.
   */
  conns;
  awareness;
  constructor(gc = true) {
    this.doc = new Y4.Doc({ gc });
    this.conns = /* @__PURE__ */ new Map();
    this.awareness = new Awareness(this.doc);
    this.awareness.setLocalState(null);
    this.awareness.on(
      "update",
      ({ added, updated, removed }, conn) => {
        const changedClients = added.concat(updated, removed);
        if (conn !== null) {
          const connControlledIDs = this.conns.get(conn);
          if (connControlledIDs !== void 0) {
            for (const clientID of added)
              connControlledIDs.add(clientID);
            for (const clientID of removed)
              connControlledIDs.delete(clientID);
          }
        }
        const encoder = encoding.createEncoder();
        encoding.writeVarUint(encoder, messageAwareness);
        const update = encodeAwarenessUpdate(this.awareness, changedClients);
        encoding.writeVarUint8Array(encoder, update);
        this.broadcast(encoding.toUint8Array(encoder));
      }
    );
    this.doc.on("update", (update, origin) => this.updateHandler(update, origin));
  }
  broadcast(message) {
    for (const [conn] of this.conns) {
      if (typeof conn !== "string")
        conn.send(message);
    }
  }
  updateHandler(update, _origin) {
    const encoder = encoding.createEncoder();
    encoding.writeVarUint(encoder, messageSync);
    writeUpdate(encoder, update);
    this.broadcast(encoding.toUint8Array(encoder));
  }
};
function setupGatewayClient(ws, lsUrl, docName2) {
  const lsSession = LanguageServerSession.get(lsUrl);
  const wsDoc = lsSession.getYDoc(docName2);
  if (wsDoc == null) {
    console.error(`Document '${docName2}' not found in language server session '${lsUrl}'.`);
    ws.close();
    return;
  }
  const connection = new YjsConnection(ws, wsDoc);
  connection.once("close", async () => {
    try {
      await lsSession.release();
    } catch (error) {
      console.error("Session release failed.\n", error);
    }
  });
}
var YjsConnection = class extends ObservableV23 {
  ws;
  wsDoc;
  constructor(ws, wsDoc) {
    super();
    this.ws = ws;
    this.wsDoc = wsDoc;
    const isLoaded = wsDoc.conns.size > 0;
    wsDoc.conns.set(this, /* @__PURE__ */ new Set());
    ws.binaryType = "arraybuffer";
    ws.on("message", (message) => this.messageListener(new Uint8Array(message)));
    ws.on("close", () => this.close());
    if (!isLoaded)
      wsDoc.doc.load();
    this.initPing();
    this.sendSyncMessage();
  }
  initPing() {
    let pongReceived = true;
    const pingInterval = setInterval(() => {
      if (!pongReceived) {
        if (this.wsDoc.conns.has(this))
          this.close();
        clearInterval(pingInterval);
      } else if (this.wsDoc.conns.has(this)) {
        pongReceived = false;
        try {
          this.ws.ping();
        } catch (error) {
          console.error("Error sending ping:", error);
          this.close();
          clearInterval(pingInterval);
        }
      }
    }, pingTimeout);
    this.ws.on("close", () => clearInterval(pingInterval));
    this.ws.on("pong", () => pongReceived = true);
  }
  sendSyncMessage() {
    const encoder = encoding.createEncoder();
    encoding.writeVarUint(encoder, messageSync);
    writeSyncStep1(encoder, this.wsDoc.doc);
    this.send(encoding.toUint8Array(encoder));
    const awarenessStates = this.wsDoc.awareness.getStates();
    if (awarenessStates.size > 0) {
      const encoder2 = encoding.createEncoder();
      encoding.writeVarUint(encoder2, messageAwareness);
      encoding.writeVarUint8Array(
        encoder2,
        encodeAwarenessUpdate(this.wsDoc.awareness, Array.from(awarenessStates.keys()))
      );
      this.send(encoding.toUint8Array(encoder2));
    }
  }
  send(message) {
    if (this.ws.readyState !== WebSocket.CONNECTING && this.ws.readyState !== WebSocket.OPEN) {
      this.close();
    }
    try {
      this.ws.send(message, (error) => error && this.close());
    } catch (e) {
      this.close();
    }
  }
  messageListener(message) {
    try {
      const encoder = encoding.createEncoder();
      const decoder = decoding.createDecoder(message);
      const messageType = decoding.readVarUint(decoder);
      switch (messageType) {
        case messageSync: {
          encoding.writeVarUint(encoder, messageSync);
          readSyncMessage(decoder, encoder, this.wsDoc.doc, this);
          if (encoding.length(encoder) > 1) {
            this.send(encoding.toUint8Array(encoder));
          }
          break;
        }
        case messageAwareness: {
          const update = decoding.readVarUint8Array(decoder);
          applyAwarenessUpdate(this.wsDoc.awareness, update, this);
          break;
        }
      }
    } catch (err) {
      console.error(err);
      this.wsDoc.doc.emit("error", [err]);
    }
  }
  close() {
    const controlledIds = this.wsDoc.conns.get(this);
    this.wsDoc.conns.delete(this);
    if (controlledIds != null) {
      removeAwarenessStates(this.wsDoc.awareness, Array.from(controlledIds), null);
    }
    this.ws.close();
    this.emit("close", []);
    if (this.wsDoc.conns.size === 0) {
      this.wsDoc.doc.emit("unload", []);
    }
  }
};

// ydoc-server/index.ts
async function createGatewayServer(httpServer, rustFFIPath) {
  await initializeFFI(rustFFIPath);
  const wss = new WebSocketServer({ noServer: true });
  wss.on("connection", (ws, _request, data) => {
    ws.on("error", onWebSocketError);
    setupGatewayClient(ws, data.lsUrl, data.doc);
  });
  httpServer.on("upgrade", (request, socket, head) => {
    socket.on("error", onHttpSocketError);
    authenticate(request, function next(err, data) {
      if (err != null) {
        socket.write("HTTP/1.1 401 Unauthorized\r\n\r\n");
        socket.destroy();
        return;
      }
      socket.removeListener("error", onHttpSocketError);
      if (data != null) {
        wss.handleUpgrade(request, socket, head, function done(ws) {
          wss.emit("connection", ws, request, data);
        });
      }
    });
  });
}
function onWebSocketError(err) {
  console.log("WebSocket error:", err);
}
function onHttpSocketError(err) {
  console.log("HTTP socket error:", err);
}
function authenticate(request, callback) {
  const user = "mock-user";
  if (request.url == null)
    return callback(null, null);
  const { pathname, query } = parse4(request.url, true);
  if (pathname == null)
    return callback(null, null);
  const doc = docName(pathname);
  const lsUrl = query.ls;
  const data = doc != null && typeof lsUrl === "string" ? { lsUrl, doc, user } : null;
  callback(null, data);
}
var docNameRegex = /^[a-z0-9/-]+$/i;
function docName(pathname) {
  const prefix = "/project/";
  if (pathname != null && pathname.startsWith(prefix)) {
    const docName2 = pathname.slice(prefix.length);
    if (docNameRegex.test(docName2)) {
      return docName2;
    }
  }
  return null;
}

// vite.config.ts
var __vite_injected_original_import_meta_url3 = "file:///C:/Projects/enso/enso/app/gui2/vite.config.ts";
var localServerPort = 8080;
var projectManagerUrl = "ws://127.0.0.1:30535";
var IS_CLOUD_BUILD = process.env.CLOUD_BUILD === "true";
await readEnvironmentFromFile();
var entrypoint = process.env.E2E === "true" ? "./src/e2e-entrypoint.ts" : "./src/entrypoint.ts";
var vite_config_default = defineConfig({
  root: fileURLToPath(new URL(".", __vite_injected_original_import_meta_url3)),
  cacheDir: fileURLToPath(new URL("../../node_modules/.cache/vite", __vite_injected_original_import_meta_url3)),
  publicDir: fileURLToPath(new URL("./public", __vite_injected_original_import_meta_url3)),
  envDir: fileURLToPath(new URL(".", __vite_injected_original_import_meta_url3)),
  plugins: [
    vue(),
    gatewayServer(),
    ...process.env.ELECTRON_DEV_MODE === "true" ? [
      (await import("file:///C:/Projects/enso/enso/node_modules/.pnpm/@vitejs+plugin-react@4.2.1_vite@5.2.9/node_modules/@vitejs/plugin-react/dist/index.mjs")).default({
        include: fileURLToPath(new URL("../ide-desktop/lib/dashboard/**/*.tsx", __vite_injected_original_import_meta_url3)),
        babel: { plugins: ["@babel/plugin-syntax-import-assertions"] }
      })
    ] : process.env.NODE_ENV === "development" ? [await projectManagerShim()] : []
  ],
  optimizeDeps: {
    entries: fileURLToPath(new URL("./index.html", __vite_injected_original_import_meta_url3))
  },
  server: {
    watch: {},
    headers: {
      "Cross-Origin-Embedder-Policy": "require-corp",
      "Cross-Origin-Opener-Policy": "same-origin",
      "Cross-Origin-Resource-Policy": "same-origin"
    }
  },
  resolve: {
    alias: {
      "/src/entrypoint.ts": fileURLToPath(new URL(entrypoint, __vite_injected_original_import_meta_url3)),
      shared: fileURLToPath(new URL("./shared", __vite_injected_original_import_meta_url3)),
      "@": fileURLToPath(new URL("./src", __vite_injected_original_import_meta_url3))
    }
  },
  define: {
    ...getDefines(localServerPort),
    IS_CLOUD_BUILD: JSON.stringify(IS_CLOUD_BUILD),
    PROJECT_MANAGER_URL: JSON.stringify(projectManagerUrl),
    RUNNING_VITEST: false,
    "import.meta.vitest": false,
    // Single hardcoded usage of `global` in aws-amplify.
    "global.TYPED_ARRAY_SUPPORT": true
  },
  assetsInclude: ["**/*.yaml", "**/*.svg"],
  css: {
    postcss: {
      plugins: [
        tailwindcssNesting(postcssNesting()),
        tailwindcss({
          ...tailwindConfig.default,
          content: tailwindConfig.default.content.map(
            (glob) => glob.replace(
              /^[.][/]/,
              fileURLToPath(new URL("../ide-desktop/lib/dashboard/", __vite_injected_original_import_meta_url3))
            )
          )
        })
      ]
    }
  },
  build: {
    // dashboard chunk size is larger than the default warning limit
    chunkSizeWarningLimit: 700,
    rollupOptions: {
      output: {
        manualChunks: {
          fontawesome: ["@fortawesome/react-fontawesome", "@fortawesome/free-brands-svg-icons"]
        }
      }
    }
  }
});
function gatewayServer() {
  return {
    name: "gateway-server",
    configureServer(server) {
      if (server.httpServer == null)
        return;
      createGatewayServer(server.httpServer, void 0);
    }
  };
}
async function projectManagerShim() {
  const module = await Promise.resolve().then(() => (init_projectManagerShimMiddleware(), projectManagerShimMiddleware_exports));
  return {
    name: "project-manager-shim",
    configureServer(server) {
      server.middlewares.use(module.default);
    }
  };
}

// vitest.config.ts
var __vite_injected_original_import_meta_url4 = "file:///C:/Projects/enso/enso/app/gui2/vitest.config.ts";
var vitest_config_default = mergeConfig(
  vite_config_default,
  defineConfig2({
    test: {
      environment: "jsdom",
      includeSource: ["./{src,shared,ydoc-server}/**/*.{ts,vue}"],
      exclude: [...configDefaults.exclude, "e2e/*"],
      root: fileURLToPath2(new URL("./", __vite_injected_original_import_meta_url4)),
      restoreMocks: true
    },
    define: {
      RUNNING_VITEST: true
    }
  })
);
export {
  vitest_config_default as default
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vaWRlLWRlc2t0b3AvbGliL3Byb2plY3QtbWFuYWdlci1zaGltL3NyYy9wcm9qZWN0TWFuYWdlbWVudC50cyIsICIuLi9pZGUtZGVza3RvcC9saWIvcHJvamVjdC1tYW5hZ2VyLXNoaW0vc3JjL3Byb2plY3RNYW5hZ2VyU2hpbU1pZGRsZXdhcmUudHMiLCAidml0ZXN0LmNvbmZpZy50cyIsICJ2aXRlLmNvbmZpZy50cyIsICJ5ZG9jLXNlcnZlci9pbmRleC50cyIsICJzaGFyZWQvYXN0L2ZmaS50cyIsICJydXN0LWZmaS9wa2cvcnVzdF9mZmkuanMiLCAic2hhcmVkL3V0aWwvYXNzZXJ0LnRzIiwgInNoYXJlZC91dGlsL2RldGVjdC50cyIsICJ5ZG9jLXNlcnZlci95ZG9jLnRzIiwgInlkb2Mtc2VydmVyL2xhbmd1YWdlU2VydmVyU2Vzc2lvbi50cyIsICJzaGFyZWQvYXN0L2luZGV4LnRzIiwgInNoYXJlZC91dGlsL2RhdGEvcmVzdWx0LnRzIiwgInNoYXJlZC95anNNb2RlbC50cyIsICJzaGFyZWQvYXN0L3BhcnNlclN1cHBvcnQudHMiLCAic2hhcmVkL2FzdC9nZW5lcmF0ZWQvYXN0LnRzIiwgInNoYXJlZC9hc3QvcGFyc2UudHMiLCAic2hhcmVkL3V0aWwvZGF0YS9pdGVyYWJsZS50cyIsICJzaGFyZWQvdXRpbC9kYXRhL3RleHQudHMiLCAic2hhcmVkL2FzdC9kZWJ1Zy50cyIsICJzaGFyZWQvYXN0L211dGFibGVNb2R1bGUudHMiLCAic2hhcmVkL2FzdC90cmVlLnRzIiwgInNoYXJlZC9hc3QvdGV4dC50cyIsICJzaGFyZWQvYXN0L3Rva2VuLnRzIiwgInNoYXJlZC9lbnNvRmlsZS50cyIsICJzaGFyZWQvbGFuZ3VhZ2VTZXJ2ZXIudHMiLCAic2hhcmVkL2xhbmd1YWdlU2VydmVyL2ZpbGVzLnRzIiwgInNoYXJlZC9yZXRyeS50cyIsICJzaGFyZWQvdXRpbC9uZXQudHMiLCAieWRvYy1zZXJ2ZXIvZWRpdHMudHMiLCAieWRvYy1zZXJ2ZXIvZmlsZUZvcm1hdC50cyIsICJ5ZG9jLXNlcnZlci9zZXJpYWxpemF0aW9uLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfZGlybmFtZSA9IFwiQzpcXFxcUHJvamVjdHNcXFxcZW5zb1xcXFxlbnNvXFxcXGFwcFxcXFxpZGUtZGVza3RvcFxcXFxsaWJcXFxccHJvamVjdC1tYW5hZ2VyLXNoaW1cXFxcc3JjXCI7Y29uc3QgX192aXRlX2luamVjdGVkX29yaWdpbmFsX2ZpbGVuYW1lID0gXCJDOlxcXFxQcm9qZWN0c1xcXFxlbnNvXFxcXGVuc29cXFxcYXBwXFxcXGlkZS1kZXNrdG9wXFxcXGxpYlxcXFxwcm9qZWN0LW1hbmFnZXItc2hpbVxcXFxzcmNcXFxccHJvamVjdE1hbmFnZW1lbnQudHNcIjtjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfaW1wb3J0X21ldGFfdXJsID0gXCJmaWxlOi8vL0M6L1Byb2plY3RzL2Vuc28vZW5zby9hcHAvaWRlLWRlc2t0b3AvbGliL3Byb2plY3QtbWFuYWdlci1zaGltL3NyYy9wcm9qZWN0TWFuYWdlbWVudC50c1wiOy8qKiBAZmlsZSBUaGlzIG1vZHVsZSBjb250YWlucyBmdW5jdGlvbnMgZm9yIGltcG9ydGluZyBwcm9qZWN0cyBpbnRvIHRoZSBQcm9qZWN0IE1hbmFnZXIuXG4gKlxuICogRXZlbnR1YWxseSB0aGlzIG1vZHVsZSBzaG91bGQgYmUgcmVwbGFjZWQgd2l0aCBhIG5ldyBQcm9qZWN0IE1hbmFnZXIgQVBJIHRoYXQgc3VwcG9ydHNcbiAqIGltcG9ydGluZyBwcm9qZWN0cy5cbiAqIEZvciBub3csIHdlIGJhc2ljYWxseSBkbyB0aGUgZm9sbG93aW5nOlxuICogLSBpZiB0aGUgcHJvamVjdCBpcyBhbHJlYWR5IGluIHRoZSBQcm9qZWN0IE1hbmFnZXIncyBsb2NhdGlvbiwgd2UganVzdCBvcGVuIGl0O1xuICogLSBpZiB0aGUgcHJvamVjdCBpcyBpbiBhIGRpZmZlcmVudCBsb2NhdGlvbiwgd2UgY29weSBpdCB0byB0aGUgUHJvamVjdCBNYW5hZ2VyJ3MgbG9jYXRpb25cbiAqIGFuZCBvcGVuIGl0LlxuICogLSBpZiB0aGUgcHJvamVjdCBpcyBhIGJ1bmRsZSwgd2UgZXh0cmFjdCBpdCB0byB0aGUgUHJvamVjdCBNYW5hZ2VyJ3MgbG9jYXRpb24gYW5kIG9wZW4gaXQuICovXG5pbXBvcnQgKiBhcyBjcnlwdG8gZnJvbSAnbm9kZTpjcnlwdG8nXG5pbXBvcnQgKiBhcyBmcyBmcm9tICdub2RlOmZzJ1xuaW1wb3J0ICogYXMgb3MgZnJvbSAnbm9kZTpvcydcbmltcG9ydCAqIGFzIHBhdGhNb2R1bGUgZnJvbSAnbm9kZTpwYXRoJ1xuaW1wb3J0IHR5cGUgKiBhcyBzdHJlYW0gZnJvbSAnbm9kZTpzdHJlYW0nXG5cbmltcG9ydCAqIGFzIHRhciBmcm9tICd0YXInXG5cbmltcG9ydCAqIGFzIGNvbW1vbiBmcm9tICdlbnNvLWNvbW1vbidcbmltcG9ydCAqIGFzIGJ1aWxkVXRpbHMgZnJvbSAnZW5zby1jb21tb24vc3JjL2J1aWxkVXRpbHMnXG5cbmNvbnN0IGxvZ2dlciA9IGNvbnNvbGVcblxuLy8gPT09PT09PT09PT09PT09PT1cbi8vID09PSBDb25zdGFudHMgPT09XG4vLyA9PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgY29uc3QgUEFDS0FHRV9NRVRBREFUQV9SRUxBVElWRV9QQVRIID0gJ3BhY2thZ2UueWFtbCdcbmV4cG9ydCBjb25zdCBQUk9KRUNUX01FVEFEQVRBX1JFTEFUSVZFX1BBVEggPSAnLmVuc28vcHJvamVjdC5qc29uJ1xuLyoqIFRoZSBmaWxlbmFtZSBzdWZmaXggZm9yIHRoZSBwcm9qZWN0IGJ1bmRsZSwgaW5jbHVkaW5nIHRoZSBsZWFkaW5nIHBlcmlvZCBjaGFyYWN0ZXIuICovXG5jb25zdCBCVU5ETEVEX1BST0pFQ1RfU1VGRklYID0gYC5lbnNvLXByb2plY3RgXG5cbi8vID09PT09PT09PT09PT09PT09PT09PT1cbi8vID09PSBQcm9qZWN0IEltcG9ydCA9PT1cbi8vID09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqIE9wZW4gYSBwcm9qZWN0IGZyb20gdGhlIGdpdmVuIHBhdGguIFBhdGggY2FuIGJlIGVpdGhlciBhIHNvdXJjZSBmaWxlIHVuZGVyIHRoZSBwcm9qZWN0IHJvb3QsXG4gKiBvciB0aGUgcHJvamVjdCBidW5kbGUuIElmIG5lZWRlZCwgdGhlIHByb2plY3Qgd2lsbCBiZSBpbXBvcnRlZCBpbnRvIHRoZSBQcm9qZWN0IE1hbmFnZXItZW5hYmxlZFxuICogbG9jYXRpb24uXG4gKiBAcmV0dXJucyBQcm9qZWN0IElEIChmcm9tIFByb2plY3QgTWFuYWdlcidzIG1ldGFkYXRhKSBpZGVudGlmeWluZyB0aGUgaW1wb3J0ZWQgcHJvamVjdC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgcGF0aCBkb2VzIG5vdCBiZWxvbmcgdG8gYSB2YWxpZCBwcm9qZWN0LiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGltcG9ydFByb2plY3RGcm9tUGF0aChcbiAgICBvcGVuZWRQYXRoOiBzdHJpbmcsXG4gICAgZGlyZWN0b3J5Pzogc3RyaW5nIHwgbnVsbCxcbiAgICBuYW1lOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuKTogc3RyaW5nIHtcbiAgICBkaXJlY3RvcnkgPz89IGdldFByb2plY3RzRGlyZWN0b3J5KClcbiAgICBpZiAocGF0aE1vZHVsZS5leHRuYW1lKG9wZW5lZFBhdGgpLmVuZHNXaXRoKEJVTkRMRURfUFJPSkVDVF9TVUZGSVgpKSB7XG4gICAgICAgIGxvZ2dlci5sb2coYFBhdGggJyR7b3BlbmVkUGF0aH0nIGRlbm90ZXMgYSBidW5kbGVkIHByb2plY3QuYClcbiAgICAgICAgLy8gVGhlIHNlY29uZCBwYXJ0IG9mIGNvbmRpdGlvbiBpcyBmb3IgdGhlIGNhc2Ugd2hlbiBzb21lb25lIG5hbWVzIGEgZGlyZWN0b3J5XG4gICAgICAgIC8vIGxpa2UgYG15LXByb2plY3QuZW5zby1wcm9qZWN0YCBhbmQgc3RvcmVzIHRoZSBwcm9qZWN0IHRoZXJlLlxuICAgICAgICAvLyBOb3QgdGhlIG1vc3QgZm9ydHVuYXRlIG1vdmUsIGJ1dC4uLlxuICAgICAgICBpZiAoaXNQcm9qZWN0Um9vdChvcGVuZWRQYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGltcG9ydERpcmVjdG9yeShvcGVuZWRQYXRoLCBkaXJlY3RvcnksIG5hbWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBQcm9qZWN0IGJ1bmRsZSB3YXMgcHJvdmlkZWQsIHNvIHdlIG5lZWQgdG8gZXh0cmFjdCBpdCBmaXJzdC5cbiAgICAgICAgICAgIHJldHVybiBpbXBvcnRCdW5kbGUob3BlbmVkUGF0aCwgZGlyZWN0b3J5LCBuYW1lKVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhgT3BlbmluZyBub24tYnVuZGxlZCBmaWxlOiAnJHtvcGVuZWRQYXRofScuYClcbiAgICAgICAgY29uc3Qgcm9vdFBhdGggPSBnZXRQcm9qZWN0Um9vdChvcGVuZWRQYXRoKVxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgcHJvamVjdCByb290IGlzIHVuZGVyIHRoZSBwcm9qZWN0cyBkaXJlY3RvcnkuIElmIGl0IGlzLCB3ZSBjYW4gb3BlbiBpdC5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBuZWVkIHRvIGluc3RhbGwgaXQgZmlyc3QuXG4gICAgICAgIGlmIChyb290UGF0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9kdWN0TmFtZSA9IGNvbW1vbi5QUk9EVUNUX05BTUVcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgRmlsZSAnJHtvcGVuZWRQYXRofScgZG9lcyBub3QgYmVsb25nIHRvIHRoZSAke3Byb2R1Y3ROYW1lfSBwcm9qZWN0LmBcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGltcG9ydERpcmVjdG9yeShyb290UGF0aCwgZGlyZWN0b3J5LCBuYW1lKVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKiogSW1wb3J0IHRoZSBwcm9qZWN0IGZyb20gYSBidW5kbGUuXG4gKiBAcmV0dXJucyBQcm9qZWN0IElEIChmcm9tIFByb2plY3QgTWFuYWdlcidzIG1ldGFkYXRhKSBpZGVudGlmeWluZyB0aGUgaW1wb3J0ZWQgcHJvamVjdC4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbXBvcnRCdW5kbGUoXG4gICAgYnVuZGxlUGF0aDogc3RyaW5nLFxuICAgIGRpcmVjdG9yeT86IHN0cmluZyB8IG51bGwsXG4gICAgbmFtZTogc3RyaW5nIHwgbnVsbCA9IG51bGxcbik6IHN0cmluZyB7XG4gICAgZGlyZWN0b3J5ID8/PSBnZXRQcm9qZWN0c0RpcmVjdG9yeSgpXG4gICAgbG9nZ2VyLmxvZyhcbiAgICAgICAgYEltcG9ydGluZyBwcm9qZWN0ICcke2J1bmRsZVBhdGh9JyBmcm9tIGJ1bmRsZSR7bmFtZSAhPSBudWxsID8gYCBhcyAnJHtuYW1lfSdgIDogJyd9LmBcbiAgICApXG4gICAgLy8gVGhlIGJ1bmRsZSBpcyBhIHRhcmJhbGwsIHNvIHdlIGp1c3QgbmVlZCB0byBleHRyYWN0IGl0IHRvIHRoZSByaWdodCBsb2NhdGlvbi5cbiAgICBjb25zdCBidW5kbGVQcmVmaXggPSBwcmVmaXhJbkJ1bmRsZShidW5kbGVQYXRoKVxuICAgIC8vIFdlIGNhcmUgYWJvdXQgc3B1cmlvdXMgJy4nIGFuZCAnLi4nIHdoZW4gc3RyaXBwaW5nIHBhdGhzIGJ1dCBub3Qgd2hlbiBnZW5lcmF0aW5nIG5hbWUuXG4gICAgY29uc3Qgbm9ybWFsaXplZEJ1bmRsZVByZWZpeCA9XG4gICAgICAgIGJ1bmRsZVByZWZpeCAhPSBudWxsXG4gICAgICAgICAgICA/IHBhdGhNb2R1bGUubm9ybWFsaXplKGJ1bmRsZVByZWZpeCkucmVwbGFjZSgvW1xcXFwvXSskLywgJycpIC8vIEFsc28gc3RyaXAgdHJhaWxpbmcgc2xhc2guXG4gICAgICAgICAgICA6IG51bGxcbiAgICBjb25zdCBkaXJOYW1lQmFzZSA9XG4gICAgICAgIG5vcm1hbGl6ZWRCdW5kbGVQcmVmaXggIT0gbnVsbCAmJlxuICAgICAgICBub3JtYWxpemVkQnVuZGxlUHJlZml4ICE9PSAnLicgJiZcbiAgICAgICAgbm9ybWFsaXplZEJ1bmRsZVByZWZpeCAhPT0gJy4uJ1xuICAgICAgICAgICAgPyBub3JtYWxpemVkQnVuZGxlUHJlZml4XG4gICAgICAgICAgICA6IGJ1bmRsZVBhdGhcbiAgICBsb2dnZXIubG9nKGBCdW5kbGUgbm9ybWFsaXplZCBwcmVmaXg6ICcke1N0cmluZyhub3JtYWxpemVkQnVuZGxlUHJlZml4KX0nLmApXG4gICAgY29uc3QgdGFyZ2V0UGF0aCA9IGdlbmVyYXRlRGlyZWN0b3J5TmFtZShkaXJOYW1lQmFzZSwgZGlyZWN0b3J5KVxuICAgIGxvZ2dlci5sb2coYEltcG9ydGluZyBwcm9qZWN0IGFzICcke3RhcmdldFBhdGh9Jy5gKVxuICAgIGZzLm1rZGlyU3luYyh0YXJnZXRQYXRoLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KVxuICAgIC8vIFRvIGJlIG1vcmUgcmVzaWxpZW50IGFnYWluc3QgZGlmZmVyZW50IHdheXMgdGhhdCB1c2VyIG1pZ2h0IGF0dGVtcHQgdG8gY3JlYXRlIGEgYnVuZGxlLFxuICAgIC8vIHdlIHRyeSB0byBzdXBwb3J0IGJvdGggYXJjaGl2ZXMgdGhhdDpcbiAgICAvLyAqIGNvbnRhaW4gYSBzaW5nbGUgZGlyZWN0b3J5IHdpdGggdGhlIHByb2plY3QgZmlsZXMgLSB0aGF0IGRpcmVjdG9yeSBuYW1lIHdpbGwgYmUgdXNlZFxuICAgIC8vICAgdG8gZ2VuZXJhdGUgYSBuZXcgdGFyZ2V0IGRpcmVjdG9yeSBuYW1lO1xuICAgIC8vICogY29udGFpbiB0aGUgcHJvamVjdCBmaWxlcyBkaXJlY3RseSAtIGluIHRoaXMgY2FzZSwgdGhlIGFyY2hpdmUgZmlsZW5hbWUgd2lsbCBiZSB1c2VkXG4gICAgLy8gICB0byBnZW5lcmF0ZSBhIG5ldyB0YXJnZXQgZGlyZWN0b3J5IG5hbWUuXG4gICAgLy8gV2UgdHJ5IHRvIHRlbGwgYXBhcnQgdGhlc2UgdHdvIGNhc2VzIGJ5IGxvb2tpbmcgYXQgdGhlIGNvbW1vbiBwcmVmaXggb2YgdGhlIHBhdGhzXG4gICAgLy8gb2YgdGhlIGZpbGVzIGluIHRoZSBhcmNoaXZlLiBJZiB0aGVyZSBpcyBhbnksIGV2ZXJ5dGhpbmcgaXMgdW5kZXIgYSBzaW5nbGUgZGlyZWN0b3J5LFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHN0cmlwIGl0LlxuICAgIC8vXG4gICAgLy8gQWRkaXRpb25hbGx5LCB3ZSBuZWVkIHRvIHRha2UgaW50byBhY2NvdW50IHRoYXQgcGF0aHMgbWlnaHQgYmUgcHJlZml4ZWQgd2l0aCBgLi9gIG9yIG5vdC5cbiAgICAvLyBUaHVzLCB3ZSBuZWVkIHRvIGFkanVzdCB0aGUgbnVtYmVyIG9mIHBhdGggY29tcG9uZW50cyB0byBzdHJpcCBhY2NvcmRpbmdseS5cblxuICAgIGxvZ2dlci5sb2coYEV4dHJhY3RpbmcgYnVuZGxlOiAnJHtidW5kbGVQYXRofScgLT4gJyR7dGFyZ2V0UGF0aH0nLmApXG5cbiAgICAvLyBTdHJpcCB0cmFpbGluZyBzZXBhcmF0b3IgYW5kIHNwbGl0IHRoZSBwYXRoIGludG8gcGllY2VzLlxuICAgIGNvbnN0IHJvb3RQaWVjZXMgPSBidW5kbGVQcmVmaXggIT0gbnVsbCA/IGJ1bmRsZVByZWZpeC5zcGxpdCgvW1xcXFwvXS8pIDogW11cblxuICAgIC8vIElmIHRoZSBsYXN0IGVsZW1lbnQgaXMgZW1wdHkgc3RyaW5nIChpLmUuIHdlIGhhZCB0cmFpbGluZyBzZXBhcmF0b3IpLCBkcm9wIGl0LlxuICAgIGlmIChyb290UGllY2VzLmxlbmd0aCA+IDAgJiYgcm9vdFBpZWNlc1tyb290UGllY2VzLmxlbmd0aCAtIDFdID09PSAnJykge1xuICAgICAgICByb290UGllY2VzLnBvcCgpXG4gICAgfVxuXG4gICAgdGFyLmV4dHJhY3Qoe1xuICAgICAgICBmaWxlOiBidW5kbGVQYXRoLFxuICAgICAgICBjd2Q6IHRhcmdldFBhdGgsXG4gICAgICAgIHN5bmM6IHRydWUsXG4gICAgICAgIHN0cmlwOiByb290UGllY2VzLmxlbmd0aCxcbiAgICB9KVxuICAgIHJldHVybiBidW1wTWV0YWRhdGEodGFyZ2V0UGF0aCwgbmFtZSA/PyBudWxsKVxufVxuXG4vKiogVXBsb2FkIHRoZSBwcm9qZWN0IGZyb20gYSBidW5kbGUuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBsb2FkQnVuZGxlKFxuICAgIGJ1bmRsZTogc3RyZWFtLlJlYWRhYmxlLFxuICAgIGRpcmVjdG9yeT86IHN0cmluZyB8IG51bGwsXG4gICAgbmFtZTogc3RyaW5nIHwgbnVsbCA9IG51bGxcbik6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgZGlyZWN0b3J5ID8/PSBnZXRQcm9qZWN0c0RpcmVjdG9yeSgpXG4gICAgbG9nZ2VyLmxvZyhgVXBsb2FkaW5nIHByb2plY3QgZnJvbSBidW5kbGUke25hbWUgIT0gbnVsbCA/IGAgYXMgJyR7bmFtZX0nYCA6ICcnfS5gKVxuICAgIGNvbnN0IHRhcmdldFBhdGggPSBnZW5lcmF0ZURpcmVjdG9yeU5hbWUobmFtZSA/PyAnUHJvamVjdCcsIGRpcmVjdG9yeSlcbiAgICBmcy5ta2RpclN5bmModGFyZ2V0UGF0aCwgeyByZWN1cnNpdmU6IHRydWUgfSlcbiAgICBhd2FpdCBuZXcgUHJvbWlzZTx2b2lkPihyZXNvbHZlID0+IHtcbiAgICAgICAgYnVuZGxlLnBpcGUodGFyLmV4dHJhY3QoeyBjd2Q6IHRhcmdldFBhdGggfSkpLm9uKCdmaW5pc2gnLCByZXNvbHZlKVxuICAgIH0pXG4gICAgY29uc3QgZW50cmllcyA9IGZzLnJlYWRkaXJTeW5jKHRhcmdldFBhdGgpXG4gICAgY29uc3QgZmlyc3RFbnRyeSA9IGVudHJpZXNbMF1cbiAgICAvLyBJZiB0aGUgZGlyZWN0b3J5IG9ubHkgY29udGFpbnMgb25lIHN1YmRpcmVjdG9yeSwgcmVwbGFjZSB0aGUgZGlyZWN0b3J5IHdpdGggaXRzIHNvbGVcbiAgICAvLyBzdWJkaXJlY3RvcnkuXG4gICAgaWYgKGVudHJpZXMubGVuZ3RoID09PSAxICYmIGZpcnN0RW50cnkgIT0gbnVsbCkge1xuICAgICAgICBpZiAoZnMuc3RhdFN5bmMocGF0aE1vZHVsZS5qb2luKHRhcmdldFBhdGgsIGZpcnN0RW50cnkpKS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICBjb25zdCB0ZW1wb3JhcnlEaXJlY3RvcnlOYW1lID1cbiAgICAgICAgICAgICAgICB0YXJnZXRQYXRoICsgYF8ke2NyeXB0by5yYW5kb21VVUlEKCkuc3BsaXQoJy0nKVswXSA/PyAnJ31gXG4gICAgICAgICAgICBmcy5yZW5hbWVTeW5jKHRhcmdldFBhdGgsIHRlbXBvcmFyeURpcmVjdG9yeU5hbWUpXG4gICAgICAgICAgICBmcy5yZW5hbWVTeW5jKHBhdGhNb2R1bGUuam9pbih0ZW1wb3JhcnlEaXJlY3RvcnlOYW1lLCBmaXJzdEVudHJ5KSwgdGFyZ2V0UGF0aClcbiAgICAgICAgICAgIGZzLnJtZGlyU3luYyh0ZW1wb3JhcnlEaXJlY3RvcnlOYW1lKVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBidW1wTWV0YWRhdGEodGFyZ2V0UGF0aCwgbmFtZSA/PyBudWxsKVxufVxuXG4vKiogSW1wb3J0IHRoZSBwcm9qZWN0IHNvIGl0IGJlY29tZXMgdmlzaWJsZSB0byB0aGUgUHJvamVjdCBNYW5hZ2VyLlxuICogQHJldHVybnMgVGhlIHByb2plY3QgSUQgKGZyb20gdGhlIFByb2plY3QgTWFuYWdlcidzIG1ldGFkYXRhKSBpZGVudGlmeWluZyB0aGUgaW1wb3J0ZWQgcHJvamVjdC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBhIHJhY2UgY29uZGl0aW9uIG9jY3VycyB3aGVuIGdlbmVyYXRpbmcgYSB1bmlxdWUgcHJvamVjdCBkaXJlY3RvcnkgbmFtZS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbXBvcnREaXJlY3RvcnkoXG4gICAgcm9vdFBhdGg6IHN0cmluZyxcbiAgICBkaXJlY3Rvcnk/OiBzdHJpbmcgfCBudWxsLFxuICAgIG5hbWU6IHN0cmluZyB8IG51bGwgPSBudWxsXG4pOiBzdHJpbmcge1xuICAgIGRpcmVjdG9yeSA/Pz0gZ2V0UHJvamVjdHNEaXJlY3RvcnkoKVxuICAgIGlmIChpc1Byb2plY3RJbnN0YWxsZWQocm9vdFBhdGgsIGRpcmVjdG9yeSkpIHtcbiAgICAgICAgLy8gUHJvamVjdCBpcyBhbHJlYWR5IHZpc2libGUgdG8gUHJvamVjdCBNYW5hZ2VyLCBzbyB3ZSBjYW4ganVzdCByZXR1cm4gaXRzIElELlxuICAgICAgICBsb2dnZXIubG9nKGBQcm9qZWN0IGFscmVhZHkgaW5zdGFsbGVkIGF0ICcke3Jvb3RQYXRofScuYClcbiAgICAgICAgY29uc3QgaWQgPSBnZXRQcm9qZWN0SWQocm9vdFBhdGgpXG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gaWRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvamVjdCBhbHJlYWR5IGluc3RhbGxlZCwgYnV0IG1pc3NpbmcgbWV0YWRhdGEuYClcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci5sb2coXG4gICAgICAgICAgICBgSW1wb3J0aW5nIGEgcHJvamVjdCBjb3B5IGZyb20gJyR7cm9vdFBhdGh9JyR7bmFtZSAhPSBudWxsID8gYCBhcyAnJHtuYW1lfSdgIDogJyd9LmBcbiAgICAgICAgKVxuICAgICAgICBjb25zdCB0YXJnZXRQYXRoID0gZ2VuZXJhdGVEaXJlY3RvcnlOYW1lKHJvb3RQYXRoLCBkaXJlY3RvcnkpXG4gICAgICAgIGlmIChmcy5leGlzdHNTeW5jKHRhcmdldFBhdGgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb2plY3QgZGlyZWN0b3J5ICcke3RhcmdldFBhdGh9JyBhbHJlYWR5IGV4aXN0cy5gKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgQ29weWluZzogJyR7cm9vdFBhdGh9JyAtPiAnJHt0YXJnZXRQYXRofScuYClcbiAgICAgICAgICAgIGZzLmNwU3luYyhyb290UGF0aCwgdGFyZ2V0UGF0aCwgeyByZWN1cnNpdmU6IHRydWUgfSlcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcHJvamVjdCBJRCwgc28gd2UgYXJlIGNlcnRhaW4gdGhhdCBpdCBpcyB1bmlxdWUuXG4gICAgICAgICAgICAvLyBUaGlzIHdvdWxkIGJlIHZpb2xhdGVkLCBpZiB3ZSBpbXBvcnRlZCB0aGUgc2FtZSBwcm9qZWN0IG11bHRpcGxlIHRpbWVzLlxuICAgICAgICAgICAgcmV0dXJuIGJ1bXBNZXRhZGF0YSh0YXJnZXRQYXRoLCBuYW1lID8/IG51bGwpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT1cbi8vID09PSBNZXRhZGF0YSA9PT1cbi8vID09PT09PT09PT09PT09PT1cblxuLyoqIFRoZSBQcm9qZWN0IE1hbmFnZXIncyBtZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggYSBwcm9qZWN0LiAqL1xuaW50ZXJmYWNlIFByb2plY3RNZXRhZGF0YSB7XG4gICAgLyoqIFRoZSBJRCBvZiB0aGUgcHJvamVjdC4gSXQgaXMgb25seSB1c2VkIGluIGNvbW11bmljYXRpb24gd2l0aCBwcm9qZWN0IG1hbmFnZXI7XG4gICAgICogaXQgaGFzIG5vIHNlbWFudGljIG1lYW5pbmcuICovXG4gICAgcmVhZG9ubHkgaWQ6IHN0cmluZ1xuICAgIC8qKiBUaGUgcHJvamVjdCB2YXJpYW50LiBUaGlzIGlzIGN1cnJlbnRseSBhbHdheXMgYFVzZXJQcm9qZWN0YC4gKi9cbiAgICByZWFkb25seSBraW5kOiAnVXNlclByb2plY3QnXG4gICAgLyoqIFRoZSBkYXRlIGF0IHdoaWNoIHRoZSBwcm9qZWN0IHdhcyBjcmVhdGVkLCBpbiBSRkMzMzM5IGZvcm1hdC4gKi9cbiAgICByZWFkb25seSBjcmVhdGVkOiBzdHJpbmdcbiAgICAvKiogVGhlIGRhdGUgYXQgd2hpY2ggdGhlIHByb2plY3Qgd2FzIGxhc3Qgb3BlbmVkLCBpbiBSRkMzMzM5IGZvcm1hdC4gKi9cbiAgICByZWFkb25seSBsYXN0T3BlbmVkOiBzdHJpbmdcbn1cblxuLyoqIEEgdHlwZSBndWFyZCBmdW5jdGlvbiB0byBjaGVjayBpZiBhbiBvYmplY3QgY29uZm9ybXMgdG8gdGhlIHtAbGluayBQcm9qZWN0TWV0YWRhdGF9IGludGVyZmFjZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGNoZWNrcyBpZiB0aGUgaW5wdXQgb2JqZWN0IGhhcyB0aGUgcmVxdWlyZWQgcHJvcGVydGllcyBhbmQgY29ycmVjdCB0eXBlc1xuICogdG8gbWF0Y2ggdGhlIHtAbGluayBQcm9qZWN0TWV0YWRhdGF9IGludGVyZmFjZS4gSXQgY2FuIGJlIHVzZWQgYXQgcnVudGltZSB0byB2YWxpZGF0ZSB0aGF0XG4gKiBhIGdpdmVuIG9iamVjdCBoYXMgdGhlIGV4cGVjdGVkIHNoYXBlLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIG9iamVjdCB0byBjaGVjayBhZ2FpbnN0IHRoZSBQcm9qZWN0TWV0YWRhdGEgaW50ZXJmYWNlLlxuICogQHJldHVybnMgQSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgb2JqZWN0IG1hdGNoZXNcbiAqIHRoZSB7QGxpbmsgUHJvamVjdE1ldGFkYXRhfSBpbnRlcmZhY2UuICovXG5mdW5jdGlvbiBpc1Byb2plY3RNZXRhZGF0YSh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIFByb2plY3RNZXRhZGF0YSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPSBudWxsICYmICdpZCcgaW4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLmlkID09PSAnc3RyaW5nJ1xuICAgIClcbn1cblxuLyoqIEdldCB0aGUgSUQgZnJvbSB0aGUgcHJvamVjdCBtZXRhZGF0YS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcm9qZWN0SWQocHJvamVjdFJvb3Q6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICAgIHJldHVybiBnZXRNZXRhZGF0YShwcm9qZWN0Um9vdCk/LmlkID8/IG51bGxcbn1cblxuLyoqIFVwZGF0ZSB0aGUgcGFja2FnZSBuYW1lLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVBhY2thZ2VOYW1lKHByb2plY3RSb290OiBzdHJpbmcsIG5hbWU6IHN0cmluZykge1xuICAgIGNvbnN0IHBhdGggPSBwYXRoTW9kdWxlLmpvaW4ocHJvamVjdFJvb3QsIFBBQ0tBR0VfTUVUQURBVEFfUkVMQVRJVkVfUEFUSClcbiAgICBjb25zdCBjb250ZW50cyA9IGZzLnJlYWRGaWxlU3luYyhwYXRoLCB7IGVuY29kaW5nOiAndXRmLTgnIH0pXG4gICAgY29uc3QgbmV3Q29udGVudHMgPSBjb250ZW50cy5yZXBsYWNlKC9ebmFtZTogLiovLCBgbmFtZTogJHtuYW1lfWApXG4gICAgZnMud3JpdGVGaWxlU3luYyhwYXRoLCBuZXdDb250ZW50cylcbn1cblxuLyoqIENyZWF0ZSBhIHByb2plY3QncyBtZXRhZGF0YS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNZXRhZGF0YSgpOiBQcm9qZWN0TWV0YWRhdGEge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBnZW5lcmF0ZUlkKCksXG4gICAgICAgIGtpbmQ6ICdVc2VyUHJvamVjdCcsXG4gICAgICAgIGNyZWF0ZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgbGFzdE9wZW5lZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIH1cbn1cblxuLyoqIFJldHJpZXZlIHRoZSBwcm9qZWN0J3MgbWV0YWRhdGEuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWV0YWRhdGEocHJvamVjdFJvb3Q6IHN0cmluZyk6IFByb2plY3RNZXRhZGF0YSB8IG51bGwge1xuICAgIGNvbnN0IG1ldGFkYXRhUGF0aCA9IHBhdGhNb2R1bGUuam9pbihwcm9qZWN0Um9vdCwgUFJPSkVDVF9NRVRBREFUQV9SRUxBVElWRV9QQVRIKVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGpzb25UZXh0ID0gZnMucmVhZEZpbGVTeW5jKG1ldGFkYXRhUGF0aCwgJ3V0ZjgnKVxuICAgICAgICBjb25zdCBtZXRhZGF0YTogdW5rbm93biA9IEpTT04ucGFyc2UoanNvblRleHQpXG4gICAgICAgIHJldHVybiBpc1Byb2plY3RNZXRhZGF0YShtZXRhZGF0YSkgPyBtZXRhZGF0YSA6IG51bGxcbiAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG59XG5cbi8qKiBXcml0ZSB0aGUgcHJvamVjdCdzIG1ldGFkYXRhLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyaXRlTWV0YWRhdGEocHJvamVjdFJvb3Q6IHN0cmluZywgbWV0YWRhdGE6IFByb2plY3RNZXRhZGF0YSk6IHZvaWQge1xuICAgIGNvbnN0IG1ldGFkYXRhUGF0aCA9IHBhdGhNb2R1bGUuam9pbihwcm9qZWN0Um9vdCwgUFJPSkVDVF9NRVRBREFUQV9SRUxBVElWRV9QQVRIKVxuICAgIGZzLm1rZGlyU3luYyhwYXRoTW9kdWxlLmRpcm5hbWUobWV0YWRhdGFQYXRoKSwgeyByZWN1cnNpdmU6IHRydWUgfSlcbiAgICBmcy53cml0ZUZpbGVTeW5jKG1ldGFkYXRhUGF0aCwgSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEsIG51bGwsIGJ1aWxkVXRpbHMuSU5ERU5UX1NJWkUpKVxufVxuXG4vKiogVXBkYXRlIHRoZSBwcm9qZWN0J3MgbWV0YWRhdGEuXG4gKiBJZiB0aGUgcHJvdmlkZWQgdXBkYXRlciBkb2VzIG5vdCByZXR1cm4gYW55dGhpbmcsIHRoZSBtZXRhZGF0YSBmaWxlIGlzIGxlZnQgaW50YWN0LlxuICpcbiAqIFJldHVybnMgdGhlIG1ldGFkYXRhIHJldHVybmVkIGZyb20gdGhlIHVwZGF0ZXIgZnVuY3Rpb24uICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlTWV0YWRhdGEoXG4gICAgcHJvamVjdFJvb3Q6IHN0cmluZyxcbiAgICB1cGRhdGVyOiAoaW5pdGlhbE1ldGFkYXRhOiBQcm9qZWN0TWV0YWRhdGEpID0+IFByb2plY3RNZXRhZGF0YVxuKTogUHJvamVjdE1ldGFkYXRhIHtcbiAgICBjb25zdCBtZXRhZGF0YSA9IGdldE1ldGFkYXRhKHByb2plY3RSb290KVxuICAgIGNvbnN0IHVwZGF0ZWRNZXRhZGF0YSA9IHVwZGF0ZXIobWV0YWRhdGEgPz8gY3JlYXRlTWV0YWRhdGEoKSlcbiAgICB3cml0ZU1ldGFkYXRhKHByb2plY3RSb290LCB1cGRhdGVkTWV0YWRhdGEpXG4gICAgcmV0dXJuIHVwZGF0ZWRNZXRhZGF0YVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyA9PT0gUHJvamVjdCBEaXJlY3RvcnkgPT09XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKiBDaGVjayBpZiB0aGUgZ2l2ZW4gcGF0aCByZXByZXNlbnRzIHRoZSByb290IG9mIGFuIEVuc28gcHJvamVjdC5cbiAqIFRoaXMgaXMgZGVjaWRlZCBieSB0aGUgcHJlc2VuY2Ugb2YgdGhlIFByb2plY3QgTWFuYWdlcidzIG1ldGFkYXRhLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUHJvamVjdFJvb3QoY2FuZGlkYXRlUGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3QgcHJvamVjdEpzb25QYXRoID0gcGF0aE1vZHVsZS5qb2luKGNhbmRpZGF0ZVBhdGgsIFBST0pFQ1RfTUVUQURBVEFfUkVMQVRJVkVfUEFUSClcbiAgICB0cnkge1xuICAgICAgICBmcy5hY2Nlc3NTeW5jKHByb2plY3RKc29uUGF0aCwgZnMuY29uc3RhbnRzLlJfT0spXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfSBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbn1cblxuLyoqIENoZWNrIGlmIHRoaXMgYnVuZGxlIGlzIGEgY29tcHJlc3NlZCBkaXJlY3RvcnkgKHJhdGhlciB0aGFuIGRpcmVjdGx5IGNvbnRhaW5pbmcgdGhlIHByb2plY3RcbiAqIGZpbGVzKS4gSWYgaXQgaXMsIHdlIHJldHVybiB0aGUgcGF0aCB0byB0aGUgZGlyZWN0b3J5LiBPdGhlcndpc2UsIHdlIHJldHVybiBgbnVsbGAuICovXG5leHBvcnQgZnVuY3Rpb24gcHJlZml4SW5CdW5kbGUoYnVuZGxlUGF0aDogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgLy8gV2UgbmVlZCB0byBsb29rIHVwIHRoZSByb290IGRpcmVjdG9yeSBhbW9uZyB0aGUgdGFyYmFsbCBlbnRyaWVzLlxuICAgIGxldCBjb21tb25QcmVmaXg6IHN0cmluZyB8IG51bGwgPSBudWxsXG4gICAgdGFyLmxpc3Qoe1xuICAgICAgICBmaWxlOiBidW5kbGVQYXRoLFxuICAgICAgICBzeW5jOiB0cnVlLFxuICAgICAgICBvbmVudHJ5OiBlbnRyeSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gZW50cnkucGF0aFxuICAgICAgICAgICAgY29tbW9uUHJlZml4ID1cbiAgICAgICAgICAgICAgICBjb21tb25QcmVmaXggPT0gbnVsbCA/IHBhdGggOiBidWlsZFV0aWxzLmdldENvbW1vblByZWZpeChjb21tb25QcmVmaXgsIHBhdGgpXG4gICAgICAgIH0sXG4gICAgfSlcblxuICAgIC8vIEVTTGludCBkb2Vzbid0IGtub3cgdGhhdCBgY29tbW9uUHJlZml4YCBjYW4gYmUgbm90IGBudWxsYCBoZXJlIGR1ZSB0byB0aGUgYG9uZW50cnlgIGNhbGxiYWNrLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgcmV0dXJuIGNvbW1vblByZWZpeCAhPSBudWxsICYmIGNvbW1vblByZWZpeCAhPT0gJycgPyBjb21tb25QcmVmaXggOiBudWxsXG59XG5cbi8qKiBHZW5lcmF0ZSBhIG5hbWUgZm9yIGEgcHJvamVjdCB1c2luZyBnaXZlbiBiYXNlIHN0cmluZy4gQSBzdWZmaXggaXMgYWRkZWQgaWYgdGhlcmUgaXMgYVxuICogY29sbGlzaW9uLlxuICpcbiAqIEZvciBleGFtcGxlIGBOYW1lYCB3aWxsIGJlY29tZSBgTmFtZV8xYCBpZiB0aGVyZSdzIGFscmVhZHkgYSBkaXJlY3RvcnkgbmFtZWQgYE5hbWVgLlxuICogSWYgZ2l2ZW4gYSBuYW1lIGxpa2UgYE5hbWVfMWAgaXQgd2lsbCBiZWNvbWUgYE5hbWVfMmAgaWYgdGhlcmUgaXMgYWxyZWFkeSBhIGRpcmVjdG9yeSBuYW1lZFxuICogYE5hbWVfMWAuIElmIGEgcGF0aCBjb250YWluaW5nIG11bHRpcGxlIGNvbXBvbmVudHMgaXMgZ2l2ZW4sIG9ubHkgdGhlIGxhc3QgY29tcG9uZW50IGlzIHVzZWRcbiAqIGZvciB0aGUgbmFtZS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZURpcmVjdG9yeU5hbWUobmFtZTogc3RyaW5nLCBkaXJlY3RvcnkgPSBnZXRQcm9qZWN0c0RpcmVjdG9yeSgpKTogc3RyaW5nIHtcbiAgICAvLyBVc2Ugb25seSB0aGUgbGFzdCBwYXRoIGNvbXBvbmVudC5cbiAgICBuYW1lID0gcGF0aE1vZHVsZS5wYXJzZShuYW1lKS5uYW1lXG5cbiAgICAvLyBJZiB0aGUgbmFtZSBhbHJlYWR5IGNvbnNpc3RzIGEgc3VmZml4LCByZXVzZSBpdC5cbiAgICBjb25zdCBtYXRjaGVzID0gbmFtZS5tYXRjaCgvXiguKilfKFxcZCspJC8pXG4gICAgY29uc3QgaW5pdGlhbFN1ZmZpeCA9IC0xXG4gICAgbGV0IHN1ZmZpeCA9IGluaXRpYWxTdWZmaXhcbiAgICAvLyBNYXRjaGVzIHN0YXJ0IHdpdGggdGhlIHdob2xlIG1hdGNoLCBzbyB3ZSBuZWVkIHRvIHNraXAgaXQuIFRoZW4gY29tZSBvdXIgdHdvIGNhcHR1cmUgZ3JvdXBzLlxuICAgIGNvbnN0IFttYXRjaGVkTmFtZSwgbWF0Y2hlZFN1ZmZpeF0gPSBtYXRjaGVzPy5zbGljZSgxKSA/PyBbXVxuICAgIGlmICh0eXBlb2YgbWF0Y2hlZE5hbWUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBtYXRjaGVkU3VmZml4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBuYW1lID0gbWF0Y2hlZE5hbWVcbiAgICAgICAgc3VmZml4ID0gcGFyc2VJbnQobWF0Y2hlZFN1ZmZpeClcbiAgICB9XG5cbiAgICBsZXQgZmluYWxQYXRoOiBzdHJpbmdcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBzdWZmaXgrK1xuICAgICAgICBjb25zdCBuZXdOYW1lID0gYCR7bmFtZX0ke3N1ZmZpeCA9PT0gMCA/ICcnIDogYF8ke3N1ZmZpeH1gfWBcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlUGF0aCA9IHBhdGhNb2R1bGUuam9pbihkaXJlY3RvcnksIG5ld05hbWUpXG4gICAgICAgIGlmICghZnMuZXhpc3RzU3luYyhjYW5kaWRhdGVQYXRoKSkge1xuICAgICAgICAgICAgZmluYWxQYXRoID0gY2FuZGlkYXRlUGF0aFxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmluYWxQYXRoXG59XG5cbi8qKiBUYWtlIGEgcGF0aCB0byBhIGZpbGUsIHByZXN1bWFibHkgbG9jYXRlZCBpbiBhIHByb2plY3QncyBzdWJ0cmVlLlJldHVybnMgdGhlIHBhdGhcbiAqIHRvIHRoZSBwcm9qZWN0J3Mgcm9vdCBkaXJlY3Rvcnkgb3IgYG51bGxgIGlmIHRoZSBmaWxlIGlzIG5vdCBsb2NhdGVkIGluIGEgcHJvamVjdC4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcm9qZWN0Um9vdChzdWJ0cmVlUGF0aDogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgbGV0IGN1cnJlbnRQYXRoID0gc3VidHJlZVBhdGhcbiAgICB3aGlsZSAoIWlzUHJvamVjdFJvb3QoY3VycmVudFBhdGgpKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHBhdGhNb2R1bGUuZGlybmFtZShjdXJyZW50UGF0aClcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gY3VycmVudFBhdGgpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50UGF0aCA9IHBhcmVudFxuICAgIH1cbiAgICByZXR1cm4gY3VycmVudFBhdGhcbn1cblxuLyoqIEdldCB0aGUgZGlyZWN0b3J5IHRoYXQgc3RvcmVzIEVuc28gcHJvamVjdHMuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJvamVjdHNEaXJlY3RvcnkoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gcGF0aE1vZHVsZS5qb2luKG9zLmhvbWVkaXIoKSwgJ2Vuc28nLCAncHJvamVjdHMnKVxufVxuXG4vKiogQ2hlY2sgaWYgdGhlIGdpdmVuIHByb2plY3QgaXMgaW5zdGFsbGVkLCBpLmUuIGNhbiBiZSBvcGVuZWQgd2l0aCB0aGUgUHJvamVjdCBNYW5hZ2VyLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUHJvamVjdEluc3RhbGxlZChcbiAgICBwcm9qZWN0Um9vdDogc3RyaW5nLFxuICAgIGRpcmVjdG9yeSA9IGdldFByb2plY3RzRGlyZWN0b3J5KClcbik6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHByb2plY3RSb290UGFyZW50ID0gcGF0aE1vZHVsZS5kaXJuYW1lKHByb2plY3RSb290KVxuICAgIC8vIFNob3VsZCByZXNvbHZlIHN5bWxpbmtzIGFuZCByZWxhdGl2ZSBwYXRocy4gTm9ybWFsaXplIGJlZm9yZSBjb21wYXJpc29uLlxuICAgIHJldHVybiBwYXRoTW9kdWxlLnJlc29sdmUocHJvamVjdFJvb3RQYXJlbnQpID09PSBwYXRoTW9kdWxlLnJlc29sdmUoZGlyZWN0b3J5KVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT1cbi8vID09PSBQcm9qZWN0IElEID09PVxuLy8gPT09PT09PT09PT09PT09PT09XG5cbi8qKiBHZW5lcmF0ZSBhIHVuaXF1ZSBVVUlEIGZvciBhIHByb2plY3QuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVJZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBjcnlwdG8ucmFuZG9tVVVJRCgpXG59XG5cbi8qKiBVcGRhdGUgdGhlIHByb2plY3QncyBJRCB0byBhIG5ldywgdW5pcXVlIHZhbHVlLCBhbmQgaXRzIGxhc3Qgb3BlbmVkIGRhdGUgdG8gdGhlIGN1cnJlbnQgZGF0ZS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidW1wTWV0YWRhdGEocHJvamVjdFJvb3Q6IHN0cmluZywgbmFtZTogc3RyaW5nIHwgbnVsbCk6IHN0cmluZyB7XG4gICAgaWYgKG5hbWUgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVQYWNrYWdlTmFtZShwcm9qZWN0Um9vdCwgbmFtZSlcbiAgICB9XG4gICAgcmV0dXJuIHVwZGF0ZU1ldGFkYXRhKHByb2plY3RSb290LCBtZXRhZGF0YSA9PiAoe1xuICAgICAgICAuLi5tZXRhZGF0YSxcbiAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgbGFzdE9wZW5lZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIH0pKS5pZFxufVxuIiwgImNvbnN0IF9fdml0ZV9pbmplY3RlZF9vcmlnaW5hbF9kaXJuYW1lID0gXCJDOlxcXFxQcm9qZWN0c1xcXFxlbnNvXFxcXGVuc29cXFxcYXBwXFxcXGlkZS1kZXNrdG9wXFxcXGxpYlxcXFxwcm9qZWN0LW1hbmFnZXItc2hpbVxcXFxzcmNcIjtjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfZmlsZW5hbWUgPSBcIkM6XFxcXFByb2plY3RzXFxcXGVuc29cXFxcZW5zb1xcXFxhcHBcXFxcaWRlLWRlc2t0b3BcXFxcbGliXFxcXHByb2plY3QtbWFuYWdlci1zaGltXFxcXHNyY1xcXFxwcm9qZWN0TWFuYWdlclNoaW1NaWRkbGV3YXJlLnRzXCI7Y29uc3QgX192aXRlX2luamVjdGVkX29yaWdpbmFsX2ltcG9ydF9tZXRhX3VybCA9IFwiZmlsZTovLy9DOi9Qcm9qZWN0cy9lbnNvL2Vuc28vYXBwL2lkZS1kZXNrdG9wL2xpYi9wcm9qZWN0LW1hbmFnZXItc2hpbS9zcmMvcHJvamVjdE1hbmFnZXJTaGltTWlkZGxld2FyZS50c1wiOy8qKiBAZmlsZSBBIHNpbXBsZSBIVFRQIHNlcnZlciB3aGljaCBzZXJ2ZXMgYXBwbGljYXRpb24gZGF0YSB0byB0aGUgRWxlY3Ryb24gd2ViLXZpZXcuICovXG5cbmltcG9ydCAqIGFzIGZzIGZyb20gJ25vZGU6ZnMvcHJvbWlzZXMnXG5pbXBvcnQgKiBhcyBmc1N5bmMgZnJvbSAnbm9kZTpmcydcbmltcG9ydCB0eXBlICogYXMgaHR0cCBmcm9tICdub2RlOmh0dHAnXG5pbXBvcnQgKiBhcyBvcyBmcm9tICdub2RlOm9zJ1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdub2RlOnBhdGgnXG5cbmltcG9ydCAqIGFzIHRhciBmcm9tICd0YXInXG5pbXBvcnQgKiBhcyB5YW1sIGZyb20gJ3lhbWwnXG5cbmltcG9ydCAqIGFzIGNvbW1vbiBmcm9tICdlbnNvLWNvbW1vbidcbmltcG9ydCAqIGFzIHByb2plY3RNYW5hZ2VtZW50IGZyb20gJy4vcHJvamVjdE1hbmFnZW1lbnQnXG5cbi8vID09PT09PT09PT09PT09PT09XG4vLyA9PT0gQ29uc3RhbnRzID09PVxuLy8gPT09PT09PT09PT09PT09PT1cblxuY29uc3QgSFRUUF9TVEFUVVNfT0sgPSAyMDBcbmNvbnN0IEhUVFBfU1RBVFVTX0JBRF9SRVFVRVNUID0gNDAwXG5jb25zdCBIVFRQX1NUQVRVU19OT1RfRk9VTkQgPSA0MDRcbmNvbnN0IFBST0pFQ1RTX1JPT1RfRElSRUNUT1JZID0gcGF0aC5qb2luKG9zLmhvbWVkaXIoKSwgJ2Vuc28vcHJvamVjdHMnKVxuXG4vLyA9PT09PT09PT09PT09XG4vLyA9PT0gVHlwZXMgPT09XG4vLyA9PT09PT09PT09PT09XG5cbi8qKiBEZXRhaWxzIG9mIGEgcHJvamVjdC4gKi9cbmludGVyZmFjZSBQcm9qZWN0TWV0YWRhdGEge1xuICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgcHJvamVjdC4gKi9cbiAgICByZWFkb25seSBuYW1lOiBzdHJpbmdcbiAgICAvKiogVGhlIG5hbWVzcGFjZSBvZiB0aGUgcHJvamVjdC4gKi9cbiAgICByZWFkb25seSBuYW1lc3BhY2U6IHN0cmluZ1xuICAgIC8qKiBUaGUgcHJvamVjdCBpZC4gKi9cbiAgICByZWFkb25seSBpZDogc3RyaW5nXG4gICAgLyoqIFRoZSBFbnNvIEVuZ2luZSB2ZXJzaW9uIHRvIHVzZSBmb3IgdGhlIHByb2plY3QsIHJlcHJlc2VudGVkIGJ5IGEgc2VtdmVyIHZlcnNpb25cbiAgICAgKiBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgZWRpdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIHByb2plY3QgY291bGQgbm90IGJlIHJlc29sdmVkLCB0aGVcbiAgICAgKiBlbmdpbmUgdmVyc2lvbiBtYXkgYmUgbWlzc2luZy4gKi9cbiAgICByZWFkb25seSBlbmdpbmVWZXJzaW9uPzogc3RyaW5nXG4gICAgLyoqIFRoZSBwcm9qZWN0IGNyZWF0aW9uIHRpbWUuICovXG4gICAgcmVhZG9ubHkgY3JlYXRlZDogc3RyaW5nXG4gICAgLyoqIFRoZSBsYXN0IG9wZW5lZCBkYXRldGltZS4gKi9cbiAgICByZWFkb25seSBsYXN0T3BlbmVkPzogc3RyaW5nXG59XG5cbi8qKiBBdHRyaWJ1dGVzIG9mIGEgZmlsZSBvciBmb2xkZXIuICovXG5pbnRlcmZhY2UgQXR0cmlidXRlcyB7XG4gICAgcmVhZG9ubHkgY3JlYXRpb25UaW1lOiBzdHJpbmdcbiAgICByZWFkb25seSBsYXN0QWNjZXNzVGltZTogc3RyaW5nXG4gICAgcmVhZG9ubHkgbGFzdE1vZGlmaWVkVGltZTogc3RyaW5nXG4gICAgcmVhZG9ubHkgYnl0ZVNpemU6IG51bWJlclxufVxuXG4vKiogTWV0YWRhdGEgZm9yIGFuIGFyYml0cmFyeSBmaWxlIHN5c3RlbSBlbnRyeS4gKi9cbnR5cGUgRmlsZVN5c3RlbUVudHJ5ID0gRGlyZWN0b3J5RW50cnkgfCBGaWxlRW50cnkgfCBQcm9qZWN0RW50cnlcblxuLyoqIFRoZSBkaXNjcmltaW5hdG9yIHZhbHVlIGZvciB7QGxpbmsgRmlsZVN5c3RlbUVudHJ5fS4gKi9cbmV4cG9ydCBlbnVtIEZpbGVTeXN0ZW1FbnRyeVR5cGUge1xuICAgIERpcmVjdG9yeUVudHJ5ID0gJ0RpcmVjdG9yeUVudHJ5JyxcbiAgICBQcm9qZWN0RW50cnkgPSAnUHJvamVjdEVudHJ5JyxcbiAgICBGaWxlRW50cnkgPSAnRmlsZUVudHJ5Jyxcbn1cblxuLyoqIE1ldGFkYXRhIGZvciBhIGZpbGUuICovXG5pbnRlcmZhY2UgRmlsZUVudHJ5IHtcbiAgICByZWFkb25seSB0eXBlOiBGaWxlU3lzdGVtRW50cnlUeXBlLkZpbGVFbnRyeVxuICAgIHJlYWRvbmx5IHBhdGg6IHN0cmluZ1xuICAgIHJlYWRvbmx5IGF0dHJpYnV0ZXM6IEF0dHJpYnV0ZXNcbn1cblxuLyoqIE1ldGFkYXRhIGZvciBhIGRpcmVjdG9yeS4gKi9cbmludGVyZmFjZSBEaXJlY3RvcnlFbnRyeSB7XG4gICAgcmVhZG9ubHkgdHlwZTogRmlsZVN5c3RlbUVudHJ5VHlwZS5EaXJlY3RvcnlFbnRyeVxuICAgIHJlYWRvbmx5IHBhdGg6IHN0cmluZ1xuICAgIHJlYWRvbmx5IGF0dHJpYnV0ZXM6IEF0dHJpYnV0ZXNcbn1cblxuLyoqIE1ldGFkYXRhIGZvciBhIHByb2plY3QuICovXG5pbnRlcmZhY2UgUHJvamVjdEVudHJ5IHtcbiAgICByZWFkb25seSB0eXBlOiBGaWxlU3lzdGVtRW50cnlUeXBlLlByb2plY3RFbnRyeVxuICAgIHJlYWRvbmx5IHBhdGg6IHN0cmluZ1xuICAgIHJlYWRvbmx5IG1ldGFkYXRhOiBQcm9qZWN0TWV0YWRhdGFcbiAgICByZWFkb25seSBhdHRyaWJ1dGVzOiBBdHRyaWJ1dGVzXG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT09IHByb2plY3RNYW5hZ2VyU2hpbU1pZGRsZXdhcmUgPT09XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqIEEgbWlkZGxld2FyZSB0aGF0IGhhbmRsZXMgICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwcm9qZWN0TWFuYWdlclNoaW1NaWRkbGV3YXJlKFxuICAgIHJlcXVlc3Q6IGh0dHAuSW5jb21pbmdNZXNzYWdlLFxuICAgIHJlc3BvbnNlOiBodHRwLlNlcnZlclJlc3BvbnNlLFxuICAgIG5leHQ6ICgpID0+IHZvaWRcbikge1xuICAgIGNvbnN0IHJlcXVlc3RVcmwgPSByZXF1ZXN0LnVybFxuICAgIGNvbnN0IHJlcXVlc3RQYXRoID0gcmVxdWVzdFVybD8uc3BsaXQoJz8nKVswXT8uc3BsaXQoJyMnKVswXVxuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gJ1BPU1QnKSB7XG4gICAgICAgIHN3aXRjaCAocmVxdWVzdFBhdGgpIHtcbiAgICAgICAgICAgIGNhc2UgJy9hcGkvdXBsb2FkLWZpbGUnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChgaHR0cHM6Ly9leGFtcGxlLmNvbS8ke3JlcXVlc3RVcmx9YClcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlTmFtZSA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0KCdmaWxlX25hbWUnKVxuICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdG9yeSA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0KCdkaXJlY3RvcnknKSA/PyBQUk9KRUNUU19ST09UX0RJUkVDVE9SWVxuICAgICAgICAgICAgICAgIGlmIChmaWxlTmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgICAgICAud3JpdGVIZWFkKEhUVFBfU1RBVFVTX0JBRF9SRVFVRVNULCBjb21tb24uQ09PUF9DT0VQX0NPUlBfSEVBREVSUylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5lbmQoJ1JlcXVlc3QgaXMgbWlzc2luZyBzZWFyY2ggcGFyYW1ldGVyIGBmaWxlX25hbWVgLicpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsZVBhdGggPSBwYXRoLmpvaW4oZGlyZWN0b3J5LCBmaWxlTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgdm9pZCBmc1xuICAgICAgICAgICAgICAgICAgICAgICAgLndyaXRlRmlsZShmaWxlUGF0aCwgcmVxdWVzdClcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAud3JpdGVIZWFkKEhUVFBfU1RBVFVTX09LLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbJ0NvbnRlbnQtTGVuZ3RoJywgU3RyaW5nKGZpbGVQYXRoLmxlbmd0aCldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWydDb250ZW50LVR5cGUnLCAndGV4dC9wbGFpbiddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uY29tbW9uLkNPT1BfQ09FUF9DT1JQX0hFQURFUlMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5lbmQoZmlsZVBhdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAud3JpdGVIZWFkKEhUVFBfU1RBVFVTX0JBRF9SRVFVRVNULCBjb21tb24uQ09PUF9DT0VQX0NPUlBfSEVBREVSUylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmVuZCgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhpcyBlbmRwb2ludCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4gYWNjZXNzaW5nIHRoZSBhcHAgZnJvbSB0aGUgYnJvd3Nlci5cbiAgICAgICAgICAgIC8vIFdoZW4gYWNjZXNzaW5nIHRoZSBhcHAgZnJvbSBFbGVjdHJvbiwgdGhlIGZpbGUgaW5wdXQgZXZlbnQgd2lsbCBoYXZlIHRoZVxuICAgICAgICAgICAgLy8gZnVsbCBzeXN0ZW0gcGF0aC5cbiAgICAgICAgICAgIGNhc2UgJy9hcGkvdXBsb2FkLXByb2plY3QnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChgaHR0cHM6Ly9leGFtcGxlLmNvbS8ke3JlcXVlc3RVcmx9YClcbiAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3RvcnkgPSB1cmwuc2VhcmNoUGFyYW1zLmdldCgnZGlyZWN0b3J5JylcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gdXJsLnNlYXJjaFBhcmFtcy5nZXQoJ25hbWUnKVxuICAgICAgICAgICAgICAgIHZvaWQgcHJvamVjdE1hbmFnZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgLnVwbG9hZEJ1bmRsZShyZXF1ZXN0LCBkaXJlY3RvcnksIG5hbWUpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGlkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLndyaXRlSGVhZChIVFRQX1NUQVRVU19PSywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbJ0NvbnRlbnQtTGVuZ3RoJywgU3RyaW5nKGlkLmxlbmd0aCldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbJ0NvbnRlbnQtVHlwZScsICd0ZXh0L3BsYWluJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNvbW1vbi5DT09QX0NPRVBfQ09SUF9IRUFERVJTLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmVuZChpZClcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLndyaXRlSGVhZChIVFRQX1NUQVRVU19CQURfUkVRVUVTVCwgY29tbW9uLkNPT1BfQ09FUF9DT1JQX0hFQURFUlMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmVuZCgpXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJy9hcGkvcnVuLXByb2plY3QtbWFuYWdlci1jb21tYW5kJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsaUFyZ3VtZW50czogdW5rbm93biA9IEpTT04ucGFyc2UoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBVUkwoYGh0dHBzOi8vZXhhbXBsZS5jb20vJHtyZXF1ZXN0VXJsfWApLnNlYXJjaFBhcmFtcy5nZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2xpLWFyZ3VtZW50cydcbiAgICAgICAgICAgICAgICAgICAgKSA/PyAnW10nXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkoY2xpQXJndW1lbnRzKSB8fFxuICAgICAgICAgICAgICAgICAgICAhY2xpQXJndW1lbnRzLmV2ZXJ5KChpdGVtKTogaXRlbSBpcyBzdHJpbmcgPT4gdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICAgICAgLndyaXRlSGVhZChIVFRQX1NUQVRVU19CQURfUkVRVUVTVCwgY29tbW9uLkNPT1BfQ09FUF9DT1JQX0hFQURFUlMpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZW5kKCdDb21tYW5kIGFyZ3VtZW50cyBtdXN0IGJlIGFuIGFycmF5IG9mIHN0cmluZ3MuJylcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2b2lkIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b0pTT05SUENSZXN1bHQgPSAocmVzdWx0OiB1bmtub3duKSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHsganNvbnJwYzogJzIuMCcsIGlkOiAwLCByZXN1bHQgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvSlNPTlJQQ0Vycm9yID0gKG1lc3NhZ2U6IHN0cmluZywgZGF0YT86IHVua25vd24pID0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiB7IGNvZGU6IDAsIG1lc3NhZ2UsIC4uLihkYXRhICE9IG51bGwgPyB7IGRhdGEgfSA6IHt9KSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gdG9KU09OUlBDRXJyb3IoYEVycm9yIHJ1bm5pbmcgUHJvamVjdCBNYW5hZ2VyIGNvbW1hbmQuYCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6IGNsaUFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2xpQXJndW1lbnRzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJy0tZmlsZXN5c3RlbS1saXN0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlyZWN0b3J5UGF0aCA9IGNsaUFyZ3VtZW50c1sxXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdG9yeVBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudHJ5TmFtZXMgPSBhd2FpdCBmcy5yZWFkZGlyKGRpcmVjdG9yeVBhdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW50cmllczogRmlsZVN5c3RlbUVudHJ5W10gPSBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnlOYW1lIG9mIGVudHJ5TmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW50cnlQYXRoID0gcGF0aC5qb2luKGRpcmVjdG9yeVBhdGgsIGVudHJ5TmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdCA9IGF3YWl0IGZzLnN0YXQoZW50cnlQYXRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzOiBBdHRyaWJ1dGVzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZVNpemU6IHN0YXQuc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0aW9uVGltZTogbmV3IERhdGUoc3RhdC5jdGltZU1zKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEFjY2Vzc1RpbWU6IG5ldyBEYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXQuYXRpbWVNc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE1vZGlmaWVkVGltZTogbmV3IERhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdC5tdGltZU1zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXQuaXNGaWxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJpZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogRmlsZVN5c3RlbUVudHJ5VHlwZS5GaWxlRW50cnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogZW50cnlQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IHNhdGlzZmllcyBGaWxlRW50cnkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhY2thZ2VNZXRhZGF0YVBhdGggPSBwYXRoLmpvaW4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5UGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3BhY2thZ2UueWFtbCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvamVjdE1ldGFkYXRhUGF0aCA9IHBhdGguam9pbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnlQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9qZWN0TWFuYWdlbWVudC5QUk9KRUNUX01FVEFEQVRBX1JFTEFUSVZFX1BBVEhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFja2FnZU1ldGFkYXRhQ29udGVudHMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBmcy5yZWFkRmlsZShwYWNrYWdlTWV0YWRhdGFQYXRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb2plY3RNZXRhZGF0YUNvbnRlbnRzID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgZnMucmVhZEZpbGUocHJvamVjdE1ldGFkYXRhUGF0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGV4dHJhY3RQcm9qZWN0TWV0YWRhdGEoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlhbWwucGFyc2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWNrYWdlTWV0YWRhdGFDb250ZW50cy50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEpTT04ucGFyc2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9qZWN0TWV0YWRhdGFDb250ZW50cy50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHByb2plY3QuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJpZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBGaWxlU3lzdGVtRW50cnlUeXBlLlByb2plY3RFbnRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGVudHJ5UGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBzYXRpc2ZpZXMgUHJvamVjdEVudHJ5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgZXJyb3IgbW92ZXMgY29udHJvbCBmbG93IHRvIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBgY2F0Y2hgIGNsYXVzZSBkaXJlY3RseSBiZWxvdy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcm9qZWN0IG1ldGFkYXRhLicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHJlZ3VsYXIgZGlyZWN0b3J5LCBub3QgYSBwcm9qZWN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJpZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEZpbGVTeXN0ZW1FbnRyeVR5cGUuRGlyZWN0b3J5RW50cnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGVudHJ5UGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IHNhdGlzZmllcyBEaXJlY3RvcnlFbnRyeSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0b0pTT05SUENSZXN1bHQoeyBlbnRyaWVzIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJy0tZmlsZXN5c3RlbS1jcmVhdGUtZGlyZWN0b3J5Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlyZWN0b3J5UGF0aCA9IGNsaUFyZ3VtZW50c1sxXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdG9yeVBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGZzLm1rZGlyKGRpcmVjdG9yeVBhdGgsIHsgcmVjdXJzaXZlOiB0cnVlIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdG9KU09OUlBDUmVzdWx0KG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJy0tZmlsZXN5c3RlbS13cml0ZS1wYXRoJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsZVBhdGggPSBjbGlBcmd1bWVudHNbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWxlUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucGlwZShmc1N5bmMuY3JlYXRlV3JpdGVTdHJlYW0oZmlsZVBhdGgpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5vbignY2xvc2UnLCByZXNvbHZlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm9uKCdlcnJvcicsIHJlamVjdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRvSlNPTlJQQ1Jlc3VsdChudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICctLWZpbGVzeXN0ZW0tbW92ZS1mcm9tJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc291cmNlUGF0aCA9IGNsaUFyZ3VtZW50c1sxXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVzdGluYXRpb25QYXRoID0gY2xpQXJndW1lbnRzWzNdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlUGF0aCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpQXJndW1lbnRzWzJdID09PSAnLS1maWxlc3lzdGVtLW1vdmUtdG8nICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb25QYXRoICE9IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGZzLnJlbmFtZShzb3VyY2VQYXRoLCBkZXN0aW5hdGlvblBhdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdG9KU09OUlBDUmVzdWx0KG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJy0tZmlsZXN5c3RlbS1kZWxldGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWxlT3JEaXJlY3RvcnlQYXRoID0gY2xpQXJndW1lbnRzWzFdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZU9yRGlyZWN0b3J5UGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgZnMucm0oZmlsZU9yRGlyZWN0b3J5UGF0aCwgeyByZWN1cnNpdmU6IHRydWUgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0b0pTT05SUENSZXN1bHQobnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlZC4gYHJlc3VsdGAgcmV0YWlucyBpdHMgb3JpZ2luYWwgdmFsdWUgaW5kaWNhdGluZyBhbiBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZWQuIGByZXN1bHRgIHJldGFpbnMgaXRzIG9yaWdpbmFsIHZhbHVlIGluZGljYXRpbmcgYW4gZXJyb3IuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShyZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC53cml0ZUhlYWQoSFRUUF9TVEFUVVNfT0ssIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWydDb250ZW50LUxlbmd0aCcsIFN0cmluZyhidWZmZXIuYnl0ZUxlbmd0aCldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNvbW1vbi5DT09QX0NPRVBfQ09SUF9IRUFERVJTLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmVuZChidWZmZXIpXG4gICAgICAgICAgICAgICAgICAgIH0pKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkb3dubG9hZFByb2plY3RNYXRjaCA9IHJlcXVlc3RQYXRoPy5tYXRjaChcbiAgICAgICAgICAgICAgICAgICAgL15bL11hcGlbL11wcm9qZWN0LW1hbmFnZXJbL11wcm9qZWN0c1svXShbXi9dKylbL11lbnNvLXByb2plY3QkL1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBpZiAoZG93bmxvYWRQcm9qZWN0TWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXVpZCA9IGRvd25sb2FkUHJvamVjdE1hdGNoWzFdXG4gICAgICAgICAgICAgICAgICAgIHZvaWQgZnMucmVhZGRpcihQUk9KRUNUU19ST09UX0RJUkVDVE9SWSkudGhlbihhc3luYyBmaWxlbmFtZXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN1Y2Nlc3MgPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBmaWxlbmFtZSBvZiBmaWxlbmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9qZWN0Um9vdCA9IHBhdGguam9pbihQUk9KRUNUU19ST09UX0RJUkVDVE9SWSwgZmlsZW5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXQgPSBhd2FpdCBmcy5zdGF0KHByb2plY3RSb290KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXRhZGF0YVBhdGggPSBwYXRoLmpvaW4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvamVjdFJvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvamVjdE1hbmFnZW1lbnQuUFJPSkVDVF9NRVRBREFUQV9SRUxBVElWRV9QQVRIXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXRhZGF0YUNvbnRlbnRzID0gYXdhaXQgZnMucmVhZEZpbGUobWV0YWRhdGFQYXRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWV0YWRhdGE6IHVua25vd24gPSBKU09OLnBhcnNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhQ29udGVudHMudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBtZXRhZGF0YSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJyBpbiBtZXRhZGF0YSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhLmlkID09PSB1dWlkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS53cml0ZUhlYWQoSFRUUF9TVEFUVVNfT0ssIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWydDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24vZ3ppcCt4LWVuc28tcHJvamVjdCddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5jb21tb24uQ09PUF9DT0VQX0NPUlBfSEVBREVSUyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhci5jcmVhdGUoeyBnemlwOiB0cnVlLCBjd2Q6IHByb2plY3RSb290IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvamVjdFJvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSkucGlwZShyZXNwb25zZSwgeyBlbmQ6IHRydWUgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAud3JpdGVIZWFkKEhUVFBfU1RBVFVTX05PVF9GT1VORCwgY29tbW9uLkNPT1BfQ09FUF9DT1JQX0hFQURFUlMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5lbmQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNwb25zZS53cml0ZUhlYWQoSFRUUF9TVEFUVVNfTk9UX0ZPVU5ELCBjb21tb24uQ09PUF9DT0VQX0NPUlBfSEVBREVSUykuZW5kKClcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gJ0dFVCcgJiYgcmVxdWVzdFBhdGggPT09ICcvYXBpL3Jvb3QtZGlyZWN0b3J5Jykge1xuICAgICAgICByZXNwb25zZVxuICAgICAgICAgICAgLndyaXRlSGVhZChIVFRQX1NUQVRVU19PSywgW1xuICAgICAgICAgICAgICAgIFsnQ29udGVudC1MZW5ndGgnLCBTdHJpbmcoUFJPSkVDVFNfUk9PVF9ESVJFQ1RPUlkubGVuZ3RoKV0sXG4gICAgICAgICAgICAgICAgWydDb250ZW50LVR5cGUnLCAndGV4dC9wbGFpbiddLFxuICAgICAgICAgICAgICAgIC4uLmNvbW1vbi5DT09QX0NPRVBfQ09SUF9IRUFERVJTLFxuICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIC5lbmQoUFJPSkVDVFNfUk9PVF9ESVJFQ1RPUlkpXG4gICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dCgpXG4gICAgfVxufVxuXG4vKiogUmV0dXJuIGEge0BsaW5rIFByb2plY3RNZXRhZGF0YX0gaWYgdGhlIG1ldGFkYXRhIGlzIGEgdmFsaWQgbWV0YWRhdGEgb2JqZWN0LFxuICogZWxzZSByZXR1cm4gYG51bGxgLiAqL1xuZnVuY3Rpb24gZXh0cmFjdFByb2plY3RNZXRhZGF0YSh5YW1sT2JqOiB1bmtub3duLCBqc29uT2JqOiB1bmtub3duKTogUHJvamVjdE1ldGFkYXRhIHwgbnVsbCB7XG4gICAgaWYgKFxuICAgICAgICB0eXBlb2YgeWFtbE9iaiAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgeWFtbE9iaiA9PSBudWxsIHx8XG4gICAgICAgIHR5cGVvZiBqc29uT2JqICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICBqc29uT2JqID09IG51bGxcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB2YWxpZERhdGVTdHJpbmcgPSAoc3RyaW5nOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShzdHJpbmcpXG4gICAgICAgICAgICByZXR1cm4gIU51bWJlci5pc05hTihOdW1iZXIoZGF0ZSkpID8gZGF0ZS50b1N0cmluZygpIDogbnVsbFxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWUgPSAnbmFtZScgaW4geWFtbE9iaiAmJiB0eXBlb2YgeWFtbE9iai5uYW1lID09PSAnc3RyaW5nJyA/IHlhbWxPYmoubmFtZSA6IG51bGxcbiAgICAgICAgY29uc3QgbmFtZXNwYWNlID1cbiAgICAgICAgICAgICduYW1lc3BhY2UnIGluIHlhbWxPYmogJiYgdHlwZW9mIHlhbWxPYmoubmFtZXNwYWNlID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgID8geWFtbE9iai5uYW1lc3BhY2VcbiAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgY29uc3QgZW5naW5lVmVyc2lvbiA9XG4gICAgICAgICAgICAnZWRpdGlvbicgaW4geWFtbE9iaiAmJiB0eXBlb2YgeWFtbE9iai5lZGl0aW9uID09PSAnc3RyaW5nJyA/IHlhbWxPYmouZWRpdGlvbiA6IG51bGxcbiAgICAgICAgY29uc3QgaWQgPSAnaWQnIGluIGpzb25PYmogJiYgdHlwZW9mIGpzb25PYmouaWQgPT09ICdzdHJpbmcnID8ganNvbk9iai5pZCA6IG51bGxcbiAgICAgICAgY29uc3QgY3JlYXRlZCA9XG4gICAgICAgICAgICAnY3JlYXRlZCcgaW4ganNvbk9iaiAmJiB0eXBlb2YganNvbk9iai5jcmVhdGVkID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgID8gdmFsaWREYXRlU3RyaW5nKGpzb25PYmouY3JlYXRlZClcbiAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgY29uc3QgbGFzdE9wZW5lZCA9XG4gICAgICAgICAgICAnbGFzdE9wZW5lZCcgaW4ganNvbk9iaiAmJiB0eXBlb2YganNvbk9iai5sYXN0T3BlbmVkID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgID8gdmFsaWREYXRlU3RyaW5nKGpzb25PYmoubGFzdE9wZW5lZClcbiAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgaWYgKG5hbWUgIT0gbnVsbCAmJiBuYW1lc3BhY2UgIT0gbnVsbCAmJiBpZCAhPSBudWxsICYmIGNyZWF0ZWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAuLi4oZW5naW5lVmVyc2lvbiAhPSBudWxsID8geyBlbmdpbmVWZXJzaW9uIH0gOiB7fSksXG4gICAgICAgICAgICAgICAgY3JlYXRlZCxcbiAgICAgICAgICAgICAgICAuLi4obGFzdE9wZW5lZCAhPSBudWxsID8geyBsYXN0T3BlbmVkIH0gOiB7fSksXG4gICAgICAgICAgICB9IHNhdGlzZmllcyBQcm9qZWN0TWV0YWRhdGFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cbiAgICB9XG59XG4iLCAiY29uc3QgX192aXRlX2luamVjdGVkX29yaWdpbmFsX2Rpcm5hbWUgPSBcIkM6XFxcXFByb2plY3RzXFxcXGVuc29cXFxcZW5zb1xcXFxhcHBcXFxcZ3VpMlwiO2NvbnN0IF9fdml0ZV9pbmplY3RlZF9vcmlnaW5hbF9maWxlbmFtZSA9IFwiQzpcXFxcUHJvamVjdHNcXFxcZW5zb1xcXFxlbnNvXFxcXGFwcFxcXFxndWkyXFxcXHZpdGVzdC5jb25maWcudHNcIjtjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfaW1wb3J0X21ldGFfdXJsID0gXCJmaWxlOi8vL0M6L1Byb2plY3RzL2Vuc28vZW5zby9hcHAvZ3VpMi92aXRlc3QuY29uZmlnLnRzXCI7aW1wb3J0IHsgZmlsZVVSTFRvUGF0aCB9IGZyb20gJ25vZGU6dXJsJ1xuaW1wb3J0IHsgY29uZmlnRGVmYXVsdHMsIGRlZmluZUNvbmZpZywgbWVyZ2VDb25maWcgfSBmcm9tICd2aXRlc3QvY29uZmlnJ1xuaW1wb3J0IHZpdGVDb25maWcgZnJvbSAnLi92aXRlLmNvbmZpZydcblxuZXhwb3J0IGRlZmF1bHQgbWVyZ2VDb25maWcoXG4gIHZpdGVDb25maWcsXG4gIGRlZmluZUNvbmZpZyh7XG4gICAgdGVzdDoge1xuICAgICAgZW52aXJvbm1lbnQ6ICdqc2RvbScsXG4gICAgICBpbmNsdWRlU291cmNlOiBbJy4ve3NyYyxzaGFyZWQseWRvYy1zZXJ2ZXJ9LyoqLyoue3RzLHZ1ZX0nXSxcbiAgICAgIGV4Y2x1ZGU6IFsuLi5jb25maWdEZWZhdWx0cy5leGNsdWRlLCAnZTJlLyonXSxcbiAgICAgIHJvb3Q6IGZpbGVVUkxUb1BhdGgobmV3IFVSTCgnLi8nLCBpbXBvcnQubWV0YS51cmwpKSxcbiAgICAgIHJlc3RvcmVNb2NrczogdHJ1ZSxcbiAgICB9LFxuICAgIGRlZmluZToge1xuICAgICAgUlVOTklOR19WSVRFU1Q6IHRydWUsXG4gICAgfSxcbiAgfSksXG4pXG4iLCAiY29uc3QgX192aXRlX2luamVjdGVkX29yaWdpbmFsX2Rpcm5hbWUgPSBcIkM6XFxcXFByb2plY3RzXFxcXGVuc29cXFxcZW5zb1xcXFxhcHBcXFxcZ3VpMlwiO2NvbnN0IF9fdml0ZV9pbmplY3RlZF9vcmlnaW5hbF9maWxlbmFtZSA9IFwiQzpcXFxcUHJvamVjdHNcXFxcZW5zb1xcXFxlbnNvXFxcXGFwcFxcXFxndWkyXFxcXHZpdGUuY29uZmlnLnRzXCI7Y29uc3QgX192aXRlX2luamVjdGVkX29yaWdpbmFsX2ltcG9ydF9tZXRhX3VybCA9IFwiZmlsZTovLy9DOi9Qcm9qZWN0cy9lbnNvL2Vuc28vYXBwL2d1aTIvdml0ZS5jb25maWcudHNcIjsvLy8gPHJlZmVyZW5jZSB0eXBlcz1cImhpc3RvaXJlXCIgLz5cblxuaW1wb3J0IHZ1ZSBmcm9tICdAdml0ZWpzL3BsdWdpbi12dWUnXG5pbXBvcnQgeyBnZXREZWZpbmVzLCByZWFkRW52aXJvbm1lbnRGcm9tRmlsZSB9IGZyb20gJ2Vuc28tY29tbW9uL3NyYy9hcHBDb25maWcnXG5pbXBvcnQgeyBmaWxlVVJMVG9QYXRoIH0gZnJvbSAnbm9kZTp1cmwnXG5pbXBvcnQgcG9zdGNzc05lc3RpbmcgZnJvbSAncG9zdGNzcy1uZXN0aW5nJ1xuaW1wb3J0IHRhaWx3aW5kY3NzIGZyb20gJ3RhaWx3aW5kY3NzJ1xuaW1wb3J0IHRhaWx3aW5kY3NzTmVzdGluZyBmcm9tICd0YWlsd2luZGNzcy9uZXN0aW5nJ1xuaW1wb3J0IHsgZGVmaW5lQ29uZmlnLCB0eXBlIFBsdWdpbiB9IGZyb20gJ3ZpdGUnXG4vLyBAdHMtZXhwZWN0LWVycm9yXG5pbXBvcnQgKiBhcyB0YWlsd2luZENvbmZpZyBmcm9tICdlbnNvLWRhc2hib2FyZC90YWlsd2luZC5jb25maWcnXG5pbXBvcnQgeyBjcmVhdGVHYXRld2F5U2VydmVyIH0gZnJvbSAnLi95ZG9jLXNlcnZlcidcbmNvbnN0IGxvY2FsU2VydmVyUG9ydCA9IDgwODBcbmNvbnN0IHByb2plY3RNYW5hZ2VyVXJsID0gJ3dzOi8vMTI3LjAuMC4xOjMwNTM1J1xuXG5jb25zdCBJU19DTE9VRF9CVUlMRCA9IHByb2Nlc3MuZW52LkNMT1VEX0JVSUxEID09PSAndHJ1ZSdcblxuYXdhaXQgcmVhZEVudmlyb25tZW50RnJvbUZpbGUoKVxuXG5jb25zdCBlbnRyeXBvaW50ID0gcHJvY2Vzcy5lbnYuRTJFID09PSAndHJ1ZScgPyAnLi9zcmMvZTJlLWVudHJ5cG9pbnQudHMnIDogJy4vc3JjL2VudHJ5cG9pbnQudHMnXG5cbi8vIGh0dHBzOi8vdml0ZWpzLmRldi9jb25maWcvXG5leHBvcnQgZGVmYXVsdCBkZWZpbmVDb25maWcoe1xuICByb290OiBmaWxlVVJMVG9QYXRoKG5ldyBVUkwoJy4nLCBpbXBvcnQubWV0YS51cmwpKSxcbiAgY2FjaGVEaXI6IGZpbGVVUkxUb1BhdGgobmV3IFVSTCgnLi4vLi4vbm9kZV9tb2R1bGVzLy5jYWNoZS92aXRlJywgaW1wb3J0Lm1ldGEudXJsKSksXG4gIHB1YmxpY0RpcjogZmlsZVVSTFRvUGF0aChuZXcgVVJMKCcuL3B1YmxpYycsIGltcG9ydC5tZXRhLnVybCkpLFxuICBlbnZEaXI6IGZpbGVVUkxUb1BhdGgobmV3IFVSTCgnLicsIGltcG9ydC5tZXRhLnVybCkpLFxuICBwbHVnaW5zOiBbXG4gICAgdnVlKCksXG4gICAgZ2F0ZXdheVNlcnZlcigpLFxuICAgIC4uLihwcm9jZXNzLmVudi5FTEVDVFJPTl9ERVZfTU9ERSA9PT0gJ3RydWUnID9cbiAgICAgIFtcbiAgICAgICAgKGF3YWl0IGltcG9ydCgnQHZpdGVqcy9wbHVnaW4tcmVhY3QnKSkuZGVmYXVsdCh7XG4gICAgICAgICAgaW5jbHVkZTogZmlsZVVSTFRvUGF0aChuZXcgVVJMKCcuLi9pZGUtZGVza3RvcC9saWIvZGFzaGJvYXJkLyoqLyoudHN4JywgaW1wb3J0Lm1ldGEudXJsKSksXG4gICAgICAgICAgYmFiZWw6IHsgcGx1Z2luczogWydAYmFiZWwvcGx1Z2luLXN5bnRheC1pbXBvcnQtYXNzZXJ0aW9ucyddIH0sXG4gICAgICAgIH0pLFxuICAgICAgXVxuICAgIDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyBbYXdhaXQgcHJvamVjdE1hbmFnZXJTaGltKCldXG4gICAgOiBbXSksXG4gIF0sXG4gIG9wdGltaXplRGVwczoge1xuICAgIGVudHJpZXM6IGZpbGVVUkxUb1BhdGgobmV3IFVSTCgnLi9pbmRleC5odG1sJywgaW1wb3J0Lm1ldGEudXJsKSksXG4gIH0sXG4gIHNlcnZlcjoge1xuICAgIHdhdGNoOiB7fSxcbiAgICBoZWFkZXJzOiB7XG4gICAgICAnQ3Jvc3MtT3JpZ2luLUVtYmVkZGVyLVBvbGljeSc6ICdyZXF1aXJlLWNvcnAnLFxuICAgICAgJ0Nyb3NzLU9yaWdpbi1PcGVuZXItUG9saWN5JzogJ3NhbWUtb3JpZ2luJyxcbiAgICAgICdDcm9zcy1PcmlnaW4tUmVzb3VyY2UtUG9saWN5JzogJ3NhbWUtb3JpZ2luJyxcbiAgICB9LFxuICB9LFxuICByZXNvbHZlOiB7XG4gICAgYWxpYXM6IHtcbiAgICAgICcvc3JjL2VudHJ5cG9pbnQudHMnOiBmaWxlVVJMVG9QYXRoKG5ldyBVUkwoZW50cnlwb2ludCwgaW1wb3J0Lm1ldGEudXJsKSksXG4gICAgICBzaGFyZWQ6IGZpbGVVUkxUb1BhdGgobmV3IFVSTCgnLi9zaGFyZWQnLCBpbXBvcnQubWV0YS51cmwpKSxcbiAgICAgICdAJzogZmlsZVVSTFRvUGF0aChuZXcgVVJMKCcuL3NyYycsIGltcG9ydC5tZXRhLnVybCkpLFxuICAgIH0sXG4gIH0sXG4gIGRlZmluZToge1xuICAgIC4uLmdldERlZmluZXMobG9jYWxTZXJ2ZXJQb3J0KSxcbiAgICBJU19DTE9VRF9CVUlMRDogSlNPTi5zdHJpbmdpZnkoSVNfQ0xPVURfQlVJTEQpLFxuICAgIFBST0pFQ1RfTUFOQUdFUl9VUkw6IEpTT04uc3RyaW5naWZ5KHByb2plY3RNYW5hZ2VyVXJsKSxcbiAgICBSVU5OSU5HX1ZJVEVTVDogZmFsc2UsXG4gICAgJ2ltcG9ydC5tZXRhLnZpdGVzdCc6IGZhbHNlLFxuICAgIC8vIFNpbmdsZSBoYXJkY29kZWQgdXNhZ2Ugb2YgYGdsb2JhbGAgaW4gYXdzLWFtcGxpZnkuXG4gICAgJ2dsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUJzogdHJ1ZSxcbiAgfSxcbiAgYXNzZXRzSW5jbHVkZTogWycqKi8qLnlhbWwnLCAnKiovKi5zdmcnXSxcbiAgY3NzOiB7XG4gICAgcG9zdGNzczoge1xuICAgICAgcGx1Z2luczogW1xuICAgICAgICB0YWlsd2luZGNzc05lc3RpbmcocG9zdGNzc05lc3RpbmcoKSksXG4gICAgICAgIHRhaWx3aW5kY3NzKHtcbiAgICAgICAgICAuLi50YWlsd2luZENvbmZpZy5kZWZhdWx0LFxuICAgICAgICAgIGNvbnRlbnQ6IHRhaWx3aW5kQ29uZmlnLmRlZmF1bHQuY29udGVudC5tYXAoKGdsb2I6IHN0cmluZykgPT5cbiAgICAgICAgICAgIGdsb2IucmVwbGFjZShcbiAgICAgICAgICAgICAgL15bLl1bL10vLFxuICAgICAgICAgICAgICBmaWxlVVJMVG9QYXRoKG5ldyBVUkwoJy4uL2lkZS1kZXNrdG9wL2xpYi9kYXNoYm9hcmQvJywgaW1wb3J0Lm1ldGEudXJsKSksXG4gICAgICAgICAgICApLFxuICAgICAgICAgICksXG4gICAgICAgIH0pLFxuICAgICAgXSxcbiAgICB9LFxuICB9LFxuICBidWlsZDoge1xuICAgIC8vIGRhc2hib2FyZCBjaHVuayBzaXplIGlzIGxhcmdlciB0aGFuIHRoZSBkZWZhdWx0IHdhcm5pbmcgbGltaXRcbiAgICBjaHVua1NpemVXYXJuaW5nTGltaXQ6IDcwMCxcbiAgICByb2xsdXBPcHRpb25zOiB7XG4gICAgICBvdXRwdXQ6IHtcbiAgICAgICAgbWFudWFsQ2h1bmtzOiB7XG4gICAgICAgICAgZm9udGF3ZXNvbWU6IFsnQGZvcnRhd2Vzb21lL3JlYWN0LWZvbnRhd2Vzb21lJywgJ0Bmb3J0YXdlc29tZS9mcmVlLWJyYW5kcy1zdmctaWNvbnMnXSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgfSxcbn0pXG5cbmZ1bmN0aW9uIGdhdGV3YXlTZXJ2ZXIoKTogUGx1Z2luIHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnZ2F0ZXdheS1zZXJ2ZXInLFxuICAgIGNvbmZpZ3VyZVNlcnZlcihzZXJ2ZXIpIHtcbiAgICAgIGlmIChzZXJ2ZXIuaHR0cFNlcnZlciA9PSBudWxsKSByZXR1cm5cblxuICAgICAgY3JlYXRlR2F0ZXdheVNlcnZlcihzZXJ2ZXIuaHR0cFNlcnZlciwgdW5kZWZpbmVkKVxuICAgIH0sXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcHJvamVjdE1hbmFnZXJTaGltKCk6IFByb21pc2U8UGx1Z2luPiB7XG4gIGNvbnN0IG1vZHVsZSA9IGF3YWl0IGltcG9ydChcbiAgICAnLi4vaWRlLWRlc2t0b3AvbGliL3Byb2plY3QtbWFuYWdlci1zaGltL3NyYy9wcm9qZWN0TWFuYWdlclNoaW1NaWRkbGV3YXJlJ1xuICApXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ3Byb2plY3QtbWFuYWdlci1zaGltJyxcbiAgICBjb25maWd1cmVTZXJ2ZXIoc2VydmVyKSB7XG4gICAgICBzZXJ2ZXIubWlkZGxld2FyZXMudXNlKG1vZHVsZS5kZWZhdWx0KVxuICAgIH0sXG4gIH1cbn1cbiIsICJjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfZGlybmFtZSA9IFwiQzpcXFxcUHJvamVjdHNcXFxcZW5zb1xcXFxlbnNvXFxcXGFwcFxcXFxndWkyXFxcXHlkb2Mtc2VydmVyXCI7Y29uc3QgX192aXRlX2luamVjdGVkX29yaWdpbmFsX2ZpbGVuYW1lID0gXCJDOlxcXFxQcm9qZWN0c1xcXFxlbnNvXFxcXGVuc29cXFxcYXBwXFxcXGd1aTJcXFxceWRvYy1zZXJ2ZXJcXFxcaW5kZXgudHNcIjtjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfaW1wb3J0X21ldGFfdXJsID0gXCJmaWxlOi8vL0M6L1Byb2plY3RzL2Vuc28vZW5zby9hcHAvZ3VpMi95ZG9jLXNlcnZlci9pbmRleC50c1wiOy8qKlxuICogQGZpbGUgQW4gZW50cnkgcG9pbnQgZm9yIHRoZSBZanMgZ2F0ZXdheSBzZXJ2ZXIuIFRoZSBnYXRld2F5IHNlcnZlciBpcyBhIFdlYlNvY2tldCBzZXJ2ZXIgdGhhdFxuICogc3luY2hyb25pemVzIGRvY3VtZW50IHJlcXVlc3RzIGFuZCB1cGRhdGVzIGJldHdlZW4gbGFuZ3VhZ2Ugc2VydmVyIGFuZCBjbGllbnRzIGNvbm5lY3RlZCB0byB0aGVcbiAqIFlqcyBkb2N1bWVudCBtZXNoLiBJdCBhbHNvIHNlcnZlcyBhcyBhIGNlbnRyYWwgcG9pbnQgZm9yIHN5bmNocm9uaXppbmcgZG9jdW1lbnQgZGF0YSBhbmRcbiAqIGF3YXJlbmVzcyB1cGRhdGVzIGJldHdlZW4gY2xpZW50cy5cbiAqXG4gKiBDdXJyZW50bHksIHRoaXMgc2VydmVyIGlzIGJlaW5nIHJ1biBhdXRvbWF0aWNhbGx5IGluIGJhY2tncm91bmQgYXMgcGFydCBvZiB0aGUgdml0ZSBkZXZlbG9wbWVudFxuICogc2VydmVyLiBJdCBpcyBub3QgeWV0IGRlcGxveWVkIHRvIGFueSBvdGhlciBlbnZpcm9ubWVudC5cbiAqL1xuXG5pbXBvcnQgeyBTZXJ2ZXIgfSBmcm9tICdodHRwJ1xuaW1wb3J0IHsgSW5jb21pbmdNZXNzYWdlIH0gZnJvbSAnbm9kZTpodHRwJ1xuaW1wb3J0IHsgcGFyc2UgfSBmcm9tICd1cmwnXG5pbXBvcnQgeyBXZWJTb2NrZXQsIFdlYlNvY2tldFNlcnZlciB9IGZyb20gJ3dzJ1xuaW1wb3J0IHsgaW5pdGlhbGl6ZUZGSSB9IGZyb20gJy4uL3NoYXJlZC9hc3QvZmZpJ1xuaW1wb3J0IHsgc2V0dXBHYXRld2F5Q2xpZW50IH0gZnJvbSAnLi95ZG9jJ1xuXG50eXBlIENvbm5lY3Rpb25EYXRhID0ge1xuICBsc1VybDogc3RyaW5nXG4gIGRvYzogc3RyaW5nXG4gIHVzZXI6IHN0cmluZ1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlR2F0ZXdheVNlcnZlcihodHRwU2VydmVyOiBTZXJ2ZXIsIHJ1c3RGRklQYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgYXdhaXQgaW5pdGlhbGl6ZUZGSShydXN0RkZJUGF0aClcbiAgY29uc3Qgd3NzID0gbmV3IFdlYlNvY2tldFNlcnZlcih7IG5vU2VydmVyOiB0cnVlIH0pXG4gIHdzcy5vbignY29ubmVjdGlvbicsICh3czogV2ViU29ja2V0LCBfcmVxdWVzdDogSW5jb21pbmdNZXNzYWdlLCBkYXRhOiBDb25uZWN0aW9uRGF0YSkgPT4ge1xuICAgIHdzLm9uKCdlcnJvcicsIG9uV2ViU29ja2V0RXJyb3IpXG4gICAgc2V0dXBHYXRld2F5Q2xpZW50KHdzLCBkYXRhLmxzVXJsLCBkYXRhLmRvYylcbiAgfSlcblxuICBodHRwU2VydmVyLm9uKCd1cGdyYWRlJywgKHJlcXVlc3QsIHNvY2tldCwgaGVhZCkgPT4ge1xuICAgIHNvY2tldC5vbignZXJyb3InLCBvbkh0dHBTb2NrZXRFcnJvcilcbiAgICBhdXRoZW50aWNhdGUocmVxdWVzdCwgZnVuY3Rpb24gbmV4dChlcnIsIGRhdGEpIHtcbiAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICBzb2NrZXQud3JpdGUoJ0hUVFAvMS4xIDQwMSBVbmF1dGhvcml6ZWRcXHJcXG5cXHJcXG4nKVxuICAgICAgICBzb2NrZXQuZGVzdHJveSgpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uSHR0cFNvY2tldEVycm9yKVxuICAgICAgaWYgKGRhdGEgIT0gbnVsbCkge1xuICAgICAgICB3c3MuaGFuZGxlVXBncmFkZShyZXF1ZXN0LCBzb2NrZXQsIGhlYWQsIGZ1bmN0aW9uIGRvbmUod3MpIHtcbiAgICAgICAgICB3c3MuZW1pdCgnY29ubmVjdGlvbicsIHdzLCByZXF1ZXN0LCBkYXRhKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIG9uV2ViU29ja2V0RXJyb3IoZXJyOiBFcnJvcikge1xuICBjb25zb2xlLmxvZygnV2ViU29ja2V0IGVycm9yOicsIGVycilcbn1cblxuZnVuY3Rpb24gb25IdHRwU29ja2V0RXJyb3IoZXJyOiBFcnJvcikge1xuICBjb25zb2xlLmxvZygnSFRUUCBzb2NrZXQgZXJyb3I6JywgZXJyKVxufVxuXG5mdW5jdGlvbiBhdXRoZW50aWNhdGUoXG4gIHJlcXVlc3Q6IEluY29taW5nTWVzc2FnZSxcbiAgY2FsbGJhY2s6IChlcnI6IEVycm9yIHwgbnVsbCwgYXV0aERhdGE6IENvbm5lY3Rpb25EYXRhIHwgbnVsbCkgPT4gdm9pZCxcbikge1xuICAvLyBGSVhNRTogU3R1Yi4gV2UgZG9uJ3QgaW1wbGVtZW50IGF1dGhlbnRpY2F0aW9uIGZvciBub3cuIE5lZWQgdG8gYmUgaW1wbGVtZW50ZWQgaW4gY29tYmluYXRpb25cbiAgLy8gd2l0aCB0aGUgbGFuZ3VhZ2Ugc2VydmVyLlxuICBjb25zdCB1c2VyID0gJ21vY2stdXNlcidcblxuICBpZiAocmVxdWVzdC51cmwgPT0gbnVsbCkgcmV0dXJuIGNhbGxiYWNrKG51bGwsIG51bGwpXG4gIGNvbnN0IHsgcGF0aG5hbWUsIHF1ZXJ5IH0gPSBwYXJzZShyZXF1ZXN0LnVybCwgdHJ1ZSlcbiAgaWYgKHBhdGhuYW1lID09IG51bGwpIHJldHVybiBjYWxsYmFjayhudWxsLCBudWxsKVxuICBjb25zdCBkb2MgPSBkb2NOYW1lKHBhdGhuYW1lKVxuICBjb25zdCBsc1VybCA9IHF1ZXJ5LmxzXG4gIGNvbnN0IGRhdGEgPSBkb2MgIT0gbnVsbCAmJiB0eXBlb2YgbHNVcmwgPT09ICdzdHJpbmcnID8geyBsc1VybCwgZG9jLCB1c2VyIH0gOiBudWxsXG4gIGNhbGxiYWNrKG51bGwsIGRhdGEpXG59XG5cbmNvbnN0IGRvY05hbWVSZWdleCA9IC9eW2EtejAtOS8tXSskL2lcbmZ1bmN0aW9uIGRvY05hbWUocGF0aG5hbWU6IHN0cmluZykge1xuICBjb25zdCBwcmVmaXggPSAnL3Byb2plY3QvJ1xuICBpZiAocGF0aG5hbWUgIT0gbnVsbCAmJiBwYXRobmFtZS5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICBjb25zdCBkb2NOYW1lID0gcGF0aG5hbWUuc2xpY2UocHJlZml4Lmxlbmd0aClcbiAgICBpZiAoZG9jTmFtZVJlZ2V4LnRlc3QoZG9jTmFtZSkpIHtcbiAgICAgIHJldHVybiBkb2NOYW1lXG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsXG59XG4iLCAiY29uc3QgX192aXRlX2luamVjdGVkX29yaWdpbmFsX2Rpcm5hbWUgPSBcIkM6XFxcXFByb2plY3RzXFxcXGVuc29cXFxcZW5zb1xcXFxhcHBcXFxcZ3VpMlxcXFxzaGFyZWRcXFxcYXN0XCI7Y29uc3QgX192aXRlX2luamVjdGVkX29yaWdpbmFsX2ZpbGVuYW1lID0gXCJDOlxcXFxQcm9qZWN0c1xcXFxlbnNvXFxcXGVuc29cXFxcYXBwXFxcXGd1aTJcXFxcc2hhcmVkXFxcXGFzdFxcXFxmZmkudHNcIjtjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfaW1wb3J0X21ldGFfdXJsID0gXCJmaWxlOi8vL0M6L1Byb2plY3RzL2Vuc28vZW5zby9hcHAvZ3VpMi9zaGFyZWQvYXN0L2ZmaS50c1wiO2ltcG9ydCB7IGNyZWF0ZVhYSGFzaDEyOCB9IGZyb20gJ2hhc2gtd2FzbSdcbmltcG9ydCB0eXBlIHsgSURhdGFUeXBlIH0gZnJvbSAnaGFzaC13YXNtL2Rpc3QvbGliL3V0aWwnXG5pbXBvcnQgaW5pdCwgeyBpc19pZGVudF9vcl9vcGVyYXRvciwgcGFyc2UsIHBhcnNlX2RvY190b19qc29uIH0gZnJvbSAnLi4vLi4vcnVzdC1mZmkvcGtnL3J1c3RfZmZpJ1xuaW1wb3J0IHsgYXNzZXJ0RGVmaW5lZCB9IGZyb20gJy4uL3V0aWwvYXNzZXJ0J1xuaW1wb3J0IHsgaXNOb2RlIH0gZnJvbSAnLi4vdXRpbC9kZXRlY3QnXG5cbmxldCB4eEhhc2hlcjEyODogQXdhaXRlZDxSZXR1cm5UeXBlPHR5cGVvZiBjcmVhdGVYWEhhc2gxMjg+PiB8IHVuZGVmaW5lZFxuZXhwb3J0IGZ1bmN0aW9uIHh4SGFzaDEyOChpbnB1dDogSURhdGFUeXBlKSB7XG4gIGFzc2VydERlZmluZWQoeHhIYXNoZXIxMjgsICdNb2R1bGUgc2hvdWxkIGhhdmUgYmVlbiBsb2FkZWQgd2l0aCBgaW5pdGlhbGl6ZUZGSWAuJylcbiAgeHhIYXNoZXIxMjguaW5pdCgpXG4gIHh4SGFzaGVyMTI4LnVwZGF0ZShpbnB1dClcbiAgcmV0dXJuIHh4SGFzaGVyMTI4LmRpZ2VzdCgpXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbml0aWFsaXplRkZJKHBhdGg/OiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgaWYgKGlzTm9kZSkge1xuICAgIGNvbnN0IGZzID0gYXdhaXQgaW1wb3J0KCdub2RlOmZzL3Byb21pc2VzJylcbiAgICBjb25zdCB7IGZpbGVVUkxUb1BhdGgsIFVSTDogbm9kZVVSTCB9ID0gYXdhaXQgaW1wb3J0KCdub2RlOnVybCcpXG4gICAgY29uc3QgYnVmZmVyID0gZnMucmVhZEZpbGUoXG4gICAgICBwYXRoID8/IGZpbGVVUkxUb1BhdGgobmV3IG5vZGVVUkwoJy4uLy4uL3J1c3QtZmZpL3BrZy9ydXN0X2ZmaV9iZy53YXNtJywgaW1wb3J0Lm1ldGEudXJsKSksXG4gICAgKVxuICAgIGF3YWl0IGluaXQoYnVmZmVyKVxuICB9IGVsc2Uge1xuICAgIGF3YWl0IGluaXQoKVxuICB9XG4gIHh4SGFzaGVyMTI4ID0gYXdhaXQgY3JlYXRlWFhIYXNoMTI4KClcbn1cblxuLy8gVE9ET1thb106IFdlIGNhbm5vdCB0byB0aGF0LCBiZWNhdXNlIHRoZSBmZmkgaXMgdXNlZCBieSBjanMgbW9kdWxlcy5cbi8vIGF3YWl0IGluaXRpYWxpemVGRkkoKVxuXG4vKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlICovXG5leHBvcnQgeyBpc19pZGVudF9vcl9vcGVyYXRvciwgcGFyc2VfZG9jX3RvX2pzb24sIHBhcnNlIGFzIHBhcnNlX3RyZWUgfVxuIiwgImNvbnN0IF9fdml0ZV9pbmplY3RlZF9vcmlnaW5hbF9kaXJuYW1lID0gXCJDOlxcXFxQcm9qZWN0c1xcXFxlbnNvXFxcXGVuc29cXFxcYXBwXFxcXGd1aTJcXFxccnVzdC1mZmlcXFxccGtnXCI7Y29uc3QgX192aXRlX2luamVjdGVkX29yaWdpbmFsX2ZpbGVuYW1lID0gXCJDOlxcXFxQcm9qZWN0c1xcXFxlbnNvXFxcXGVuc29cXFxcYXBwXFxcXGd1aTJcXFxccnVzdC1mZmlcXFxccGtnXFxcXHJ1c3RfZmZpLmpzXCI7Y29uc3QgX192aXRlX2luamVjdGVkX29yaWdpbmFsX2ltcG9ydF9tZXRhX3VybCA9IFwiZmlsZTovLy9DOi9Qcm9qZWN0cy9lbnNvL2Vuc28vYXBwL2d1aTIvcnVzdC1mZmkvcGtnL3J1c3RfZmZpLmpzXCI7bGV0IHdhc207XG5cbmNvbnN0IGhlYXAgPSBuZXcgQXJyYXkoMTI4KS5maWxsKHVuZGVmaW5lZCk7XG5cbmhlYXAucHVzaCh1bmRlZmluZWQsIG51bGwsIHRydWUsIGZhbHNlKTtcblxuZnVuY3Rpb24gZ2V0T2JqZWN0KGlkeCkgeyByZXR1cm4gaGVhcFtpZHhdOyB9XG5cbmxldCBoZWFwX25leHQgPSBoZWFwLmxlbmd0aDtcblxuZnVuY3Rpb24gZHJvcE9iamVjdChpZHgpIHtcbiAgICBpZiAoaWR4IDwgMTMyKSByZXR1cm47XG4gICAgaGVhcFtpZHhdID0gaGVhcF9uZXh0O1xuICAgIGhlYXBfbmV4dCA9IGlkeDtcbn1cblxuZnVuY3Rpb24gdGFrZU9iamVjdChpZHgpIHtcbiAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoaWR4KTtcbiAgICBkcm9wT2JqZWN0KGlkeCk7XG4gICAgcmV0dXJuIHJldDtcbn1cblxubGV0IFdBU01fVkVDVE9SX0xFTiA9IDA7XG5cbmxldCBjYWNoZWRVaW50OE1lbW9yeTAgPSBudWxsO1xuXG5mdW5jdGlvbiBnZXRVaW50OE1lbW9yeTAoKSB7XG4gICAgaWYgKGNhY2hlZFVpbnQ4TWVtb3J5MCA9PT0gbnVsbCB8fCBjYWNoZWRVaW50OE1lbW9yeTAuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjYWNoZWRVaW50OE1lbW9yeTAgPSBuZXcgVWludDhBcnJheSh3YXNtLm1lbW9yeS5idWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVkVWludDhNZW1vcnkwO1xufVxuXG5jb25zdCBjYWNoZWRUZXh0RW5jb2RlciA9ICh0eXBlb2YgVGV4dEVuY29kZXIgIT09ICd1bmRlZmluZWQnID8gbmV3IFRleHRFbmNvZGVyKCd1dGYtOCcpIDogeyBlbmNvZGU6ICgpID0+IHsgdGhyb3cgRXJyb3IoJ1RleHRFbmNvZGVyIG5vdCBhdmFpbGFibGUnKSB9IH0gKTtcblxuY29uc3QgZW5jb2RlU3RyaW5nID0gKHR5cGVvZiBjYWNoZWRUZXh0RW5jb2Rlci5lbmNvZGVJbnRvID09PSAnZnVuY3Rpb24nXG4gICAgPyBmdW5jdGlvbiAoYXJnLCB2aWV3KSB7XG4gICAgcmV0dXJuIGNhY2hlZFRleHRFbmNvZGVyLmVuY29kZUludG8oYXJnLCB2aWV3KTtcbn1cbiAgICA6IGZ1bmN0aW9uIChhcmcsIHZpZXcpIHtcbiAgICBjb25zdCBidWYgPSBjYWNoZWRUZXh0RW5jb2Rlci5lbmNvZGUoYXJnKTtcbiAgICB2aWV3LnNldChidWYpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlYWQ6IGFyZy5sZW5ndGgsXG4gICAgICAgIHdyaXR0ZW46IGJ1Zi5sZW5ndGhcbiAgICB9O1xufSk7XG5cbmZ1bmN0aW9uIHBhc3NTdHJpbmdUb1dhc20wKGFyZywgbWFsbG9jLCByZWFsbG9jKSB7XG5cbiAgICBpZiAocmVhbGxvYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IGNhY2hlZFRleHRFbmNvZGVyLmVuY29kZShhcmcpO1xuICAgICAgICBjb25zdCBwdHIgPSBtYWxsb2MoYnVmLmxlbmd0aCwgMSkgPj4+IDA7XG4gICAgICAgIGdldFVpbnQ4TWVtb3J5MCgpLnN1YmFycmF5KHB0ciwgcHRyICsgYnVmLmxlbmd0aCkuc2V0KGJ1Zik7XG4gICAgICAgIFdBU01fVkVDVE9SX0xFTiA9IGJ1Zi5sZW5ndGg7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgbGV0IGxlbiA9IGFyZy5sZW5ndGg7XG4gICAgbGV0IHB0ciA9IG1hbGxvYyhsZW4sIDEpID4+PiAwO1xuXG4gICAgY29uc3QgbWVtID0gZ2V0VWludDhNZW1vcnkwKCk7XG5cbiAgICBsZXQgb2Zmc2V0ID0gMDtcblxuICAgIGZvciAoOyBvZmZzZXQgPCBsZW47IG9mZnNldCsrKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBhcmcuY2hhckNvZGVBdChvZmZzZXQpO1xuICAgICAgICBpZiAoY29kZSA+IDB4N0YpIGJyZWFrO1xuICAgICAgICBtZW1bcHRyICsgb2Zmc2V0XSA9IGNvZGU7XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldCAhPT0gbGVuKSB7XG4gICAgICAgIGlmIChvZmZzZXQgIT09IDApIHtcbiAgICAgICAgICAgIGFyZyA9IGFyZy5zbGljZShvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHB0ciA9IHJlYWxsb2MocHRyLCBsZW4sIGxlbiA9IG9mZnNldCArIGFyZy5sZW5ndGggKiAzLCAxKSA+Pj4gMDtcbiAgICAgICAgY29uc3QgdmlldyA9IGdldFVpbnQ4TWVtb3J5MCgpLnN1YmFycmF5KHB0ciArIG9mZnNldCwgcHRyICsgbGVuKTtcbiAgICAgICAgY29uc3QgcmV0ID0gZW5jb2RlU3RyaW5nKGFyZywgdmlldyk7XG5cbiAgICAgICAgb2Zmc2V0ICs9IHJldC53cml0dGVuO1xuICAgICAgICBwdHIgPSByZWFsbG9jKHB0ciwgbGVuLCBvZmZzZXQsIDEpID4+PiAwO1xuICAgIH1cblxuICAgIFdBU01fVkVDVE9SX0xFTiA9IG9mZnNldDtcbiAgICByZXR1cm4gcHRyO1xufVxuXG5sZXQgY2FjaGVkSW50MzJNZW1vcnkwID0gbnVsbDtcblxuZnVuY3Rpb24gZ2V0SW50MzJNZW1vcnkwKCkge1xuICAgIGlmIChjYWNoZWRJbnQzMk1lbW9yeTAgPT09IG51bGwgfHwgY2FjaGVkSW50MzJNZW1vcnkwLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgY2FjaGVkSW50MzJNZW1vcnkwID0gbmV3IEludDMyQXJyYXkod2FzbS5tZW1vcnkuYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZEludDMyTWVtb3J5MDtcbn1cblxuY29uc3QgY2FjaGVkVGV4dERlY29kZXIgPSAodHlwZW9mIFRleHREZWNvZGVyICE9PSAndW5kZWZpbmVkJyA/IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnLCB7IGlnbm9yZUJPTTogdHJ1ZSwgZmF0YWw6IHRydWUgfSkgOiB7IGRlY29kZTogKCkgPT4geyB0aHJvdyBFcnJvcignVGV4dERlY29kZXIgbm90IGF2YWlsYWJsZScpIH0gfSApO1xuXG5pZiAodHlwZW9mIFRleHREZWNvZGVyICE9PSAndW5kZWZpbmVkJykgeyBjYWNoZWRUZXh0RGVjb2Rlci5kZWNvZGUoKTsgfTtcblxuZnVuY3Rpb24gZ2V0U3RyaW5nRnJvbVdhc20wKHB0ciwgbGVuKSB7XG4gICAgcHRyID0gcHRyID4+PiAwO1xuICAgIHJldHVybiBjYWNoZWRUZXh0RGVjb2Rlci5kZWNvZGUoZ2V0VWludDhNZW1vcnkwKCkuc3ViYXJyYXkocHRyLCBwdHIgKyBsZW4pKTtcbn1cbi8qKlxuKiBAcGFyYW0ge3N0cmluZ30gZG9jc1xuKiBAcmV0dXJucyB7c3RyaW5nfVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZV9kb2NfdG9fanNvbihkb2NzKSB7XG4gICAgbGV0IGRlZmVycmVkMl8wO1xuICAgIGxldCBkZWZlcnJlZDJfMTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGRvY3MsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5wYXJzZV9kb2NfdG9fanNvbihyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgZGVmZXJyZWQyXzAgPSByMDtcbiAgICAgICAgZGVmZXJyZWQyXzEgPSByMTtcbiAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKGRlZmVycmVkMl8wLCBkZWZlcnJlZDJfMSwgMSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRBcnJheVU4RnJvbVdhc20wKHB0ciwgbGVuKSB7XG4gICAgcHRyID0gcHRyID4+PiAwO1xuICAgIHJldHVybiBnZXRVaW50OE1lbW9yeTAoKS5zdWJhcnJheShwdHIgLyAxLCBwdHIgLyAxICsgbGVuKTtcbn1cbi8qKlxuKiBAcGFyYW0ge3N0cmluZ30gY29kZVxuKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2UoY29kZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoY29kZSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLnBhcnNlKHJldHB0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICB2YXIgdjIgPSBnZXRBcnJheVU4RnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUocjAsIHIxICogMSwgMSk7XG4gICAgICAgIHJldHVybiB2MjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgIH1cbn1cblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nfSBjb2RlXG4qIEByZXR1cm5zIHtudW1iZXJ9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX2lkZW50X29yX29wZXJhdG9yKGNvZGUpIHtcbiAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoY29kZSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgY29uc3QgcmV0ID0gd2FzbS5pc19pZGVudF9vcl9vcGVyYXRvcihwdHIwLCBsZW4wKTtcbiAgICByZXR1cm4gcmV0ID4+PiAwO1xufVxuXG4vKipcbiovXG5leHBvcnQgZnVuY3Rpb24gbWFpbigpIHtcbiAgICB3YXNtLm1haW4oKTtcbn1cblxuZnVuY3Rpb24gYWRkSGVhcE9iamVjdChvYmopIHtcbiAgICBpZiAoaGVhcF9uZXh0ID09PSBoZWFwLmxlbmd0aCkgaGVhcC5wdXNoKGhlYXAubGVuZ3RoICsgMSk7XG4gICAgY29uc3QgaWR4ID0gaGVhcF9uZXh0O1xuICAgIGhlYXBfbmV4dCA9IGhlYXBbaWR4XTtcblxuICAgIGhlYXBbaWR4XSA9IG9iajtcbiAgICByZXR1cm4gaWR4O1xufVxuXG5hc3luYyBmdW5jdGlvbiBfX3diZ19sb2FkKG1vZHVsZSwgaW1wb3J0cykge1xuICAgIGlmICh0eXBlb2YgUmVzcG9uc2UgPT09ICdmdW5jdGlvbicgJiYgbW9kdWxlIGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcobW9kdWxlLCBpbXBvcnRzKTtcblxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChtb2R1bGUuaGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpICE9ICdhcHBsaWNhdGlvbi93YXNtJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmdgIGZhaWxlZCBiZWNhdXNlIHlvdXIgc2VydmVyIGRvZXMgbm90IHNlcnZlIHdhc20gd2l0aCBgYXBwbGljYXRpb24vd2FzbWAgTUlNRSB0eXBlLiBGYWxsaW5nIGJhY2sgdG8gYFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlYCB3aGljaCBpcyBzbG93ZXIuIE9yaWdpbmFsIGVycm9yOlxcblwiLCBlKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYnl0ZXMgPSBhd2FpdCBtb2R1bGUuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGJ5dGVzLCBpbXBvcnRzKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUobW9kdWxlLCBpbXBvcnRzKTtcblxuICAgICAgICBpZiAoaW5zdGFuY2UgaW5zdGFuY2VvZiBXZWJBc3NlbWJseS5JbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgaW5zdGFuY2UsIG1vZHVsZSB9O1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIF9fd2JnX2dldF9pbXBvcnRzKCkge1xuICAgIGNvbnN0IGltcG9ydHMgPSB7fTtcbiAgICBpbXBvcnRzLndiZyA9IHt9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2Vycm9yX2Y4NTE2NjdhZjcxYmNmYzYgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVmZXJyZWQwXzAgPSBhcmcwO1xuICAgICAgICAgICAgZGVmZXJyZWQwXzEgPSBhcmcxO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSkpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUoZGVmZXJyZWQwXzAsIGRlZmVycmVkMF8xLCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3X2FiZGE3NmU4ODNiYThhNWYgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IEVycm9yKCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zdGFja182NTgyNzlmZTQ0NTQxY2Y2ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMSkuc3RhY2s7XG4gICAgICAgIGNvbnN0IHB0cjEgPSBwYXNzU3RyaW5nVG9XYXNtMChyZXQsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgZ2V0SW50MzJNZW1vcnkwKClbYXJnMCAvIDQgKyAxXSA9IGxlbjE7XG4gICAgICAgIGdldEludDMyTWVtb3J5MCgpW2FyZzAgLyA0ICsgMF0gPSBwdHIxO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9vYmplY3RfZHJvcF9yZWYgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIHRha2VPYmplY3QoYXJnMCk7XG4gICAgfTtcblxuICAgIHJldHVybiBpbXBvcnRzO1xufVxuXG5mdW5jdGlvbiBfX3diZ19pbml0X21lbW9yeShpbXBvcnRzLCBtYXliZV9tZW1vcnkpIHtcblxufVxuXG5mdW5jdGlvbiBfX3diZ19maW5hbGl6ZV9pbml0KGluc3RhbmNlLCBtb2R1bGUpIHtcbiAgICB3YXNtID0gaW5zdGFuY2UuZXhwb3J0cztcbiAgICBfX3diZ19pbml0Ll9fd2JpbmRnZW5fd2FzbV9tb2R1bGUgPSBtb2R1bGU7XG4gICAgY2FjaGVkSW50MzJNZW1vcnkwID0gbnVsbDtcbiAgICBjYWNoZWRVaW50OE1lbW9yeTAgPSBudWxsO1xuXG4gICAgd2FzbS5fX3diaW5kZ2VuX3N0YXJ0KCk7XG4gICAgcmV0dXJuIHdhc207XG59XG5cbmZ1bmN0aW9uIGluaXRTeW5jKG1vZHVsZSkge1xuICAgIGlmICh3YXNtICE9PSB1bmRlZmluZWQpIHJldHVybiB3YXNtO1xuXG4gICAgY29uc3QgaW1wb3J0cyA9IF9fd2JnX2dldF9pbXBvcnRzKCk7XG5cbiAgICBfX3diZ19pbml0X21lbW9yeShpbXBvcnRzKTtcblxuICAgIGlmICghKG1vZHVsZSBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5Lk1vZHVsZSkpIHtcbiAgICAgICAgbW9kdWxlID0gbmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShtb2R1bGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKG1vZHVsZSwgaW1wb3J0cyk7XG5cbiAgICByZXR1cm4gX193YmdfZmluYWxpemVfaW5pdChpbnN0YW5jZSwgbW9kdWxlKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gX193YmdfaW5pdChpbnB1dCkge1xuICAgIGlmICh3YXNtICE9PSB1bmRlZmluZWQpIHJldHVybiB3YXNtO1xuXG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaW5wdXQgPSBuZXcgVVJMKCdydXN0X2ZmaV9iZy53YXNtJywgaW1wb3J0Lm1ldGEudXJsKTtcbiAgICB9XG4gICAgY29uc3QgaW1wb3J0cyA9IF9fd2JnX2dldF9pbXBvcnRzKCk7XG5cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyB8fCAodHlwZW9mIFJlcXVlc3QgPT09ICdmdW5jdGlvbicgJiYgaW5wdXQgaW5zdGFuY2VvZiBSZXF1ZXN0KSB8fCAodHlwZW9mIFVSTCA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnB1dCBpbnN0YW5jZW9mIFVSTCkpIHtcbiAgICAgICAgaW5wdXQgPSBmZXRjaChpbnB1dCk7XG4gICAgfVxuXG4gICAgX193YmdfaW5pdF9tZW1vcnkoaW1wb3J0cyk7XG5cbiAgICBjb25zdCB7IGluc3RhbmNlLCBtb2R1bGUgfSA9IGF3YWl0IF9fd2JnX2xvYWQoYXdhaXQgaW5wdXQsIGltcG9ydHMpO1xuXG4gICAgcmV0dXJuIF9fd2JnX2ZpbmFsaXplX2luaXQoaW5zdGFuY2UsIG1vZHVsZSk7XG59XG5cbmV4cG9ydCB7IGluaXRTeW5jIH1cbmV4cG9ydCBkZWZhdWx0IF9fd2JnX2luaXQ7XG4iLCAiY29uc3QgX192aXRlX2luamVjdGVkX29yaWdpbmFsX2Rpcm5hbWUgPSBcIkM6XFxcXFByb2plY3RzXFxcXGVuc29cXFxcZW5zb1xcXFxhcHBcXFxcZ3VpMlxcXFxzaGFyZWRcXFxcdXRpbFwiO2NvbnN0IF9fdml0ZV9pbmplY3RlZF9vcmlnaW5hbF9maWxlbmFtZSA9IFwiQzpcXFxcUHJvamVjdHNcXFxcZW5zb1xcXFxlbnNvXFxcXGFwcFxcXFxndWkyXFxcXHNoYXJlZFxcXFx1dGlsXFxcXGFzc2VydC50c1wiO2NvbnN0IF9fdml0ZV9pbmplY3RlZF9vcmlnaW5hbF9pbXBvcnRfbWV0YV91cmwgPSBcImZpbGU6Ly8vQzovUHJvamVjdHMvZW5zby9lbnNvL2FwcC9ndWkyL3NoYXJlZC91dGlsL2Fzc2VydC50c1wiO2V4cG9ydCBmdW5jdGlvbiBhc3NlcnROZXZlcih4OiBuZXZlcik6IG5ldmVyIHtcbiAgYmFpbCgnVW5leHBlY3RlZCBvYmplY3Q6ICcgKyBKU09OLnN0cmluZ2lmeSh4KSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb246IGJvb2xlYW4sIG1lc3NhZ2U/OiBzdHJpbmcpOiBhc3NlcnRzIGNvbmRpdGlvbiB7XG4gIGlmICghY29uZGl0aW9uKSBiYWlsKG1lc3NhZ2UgPyBgQXNzZXJ0aW9uIGZhaWxlZDogJHttZXNzYWdlfWAgOiAnQXNzZXJ0aW9uIGZhaWxlZCcpXG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBpdGVyYWJsZSBoYXMgdGhlIHNwZWNpZmllZCBsZW5ndGggYW5kIHRocm93cyBhbiBhc3NlcnRpb24gZXJyb3JcbiAqIGlmIHRoZSBsZW5ndGhzIGRvIG5vdCBtYXRjaC5cbiAqXG4gKiBAcGFyYW0gaXRlcmFibGUgVGhlIGl0ZXJhYmxlIHRvIGNoZWNrLlxuICogQHBhcmFtIGxlbmd0aCBUaGUgZXhwZWN0ZWQgbGVuZ3RoIG9mIHRoZSBpdGVyYWJsZS5cbiAqIEBwYXJhbSBtZXNzYWdlIE9wdGlvbmFsIG1lc3NhZ2UgZm9yIHRoZSBhc3NlcnRpb24gZXJyb3IuXG4gKiBAcmV0dXJuIHZvaWRcbiAqIEB0aHJvd3MgRXJyb3IgV2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgbGVuZ3RoIGRvZXMgbm90IG1hdGNoLlxuICpcbiAqIFRoZSBmaXJzdCBmaXZlIGVsZW1lbnRzIG9mIHRoZSBpdGVyYWJsZSB3aWxsIGJlIGRpc3BsYXllZCBpbiB0aGUgZXJyb3IgbWVzc2FnZVxuICogaWYgdGhlIGFzc2VydGlvbiBmYWlscy4gSWYgdGhlIGl0ZXJhYmxlIGNvbnRhaW5zIG1vcmUgdGhhbiBmaXZlIGVsZW1lbnRzLFxuICogdGhlIHJlbWFpbmluZyBlbGVtZW50cyB3aWxsIGJlIHJlcHJlc2VudGVkIGFzICcuLi4nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0TGVuZ3RoPFQ+KGl0ZXJhYmxlOiBJdGVyYWJsZTxUPiwgbGVuZ3RoOiBudW1iZXIsIG1lc3NhZ2U/OiBzdHJpbmcpOiB2b2lkIHtcbiAgY29uc3QgY29udmVydGVkQXJyYXkgPSBBcnJheS5mcm9tKGl0ZXJhYmxlKVxuICBjb25zdCBtZXNzYWdlUHJlZml4ID0gbWVzc2FnZSA/IG1lc3NhZ2UgKyAnICcgOiAnJ1xuICBjb25zdCBlbGVtZW50UmVwcmVzZW50YXRpb24gPVxuICAgIGNvbnZlcnRlZEFycmF5Lmxlbmd0aCA+IDUgP1xuICAgICAgYCR7Y29udmVydGVkQXJyYXkuc2xpY2UoMCwgNSkuam9pbignLCAnKX0sLi4uYFxuICAgIDogY29udmVydGVkQXJyYXkuam9pbignLCAnKVxuICBhc3NlcnQoXG4gICAgY29udmVydGVkQXJyYXkubGVuZ3RoID09PSBsZW5ndGgsXG4gICAgYCR7bWVzc2FnZVByZWZpeH1FeHBlY3RlZCBpdGVyYWJsZSBvZiBsZW5ndGggJHtsZW5ndGh9LCBnb3QgbGVuZ3RoICR7Y29udmVydGVkQXJyYXkubGVuZ3RofS4gRWxlbWVudHM6IFske2VsZW1lbnRSZXByZXNlbnRhdGlvbn1dYCxcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0RW1wdHk8VD4oaXRlcmFibGU6IEl0ZXJhYmxlPFQ+LCBtZXNzYWdlPzogc3RyaW5nKTogdm9pZCB7XG4gIGFzc2VydExlbmd0aChpdGVyYWJsZSwgMCwgbWVzc2FnZSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEVxdWFsPFQ+KGFjdHVhbDogVCwgZXhwZWN0ZWQ6IFQsIG1lc3NhZ2U/OiBzdHJpbmcpIHtcbiAgY29uc3QgbWVzc2FnZVByZWZpeCA9IG1lc3NhZ2UgPyBtZXNzYWdlICsgJyAnIDogJydcbiAgYXNzZXJ0KGFjdHVhbCA9PT0gZXhwZWN0ZWQsIGAke21lc3NhZ2VQcmVmaXh9RXhwZWN0ZWQgJHtleHBlY3RlZH0sIGdvdCAke2FjdHVhbH0uYClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydE5vdEVxdWFsPFQ+KGFjdHVhbDogVCwgdW5leHBlY3RlZDogVCwgbWVzc2FnZT86IHN0cmluZykge1xuICBjb25zdCBtZXNzYWdlUHJlZml4ID0gbWVzc2FnZSA/IG1lc3NhZ2UgKyAnICcgOiAnJ1xuICBhc3NlcnQoYWN0dWFsICE9PSB1bmV4cGVjdGVkLCBgJHttZXNzYWdlUHJlZml4fUV4cGVjdGVkIG5vdCAke3VuZXhwZWN0ZWR9LCBnb3QgJHthY3R1YWx9LmApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnREZWZpbmVkPFQ+KHg6IFQgfCB1bmRlZmluZWQsIG1lc3NhZ2U/OiBzdHJpbmcpOiBhc3NlcnRzIHggaXMgVCB7XG4gIGNvbnN0IG1lc3NhZ2VQcmVmaXggPSBtZXNzYWdlID8gbWVzc2FnZSArICcgJyA6ICcnXG4gIGFzc2VydCh4ICE9PSB1bmRlZmluZWQsIGAke21lc3NhZ2VQcmVmaXh9RXhwZWN0ZWQgdmFsdWUgdG8gYmUgZGVmaW5lZC5gKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0VW5yZWFjaGFibGUoKTogbmV2ZXIge1xuICBiYWlsKCdVbnJlYWNoYWJsZSBjb2RlJylcbn1cblxuLyoqXG4gKiBUaHJvdyBhbiBlcnJvciB3aXRoIHByb3ZpZGVkIG1lc3NhZ2UuXG4gKlxuICogSXQgaXMgY29udmVuaWVudCB0byB1c2UgYXQgdGhlIGVuZCBvZiBhIG51bGxhYmxlIGNoYWluOlxuICogYGBgdHNcbiAqIGNvbnN0IHggPSBmb28/LmJhci5iYXo/LigpID8/IGJhaWwoJ0V4cGVjdGVkIGZvby5iYXIuYmF6IHRvIGV4aXN0JylcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYmFpbChtZXNzYWdlOiBzdHJpbmcpOiBuZXZlciB7XG4gIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKVxufVxuIiwgImNvbnN0IF9fdml0ZV9pbmplY3RlZF9vcmlnaW5hbF9kaXJuYW1lID0gXCJDOlxcXFxQcm9qZWN0c1xcXFxlbnNvXFxcXGVuc29cXFxcYXBwXFxcXGd1aTJcXFxcc2hhcmVkXFxcXHV0aWxcIjtjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfZmlsZW5hbWUgPSBcIkM6XFxcXFByb2plY3RzXFxcXGVuc29cXFxcZW5zb1xcXFxhcHBcXFxcZ3VpMlxcXFxzaGFyZWRcXFxcdXRpbFxcXFxkZXRlY3QudHNcIjtjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfaW1wb3J0X21ldGFfdXJsID0gXCJmaWxlOi8vL0M6L1Byb2plY3RzL2Vuc28vZW5zby9hcHAvZ3VpMi9zaGFyZWQvdXRpbC9kZXRlY3QudHNcIjsvLyBFbnZpcm9ubWVudCBkZXRlY3Rpb25cblxuLy8gTm9ybWFsbHkgYGdsb2JhbGAgaXMgbm9kZS1zcGVjaWZpYywgYnV0IGEgd29ya2Fyb3VuZCByZXF1aXJlcyBgZ2xvYmFsYCB0byBhbHNvIGV4aXN0XG4vLyBpbiB0aGUgYnJvd3NlciBmb3IgQW1wbGlmeSB0byB3b3JrLlxuZXhwb3J0IGNvbnN0IGlzTm9kZSA9XG4gIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIChnbG9iYWwgYXMgYW55KVtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnZ2xvYmFsJ1xuXG5leHBvcnQgY29uc3QgaXNEZXZNb2RlID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCdcbiIsICJjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfZGlybmFtZSA9IFwiQzpcXFxcUHJvamVjdHNcXFxcZW5zb1xcXFxlbnNvXFxcXGFwcFxcXFxndWkyXFxcXHlkb2Mtc2VydmVyXCI7Y29uc3QgX192aXRlX2luamVjdGVkX29yaWdpbmFsX2ZpbGVuYW1lID0gXCJDOlxcXFxQcm9qZWN0c1xcXFxlbnNvXFxcXGVuc29cXFxcYXBwXFxcXGd1aTJcXFxceWRvYy1zZXJ2ZXJcXFxceWRvYy50c1wiO2NvbnN0IF9fdml0ZV9pbmplY3RlZF9vcmlnaW5hbF9pbXBvcnRfbWV0YV91cmwgPSBcImZpbGU6Ly8vQzovUHJvamVjdHMvZW5zby9lbnNvL2FwcC9ndWkyL3lkb2Mtc2VydmVyL3lkb2MudHNcIjtpbXBvcnQge1xuICBhcHBseUF3YXJlbmVzc1VwZGF0ZSxcbiAgQXdhcmVuZXNzLFxuICBlbmNvZGVBd2FyZW5lc3NVcGRhdGUsXG4gIHJlbW92ZUF3YXJlbmVzc1N0YXRlcyxcbn0gZnJvbSAneS1wcm90b2NvbHMvYXdhcmVuZXNzJ1xuaW1wb3J0IHsgcmVhZFN5bmNNZXNzYWdlLCB3cml0ZVN5bmNTdGVwMSwgd3JpdGVVcGRhdGUgfSBmcm9tICd5LXByb3RvY29scy9zeW5jJ1xuaW1wb3J0ICogYXMgWSBmcm9tICd5anMnXG5cbmltcG9ydCAqIGFzIGRlY29kaW5nIGZyb20gJ2xpYjAvZGVjb2RpbmcnXG5pbXBvcnQgKiBhcyBlbmNvZGluZyBmcm9tICdsaWIwL2VuY29kaW5nJ1xuaW1wb3J0IHsgT2JzZXJ2YWJsZVYyIH0gZnJvbSAnbGliMC9vYnNlcnZhYmxlJ1xuaW1wb3J0IHsgV2ViU29ja2V0IH0gZnJvbSAnd3MnXG5pbXBvcnQgeyBMYW5ndWFnZVNlcnZlclNlc3Npb24gfSBmcm9tICcuL2xhbmd1YWdlU2VydmVyU2Vzc2lvbidcblxuY29uc3QgcGluZ1RpbWVvdXQgPSAzMDAwMFxuXG5jb25zdCBtZXNzYWdlU3luYyA9IDBcbmNvbnN0IG1lc3NhZ2VBd2FyZW5lc3MgPSAxXG5cbmludGVyZmFjZSBBd2FyZW5lc3NVcGRhdGUge1xuICBhZGRlZDogbnVtYmVyW11cbiAgdXBkYXRlZDogbnVtYmVyW11cbiAgcmVtb3ZlZDogbnVtYmVyW11cbn1cblxudHlwZSBDb25uZWN0aW9uSWQgPSBZanNDb25uZWN0aW9uIHwgc3RyaW5nXG5cbi8qKlxuICogQSBZanMgZG9jdW1lbnQgdGhhdCBpcyBzaGFyZWQgb3ZlciBtdWx0aXBsZSB3ZWJzb2NrZXQgY29ubmVjdGlvbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBXU1NoYXJlZERvYyB7XG4gIGRvYzogWS5Eb2NcbiAgLyoqXG4gICAqIE1hcHMgZnJvbSBjb25uZWN0aW9uIGlkIHRvIHNldCBvZiBjb250cm9sbGVkIHVzZXIgaWRzLlxuICAgKiBEZWxldGUgYWxsIHVzZXIgaWRzIGZyb20gYXdhcmVuZXNzIHdoZW4gdGhpcyBjb25uIGlzIGNsb3NlZC5cbiAgICovXG4gIGNvbm5zOiBNYXA8Q29ubmVjdGlvbklkLCBTZXQ8bnVtYmVyPj5cbiAgYXdhcmVuZXNzOiBBd2FyZW5lc3NcblxuICBjb25zdHJ1Y3RvcihnYyA9IHRydWUpIHtcbiAgICB0aGlzLmRvYyA9IG5ldyBZLkRvYyh7IGdjIH0pXG4gICAgLy8gdGhpcy5uYW1lID0gbmFtZVxuICAgIHRoaXMuY29ubnMgPSBuZXcgTWFwKClcblxuICAgIHRoaXMuYXdhcmVuZXNzID0gbmV3IEF3YXJlbmVzcyh0aGlzLmRvYylcbiAgICB0aGlzLmF3YXJlbmVzcy5zZXRMb2NhbFN0YXRlKG51bGwpXG5cbiAgICB0aGlzLmF3YXJlbmVzcy5vbihcbiAgICAgICd1cGRhdGUnLFxuICAgICAgKHsgYWRkZWQsIHVwZGF0ZWQsIHJlbW92ZWQgfTogQXdhcmVuZXNzVXBkYXRlLCBjb25uOiBDb25uZWN0aW9uSWQgfCBudWxsKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoYW5nZWRDbGllbnRzID0gYWRkZWQuY29uY2F0KHVwZGF0ZWQsIHJlbW92ZWQpXG4gICAgICAgIGlmIChjb25uICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgY29ubkNvbnRyb2xsZWRJRHMgPSB0aGlzLmNvbm5zLmdldChjb25uKVxuICAgICAgICAgIGlmIChjb25uQ29udHJvbGxlZElEcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNsaWVudElEIG9mIGFkZGVkKSBjb25uQ29udHJvbGxlZElEcy5hZGQoY2xpZW50SUQpXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNsaWVudElEIG9mIHJlbW92ZWQpIGNvbm5Db250cm9sbGVkSURzLmRlbGV0ZShjbGllbnRJRClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYnJvYWRjYXN0IGF3YXJlbmVzcyB1cGRhdGVcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbWVzc2FnZUF3YXJlbmVzcylcbiAgICAgICAgY29uc3QgdXBkYXRlID0gZW5jb2RlQXdhcmVuZXNzVXBkYXRlKHRoaXMuYXdhcmVuZXNzLCBjaGFuZ2VkQ2xpZW50cylcbiAgICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIHVwZGF0ZSlcbiAgICAgICAgdGhpcy5icm9hZGNhc3QoZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpKVxuICAgICAgfSxcbiAgICApXG4gICAgdGhpcy5kb2Mub24oJ3VwZGF0ZScsICh1cGRhdGUsIG9yaWdpbikgPT4gdGhpcy51cGRhdGVIYW5kbGVyKHVwZGF0ZSwgb3JpZ2luKSlcbiAgfVxuXG4gIGJyb2FkY2FzdChtZXNzYWdlOiBVaW50OEFycmF5KSB7XG4gICAgZm9yIChjb25zdCBbY29ubl0gb2YgdGhpcy5jb25ucykge1xuICAgICAgaWYgKHR5cGVvZiBjb25uICE9PSAnc3RyaW5nJykgY29ubi5zZW5kKG1lc3NhZ2UpXG4gICAgfVxuICB9XG5cbiAgdXBkYXRlSGFuZGxlcih1cGRhdGU6IFVpbnQ4QXJyYXksIF9vcmlnaW46IGFueSkge1xuICAgIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbWVzc2FnZVN5bmMpXG4gICAgd3JpdGVVcGRhdGUoZW5jb2RlciwgdXBkYXRlKVxuICAgIHRoaXMuYnJvYWRjYXN0KGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKSlcbiAgfVxufVxuXG4vKipcbiAqIEhhbmRsZSBzZXJ2aWNpbmcgaW5jb21pbmcgV2ViU29ja2V0IGNvbm5lY3Rpb24gbGlzdGVuaW5nIGZvciBnaXZlbiBkb2N1bWVudCB1cGRhdGVzLlxuICogQHBhcmFtIHdzIFRoZSBuZXdseSBjb25uZWN0ZWQgV2ViU29ja2V0IHJlcXVlc3RpbmcgWWpzIGRvY3VtZW50IHN5bmNocm9uaXphdGlvblxuICogQHBhcmFtIGxzVXJsIEFkZHJlc3Mgb2YgdGhlIGxhbmd1YWdlIHNlcnZlciB0byBjb25uZWN0IHRvLiBFYWNoIHVuaXF1ZSBsYW5ndWFnZSBzZXJ2ZXIgYWRkcmVzc1xuICogd2lsbCBiZSBhc3NpZ25lZCBpdHMgb3duIGBEaXN0cmlidXRlZFByb2plY3RgIGluc3RhbmNlIHdpdGggYSB1bmlxdWUgbmFtZXNwYWNlIG9mIFlqcyBkb2N1bWVudHMuXG4gKiBAcGFyYW0gZG9jTmFtZSBUaGUgbmFtZSBvZiB0aGUgZG9jdW1lbnQgdG8gc3luY2hyb25pemUuIFdoZW4gdGhlIGRvY3VtZW50IG5hbWUgaXMgYGluZGV4YCwgdGhlXG4gKiBkb2N1bWVudCBpcyBjb25zaWRlcmVkIHRvIGJlIHRoZSByb290IGRvY3VtZW50IG9mIHRoZSBgRGlzdHJpYnV0ZWRQcm9qZWN0YCBkYXRhIG1vZGVsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0dXBHYXRld2F5Q2xpZW50KHdzOiBXZWJTb2NrZXQsIGxzVXJsOiBzdHJpbmcsIGRvY05hbWU6IHN0cmluZykge1xuICBjb25zdCBsc1Nlc3Npb24gPSBMYW5ndWFnZVNlcnZlclNlc3Npb24uZ2V0KGxzVXJsKVxuICBjb25zdCB3c0RvYyA9IGxzU2Vzc2lvbi5nZXRZRG9jKGRvY05hbWUpXG4gIGlmICh3c0RvYyA9PSBudWxsKSB7XG4gICAgY29uc29sZS5lcnJvcihgRG9jdW1lbnQgJyR7ZG9jTmFtZX0nIG5vdCBmb3VuZCBpbiBsYW5ndWFnZSBzZXJ2ZXIgc2Vzc2lvbiAnJHtsc1VybH0nLmApXG4gICAgd3MuY2xvc2UoKVxuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IGNvbm5lY3Rpb24gPSBuZXcgWWpzQ29ubmVjdGlvbih3cywgd3NEb2MpXG4gIGNvbm5lY3Rpb24ub25jZSgnY2xvc2UnLCBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGxzU2Vzc2lvbi5yZWxlYXNlKClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignU2Vzc2lvbiByZWxlYXNlIGZhaWxlZC5cXG4nLCBlcnJvcilcbiAgICB9XG4gIH0pXG59XG5cbmNsYXNzIFlqc0Nvbm5lY3Rpb24gZXh0ZW5kcyBPYnNlcnZhYmxlVjI8eyBjbG9zZSgpOiB2b2lkIH0+IHtcbiAgd3M6IFdlYlNvY2tldFxuICB3c0RvYzogV1NTaGFyZWREb2NcbiAgY29uc3RydWN0b3Iod3M6IFdlYlNvY2tldCwgd3NEb2M6IFdTU2hhcmVkRG9jKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMud3MgPSB3c1xuICAgIHRoaXMud3NEb2MgPSB3c0RvY1xuICAgIGNvbnN0IGlzTG9hZGVkID0gd3NEb2MuY29ubnMuc2l6ZSA+IDBcbiAgICB3c0RvYy5jb25ucy5zZXQodGhpcywgbmV3IFNldCgpKVxuICAgIHdzLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInXG4gICAgd3Mub24oJ21lc3NhZ2UnLCAobWVzc2FnZTogQXJyYXlCdWZmZXIpID0+IHRoaXMubWVzc2FnZUxpc3RlbmVyKG5ldyBVaW50OEFycmF5KG1lc3NhZ2UpKSlcbiAgICB3cy5vbignY2xvc2UnLCAoKSA9PiB0aGlzLmNsb3NlKCkpXG4gICAgaWYgKCFpc0xvYWRlZCkgd3NEb2MuZG9jLmxvYWQoKVxuICAgIHRoaXMuaW5pdFBpbmcoKVxuICAgIHRoaXMuc2VuZFN5bmNNZXNzYWdlKClcbiAgfVxuXG4gIHByaXZhdGUgaW5pdFBpbmcoKSB7XG4gICAgLy8gQ2hlY2sgaWYgY29ubmVjdGlvbiBpcyBzdGlsbCBhbGl2ZVxuICAgIGxldCBwb25nUmVjZWl2ZWQgPSB0cnVlXG4gICAgY29uc3QgcGluZ0ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgaWYgKCFwb25nUmVjZWl2ZWQpIHtcbiAgICAgICAgaWYgKHRoaXMud3NEb2MuY29ubnMuaGFzKHRoaXMpKSB0aGlzLmNsb3NlKClcbiAgICAgICAgY2xlYXJJbnRlcnZhbChwaW5nSW50ZXJ2YWwpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMud3NEb2MuY29ubnMuaGFzKHRoaXMpKSB7XG4gICAgICAgIHBvbmdSZWNlaXZlZCA9IGZhbHNlXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy53cy5waW5nKClcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzZW5kaW5nIHBpbmc6JywgZXJyb3IpXG4gICAgICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChwaW5nSW50ZXJ2YWwpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBwaW5nVGltZW91dClcbiAgICB0aGlzLndzLm9uKCdjbG9zZScsICgpID0+IGNsZWFySW50ZXJ2YWwocGluZ0ludGVydmFsKSlcbiAgICB0aGlzLndzLm9uKCdwb25nJywgKCkgPT4gKHBvbmdSZWNlaXZlZCA9IHRydWUpKVxuICB9XG5cbiAgc2VuZFN5bmNNZXNzYWdlKCkge1xuICAgIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbWVzc2FnZVN5bmMpXG4gICAgd3JpdGVTeW5jU3RlcDEoZW5jb2RlciwgdGhpcy53c0RvYy5kb2MpXG4gICAgdGhpcy5zZW5kKGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKSlcbiAgICBjb25zdCBhd2FyZW5lc3NTdGF0ZXMgPSB0aGlzLndzRG9jLmF3YXJlbmVzcy5nZXRTdGF0ZXMoKVxuICAgIGlmIChhd2FyZW5lc3NTdGF0ZXMuc2l6ZSA+IDApIHtcbiAgICAgIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBtZXNzYWdlQXdhcmVuZXNzKVxuICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KFxuICAgICAgICBlbmNvZGVyLFxuICAgICAgICBlbmNvZGVBd2FyZW5lc3NVcGRhdGUodGhpcy53c0RvYy5hd2FyZW5lc3MsIEFycmF5LmZyb20oYXdhcmVuZXNzU3RhdGVzLmtleXMoKSkpLFxuICAgICAgKVxuICAgICAgdGhpcy5zZW5kKGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKSlcbiAgICB9XG4gIH1cblxuICBzZW5kKG1lc3NhZ2U6IFVpbnQ4QXJyYXkpIHtcbiAgICBpZiAodGhpcy53cy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuQ09OTkVDVElORyAmJiB0aGlzLndzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICB0aGlzLmNsb3NlKClcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMud3Muc2VuZChtZXNzYWdlLCAoZXJyb3IpID0+IGVycm9yICYmIHRoaXMuY2xvc2UoKSlcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmNsb3NlKClcbiAgICB9XG4gIH1cblxuICBtZXNzYWdlTGlzdGVuZXIobWVzc2FnZTogVWludDhBcnJheSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gICAgICBjb25zdCBkZWNvZGVyID0gZGVjb2RpbmcuY3JlYXRlRGVjb2RlcihtZXNzYWdlKVxuICAgICAgY29uc3QgbWVzc2FnZVR5cGUgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKVxuICAgICAgc3dpdGNoIChtZXNzYWdlVHlwZSkge1xuICAgICAgICBjYXNlIG1lc3NhZ2VTeW5jOiB7XG4gICAgICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIG1lc3NhZ2VTeW5jKVxuICAgICAgICAgIHJlYWRTeW5jTWVzc2FnZShkZWNvZGVyLCBlbmNvZGVyLCB0aGlzLndzRG9jLmRvYywgdGhpcylcbiAgICAgICAgICAvLyBJZiB0aGUgYGVuY29kZXJgIG9ubHkgY29udGFpbnMgdGhlIHR5cGUgb2YgcmVwbHkgbWVzc2FnZSBhbmQgbm9cbiAgICAgICAgICAvLyBtZXNzYWdlLCB0aGVyZSBpcyBubyBuZWVkIHRvIHNlbmQgdGhlIG1lc3NhZ2UuIFdoZW4gYGVuY29kZXJgIG9ubHlcbiAgICAgICAgICAvLyBjb250YWlucyB0aGUgdHlwZSBvZiByZXBseSwgaXRzIGxlbmd0aCBpcyAxLlxuICAgICAgICAgIGlmIChlbmNvZGluZy5sZW5ndGgoZW5jb2RlcikgPiAxKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmQoZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpKVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgbWVzc2FnZUF3YXJlbmVzczoge1xuICAgICAgICAgIGNvbnN0IHVwZGF0ZSA9IGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpXG4gICAgICAgICAgYXBwbHlBd2FyZW5lc3NVcGRhdGUodGhpcy53c0RvYy5hd2FyZW5lc3MsIHVwZGF0ZSwgdGhpcylcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycilcbiAgICAgIHRoaXMud3NEb2MuZG9jLmVtaXQoJ2Vycm9yJywgW2Vycl0pXG4gICAgfVxuICB9XG5cbiAgY2xvc2UoKSB7XG4gICAgY29uc3QgY29udHJvbGxlZElkcyA9IHRoaXMud3NEb2MuY29ubnMuZ2V0KHRoaXMpXG4gICAgdGhpcy53c0RvYy5jb25ucy5kZWxldGUodGhpcylcbiAgICBpZiAoY29udHJvbGxlZElkcyAhPSBudWxsKSB7XG4gICAgICByZW1vdmVBd2FyZW5lc3NTdGF0ZXModGhpcy53c0RvYy5hd2FyZW5lc3MsIEFycmF5LmZyb20oY29udHJvbGxlZElkcyksIG51bGwpXG4gICAgfVxuICAgIHRoaXMud3MuY2xvc2UoKVxuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCBbXSlcbiAgICBpZiAodGhpcy53c0RvYy5jb25ucy5zaXplID09PSAwKSB7XG4gICAgICB0aGlzLndzRG9jLmRvYy5lbWl0KCd1bmxvYWQnLCBbXSlcbiAgICB9XG4gIH1cbn1cbiIsICJjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfZGlybmFtZSA9IFwiQzpcXFxcUHJvamVjdHNcXFxcZW5zb1xcXFxlbnNvXFxcXGFwcFxcXFxndWkyXFxcXHlkb2Mtc2VydmVyXCI7Y29uc3QgX192aXRlX2luamVjdGVkX29yaWdpbmFsX2ZpbGVuYW1lID0gXCJDOlxcXFxQcm9qZWN0c1xcXFxlbnNvXFxcXGVuc29cXFxcYXBwXFxcXGd1aTJcXFxceWRvYy1zZXJ2ZXJcXFxcbGFuZ3VhZ2VTZXJ2ZXJTZXNzaW9uLnRzXCI7Y29uc3QgX192aXRlX2luamVjdGVkX29yaWdpbmFsX2ltcG9ydF9tZXRhX3VybCA9IFwiZmlsZTovLy9DOi9Qcm9qZWN0cy9lbnNvL2Vuc28vYXBwL2d1aTIveWRvYy1zZXJ2ZXIvbGFuZ3VhZ2VTZXJ2ZXJTZXNzaW9uLnRzXCI7aW1wb3J0IHsgQ2xpZW50LCBSZXF1ZXN0TWFuYWdlciwgV2ViU29ja2V0VHJhbnNwb3J0IH0gZnJvbSAnQG9wZW4tcnBjL2NsaWVudC1qcydcbmltcG9ydCAqIGFzIGpzb24gZnJvbSAnbGliMC9qc29uJ1xuaW1wb3J0ICogYXMgbWFwIGZyb20gJ2xpYjAvbWFwJ1xuaW1wb3J0IHsgT2JzZXJ2YWJsZVYyIH0gZnJvbSAnbGliMC9vYnNlcnZhYmxlJ1xuaW1wb3J0ICogYXMgcmFuZG9tIGZyb20gJ2xpYjAvcmFuZG9tJ1xuaW1wb3J0ICogYXMgWSBmcm9tICd5anMnXG5pbXBvcnQgKiBhcyBBc3QgZnJvbSAnLi4vc2hhcmVkL2FzdCdcbmltcG9ydCB7IGFzdENvdW50IH0gZnJvbSAnLi4vc2hhcmVkL2FzdCdcbmltcG9ydCB7IEVuc29GaWxlUGFydHMsIGNvbWJpbmVGaWxlUGFydHMsIHNwbGl0RmlsZUNvbnRlbnRzIH0gZnJvbSAnLi4vc2hhcmVkL2Vuc29GaWxlJ1xuaW1wb3J0IHsgTGFuZ3VhZ2VTZXJ2ZXIsIGNvbXB1dGVUZXh0Q2hlY2tzdW0gfSBmcm9tICcuLi9zaGFyZWQvbGFuZ3VhZ2VTZXJ2ZXInXG5pbXBvcnQgeyBDaGVja3N1bSwgRmlsZUVkaXQsIFBhdGgsIFRleHRFZGl0LCByZXNwb25zZSB9IGZyb20gJy4uL3NoYXJlZC9sYW5ndWFnZVNlcnZlclR5cGVzJ1xuaW1wb3J0IHsgZXhwb25lbnRpYWxCYWNrb2ZmLCBwcmludGluZ0NhbGxiYWNrcyB9IGZyb20gJy4uL3NoYXJlZC9yZXRyeSdcbmltcG9ydCB7IEFib3J0U2NvcGUgfSBmcm9tICcuLi9zaGFyZWQvdXRpbC9uZXQnXG5pbXBvcnQge1xuICBEaXN0cmlidXRlZFByb2plY3QsXG4gIEV4dGVybmFsSWQsXG4gIElkTWFwLFxuICBNb2R1bGVEb2MsXG4gIHZpc01ldGFkYXRhRXF1YWxzLFxuICB0eXBlIFV1aWQsXG59IGZyb20gJy4uL3NoYXJlZC95anNNb2RlbCdcbmltcG9ydCB7XG4gIGFwcGx5RGlmZkFzVGV4dEVkaXRzLFxuICBhcHBseURvY3VtZW50VXBkYXRlcyxcbiAgcHJldHR5UHJpbnREaWZmLFxuICB0cmFuc2xhdGVWaXN1YWxpemF0aW9uRnJvbUZpbGUsXG59IGZyb20gJy4vZWRpdHMnXG5pbXBvcnQgKiBhcyBmaWxlRm9ybWF0IGZyb20gJy4vZmlsZUZvcm1hdCdcbmltcG9ydCB7IGRlc2VyaWFsaXplSWRNYXAsIHNlcmlhbGl6ZUlkTWFwIH0gZnJvbSAnLi9zZXJpYWxpemF0aW9uJ1xuaW1wb3J0IHsgV1NTaGFyZWREb2MgfSBmcm9tICcuL3lkb2MnXG5cbmNvbnN0IFNPVVJDRV9ESVIgPSAnc3JjJ1xuY29uc3QgRVhURU5TSU9OID0gJy5lbnNvJ1xuXG5jb25zdCBERUJVR19MT0dfU1lOQyA9IGZhbHNlXG5cbmZ1bmN0aW9uIGNyZWF0ZU9wZW5SUENDbGllbnQodXJsOiBzdHJpbmcpIHtcbiAgY29uc3QgdHJhbnNwb3J0ID0gbmV3IFdlYlNvY2tldFRyYW5zcG9ydCh1cmwpXG4gIGNvbnN0IHJlcXVlc3RNYW5hZ2VyID0gbmV3IFJlcXVlc3RNYW5hZ2VyKFt0cmFuc3BvcnRdKVxuICB0cmFuc3BvcnQuY29ubmVjdGlvbi5vbignZXJyb3InLCAoZXJyb3IpID0+XG4gICAgY29uc29sZS5lcnJvcignTGFuZ3VhZ2UgU2VydmVyIHRyYW5zcG9ydCBlcnJvcjonLCBlcnJvciksXG4gIClcbiAgcmV0dXJuIG5ldyBDbGllbnQocmVxdWVzdE1hbmFnZXIpXG59XG5cbmV4cG9ydCBjbGFzcyBMYW5ndWFnZVNlcnZlclNlc3Npb24ge1xuICBjbGllbnRJZDogVXVpZFxuICBpbmRleERvYzogV1NTaGFyZWREb2NcbiAgZG9jczogTWFwPHN0cmluZywgV1NTaGFyZWREb2M+XG4gIHJldGFpbkNvdW50OiBudW1iZXJcbiAgdXJsOiBzdHJpbmdcbiAgY2xpZW50OiBDbGllbnRcbiAgbHM6IExhbmd1YWdlU2VydmVyXG4gIGNvbm5lY3Rpb246IHJlc3BvbnNlLkluaXRQcm90b2NvbENvbm5lY3Rpb24gfCB1bmRlZmluZWRcbiAgbW9kZWw6IERpc3RyaWJ1dGVkUHJvamVjdFxuICBwcm9qZWN0Um9vdElkOiBVdWlkIHwgbnVsbFxuICBhdXRob3JpdGF0aXZlTW9kdWxlczogTWFwPHN0cmluZywgTW9kdWxlUGVyc2lzdGVuY2U+XG4gIGNsaWVudFNjb3BlOiBBYm9ydFNjb3BlXG5cbiAgY29uc3RydWN0b3IodXJsOiBzdHJpbmcpIHtcbiAgICB0aGlzLmNsaWVudFNjb3BlID0gbmV3IEFib3J0U2NvcGUoKVxuICAgIHRoaXMuY2xpZW50SWQgPSByYW5kb20udXVpZHY0KCkgYXMgVXVpZFxuICAgIHRoaXMuZG9jcyA9IG5ldyBNYXAoKVxuICAgIHRoaXMucmV0YWluQ291bnQgPSAwXG4gICAgdGhpcy51cmwgPSB1cmxcbiAgICBjb25zb2xlLmxvZygnbmV3IHNlc3Npb24gd2l0aCcsIHVybClcbiAgICB0aGlzLmluZGV4RG9jID0gbmV3IFdTU2hhcmVkRG9jKClcbiAgICB0aGlzLmRvY3Muc2V0KCdpbmRleCcsIHRoaXMuaW5kZXhEb2MpXG4gICAgdGhpcy5tb2RlbCA9IG5ldyBEaXN0cmlidXRlZFByb2plY3QodGhpcy5pbmRleERvYy5kb2MpXG4gICAgdGhpcy5wcm9qZWN0Um9vdElkID0gbnVsbFxuICAgIHRoaXMuYXV0aG9yaXRhdGl2ZU1vZHVsZXMgPSBuZXcgTWFwKClcblxuICAgIHRoaXMuaW5kZXhEb2MuZG9jLm9uKCdzdWJkb2NzJywgKHN1YmRvY3M6IHsgbG9hZGVkOiBTZXQ8WS5Eb2M+IH0pID0+IHtcbiAgICAgIGZvciAoY29uc3QgZG9jIG9mIHN1YmRvY3MubG9hZGVkKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLm1vZGVsLmZpbmRNb2R1bGVCeURvY0lkKGRvYy5ndWlkKVxuICAgICAgICBpZiAoIW5hbWUpIGNvbnRpbnVlXG4gICAgICAgIGNvbnN0IHBlcnNpc3RlbmNlID0gdGhpcy5hdXRob3JpdGF0aXZlTW9kdWxlcy5nZXQobmFtZSlcbiAgICAgICAgaWYgKCFwZXJzaXN0ZW5jZSkgY29udGludWVcbiAgICAgIH1cbiAgICB9KVxuICAgIGNvbnN0IHsgY2xpZW50LCBscyB9ID0gdGhpcy5zZXR1cENsaWVudCgpXG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnRcbiAgICB0aGlzLmxzID0gbHNcbiAgfVxuXG4gIHN0YXRpYyBzZXNzaW9ucyA9IG5ldyBNYXA8c3RyaW5nLCBMYW5ndWFnZVNlcnZlclNlc3Npb24+KClcbiAgc3RhdGljIGdldCh1cmw6IHN0cmluZyk6IExhbmd1YWdlU2VydmVyU2Vzc2lvbiB7XG4gICAgY29uc3Qgc2Vzc2lvbiA9IG1hcC5zZXRJZlVuZGVmaW5lZChcbiAgICAgIExhbmd1YWdlU2VydmVyU2Vzc2lvbi5zZXNzaW9ucyxcbiAgICAgIHVybCxcbiAgICAgICgpID0+IG5ldyBMYW5ndWFnZVNlcnZlclNlc3Npb24odXJsKSxcbiAgICApXG4gICAgc2Vzc2lvbi5yZXRhaW4oKVxuICAgIHJldHVybiBzZXNzaW9uXG4gIH1cblxuICBwcml2YXRlIHJlc3RhcnRDbGllbnQoKSB7XG4gICAgdGhpcy5jbGllbnRTY29wZS5kaXNwb3NlKCdDbGllbnQgcmVzdGFydGVkLicpXG4gICAgdGhpcy5jbGllbnRTY29wZSA9IG5ldyBBYm9ydFNjb3BlKClcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSB1bmRlZmluZWRcbiAgICB0aGlzLnNldHVwQ2xpZW50KClcbiAgfVxuXG4gIHByaXZhdGUgc2V0dXBDbGllbnQoKSB7XG4gICAgdGhpcy5jbGllbnQgPSBjcmVhdGVPcGVuUlBDQ2xpZW50KHRoaXMudXJsKVxuICAgIHRoaXMubHMgPSBuZXcgTGFuZ3VhZ2VTZXJ2ZXIodGhpcy5jbGllbnQpXG4gICAgdGhpcy5jbGllbnRTY29wZS5vbkFib3J0KCgpID0+IHRoaXMubHMucmVsZWFzZSgpKVxuICAgIHRoaXMubHMub24oJ2ZpbGUvZXZlbnQnLCBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChERUJVR19MT0dfU1lOQykge1xuICAgICAgICBjb25zb2xlLmxvZygnZmlsZS9ldmVudCcsIGV2ZW50KVxuICAgICAgfVxuICAgICAgY29uc3QgcGF0aCA9IGV2ZW50LnBhdGguc2VnbWVudHMuam9pbignLycpXG4gICAgICB0cnkge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LmtpbmQpIHtcbiAgICAgICAgICBjYXNlICdBZGRlZCc6IHtcbiAgICAgICAgICAgIGlmIChpc1NvdXJjZUZpbGUoZXZlbnQucGF0aCkpIHtcbiAgICAgICAgICAgICAgY29uc3QgZmlsZUluZm8gPSBhd2FpdCB0aGlzLmxzLmZpbGVJbmZvKGV2ZW50LnBhdGgpXG4gICAgICAgICAgICAgIGlmIChmaWxlSW5mby5hdHRyaWJ1dGVzLmtpbmQudHlwZSA9PSAnRmlsZScpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBleHBvbmVudGlhbEJhY2tvZmYoXG4gICAgICAgICAgICAgICAgICAoKSA9PiB0aGlzLmdldE1vZHVsZU1vZGVsKGV2ZW50LnBhdGgpLm9wZW4oKSxcbiAgICAgICAgICAgICAgICAgIHByaW50aW5nQ2FsbGJhY2tzKGBvcGVuZWQgbmV3IGZpbGUgJyR7cGF0aH0nYCwgYG9wZW4gbmV3IGZpbGUgJyR7cGF0aH0nYCksXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdNb2RpZmllZCc6IHtcbiAgICAgICAgICAgIGF3YWl0IGV4cG9uZW50aWFsQmFja29mZihcbiAgICAgICAgICAgICAgYXN5bmMgKCkgPT4gdGhpcy50cnlHZXRFeGlzdGluZ01vZHVsZU1vZGVsKGV2ZW50LnBhdGgpPy5yZWxvYWQoKSxcbiAgICAgICAgICAgICAgcHJpbnRpbmdDYWxsYmFja3MoYHJlbG9hZGVkIGZpbGUgJyR7cGF0aH0nYCwgYHJlbG9hZCBmaWxlICcke3BhdGh9J2ApLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICB0aGlzLnJlc3RhcnRDbGllbnQoKVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5scy5vbigndGV4dC9maWxlTW9kaWZpZWRPbkRpc2snLCBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHBhdGggPSBldmVudC5wYXRoLnNlZ21lbnRzLmpvaW4oJy8nKVxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZXhwb25lbnRpYWxCYWNrb2ZmKFxuICAgICAgICAgIGFzeW5jICgpID0+IHRoaXMudHJ5R2V0RXhpc3RpbmdNb2R1bGVNb2RlbChldmVudC5wYXRoKT8ucmVsb2FkKCksXG4gICAgICAgICAgcHJpbnRpbmdDYWxsYmFja3MoYHJlbG9hZGVkIGZpbGUgJyR7cGF0aH0nYCwgYHJlbG9hZCBmaWxlICcke3BhdGh9J2ApLFxuICAgICAgICApXG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgdGhpcy5yZXN0YXJ0Q2xpZW50KClcbiAgICAgIH1cbiAgICB9KVxuICAgIGV4cG9uZW50aWFsQmFja29mZihcbiAgICAgICgpID0+IHRoaXMucmVhZEluaXRpYWxTdGF0ZSgpLFxuICAgICAgcHJpbnRpbmdDYWxsYmFja3MoJ3JlYWQgaW5pdGlhbCBzdGF0ZScsICdyZWFkIGluaXRpYWwgc3RhdGUnKSxcbiAgICApLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcignQ291bGQgbm90IHJlYWQgaW5pdGlhbCBzdGF0ZS4nKVxuICAgICAgY29uc29sZS5lcnJvcihlcnJvcilcbiAgICAgIGV4cG9uZW50aWFsQmFja29mZihcbiAgICAgICAgYXN5bmMgKCkgPT4gdGhpcy5yZXN0YXJ0Q2xpZW50KCksXG4gICAgICAgIHByaW50aW5nQ2FsbGJhY2tzKCdyZXN0YXJ0ZWQgUlBDIGNsaWVudCcsICdyZXN0YXJ0IFJQQyBjbGllbnQnKSxcbiAgICAgIClcbiAgICB9KVxuICAgIHJldHVybiB7IGNsaWVudDogdGhpcy5jbGllbnQsIGxzOiB0aGlzLmxzIH1cbiAgfVxuXG4gIHByaXZhdGUgYXNzZXJ0UHJvamVjdFJvb3QoKTogYXNzZXJ0cyB0aGlzIGlzIHsgcHJvamVjdFJvb3RJZDogVXVpZCB9IHtcbiAgICBpZiAodGhpcy5wcm9qZWN0Um9vdElkID09IG51bGwpIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwcm9qZWN0IHJvb3QnKVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyByZWFkSW5pdGlhbFN0YXRlKCkge1xuICAgIGxldCBtb2R1bGVPcGVuUHJvbWlzZXM6IFByb21pc2U8dm9pZD5bXSA9IFtdXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB0aGlzLmNvbm5lY3Rpb24gPz8gKGF3YWl0IHRoaXMubHMuaW5pdFByb3RvY29sQ29ubmVjdGlvbih0aGlzLmNsaWVudElkKSlcbiAgICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb25cbiAgICAgIGNvbnN0IHByb2plY3RSb290ID0gY29ubmVjdGlvbi5jb250ZW50Um9vdHMuZmluZCgocm9vdCkgPT4gcm9vdC50eXBlID09PSAnUHJvamVjdCcpXG4gICAgICBpZiAoIXByb2plY3RSb290KSB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcHJvamVjdCByb290JylcbiAgICAgIHRoaXMucHJvamVjdFJvb3RJZCA9IHByb2plY3RSb290LmlkXG4gICAgICBhd2FpdCB0aGlzLmxzLmFjcXVpcmVSZWNlaXZlc1RyZWVVcGRhdGVzKHsgcm9vdElkOiB0aGlzLnByb2plY3RSb290SWQsIHNlZ21lbnRzOiBbXSB9KVxuICAgICAgY29uc3QgZmlsZXMgPSBhd2FpdCB0aGlzLnNjYW5Tb3VyY2VGaWxlcygpXG4gICAgICBtb2R1bGVPcGVuUHJvbWlzZXMgPSB0aGlzLmluZGV4RG9jLmRvYy50cmFuc2FjdChcbiAgICAgICAgKCkgPT5cbiAgICAgICAgICBmaWxlcy5tYXAoKGZpbGUpID0+IHRoaXMuZ2V0TW9kdWxlTW9kZWwocHVzaFBhdGhTZWdtZW50KGZpbGUucGF0aCwgZmlsZS5uYW1lKSkub3BlbigpKSxcbiAgICAgICAgdGhpcyxcbiAgICAgIClcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKG1vZHVsZU9wZW5Qcm9taXNlcylcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignTFMgaW5pdGlhbGl6YXRpb24gZmFpbGVkLicpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgICBjb25zb2xlLmxvZygnTFMgY29ubmVjdGlvbiBpbml0aWFsaXplZC4nKVxuICB9XG5cbiAgYXN5bmMgc2NhblNvdXJjZUZpbGVzKCkge1xuICAgIHRoaXMuYXNzZXJ0UHJvamVjdFJvb3QoKVxuICAgIGNvbnN0IHNvdXJjZURpcjogUGF0aCA9IHsgcm9vdElkOiB0aGlzLnByb2plY3RSb290SWQsIHNlZ21lbnRzOiBbU09VUkNFX0RJUl0gfVxuICAgIGNvbnN0IHNyY01vZHVsZXMgPSBhd2FpdCB0aGlzLmxzLmxpc3RGaWxlcyhzb3VyY2VEaXIpXG4gICAgcmV0dXJuIHNyY01vZHVsZXMucGF0aHMuZmlsdGVyKChmaWxlKSA9PiBmaWxlLnR5cGUgPT09ICdGaWxlJyAmJiBmaWxlLm5hbWUuZW5kc1dpdGgoRVhURU5TSU9OKSlcbiAgfVxuXG4gIHRyeUdldEV4aXN0aW5nTW9kdWxlTW9kZWwocGF0aDogUGF0aCk6IE1vZHVsZVBlcnNpc3RlbmNlIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBuYW1lID0gcGF0aFRvTW9kdWxlTmFtZShwYXRoKVxuICAgIHJldHVybiB0aGlzLmF1dGhvcml0YXRpdmVNb2R1bGVzLmdldChuYW1lKVxuICB9XG5cbiAgZ2V0TW9kdWxlTW9kZWwocGF0aDogUGF0aCk6IE1vZHVsZVBlcnNpc3RlbmNlIHtcbiAgICBjb25zdCBuYW1lID0gcGF0aFRvTW9kdWxlTmFtZShwYXRoKVxuICAgIHJldHVybiBtYXAuc2V0SWZVbmRlZmluZWQodGhpcy5hdXRob3JpdGF0aXZlTW9kdWxlcywgbmFtZSwgKCkgPT4ge1xuICAgICAgY29uc3Qgd3NEb2MgPSBuZXcgV1NTaGFyZWREb2MoKVxuICAgICAgdGhpcy5kb2NzLnNldCh3c0RvYy5kb2MuZ3VpZCwgd3NEb2MpXG4gICAgICB0aGlzLm1vZGVsLmNyZWF0ZVVubG9hZGVkTW9kdWxlKG5hbWUsIHdzRG9jLmRvYylcbiAgICAgIGNvbnN0IG1vZCA9IG5ldyBNb2R1bGVQZXJzaXN0ZW5jZSh0aGlzLmxzLCBwYXRoLCB3c0RvYy5kb2MpXG4gICAgICBtb2Qub25jZSgncmVtb3ZlZCcsICgpID0+IHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm1vZGVsLmZpbmRNb2R1bGVCeURvY0lkKHdzRG9jLmRvYy5ndWlkKVxuICAgICAgICB0aGlzLmRvY3MuZGVsZXRlKHdzRG9jLmRvYy5ndWlkKVxuICAgICAgICB0aGlzLmF1dGhvcml0YXRpdmVNb2R1bGVzLmRlbGV0ZShuYW1lKVxuICAgICAgICBpZiAoaW5kZXggIT0gbnVsbCkgdGhpcy5tb2RlbC5kZWxldGVNb2R1bGUoaW5kZXgpXG4gICAgICB9KVxuICAgICAgcmV0dXJuIG1vZFxuICAgIH0pXG4gIH1cblxuICByZXRhaW4oKSB7XG4gICAgdGhpcy5yZXRhaW5Db3VudCArPSAxXG4gIH1cblxuICBhc3luYyByZWxlYXNlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMucmV0YWluQ291bnQgLT0gMVxuICAgIGlmICh0aGlzLnJldGFpbkNvdW50ICE9PSAwKSByZXR1cm5cbiAgICBjb25zdCBtb2R1bGVzID0gdGhpcy5hdXRob3JpdGF0aXZlTW9kdWxlcy52YWx1ZXMoKVxuICAgIGNvbnN0IG1vZHVsZURpc3Bvc2VQcm9taXNlcyA9IEFycmF5LmZyb20obW9kdWxlcywgKG1vZCkgPT4gbW9kLmRpc3Bvc2UoKSlcbiAgICB0aGlzLmF1dGhvcml0YXRpdmVNb2R1bGVzLmNsZWFyKClcbiAgICB0aGlzLm1vZGVsLmRvYy5kZXN0cm95KClcbiAgICB0aGlzLmNsaWVudFNjb3BlLmRpc3Bvc2UoJ0xhbmd1ZVNlcnZlclNlc3Npb24gZGlzcG9zZWQuJylcbiAgICBMYW5ndWFnZVNlcnZlclNlc3Npb24uc2Vzc2lvbnMuZGVsZXRlKHRoaXMudXJsKVxuICAgIGF3YWl0IFByb21pc2UuYWxsKG1vZHVsZURpc3Bvc2VQcm9taXNlcylcbiAgfVxuXG4gIGdldFlEb2MoZ3VpZDogc3RyaW5nKTogV1NTaGFyZWREb2MgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLmRvY3MuZ2V0KGd1aWQpXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTb3VyY2VGaWxlKHBhdGg6IFBhdGgpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICBwYXRoLnNlZ21lbnRzWzBdID09PSBTT1VSQ0VfRElSICYmIHBhdGguc2VnbWVudHNbcGF0aC5zZWdtZW50cy5sZW5ndGggLSAxXS5lbmRzV2l0aChFWFRFTlNJT04pXG4gIClcbn1cblxuZnVuY3Rpb24gcGF0aFRvTW9kdWxlTmFtZShwYXRoOiBQYXRoKTogc3RyaW5nIHtcbiAgaWYgKHBhdGguc2VnbWVudHNbMF0gPT09IFNPVVJDRV9ESVIpIHJldHVybiBwYXRoLnNlZ21lbnRzLnNsaWNlKDEpLmpvaW4oJy8nKVxuICBlbHNlIHJldHVybiAnLy8nICsgcGF0aC5zZWdtZW50cy5qb2luKCcvJylcbn1cblxuZnVuY3Rpb24gcHVzaFBhdGhTZWdtZW50KHBhdGg6IFBhdGgsIHNlZ21lbnQ6IHN0cmluZyk6IFBhdGgge1xuICByZXR1cm4geyByb290SWQ6IHBhdGgucm9vdElkLCBzZWdtZW50czogWy4uLnBhdGguc2VnbWVudHMsIHNlZ21lbnRdIH1cbn1cblxuZW51bSBMc1N5bmNTdGF0ZSB7XG4gIENsb3NlZCxcbiAgT3BlbmluZyxcbiAgU3luY2hyb25pemVkLFxuICBXcml0aW5nRmlsZSxcbiAgV3JpdGVFcnJvcixcbiAgUmVsb2FkaW5nLFxuICBDbG9zaW5nLFxuICBEaXNwb3NlZCxcbn1cblxuZW51bSBMc0FjdGlvbiB7XG4gIE9wZW4sXG4gIENsb3NlLFxuICBSZWxvYWQsXG59XG5cbmNsYXNzIE1vZHVsZVBlcnNpc3RlbmNlIGV4dGVuZHMgT2JzZXJ2YWJsZVYyPHsgcmVtb3ZlZDogKCkgPT4gdm9pZCB9PiB7XG4gIGxzOiBMYW5ndWFnZVNlcnZlclxuICBwYXRoOiBQYXRoXG4gIGRvYzogTW9kdWxlRG9jID0gbmV3IE1vZHVsZURvYyhuZXcgWS5Eb2MoKSlcbiAgcmVhZG9ubHkgc3RhdGU6IExzU3luY1N0YXRlID0gTHNTeW5jU3RhdGUuQ2xvc2VkXG4gIHJlYWRvbmx5IGxhc3RBY3Rpb24gPSBQcm9taXNlLnJlc29sdmUoKVxuICB1cGRhdGVUb0FwcGx5OiBVaW50OEFycmF5IHwgbnVsbCA9IG51bGxcbiAgc3luY2VkQ29kZTogc3RyaW5nIHwgbnVsbCA9IG51bGxcbiAgc3luY2VkSWRNYXA6IHN0cmluZyB8IG51bGwgPSBudWxsXG4gIHN5bmNlZE1ldGFKc29uOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICBzeW5jZWRDb250ZW50OiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICBzeW5jZWRWZXJzaW9uOiBDaGVja3N1bSB8IG51bGwgPSBudWxsXG4gIHN5bmNlZE1ldGE6IGZpbGVGb3JtYXQuTWV0YWRhdGEgPSBmaWxlRm9ybWF0LnRyeVBhcnNlTWV0YWRhdGFPckZhbGxiYWNrKG51bGwpXG4gIHF1ZXVlZEFjdGlvbjogTHNBY3Rpb24gfCBudWxsID0gbnVsbFxuICBjbGVhbnVwID0gKCkgPT4ge31cblxuICBjb25zdHJ1Y3RvcihsczogTGFuZ3VhZ2VTZXJ2ZXIsIHBhdGg6IFBhdGgsIHNoYXJlZERvYzogWS5Eb2MpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5scyA9IGxzXG4gICAgdGhpcy5wYXRoID0gcGF0aFxuXG4gICAgY29uc3Qgb25SZW1vdGVVcGRhdGUgPSB0aGlzLnF1ZXVlUmVtb3RlVXBkYXRlLmJpbmQodGhpcylcbiAgICBjb25zdCBvbkxvY2FsVXBkYXRlID0gKHVwZGF0ZTogVWludDhBcnJheSwgb3JpZ2luOiB1bmtub3duKSA9PiB7XG4gICAgICBpZiAob3JpZ2luID09PSAnZmlsZScpIFkuYXBwbHlVcGRhdGUoc2hhcmVkRG9jLCB1cGRhdGUsIHRoaXMpXG4gICAgfVxuICAgIGNvbnN0IG9uRmlsZU1vZGlmaWVkID0gdGhpcy5oYW5kbGVGaWxlTW9kaWZpZWQuYmluZCh0aGlzKVxuICAgIGNvbnN0IG9uRmlsZVJlbW92ZWQgPSB0aGlzLmhhbmRsZUZpbGVSZW1vdmVkLmJpbmQodGhpcylcbiAgICB0aGlzLmRvYy55ZG9jLm9uKCd1cGRhdGUnLCBvbkxvY2FsVXBkYXRlKVxuICAgIHNoYXJlZERvYy5vbigndXBkYXRlJywgb25SZW1vdGVVcGRhdGUpXG4gICAgdGhpcy5scy5vbigndGV4dC9maWxlTW9kaWZpZWRPbkRpc2snLCBvbkZpbGVNb2RpZmllZClcbiAgICB0aGlzLmxzLm9uKCdmaWxlL3Jvb3RSZW1vdmVkJywgb25GaWxlUmVtb3ZlZClcbiAgICB0aGlzLmNsZWFudXAgPSAoKSA9PiB7XG4gICAgICB0aGlzLmRvYy55ZG9jLm9mZigndXBkYXRlJywgb25Mb2NhbFVwZGF0ZSlcbiAgICAgIHNoYXJlZERvYy5vZmYoJ3VwZGF0ZScsIG9uUmVtb3RlVXBkYXRlKVxuICAgICAgdGhpcy5scy5vZmYoJ3RleHQvZmlsZU1vZGlmaWVkT25EaXNrJywgb25GaWxlTW9kaWZpZWQpXG4gICAgICB0aGlzLmxzLm9mZignZmlsZS9yb290UmVtb3ZlZCcsIG9uRmlsZVJlbW92ZWQpXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBpblN0YXRlKC4uLnN0YXRlczogTHNTeW5jU3RhdGVbXSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBzdGF0ZXMuaW5jbHVkZXModGhpcy5zdGF0ZSlcbiAgfVxuXG4gIHByaXZhdGUgc2V0U3RhdGUoc3RhdGU6IExzU3luY1N0YXRlKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IExzU3luY1N0YXRlLkRpc3Bvc2VkKSB7XG4gICAgICBpZiAoREVCVUdfTE9HX1NZTkMpIHtcbiAgICAgICAgY29uc29sZS5kZWJ1ZygnU3RhdGUgY2hhbmdlOicsIExzU3luY1N0YXRlW3RoaXMuc3RhdGVdLCAnLT4nLCBMc1N5bmNTdGF0ZVtzdGF0ZV0pXG4gICAgICB9XG4gICAgICAvLyBUaGlzIGlzIFNBRkUuIGB0aGlzLnN0YXRlYCBpcyBvbmx5IGByZWFkb25seWAgdG8gZW5zdXJlIHRoYXQgdGhpcyBpcyB0aGUgb25seSBwbGFjZVxuICAgICAgLy8gd2hlcmUgaXQgaXMgbXV0YXRlZC5cbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZVxuICAgICAgaWYgKHN0YXRlID09PSBMc1N5bmNTdGF0ZS5TeW5jaHJvbml6ZWQpIHRoaXMudHJ5U3luY1JlbW92ZVVwZGF0ZXMoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xzU3luYyBkaXNwb3NlZCcpXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzZXRMYXN0QWN0aW9uPFQ+KGxhc3RBY3Rpb246IFByb21pc2U8VD4pIHtcbiAgICAvLyBUaGlzIGlzIFNBRkUuIGB0aGlzLmxhc3RBY3Rpb25gIGlzIG9ubHkgYHJlYWRvbmx5YCB0byBlbnN1cmUgdGhhdCB0aGlzIGlzIHRoZSBvbmx5IHBsYWNlXG4gICAgLy8gd2hlcmUgaXQgaXMgbXV0YXRlZC5cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgdGhpcy5sYXN0QWN0aW9uID0gbGFzdEFjdGlvbi50aGVuKFxuICAgICAgKCkgPT4ge30sXG4gICAgICAoKSA9PiB7fSxcbiAgICApXG4gICAgcmV0dXJuIGxhc3RBY3Rpb25cbiAgfVxuXG4gIC8qKiBTZXQgdGhlIGN1cnJlbnQgc3RhdGUgdG8gdGhlIGdpdmVuIHN0YXRlIHdoaWxlIHRoZSBjYWxsYmFjayBpcyBydW5uaW5nLlxuICAgKiBTZXQgdGhlIGN1cnJlbnQgc3RhdGUgYmFjayB0byB7QGxpbmsgTHNTeW5jU3RhdGUuU3luY2hyb25pemVkfSB3aGVuIHRoZSBjYWxsYmFjayBmaW5pc2hlcy4gKi9cbiAgcHJpdmF0ZSBhc3luYyB3aXRoU3RhdGUoc3RhdGU6IExzU3luY1N0YXRlLCBjYWxsYmFjazogKCkgPT4gdm9pZCB8IFByb21pc2U8dm9pZD4pIHtcbiAgICB0aGlzLnNldFN0YXRlKHN0YXRlKVxuICAgIGF3YWl0IGNhbGxiYWNrKClcbiAgICB0aGlzLnNldFN0YXRlKExzU3luY1N0YXRlLlN5bmNocm9uaXplZClcbiAgfVxuXG4gIGFzeW5jIG9wZW4oKSB7XG4gICAgdGhpcy5xdWV1ZWRBY3Rpb24gPSBMc0FjdGlvbi5PcGVuXG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIExzU3luY1N0YXRlLkRpc3Bvc2VkOlxuICAgICAgY2FzZSBMc1N5bmNTdGF0ZS5Xcml0aW5nRmlsZTpcbiAgICAgIGNhc2UgTHNTeW5jU3RhdGUuU3luY2hyb25pemVkOlxuICAgICAgY2FzZSBMc1N5bmNTdGF0ZS5Xcml0ZUVycm9yOlxuICAgICAgY2FzZSBMc1N5bmNTdGF0ZS5SZWxvYWRpbmc6IHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBjYXNlIExzU3luY1N0YXRlLkNsb3Npbmc6IHtcbiAgICAgICAgYXdhaXQgdGhpcy5sYXN0QWN0aW9uXG4gICAgICAgIGlmICh0aGlzLnF1ZXVlZEFjdGlvbiA9PT0gTHNBY3Rpb24uT3BlbikgYXdhaXQgdGhpcy5vcGVuKClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBjYXNlIExzU3luY1N0YXRlLk9wZW5pbmc6IHtcbiAgICAgICAgYXdhaXQgdGhpcy5sYXN0QWN0aW9uXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY2FzZSBMc1N5bmNTdGF0ZS5DbG9zZWQ6IHtcbiAgICAgICAgYXdhaXQgdGhpcy53aXRoU3RhdGUoTHNTeW5jU3RhdGUuT3BlbmluZywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLmxzLm9wZW5UZXh0RmlsZSh0aGlzLnBhdGgpXG4gICAgICAgICAgdGhpcy5zZXRMYXN0QWN0aW9uKHByb21pc2UuY2F0Y2goKCkgPT4gdGhpcy5zZXRTdGF0ZShMc1N5bmNTdGF0ZS5DbG9zZWQpKSlcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9taXNlXG4gICAgICAgICAgaWYgKCFyZXN1bHQud3JpdGVDYXBhYmlsaXR5KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdDb3VsZCBub3QgYWNxdWlyZSB3cml0ZSBjYXBhYmlsaXR5IGZvciBtb2R1bGU6JywgdGhpcy5wYXRoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgQ291bGQgbm90IGFjcXVpcmUgd3JpdGUgY2FwYWJpbGl0eSBmb3IgbW9kdWxlICcke3RoaXMucGF0aC5zZWdtZW50cy5qb2luKCcvJyl9J2AsXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc3luY0ZpbGVDb250ZW50cyhyZXN1bHQuY29udGVudCwgcmVzdWx0LmN1cnJlbnRWZXJzaW9uKVxuICAgICAgICB9KVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgdGhpcy5zdGF0ZSBzYXRpc2ZpZXMgbmV2ZXJcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlRmlsZVJlbW92ZWQoKSB7XG4gICAgaWYgKHRoaXMuaW5TdGF0ZShMc1N5bmNTdGF0ZS5DbG9zZWQpKSByZXR1cm5cbiAgICB0aGlzLmNsb3NlKClcbiAgfVxuXG4gIGhhbmRsZUZpbGVNb2RpZmllZCgpIHtcbiAgICBpZiAodGhpcy5pblN0YXRlKExzU3luY1N0YXRlLkNsb3NlZCkpIHJldHVyblxuICB9XG5cbiAgcXVldWVSZW1vdGVVcGRhdGUodXBkYXRlOiBVaW50OEFycmF5LCBvcmlnaW46IHVua25vd24pIHtcbiAgICBpZiAob3JpZ2luID09PSB0aGlzKSByZXR1cm5cbiAgICBpZiAodGhpcy51cGRhdGVUb0FwcGx5ICE9IG51bGwpIHtcbiAgICAgIHRoaXMudXBkYXRlVG9BcHBseSA9IFkubWVyZ2VVcGRhdGVzKFt0aGlzLnVwZGF0ZVRvQXBwbHksIHVwZGF0ZV0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXBkYXRlVG9BcHBseSA9IHVwZGF0ZVxuICAgIH1cbiAgICB0aGlzLnRyeVN5bmNSZW1vdmVVcGRhdGVzKClcbiAgfVxuXG4gIHRyeVN5bmNSZW1vdmVVcGRhdGVzKCkge1xuICAgIGlmICh0aGlzLnVwZGF0ZVRvQXBwbHkgPT0gbnVsbCkgcmV0dXJuXG4gICAgLy8gYXBwbHkgdXBkYXRlcyB0byB0aGUgbHMtcmVwcmVzZW50YXRpb24gZG9jIGlmIHdlIGFyZSBhbHJlYWR5IGluIHN5bmMgd2l0aCB0aGUgTFMuXG4gICAgaWYgKCF0aGlzLmluU3RhdGUoTHNTeW5jU3RhdGUuU3luY2hyb25pemVkKSkgcmV0dXJuXG4gICAgY29uc3QgdXBkYXRlID0gdGhpcy51cGRhdGVUb0FwcGx5XG4gICAgdGhpcy51cGRhdGVUb0FwcGx5ID0gbnVsbFxuXG4gICAgY29uc3Qgc3luY01vZHVsZSA9IG5ldyBBc3QuTXV0YWJsZU1vZHVsZSh0aGlzLmRvYy55ZG9jKVxuICAgIGNvbnN0IG1vZHVsZVVwZGF0ZSA9IHN5bmNNb2R1bGUuYXBwbHlVcGRhdGUodXBkYXRlLCAncmVtb3RlJylcbiAgICBpZiAobW9kdWxlVXBkYXRlICYmIHRoaXMuc3luY2VkQ29udGVudCkge1xuICAgICAgY29uc3Qgc3luY2VkID0gc3BsaXRGaWxlQ29udGVudHModGhpcy5zeW5jZWRDb250ZW50KVxuICAgICAgY29uc3QgeyBuZXdDb2RlLCBuZXdJZE1hcCwgbmV3TWV0YWRhdGEgfSA9IGFwcGx5RG9jdW1lbnRVcGRhdGVzKFxuICAgICAgICB0aGlzLmRvYyxcbiAgICAgICAgc3luY2VkLFxuICAgICAgICBtb2R1bGVVcGRhdGUsXG4gICAgICApXG4gICAgICB0aGlzLnNlbmRMc1VwZGF0ZShzeW5jZWQsIG5ld0NvZGUsIG5ld0lkTWFwLCBuZXdNZXRhZGF0YSlcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNlbmRMc1VwZGF0ZShcbiAgICBzeW5jZWQ6IEVuc29GaWxlUGFydHMsXG4gICAgbmV3Q29kZTogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIG5ld0lkTWFwOiBJZE1hcCB8IHVuZGVmaW5lZCxcbiAgICBuZXdNZXRhZGF0YTogZmlsZUZvcm1hdC5JZGVNZXRhZGF0YVsnbm9kZSddIHwgdW5kZWZpbmVkLFxuICApIHtcbiAgICBpZiAodGhpcy5zeW5jZWRDb250ZW50ID09IG51bGwgfHwgdGhpcy5zeW5jZWRWZXJzaW9uID09IG51bGwpIHJldHVyblxuXG4gICAgY29uc3QgY29kZSA9IG5ld0NvZGUgPz8gc3luY2VkLmNvZGVcbiAgICBjb25zdCBuZXdNZXRhZGF0YUpzb24gPVxuICAgICAgbmV3TWV0YWRhdGEgJiZcbiAgICAgIGpzb24uc3RyaW5naWZ5KHsgLi4udGhpcy5zeW5jZWRNZXRhLCBpZGU6IHsgLi4udGhpcy5zeW5jZWRNZXRhLmlkZSwgbm9kZTogbmV3TWV0YWRhdGEgfSB9KVxuICAgIGNvbnN0IG5ld0lkTWFwSnNvbiA9IG5ld0lkTWFwICYmIHNlcmlhbGl6ZUlkTWFwKG5ld0lkTWFwKVxuICAgIGNvbnN0IG5ld0NvbnRlbnQgPSBjb21iaW5lRmlsZVBhcnRzKHtcbiAgICAgIGNvZGUsXG4gICAgICBpZE1hcEpzb246IG5ld0lkTWFwSnNvbiA/PyBzeW5jZWQuaWRNYXBKc29uID8/ICdbXScsXG4gICAgICBtZXRhZGF0YUpzb246IG5ld01ldGFkYXRhSnNvbiA/PyBzeW5jZWQubWV0YWRhdGFKc29uID8/ICd7fScsXG4gICAgfSlcblxuICAgIGNvbnN0IGVkaXRzOiBUZXh0RWRpdFtdID0gW11cbiAgICBpZiAobmV3Q29kZSkgZWRpdHMucHVzaCguLi5hcHBseURpZmZBc1RleHRFZGl0cygwLCBzeW5jZWQuY29kZSwgbmV3Q29kZSkpXG4gICAgaWYgKG5ld0lkTWFwIHx8IG5ld01ldGFkYXRhKSB7XG4gICAgICBjb25zdCBvbGRNZXRhQ29udGVudCA9IHRoaXMuc3luY2VkQ29udGVudC5zbGljZShzeW5jZWQuY29kZS5sZW5ndGgpXG4gICAgICBjb25zdCBtZXRhQ29udGVudCA9IG5ld0NvbnRlbnQuc2xpY2UoY29kZS5sZW5ndGgpXG4gICAgICBjb25zdCBtZXRhU3RhcnRMaW5lID0gKGNvZGUubWF0Y2goL1xcbi9nKSA/PyBbXSkubGVuZ3RoXG4gICAgICBlZGl0cy5wdXNoKC4uLmFwcGx5RGlmZkFzVGV4dEVkaXRzKG1ldGFTdGFydExpbmUsIG9sZE1ldGFDb250ZW50LCBtZXRhQ29udGVudCkpXG4gICAgfVxuXG4gICAgY29uc3QgbmV3VmVyc2lvbiA9IGNvbXB1dGVUZXh0Q2hlY2tzdW0obmV3Q29udGVudClcblxuICAgIGlmIChERUJVR19MT0dfU1lOQykge1xuICAgICAgY29uc29sZS5kZWJ1ZygnID09PSBjaGFuZ2VzID09PSAnKVxuICAgICAgY29uc29sZS5kZWJ1ZygnbnVtYmVyIG9mIGVkaXRzOicsIGVkaXRzLmxlbmd0aClcbiAgICAgIGlmIChlZGl0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoJ3ZlcnNpb246JywgdGhpcy5zeW5jZWRWZXJzaW9uLCAnLT4nLCBuZXdWZXJzaW9uKVxuICAgICAgICBjb25zb2xlLmRlYnVnKCdDb250ZW50IGRpZmY6JylcbiAgICAgICAgY29uc29sZS5kZWJ1ZyhwcmV0dHlQcmludERpZmYodGhpcy5zeW5jZWRDb250ZW50LCBuZXdDb250ZW50KSlcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUuZGVidWcoJyA9PT09PT09PT09PT09PT0gJylcbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKExzU3luY1N0YXRlLldyaXRpbmdGaWxlKVxuXG4gICAgY29uc3QgZXhlY3V0ZSA9IG5ld0NvZGUgIT0gbnVsbCB8fCBuZXdJZE1hcCAhPSBudWxsXG4gICAgY29uc3QgZWRpdDogRmlsZUVkaXQgPSB7IHBhdGg6IHRoaXMucGF0aCwgZWRpdHMsIG9sZFZlcnNpb246IHRoaXMuc3luY2VkVmVyc2lvbiwgbmV3VmVyc2lvbiB9XG4gICAgY29uc3QgYXBwbHkgPSB0aGlzLmxzLmFwcGx5RWRpdChlZGl0LCBleGVjdXRlKVxuICAgIGNvbnN0IHByb21pc2UgPSBhcHBseS50aGVuKFxuICAgICAgKCkgPT4ge1xuICAgICAgICB0aGlzLnN5bmNlZENvbnRlbnQgPSBuZXdDb250ZW50XG4gICAgICAgIHRoaXMuc3luY2VkVmVyc2lvbiA9IG5ld1ZlcnNpb25cbiAgICAgICAgaWYgKG5ld01ldGFkYXRhKSB0aGlzLnN5bmNlZE1ldGEuaWRlLm5vZGUgPSBuZXdNZXRhZGF0YVxuICAgICAgICBpZiAobmV3Q29kZSkgdGhpcy5zeW5jZWRDb2RlID0gbmV3Q29kZVxuICAgICAgICBpZiAobmV3SWRNYXBKc29uKSB0aGlzLnN5bmNlZElkTWFwID0gbmV3SWRNYXBKc29uXG4gICAgICAgIGlmIChuZXdNZXRhZGF0YUpzb24pIHRoaXMuc3luY2VkTWV0YUpzb24gPSBuZXdNZXRhZGF0YUpzb25cbiAgICAgICAgdGhpcy5zZXRTdGF0ZShMc1N5bmNTdGF0ZS5TeW5jaHJvbml6ZWQpXG4gICAgICB9LFxuICAgICAgKGVycm9yKSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0NvdWxkIG5vdCBhcHBseSBlZGl0OicsIGVycm9yKVxuICAgICAgICAvLyBUcnkgdG8gcmVjb3ZlciBieSByZWxvYWRpbmcgdGhlIGZpbGUuXG4gICAgICAgIC8vIERyb3AgdGhlIGF0dGVtcHRlZCB1cGRhdGVzLCBzaW5jZSBhcHBseWluZyB0aGVtIGhhdmUgZmFpbGVkLlxuICAgICAgICB0aGlzLnNldFN0YXRlKExzU3luY1N0YXRlLldyaXRlRXJyb3IpXG4gICAgICAgIHRoaXMuc3luY2VkQ29udGVudCA9IG51bGxcbiAgICAgICAgdGhpcy5zeW5jZWRWZXJzaW9uID0gbnVsbFxuICAgICAgICB0aGlzLnN5bmNlZENvZGUgPSBudWxsXG4gICAgICAgIHRoaXMuc3luY2VkSWRNYXAgPSBudWxsXG4gICAgICAgIHRoaXMuc3luY2VkTWV0YUpzb24gPSBudWxsXG4gICAgICAgIHJldHVybiB0aGlzLnJlbG9hZCgpXG4gICAgICB9LFxuICAgIClcbiAgICB0aGlzLnNldExhc3RBY3Rpb24ocHJvbWlzZSlcbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgcHJpdmF0ZSBzeW5jRmlsZUNvbnRlbnRzKGNvbnRlbnQ6IHN0cmluZywgdmVyc2lvbjogQ2hlY2tzdW0pIHtcbiAgICBjb25zdCBjb250ZW50c1JlY2VpdmVkID0gc3BsaXRGaWxlQ29udGVudHMoY29udGVudClcbiAgICBsZXQgdW5zeW5jZWRJZE1hcDogSWRNYXAgfCB1bmRlZmluZWRcbiAgICB0aGlzLmRvYy55ZG9jLnRyYW5zYWN0KCgpID0+IHtcbiAgICAgIGNvbnN0IHsgY29kZSwgaWRNYXBKc29uLCBtZXRhZGF0YUpzb24gfSA9IGNvbnRlbnRzUmVjZWl2ZWRcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gZmlsZUZvcm1hdC50cnlQYXJzZU1ldGFkYXRhT3JGYWxsYmFjayhtZXRhZGF0YUpzb24pXG4gICAgICBjb25zdCBub2RlTWV0YSA9IE9iamVjdC5lbnRyaWVzKG1ldGFkYXRhLmlkZS5ub2RlKVxuXG4gICAgICBsZXQgcGFyc2VkU3BhbnNcbiAgICAgIGNvbnN0IHN5bmNNb2R1bGUgPSBuZXcgQXN0Lk11dGFibGVNb2R1bGUodGhpcy5kb2MueWRvYylcbiAgICAgIGlmIChjb2RlICE9PSB0aGlzLnN5bmNlZENvZGUpIHtcbiAgICAgICAgY29uc3Qgc3luY1Jvb3QgPSBzeW5jTW9kdWxlLnJvb3QoKVxuICAgICAgICBpZiAoc3luY1Jvb3QpIHtcbiAgICAgICAgICBjb25zdCBlZGl0ID0gc3luY01vZHVsZS5lZGl0KClcbiAgICAgICAgICBlZGl0LmdldFZlcnNpb24oc3luY1Jvb3QpLnN5bmNUb0NvZGUoY29kZSlcbiAgICAgICAgICBjb25zdCBlZGl0ZWRSb290ID0gZWRpdC5yb290KClcbiAgICAgICAgICBpZiAoZWRpdGVkUm9vdCBpbnN0YW5jZW9mIEFzdC5Cb2R5QmxvY2spIEFzdC5yZXBhaXIoZWRpdGVkUm9vdCwgZWRpdClcbiAgICAgICAgICBzeW5jTW9kdWxlLmFwcGx5RWRpdChlZGl0KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHsgcm9vdCwgc3BhbnMgfSA9IEFzdC5wYXJzZUJsb2NrV2l0aFNwYW5zKGNvZGUsIHN5bmNNb2R1bGUpXG4gICAgICAgICAgc3luY01vZHVsZS5zeW5jUm9vdChyb290KVxuICAgICAgICAgIHBhcnNlZFNwYW5zID0gc3BhbnNcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgYXN0Um9vdCA9IHN5bmNNb2R1bGUucm9vdCgpXG4gICAgICBpZiAoIWFzdFJvb3QpIHJldHVyblxuICAgICAgaWYgKChjb2RlICE9PSB0aGlzLnN5bmNlZENvZGUgfHwgaWRNYXBKc29uICE9PSB0aGlzLnN5bmNlZElkTWFwKSAmJiBpZE1hcEpzb24pIHtcbiAgICAgICAgY29uc3QgaWRNYXAgPSBkZXNlcmlhbGl6ZUlkTWFwKGlkTWFwSnNvbilcbiAgICAgICAgY29uc3Qgc3BhbnMgPSBwYXJzZWRTcGFucyA/PyBBc3QucHJpbnQoYXN0Um9vdCkuaW5mb1xuICAgICAgICBjb25zdCBpZHNBc3NpZ25lZCA9IEFzdC5zZXRFeHRlcm5hbElkcyhzeW5jTW9kdWxlLCBzcGFucywgaWRNYXApXG4gICAgICAgIGNvbnN0IG51bWJlck9mQXN0cyA9IGFzdENvdW50KGFzdFJvb3QpXG4gICAgICAgIGNvbnN0IGlkc05vdFNldEJ5TWFwID0gbnVtYmVyT2ZBc3RzIC0gaWRzQXNzaWduZWRcbiAgICAgICAgaWYgKGlkc05vdFNldEJ5TWFwID4gMCkge1xuICAgICAgICAgIGlmIChjb2RlICE9PSB0aGlzLnN5bmNlZENvZGUpIHtcbiAgICAgICAgICAgIHVuc3luY2VkSWRNYXAgPSBBc3Quc3Bhbk1hcFRvSWRNYXAoc3BhbnMpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgYFRoZSBMUyBzZW50IGFuIElkTWFwLW9ubHkgZWRpdCB0aGF0IGlzIG1pc3NpbmcgJHtpZHNOb3RTZXRCeU1hcH0gb2Ygb3VyIGV4cGVjdGVkIEFTVHMuYCxcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgKGNvZGUgIT09IHRoaXMuc3luY2VkQ29kZSB8fFxuICAgICAgICAgIGlkTWFwSnNvbiAhPT0gdGhpcy5zeW5jZWRJZE1hcCB8fFxuICAgICAgICAgIG1ldGFkYXRhSnNvbiAhPT0gdGhpcy5zeW5jZWRNZXRhSnNvbikgJiZcbiAgICAgICAgbm9kZU1ldGEubGVuZ3RoICE9PSAwXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgZXh0ZXJuYWxJZFRvQXN0ID0gbmV3IE1hcDxFeHRlcm5hbElkLCBBc3QuQXN0PigpXG4gICAgICAgIGFzdFJvb3QudmlzaXRSZWN1cnNpdmVBc3QoKGFzdCkgPT4ge1xuICAgICAgICAgIGlmICghZXh0ZXJuYWxJZFRvQXN0Lmhhcyhhc3QuZXh0ZXJuYWxJZCkpIGV4dGVybmFsSWRUb0FzdC5zZXQoYXN0LmV4dGVybmFsSWQsIGFzdClcbiAgICAgICAgfSlcbiAgICAgICAgY29uc3QgbWlzc2luZyA9IG5ldyBTZXQ8c3RyaW5nPigpXG4gICAgICAgIGZvciAoY29uc3QgW2lkLCBtZXRhXSBvZiBub2RlTWV0YSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSBjb250aW51ZVxuICAgICAgICAgIGNvbnN0IGFzdCA9IGV4dGVybmFsSWRUb0FzdC5nZXQoaWQgYXMgRXh0ZXJuYWxJZClcbiAgICAgICAgICBpZiAoIWFzdCkge1xuICAgICAgICAgICAgbWlzc2luZy5hZGQoaWQpXG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHN5bmNNb2R1bGUuZ2V0VmVyc2lvbihhc3QpLm11dGFibGVOb2RlTWV0YWRhdGEoKVxuICAgICAgICAgIGNvbnN0IG9sZFBvcyA9IG1ldGFkYXRhLmdldCgncG9zaXRpb24nKVxuICAgICAgICAgIGNvbnN0IG5ld1BvcyA9IHsgeDogbWV0YS5wb3NpdGlvbi52ZWN0b3JbMF0sIHk6IC1tZXRhLnBvc2l0aW9uLnZlY3RvclsxXSB9XG4gICAgICAgICAgaWYgKG9sZFBvcz8ueCAhPT0gbmV3UG9zLnggfHwgb2xkUG9zPy55ICE9PSBuZXdQb3MueSkgbWV0YWRhdGEuc2V0KCdwb3NpdGlvbicsIG5ld1BvcylcbiAgICAgICAgICBjb25zdCBvbGRWaXMgPSBtZXRhZGF0YS5nZXQoJ3Zpc3VhbGl6YXRpb24nKVxuICAgICAgICAgIGNvbnN0IG5ld1ZpcyA9IG1ldGEudmlzdWFsaXphdGlvbiAmJiB0cmFuc2xhdGVWaXN1YWxpemF0aW9uRnJvbUZpbGUobWV0YS52aXN1YWxpemF0aW9uKVxuICAgICAgICAgIGlmICghdmlzTWV0YWRhdGFFcXVhbHMobmV3VmlzLCBvbGRWaXMpKSBtZXRhZGF0YS5zZXQoJ3Zpc3VhbGl6YXRpb24nLCBuZXdWaXMpXG4gICAgICAgICAgY29uc3Qgb2xkQ29sb3JPdmVycmlkZSA9IG1ldGFkYXRhLmdldCgnY29sb3JPdmVycmlkZScpXG4gICAgICAgICAgY29uc3QgbmV3Q29sb3JPdmVycmlkZSA9IG1ldGEuY29sb3JPdmVycmlkZVxuICAgICAgICAgIGlmIChvbGRDb2xvck92ZXJyaWRlICE9PSBuZXdDb2xvck92ZXJyaWRlKSBtZXRhZGF0YS5zZXQoJ2NvbG9yT3ZlcnJpZGUnLCBuZXdDb2xvck92ZXJyaWRlKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3luY2VkQ29kZSA9IGNvZGVcbiAgICAgIHRoaXMuc3luY2VkSWRNYXAgPSB1bnN5bmNlZElkTWFwID8gbnVsbCA6IGlkTWFwSnNvblxuICAgICAgdGhpcy5zeW5jZWRDb250ZW50ID0gY29udGVudFxuICAgICAgdGhpcy5zeW5jZWRWZXJzaW9uID0gdmVyc2lvblxuICAgICAgdGhpcy5zeW5jZWRNZXRhID0gbWV0YWRhdGFcbiAgICAgIHRoaXMuc3luY2VkTWV0YUpzb24gPSBtZXRhZGF0YUpzb25cbiAgICB9LCAnZmlsZScpXG4gICAgaWYgKHVuc3luY2VkSWRNYXApIHRoaXMuc2VuZExzVXBkYXRlKGNvbnRlbnRzUmVjZWl2ZWQsIHVuZGVmaW5lZCwgdW5zeW5jZWRJZE1hcCwgdW5kZWZpbmVkKVxuICB9XG5cbiAgYXN5bmMgY2xvc2UoKSB7XG4gICAgdGhpcy5xdWV1ZWRBY3Rpb24gPSBMc0FjdGlvbi5DbG9zZVxuICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBMc1N5bmNTdGF0ZS5EaXNwb3NlZDpcbiAgICAgIGNhc2UgTHNTeW5jU3RhdGUuQ2xvc2VkOiB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY2FzZSBMc1N5bmNTdGF0ZS5DbG9zaW5nOiB7XG4gICAgICAgIGF3YWl0IHRoaXMubGFzdEFjdGlvblxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGNhc2UgTHNTeW5jU3RhdGUuT3BlbmluZzpcbiAgICAgIGNhc2UgTHNTeW5jU3RhdGUuV3JpdGluZ0ZpbGU6XG4gICAgICBjYXNlIExzU3luY1N0YXRlLlJlbG9hZGluZzoge1xuICAgICAgICBhd2FpdCB0aGlzLmxhc3RBY3Rpb25cbiAgICAgICAgaWYgKHRoaXMucXVldWVkQWN0aW9uID09PSBMc0FjdGlvbi5DbG9zZSkge1xuICAgICAgICAgIGF3YWl0IHRoaXMuY2xvc2UoKVxuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY2FzZSBMc1N5bmNTdGF0ZS5Xcml0ZUVycm9yOlxuICAgICAgY2FzZSBMc1N5bmNTdGF0ZS5TeW5jaHJvbml6ZWQ6IHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShMc1N5bmNTdGF0ZS5DbG9zaW5nKVxuICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5scy5jbG9zZVRleHRGaWxlKHRoaXMucGF0aClcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlXG4gICAgICAgIHRoaXMuc2V0TGFzdEFjdGlvbihwcm9taXNlLmNhdGNoKCgpID0+IHRoaXMuc2V0U3RhdGUoc3RhdGUpKSlcbiAgICAgICAgYXdhaXQgcHJvbWlzZVxuICAgICAgICB0aGlzLnNldFN0YXRlKExzU3luY1N0YXRlLkNsb3NlZClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHRoaXMuc3RhdGUgc2F0aXNmaWVzIG5ldmVyXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHJlbG9hZCgpIHtcbiAgICB0aGlzLnF1ZXVlZEFjdGlvbiA9IExzQWN0aW9uLlJlbG9hZFxuICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBMc1N5bmNTdGF0ZS5PcGVuaW5nOlxuICAgICAgY2FzZSBMc1N5bmNTdGF0ZS5EaXNwb3NlZDpcbiAgICAgIGNhc2UgTHNTeW5jU3RhdGUuQ2xvc2VkOlxuICAgICAgY2FzZSBMc1N5bmNTdGF0ZS5DbG9zaW5nOiB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY2FzZSBMc1N5bmNTdGF0ZS5SZWxvYWRpbmc6IHtcbiAgICAgICAgYXdhaXQgdGhpcy5sYXN0QWN0aW9uXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY2FzZSBMc1N5bmNTdGF0ZS5Xcml0aW5nRmlsZToge1xuICAgICAgICBhd2FpdCB0aGlzLmxhc3RBY3Rpb25cbiAgICAgICAgaWYgKHRoaXMucXVldWVkQWN0aW9uID09PSBMc0FjdGlvbi5SZWxvYWQpIGF3YWl0IHRoaXMucmVsb2FkKClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBjYXNlIExzU3luY1N0YXRlLlN5bmNocm9uaXplZDoge1xuICAgICAgICB0aGlzLndpdGhTdGF0ZShMc1N5bmNTdGF0ZS5SZWxvYWRpbmcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICBjb25zdCBwcm9taXNlID0gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgdGhpcy5scy5yZWFkRmlsZSh0aGlzLnBhdGgpLFxuICAgICAgICAgICAgdGhpcy5scy5maWxlQ2hlY2tzdW0odGhpcy5wYXRoKSxcbiAgICAgICAgICBdKVxuICAgICAgICAgIHRoaXMuc2V0TGFzdEFjdGlvbihwcm9taXNlKVxuICAgICAgICAgIGNvbnN0IFtjb250ZW50cywgY2hlY2tzdW1dID0gYXdhaXQgcHJvbWlzZVxuICAgICAgICAgIHRoaXMuc3luY0ZpbGVDb250ZW50cyhjb250ZW50cy5jb250ZW50cywgY2hlY2tzdW0uY2hlY2tzdW0pXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY2FzZSBMc1N5bmNTdGF0ZS5Xcml0ZUVycm9yOiB7XG4gICAgICAgIHRoaXMud2l0aFN0YXRlKExzU3luY1N0YXRlLlJlbG9hZGluZywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHBhdGggPSB0aGlzLnBhdGguc2VnbWVudHMuam9pbignLycpXG4gICAgICAgICAgY29uc3QgcmVsb2FkaW5nID0gdGhpcy5sc1xuICAgICAgICAgICAgLmNsb3NlVGV4dEZpbGUodGhpcy5wYXRoKVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdDb3VsZCBub3QgY2xvc2UgZmlsZSBhZnRlciB3cml0ZSBlcnJvcjonKVxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKFxuICAgICAgICAgICAgICAoKSA9PlxuICAgICAgICAgICAgICAgIGV4cG9uZW50aWFsQmFja29mZihcbiAgICAgICAgICAgICAgICAgIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5scy5vcGVuVGV4dEZpbGUodGhpcy5wYXRoKVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC53cml0ZUNhcGFiaWxpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYENvdWxkIG5vdCBhY3F1aXJlIHdyaXRlIGNhcGFiaWxpdHkgZm9yIG1vZHVsZSAnJHt0aGlzLnBhdGguc2VnbWVudHMuam9pbihcbiAgICAgICAgICAgICAgICAgICAgICAgICcvJyxcbiAgICAgICAgICAgICAgICAgICAgICApfSdgXG4gICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBwcmludGluZ0NhbGxiYWNrcyhcbiAgICAgICAgICAgICAgICAgICAgYG9wZW5lZCBmaWxlICcke3BhdGh9JyBmb3Igd3JpdGluZ2AsXG4gICAgICAgICAgICAgICAgICAgIGBvcGVuIGZpbGUgJyR7cGF0aH0nIGZvciB3cml0aW5nYCxcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignQ291bGQgbm90IHJlb3BlbiBmaWxlIGFmdGVyIHdyaXRlIGVycm9yOicpXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcilcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGVycm9yIGlzIHVucmVjb3ZlcmFibGUuXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIClcbiAgICAgICAgICB0aGlzLnNldExhc3RBY3Rpb24ocmVsb2FkaW5nKVxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlbG9hZGluZ1xuICAgICAgICAgIHRoaXMuc3luY0ZpbGVDb250ZW50cyhyZXN1bHQuY29udGVudCwgcmVzdWx0LmN1cnJlbnRWZXJzaW9uKVxuICAgICAgICB9KVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgdGhpcy5zdGF0ZSBzYXRpc2ZpZXMgbmV2ZXJcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZGlzcG9zZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLmNsZWFudXAoKVxuICAgIGNvbnN0IGFscmVhZHlDbG9zZWQgPSB0aGlzLmluU3RhdGUoTHNTeW5jU3RhdGUuQ2xvc2luZywgTHNTeW5jU3RhdGUuQ2xvc2VkKVxuICAgIHRoaXMuc2V0U3RhdGUoTHNTeW5jU3RhdGUuRGlzcG9zZWQpXG4gICAgaWYgKGFscmVhZHlDbG9zZWQpIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgIHJldHVybiB0aGlzLmxzLmNsb3NlVGV4dEZpbGUodGhpcy5wYXRoKVxuICB9XG59XG4iLCAiY29uc3QgX192aXRlX2luamVjdGVkX29yaWdpbmFsX2Rpcm5hbWUgPSBcIkM6XFxcXFByb2plY3RzXFxcXGVuc29cXFxcZW5zb1xcXFxhcHBcXFxcZ3VpMlxcXFxzaGFyZWRcXFxcYXN0XCI7Y29uc3QgX192aXRlX2luamVjdGVkX29yaWdpbmFsX2ZpbGVuYW1lID0gXCJDOlxcXFxQcm9qZWN0c1xcXFxlbnNvXFxcXGVuc29cXFxcYXBwXFxcXGd1aTJcXFxcc2hhcmVkXFxcXGFzdFxcXFxpbmRleC50c1wiO2NvbnN0IF9fdml0ZV9pbmplY3RlZF9vcmlnaW5hbF9pbXBvcnRfbWV0YV91cmwgPSBcImZpbGU6Ly8vQzovUHJvamVjdHMvZW5zby9lbnNvL2FwcC9ndWkyL3NoYXJlZC9hc3QvaW5kZXgudHNcIjtpbXBvcnQgKiBhcyByYW5kb20gZnJvbSAnbGliMC9yYW5kb20nXG5pbXBvcnQgeyByZWFjaGFibGUgfSBmcm9tICcuLi91dGlsL2RhdGEvZ3JhcGgnXG5pbXBvcnQgdHlwZSB7IEV4dGVybmFsSWQgfSBmcm9tICcuLi95anNNb2RlbCdcbmltcG9ydCB0eXBlIHsgTW9kdWxlIH0gZnJvbSAnLi9tdXRhYmxlTW9kdWxlJ1xuaW1wb3J0IHR5cGUgeyBTeW5jVG9rZW5JZCB9IGZyb20gJy4vdG9rZW4nXG5pbXBvcnQgdHlwZSB7IEFzdElkIH0gZnJvbSAnLi90cmVlJ1xuaW1wb3J0IHsgQXBwLCBBc3QsIEdyb3VwLCBNdXRhYmxlQXN0LCBPcHJBcHAsIFdpbGRjYXJkIH0gZnJvbSAnLi90cmVlJ1xuXG5leHBvcnQgKiBmcm9tICcuL211dGFibGVNb2R1bGUnXG5leHBvcnQgKiBmcm9tICcuL3BhcnNlJ1xuZXhwb3J0ICogZnJvbSAnLi90ZXh0J1xuZXhwb3J0ICogZnJvbSAnLi90b2tlbidcbmV4cG9ydCAqIGZyb20gJy4vdHJlZSdcblxuZGVjbGFyZSBjb25zdCBicmFuZE93bmVkOiB1bmlxdWUgc3ltYm9sXG4vKiogVXNlZCB0byBtYXJrIHJlZmVyZW5jZXMgcmVxdWlyZWQgdG8gYmUgdW5pcXVlLlxuICpcbiAqICBOb3RlIHRoYXQgdGhlIHR5cGVzeXN0ZW0gY2Fubm90IHN0b3AgeW91IGZyb20gY29weWluZyBhbiBgT3duZWRgLFxuICogIGJ1dCB0aGF0IGlzIGFuIGVhc3kgbWlzdGFrZSB0byBzZWUgKGJlY2F1c2UgaXQgb2NjdXJzIGxvY2FsbHkpLlxuICpcbiAqICBXZSBjYW4gYXQgbGVhc3QgcmVxdWlyZSAqb2J0YWluaW5nKiBhbiBgT3duZWRgLFxuICogIHdoaWNoIHN0YXRpY2FsbHkgcHJldmVudHMgdGhlIG90aGVyd2lzZSBtb3N0IGxpa2VseSB1c2FnZSBlcnJvcnMgd2hlbiByZWFycmFuZ2luZyBBU1RzLlxuICovXG5leHBvcnQgdHlwZSBPd25lZDxUID0gTXV0YWJsZUFzdD4gPSBUICYgeyBbYnJhbmRPd25lZF06IG5ldmVyIH1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBhc093bmVkPFQ+KHQ6IFQpOiBPd25lZDxUPiB7XG4gIHJldHVybiB0IGFzIE93bmVkPFQ+XG59XG5cbmV4cG9ydCB0eXBlIE5vZGVDaGlsZDxUPiA9IHsgd2hpdGVzcGFjZTogc3RyaW5nIHwgdW5kZWZpbmVkOyBub2RlOiBUIH1cbmV4cG9ydCB0eXBlIFJhd05vZGVDaGlsZCA9IE5vZGVDaGlsZDxBc3RJZD4gfCBOb2RlQ2hpbGQ8U3luY1Rva2VuSWQ+XG5cbmV4cG9ydCBmdW5jdGlvbiBuZXdFeHRlcm5hbElkKCk6IEV4dGVybmFsSWQge1xuICByZXR1cm4gcmFuZG9tLnV1aWR2NCgpIGFzIEV4dGVybmFsSWRcbn1cblxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcmVudElkKGFzdDogQXN0KTogQXN0SWQgfCB1bmRlZmluZWQge1xuICByZXR1cm4gYXN0LmZpZWxkcy5nZXQoJ3BhcmVudCcpXG59XG5cbi8qKiBSZXR1cm5zIHRoZSBnaXZlbiBJRHMsIGFuZCB0aGUgSURzIG9mIGFsbCB0aGVpciBhbmNlc3RvcnMuICovXG5leHBvcnQgZnVuY3Rpb24gc3VidHJlZXMobW9kdWxlOiBNb2R1bGUsIGlkczogSXRlcmFibGU8QXN0SWQ+KSB7XG4gIHJldHVybiByZWFjaGFibGUoaWRzLCAoaWQpID0+IHtcbiAgICBjb25zdCBwYXJlbnQgPSBtb2R1bGUudHJ5R2V0KGlkKT8ucGFyZW50KClcbiAgICByZXR1cm4gcGFyZW50ID8gW3BhcmVudC5pZF0gOiBbXVxuICB9KVxufVxuXG4vKiogUmV0dXJucyB0aGUgSURzIG9mIHRoZSBBU1RzIHRoYXQgYXJlIG5vdCBkZXNjZW5kYW50cyBvZiBhbnkgb3RoZXJzIGluIHRoZSBnaXZlbiBzZXQuICovXG5leHBvcnQgZnVuY3Rpb24gc3VidHJlZVJvb3RzKG1vZHVsZTogTW9kdWxlLCBpZHM6IFNldDxBc3RJZD4pOiBTZXQ8QXN0SWQ+IHtcbiAgY29uc3Qgcm9vdHMgPSBuZXcgU2V0PEFzdElkPigpXG4gIGZvciAoY29uc3QgaWQgb2YgaWRzKSB7XG4gICAgY29uc3QgYXN0SW5Nb2R1bGUgPSBtb2R1bGUudHJ5R2V0KGlkKVxuICAgIGlmICghYXN0SW5Nb2R1bGUpIGNvbnRpbnVlXG4gICAgbGV0IGFzdCA9IGFzdEluTW9kdWxlLnBhcmVudCgpXG4gICAgbGV0IGhhc1BhcmVudEluU2V0XG4gICAgd2hpbGUgKGFzdCAhPSBudWxsKSB7XG4gICAgICBpZiAoaWRzLmhhcyhhc3QuaWQpKSB7XG4gICAgICAgIGhhc1BhcmVudEluU2V0ID0gdHJ1ZVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgYXN0ID0gYXN0LnBhcmVudCgpXG4gICAgfVxuICAgIGlmICghaGFzUGFyZW50SW5TZXQpIHJvb3RzLmFkZChpZClcbiAgfVxuICByZXR1cm4gcm9vdHNcbn1cblxuZnVuY3Rpb24gdW53cmFwR3JvdXBzKGFzdDogQXN0KSB7XG4gIHdoaWxlIChhc3QgaW5zdGFuY2VvZiBHcm91cCAmJiBhc3QuZXhwcmVzc2lvbikgYXN0ID0gYXN0LmV4cHJlc3Npb25cbiAgcmV0dXJuIGFzdFxufVxuXG4vKiogVHJpZXMgdG8gcmVjb2duaXplIGlucHV0cyB0aGF0IGFyZSBzZW1hbnRpY2FsbHktZXF1aXZhbGVudCB0byBhIHNlcXVlbmNlIG9mIGBBcHBgcywgYW5kIHJldHVybnMgdGhlIGFyZ3VtZW50c1xuICogIGlkZW50aWZpZWQgYW5kIExIUyBvZiB0aGUgYW5hbHl6YWJsZSBjaGFpbi5cbiAqXG4gKiAgSW4gcGFydGljdWxhciwgdGhpcyBmdW5jdGlvbiBjdXJyZW50bHkgcmVjb2duaXplcyBzeW50YXggdXNlZCBpbiB2aXN1YWxpemF0aW9uLXByZXByb2Nlc3NvciBleHByZXNzaW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFuYWx5emVBcHBMaWtlKGFzdDogQXN0KTogeyBmdW5jOiBBc3Q7IGFyZ3M6IEFzdFtdIH0ge1xuICBjb25zdCBkZWZlcnJlZE9wZXJhbmRzID0gbmV3IEFycmF5PEFzdD4oKVxuICB3aGlsZSAoXG4gICAgYXN0IGluc3RhbmNlb2YgT3ByQXBwICYmXG4gICAgYXN0Lm9wZXJhdG9yLm9rICYmXG4gICAgYXN0Lm9wZXJhdG9yLnZhbHVlLmNvZGUoKSA9PT0gJzx8JyAmJlxuICAgIGFzdC5saHMgJiZcbiAgICBhc3QucmhzXG4gICkge1xuICAgIGRlZmVycmVkT3BlcmFuZHMucHVzaCh1bndyYXBHcm91cHMoYXN0LnJocykpXG4gICAgYXN0ID0gdW53cmFwR3JvdXBzKGFzdC5saHMpXG4gIH1cbiAgZGVmZXJyZWRPcGVyYW5kcy5yZXZlcnNlKClcbiAgY29uc3QgYXJncyA9IG5ldyBBcnJheTxBc3Q+KClcbiAgd2hpbGUgKGFzdCBpbnN0YW5jZW9mIEFwcCkge1xuICAgIGNvbnN0IGRlZmVycmVkT3BlcmFuZCA9IGFzdC5hcmd1bWVudCBpbnN0YW5jZW9mIFdpbGRjYXJkID8gZGVmZXJyZWRPcGVyYW5kcy5wb3AoKSA6IHVuZGVmaW5lZFxuICAgIGFyZ3MucHVzaChkZWZlcnJlZE9wZXJhbmQgPz8gdW53cmFwR3JvdXBzKGFzdC5hcmd1bWVudCkpXG4gICAgYXN0ID0gYXN0LmZ1bmN0aW9uXG4gIH1cbiAgYXJncy5yZXZlcnNlKClcbiAgcmV0dXJuIHsgZnVuYzogYXN0LCBhcmdzIH1cbn1cbiIsICJjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfZGlybmFtZSA9IFwiQzpcXFxcUHJvamVjdHNcXFxcZW5zb1xcXFxlbnNvXFxcXGFwcFxcXFxndWkyXFxcXHNoYXJlZFxcXFx1dGlsXFxcXGRhdGFcIjtjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfZmlsZW5hbWUgPSBcIkM6XFxcXFByb2plY3RzXFxcXGVuc29cXFxcZW5zb1xcXFxhcHBcXFxcZ3VpMlxcXFxzaGFyZWRcXFxcdXRpbFxcXFxkYXRhXFxcXHJlc3VsdC50c1wiO2NvbnN0IF9fdml0ZV9pbmplY3RlZF9vcmlnaW5hbF9pbXBvcnRfbWV0YV91cmwgPSBcImZpbGU6Ly8vQzovUHJvamVjdHMvZW5zby9lbnNvL2FwcC9ndWkyL3NoYXJlZC91dGlsL2RhdGEvcmVzdWx0LnRzXCI7LyoqIEBmaWxlIEEgZ2VuZXJpYyB0eXBlIHRoYXQgY2FuIGVpdGhlciBob2xkIGEgdmFsdWUgcmVwcmVzZW50aW5nIGEgc3VjY2Vzc2Z1bCByZXN1bHQsXG4gKiBvciBhbiBlcnJvci4gKi9cblxuaW1wb3J0IHsgaXNTb21lLCB0eXBlIE9wdCB9IGZyb20gJy4vb3B0J1xuXG5leHBvcnQgdHlwZSBSZXN1bHQ8VCA9IHVuZGVmaW5lZCwgRSA9IHN0cmluZz4gPVxuICB8IHsgb2s6IHRydWU7IHZhbHVlOiBUIH1cbiAgfCB7IG9rOiBmYWxzZTsgZXJyb3I6IFJlc3VsdEVycm9yPEU+IH1cblxuZXhwb3J0IGZ1bmN0aW9uIE9rPFQ+KGRhdGE6IFQpOiBSZXN1bHQ8VCwgbmV2ZXI+IHtcbiAgcmV0dXJuIHsgb2s6IHRydWUsIHZhbHVlOiBkYXRhIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEVycjxFPihlcnJvcjogRSk6IFJlc3VsdDxuZXZlciwgRT4ge1xuICByZXR1cm4geyBvazogZmFsc2UsIGVycm9yOiBuZXcgUmVzdWx0RXJyb3IoZXJyb3IpIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9rT3I8VCwgRT4oZGF0YTogT3B0PFQ+LCBlcnJvcjogRSk6IFJlc3VsdDxULCBFPiB7XG4gIGlmIChpc1NvbWUoZGF0YSkpIHJldHVybiBPayhkYXRhKVxuICBlbHNlIHJldHVybiBFcnIoZXJyb3IpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bndyYXA8VCwgRT4ocmVzdWx0OiBSZXN1bHQ8VCwgRT4pOiBUIHtcbiAgaWYgKHJlc3VsdC5vaykgcmV0dXJuIHJlc3VsdC52YWx1ZVxuICBlbHNlIHRocm93IHJlc3VsdC5lcnJvclxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFwT2s8VCwgVSwgRT4ocmVzdWx0OiBSZXN1bHQ8VCwgRT4sIGY6ICh2YWx1ZTogVCkgPT4gVSk6IFJlc3VsdDxVLCBFPiB7XG4gIGlmIChyZXN1bHQub2spIHJldHVybiBPayhmKHJlc3VsdC52YWx1ZSkpXG4gIGVsc2UgcmV0dXJuIHJlc3VsdFxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNSZXN1bHQodjogdW5rbm93bik6IHYgaXMgUmVzdWx0IHtcbiAgcmV0dXJuIChcbiAgICB2ICE9IG51bGwgJiZcbiAgICB0eXBlb2YgdiA9PT0gJ29iamVjdCcgJiZcbiAgICAnb2snIGluIHYgJiZcbiAgICB0eXBlb2Ygdi5vayA9PT0gJ2Jvb2xlYW4nICYmXG4gICAgKCd2YWx1ZScgaW4gdiB8fCAoJ2Vycm9yJyBpbiB2ICYmIHYuZXJyb3IgaW5zdGFuY2VvZiBSZXN1bHRFcnJvcikpXG4gIClcbn1cblxuZXhwb3J0IGNsYXNzIFJlc3VsdEVycm9yPEUgPSBzdHJpbmc+IHtcbiAgcGF5bG9hZDogRVxuICBjb250ZXh0OiAoKCkgPT4gc3RyaW5nKVtdXG5cbiAgY29uc3RydWN0b3IocGF5bG9hZDogRSkge1xuICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWRcbiAgICB0aGlzLmNvbnRleHQgPSBbXVxuICB9XG5cbiAgbG9nKHByZWFtYmxlOiBzdHJpbmcgPSAnRXJyb3InKSB7XG4gICAgY29uc29sZS5lcnJvcih0aGlzLm1lc3NhZ2UocHJlYW1ibGUpKVxuICB9XG5cbiAgbWVzc2FnZShwcmVhbWJsZTogc3RyaW5nID0gJ2Vycm9yJykge1xuICAgIGNvbnN0IGN0eCA9XG4gICAgICB0aGlzLmNvbnRleHQubGVuZ3RoID4gMCA/IGBcXG4ke0FycmF5LmZyb20odGhpcy5jb250ZXh0LCAoY3R4KSA9PiBjdHgoKSkuam9pbignXFxuJyl9YCA6ICcnXG4gICAgcmV0dXJuIGAke3ByZWFtYmxlfTogJHt0aGlzLnBheWxvYWR9JHtjdHh9YFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3aXRoQ29udGV4dDxULCBFPihjb250ZXh0OiAoKSA9PiBzdHJpbmcsIGY6ICgpID0+IFJlc3VsdDxULCBFPik6IFJlc3VsdDxULCBFPiB7XG4gIGNvbnN0IHJlc3VsdCA9IGYoKVxuICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3dpdGhDb250ZXh0OiBmKCkgcmV0dXJuZWQgbnVsbCBvciB1bmRlZmluZWQnKVxuICB9XG4gIGlmICghcmVzdWx0Lm9rKSByZXN1bHQuZXJyb3IuY29udGV4dC5zcGxpY2UoMCwgMCwgY29udGV4dClcbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKipcbiAqIENhdGNoIHByb21pc2UgcmVqZWN0aW9uIG9mIHByb3ZpZGVkIHR5cGVzIGFuZCBjb252ZXJ0IHRoZW0gdG8gYSBSZXN1bHQgdHlwZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlamVjdGlvblRvUmVzdWx0PEVycm9yS2luZCBleHRlbmRzIG5ldyAoLi4uYXJnczogYW55W10pID0+IGFueT4oXG4gIGVycm9yS2luZHM6IEVycm9yS2luZCB8IEVycm9yS2luZFtdLFxuKTogPFQ+KHByb21pc2U6IFByb21pc2U8VD4pID0+IFByb21pc2U8UmVzdWx0PFQsIEluc3RhbmNlVHlwZTxFcnJvcktpbmQ+Pj4ge1xuICBjb25zdCBlcnJvcktpbmRBcnJheSA9IEFycmF5LmlzQXJyYXkoZXJyb3JLaW5kcykgPyBlcnJvcktpbmRzIDogW2Vycm9yS2luZHNdXG4gIHJldHVybiBhc3luYyAocHJvbWlzZSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gT2soYXdhaXQgcHJvbWlzZSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZm9yIChjb25zdCBlcnJvcktpbmQgb2YgZXJyb3JLaW5kQXJyYXkpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgZXJyb3JLaW5kKSByZXR1cm4gRXJyKGVycm9yKVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cbn1cbiIsICJjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfZGlybmFtZSA9IFwiQzpcXFxcUHJvamVjdHNcXFxcZW5zb1xcXFxlbnNvXFxcXGFwcFxcXFxndWkyXFxcXHNoYXJlZFwiO2NvbnN0IF9fdml0ZV9pbmplY3RlZF9vcmlnaW5hbF9maWxlbmFtZSA9IFwiQzpcXFxcUHJvamVjdHNcXFxcZW5zb1xcXFxlbnNvXFxcXGFwcFxcXFxndWkyXFxcXHNoYXJlZFxcXFx5anNNb2RlbC50c1wiO2NvbnN0IF9fdml0ZV9pbmplY3RlZF9vcmlnaW5hbF9pbXBvcnRfbWV0YV91cmwgPSBcImZpbGU6Ly8vQzovUHJvamVjdHMvZW5zby9lbnNvL2FwcC9ndWkyL3NoYXJlZC95anNNb2RlbC50c1wiO2ltcG9ydCAqIGFzIG9iamVjdCBmcm9tICdsaWIwL29iamVjdCdcbmltcG9ydCAqIGFzIHJhbmRvbSBmcm9tICdsaWIwL3JhbmRvbSdcbmltcG9ydCAqIGFzIFkgZnJvbSAneWpzJ1xuXG5leHBvcnQgdHlwZSBVdWlkID0gYCR7c3RyaW5nfS0ke3N0cmluZ30tJHtzdHJpbmd9LSR7c3RyaW5nfS0ke3N0cmluZ31gXG5cbmRlY2xhcmUgY29uc3QgYnJhbmRFeHRlcm5hbElkOiB1bmlxdWUgc3ltYm9sXG4vKiogSWRlbnRpZmllcyBhbiBBU1Qgbm9kZSBvciB0b2tlbi4gVXNlZCBpbiBtb2R1bGUgc2VyaWFsaXphdGlvbiBhbmQgY29tbXVuaWNhdGlvbiB3aXRoIHRoZSBsYW5ndWFnZSBzZXJ2ZXIuICovXG5leHBvcnQgdHlwZSBFeHRlcm5hbElkID0gVXVpZCAmIHsgW2JyYW5kRXh0ZXJuYWxJZF06IG5ldmVyIH1cblxuZXhwb3J0IHR5cGUgVmlzdWFsaXphdGlvbk1vZHVsZSA9XG4gIHwgeyBraW5kOiAnQnVpbHRpbicgfVxuICB8IHsga2luZDogJ0N1cnJlbnRQcm9qZWN0JyB9XG4gIHwgeyBraW5kOiAnTGlicmFyeSc7IG5hbWU6IHN0cmluZyB9XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmlzdWFsaXphdGlvbklkZW50aWZpZXIge1xuICBtb2R1bGU6IFZpc3VhbGl6YXRpb25Nb2R1bGVcbiAgbmFtZTogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmlzdWFsaXphdGlvbk1ldGFkYXRhIHtcbiAgaWRlbnRpZmllcjogVmlzdWFsaXphdGlvbklkZW50aWZpZXIgfCBudWxsXG4gIHZpc2libGU6IGJvb2xlYW5cbiAgZnVsbHNjcmVlbjogYm9vbGVhblxuICB3aWR0aDogbnVtYmVyIHwgbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmlzTWV0YWRhdGFFcXVhbHMoXG4gIGE6IFZpc3VhbGl6YXRpb25NZXRhZGF0YSB8IG51bGwgfCB1bmRlZmluZWQsXG4gIGI6IFZpc3VhbGl6YXRpb25NZXRhZGF0YSB8IG51bGwgfCB1bmRlZmluZWQsXG4pIHtcbiAgcmV0dXJuIChcbiAgICAoIWEgJiYgIWIpIHx8XG4gICAgKGEgJiZcbiAgICAgIGIgJiZcbiAgICAgIGEudmlzaWJsZSA9PT0gYi52aXNpYmxlICYmXG4gICAgICBhLmZ1bGxzY3JlZW4gPT0gYi5mdWxsc2NyZWVuICYmXG4gICAgICBhLndpZHRoID09IGIud2lkdGggJiZcbiAgICAgIHZpc0lkZW50aWZpZXJFcXVhbHMoYS5pZGVudGlmaWVyLCBiLmlkZW50aWZpZXIpKVxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2aXNJZGVudGlmaWVyRXF1YWxzKFxuICBhOiBWaXN1YWxpemF0aW9uSWRlbnRpZmllciB8IG51bGwgfCB1bmRlZmluZWQsXG4gIGI6IFZpc3VhbGl6YXRpb25JZGVudGlmaWVyIHwgbnVsbCB8IHVuZGVmaW5lZCxcbikge1xuICByZXR1cm4gKCFhICYmICFiKSB8fCAoYSAmJiBiICYmIGEubmFtZSA9PT0gYi5uYW1lICYmIG9iamVjdC5lcXVhbEZsYXQoYS5tb2R1bGUsIGIubW9kdWxlKSlcbn1cblxuZXhwb3J0IHR5cGUgUHJvamVjdFNldHRpbmcgPSBzdHJpbmdcblxuZXhwb3J0IGNsYXNzIERpc3RyaWJ1dGVkUHJvamVjdCB7XG4gIGRvYzogWS5Eb2NcbiAgbmFtZTogWS5UZXh0XG4gIG1vZHVsZXM6IFkuTWFwPFkuRG9jPlxuICBzZXR0aW5nczogWS5NYXA8UHJvamVjdFNldHRpbmc+XG5cbiAgY29uc3RydWN0b3IoZG9jOiBZLkRvYykge1xuICAgIHRoaXMuZG9jID0gZG9jXG4gICAgdGhpcy5uYW1lID0gdGhpcy5kb2MuZ2V0VGV4dCgnbmFtZScpXG4gICAgdGhpcy5tb2R1bGVzID0gdGhpcy5kb2MuZ2V0TWFwKCdtb2R1bGVzJylcbiAgICB0aGlzLnNldHRpbmdzID0gdGhpcy5kb2MuZ2V0TWFwKCdzZXR0aW5ncycpXG4gIH1cblxuICBtb2R1bGVOYW1lcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5tb2R1bGVzLmtleXMoKSlcbiAgfVxuXG4gIGZpbmRNb2R1bGVCeURvY0lkKGlkOiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCBkb2NdIG9mIHRoaXMubW9kdWxlcy5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChkb2MuZ3VpZCA9PT0gaWQpIHJldHVybiBuYW1lXG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBhc3luYyBvcGVuTW9kdWxlKG5hbWU6IHN0cmluZyk6IFByb21pc2U8RGlzdHJpYnV0ZWRNb2R1bGUgfCBudWxsPiB7XG4gICAgY29uc3QgZG9jID0gdGhpcy5tb2R1bGVzLmdldChuYW1lKVxuICAgIGlmIChkb2MgPT0gbnVsbCkgcmV0dXJuIG51bGxcbiAgICByZXR1cm4gYXdhaXQgRGlzdHJpYnV0ZWRNb2R1bGUubG9hZChkb2MpXG4gIH1cblxuICBvcGVuVW5sb2FkZWRNb2R1bGUobmFtZTogc3RyaW5nKTogRGlzdHJpYnV0ZWRNb2R1bGUgfCBudWxsIHtcbiAgICBjb25zdCBkb2MgPSB0aGlzLm1vZHVsZXMuZ2V0KG5hbWUpXG4gICAgaWYgKGRvYyA9PSBudWxsKSByZXR1cm4gbnVsbFxuICAgIHJldHVybiBuZXcgRGlzdHJpYnV0ZWRNb2R1bGUoZG9jKVxuICB9XG5cbiAgY3JlYXRlVW5sb2FkZWRNb2R1bGUobmFtZTogc3RyaW5nLCBkb2M6IFkuRG9jKTogRGlzdHJpYnV0ZWRNb2R1bGUge1xuICAgIHRoaXMubW9kdWxlcy5zZXQobmFtZSwgZG9jKVxuICAgIHJldHVybiBuZXcgRGlzdHJpYnV0ZWRNb2R1bGUoZG9jKVxuICB9XG5cbiAgY3JlYXRlTmV3TW9kdWxlKG5hbWU6IHN0cmluZyk6IERpc3RyaWJ1dGVkTW9kdWxlIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVVbmxvYWRlZE1vZHVsZShuYW1lLCBuZXcgWS5Eb2MoKSlcbiAgfVxuXG4gIGRlbGV0ZU1vZHVsZShuYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLm1vZHVsZXMuZGVsZXRlKG5hbWUpXG4gIH1cblxuICBkaXNwb3NlKCk6IHZvaWQge1xuICAgIHRoaXMuZG9jLmRlc3Ryb3koKVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBNb2R1bGVEb2Mge1xuICB5ZG9jOiBZLkRvY1xuICBub2RlczogWS5NYXA8YW55PlxuICBjb25zdHJ1Y3Rvcih5ZG9jOiBZLkRvYykge1xuICAgIHRoaXMueWRvYyA9IHlkb2NcbiAgICB0aGlzLm5vZGVzID0geWRvYy5nZXRNYXAoJ25vZGVzJylcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRGlzdHJpYnV0ZWRNb2R1bGUge1xuICBkb2M6IE1vZHVsZURvY1xuICB1bmRvTWFuYWdlcjogWS5VbmRvTWFuYWdlclxuXG4gIHN0YXRpYyBhc3luYyBsb2FkKHlkb2M6IFkuRG9jKTogUHJvbWlzZTxEaXN0cmlidXRlZE1vZHVsZT4ge1xuICAgIHlkb2MubG9hZCgpXG4gICAgYXdhaXQgeWRvYy53aGVuTG9hZGVkXG4gICAgcmV0dXJuIG5ldyBEaXN0cmlidXRlZE1vZHVsZSh5ZG9jKVxuICB9XG5cbiAgY29uc3RydWN0b3IoeWRvYzogWS5Eb2MpIHtcbiAgICB0aGlzLmRvYyA9IG5ldyBNb2R1bGVEb2MoeWRvYylcbiAgICB0aGlzLnVuZG9NYW5hZ2VyID0gbmV3IFkuVW5kb01hbmFnZXIoW3RoaXMuZG9jLm5vZGVzXSlcbiAgfVxuXG4gIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgdGhpcy5kb2MueWRvYy5kZXN0cm95KClcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgbG9jYWxVc2VyQWN0aW9uT3JpZ2lucyA9IFsnbG9jYWw6dXNlckFjdGlvbicsICdsb2NhbDp1c2VyQWN0aW9uOkNvZGVFZGl0b3InXSBhcyBjb25zdFxuZXhwb3J0IHR5cGUgTG9jYWxVc2VyQWN0aW9uT3JpZ2luID0gKHR5cGVvZiBsb2NhbFVzZXJBY3Rpb25PcmlnaW5zKVtudW1iZXJdXG5leHBvcnQgdHlwZSBPcmlnaW4gPSBMb2NhbFVzZXJBY3Rpb25PcmlnaW4gfCAncmVtb3RlJyB8ICdsb2NhbDphdXRvTGF5b3V0J1xuLyoqIExvY2FsbHktb3JpZ2luYXRlZCBjaGFuZ2VzIG5vdCBvdGhlcndpc2Ugc3BlY2lmaWVkLiAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRMb2NhbE9yaWdpbjogTG9jYWxVc2VyQWN0aW9uT3JpZ2luID0gJ2xvY2FsOnVzZXJBY3Rpb24nXG5leHBvcnQgZnVuY3Rpb24gaXNMb2NhbFVzZXJBY3Rpb25PcmlnaW4ob3JpZ2luOiBzdHJpbmcpOiBvcmlnaW4gaXMgTG9jYWxVc2VyQWN0aW9uT3JpZ2luIHtcbiAgY29uc3QgbG9jYWxPcmlnaW5OYW1lczogcmVhZG9ubHkgc3RyaW5nW10gPSBsb2NhbFVzZXJBY3Rpb25PcmlnaW5zXG4gIHJldHVybiBsb2NhbE9yaWdpbk5hbWVzLmluY2x1ZGVzKG9yaWdpbilcbn1cbmV4cG9ydCBmdW5jdGlvbiB0cnlBc09yaWdpbihvcmlnaW46IHN0cmluZyk6IE9yaWdpbiB8IHVuZGVmaW5lZCB7XG4gIGlmIChpc0xvY2FsVXNlckFjdGlvbk9yaWdpbihvcmlnaW4pKSByZXR1cm4gb3JpZ2luXG4gIGlmIChvcmlnaW4gPT09ICdsb2NhbDphdXRvTGF5b3V0JykgcmV0dXJuIG9yaWdpblxuICBpZiAob3JpZ2luID09PSAncmVtb3RlJykgcmV0dXJuIG9yaWdpblxufVxuXG5leHBvcnQgdHlwZSBTb3VyY2VSYW5nZSA9IHJlYWRvbmx5IFtzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcl1cbmRlY2xhcmUgY29uc3QgYnJhbmRTb3VyY2VSYW5nZUtleTogdW5pcXVlIHN5bWJvbFxuZXhwb3J0IHR5cGUgU291cmNlUmFuZ2VLZXkgPSBzdHJpbmcgJiB7IFticmFuZFNvdXJjZVJhbmdlS2V5XTogbmV2ZXIgfVxuXG5leHBvcnQgZnVuY3Rpb24gc291cmNlUmFuZ2VLZXkocmFuZ2U6IFNvdXJjZVJhbmdlKTogU291cmNlUmFuZ2VLZXkge1xuICByZXR1cm4gYCR7cmFuZ2VbMF0udG9TdHJpbmcoMTYpfToke3JhbmdlWzFdLnRvU3RyaW5nKDE2KX1gIGFzIFNvdXJjZVJhbmdlS2V5XG59XG5leHBvcnQgZnVuY3Rpb24gc291cmNlUmFuZ2VGcm9tS2V5KGtleTogU291cmNlUmFuZ2VLZXkpOiBTb3VyY2VSYW5nZSB7XG4gIHJldHVybiBrZXkuc3BsaXQoJzonKS5tYXAoKHgpID0+IHBhcnNlSW50KHgsIDE2KSkgYXMgW251bWJlciwgbnVtYmVyXVxufVxuXG5leHBvcnQgY2xhc3MgSWRNYXAge1xuICBwcml2YXRlIHJlYWRvbmx5IHJhbmdlVG9FeHByOiBNYXA8c3RyaW5nLCBFeHRlcm5hbElkPlxuXG4gIGNvbnN0cnVjdG9yKGVudHJpZXM/OiBbc3RyaW5nLCBFeHRlcm5hbElkXVtdKSB7XG4gICAgdGhpcy5yYW5nZVRvRXhwciA9IG5ldyBNYXAoZW50cmllcyA/PyBbXSlcbiAgfVxuXG4gIHN0YXRpYyBNb2NrKCk6IElkTWFwIHtcbiAgICByZXR1cm4gbmV3IElkTWFwKFtdKVxuICB9XG5cbiAgaW5zZXJ0S25vd25JZChyYW5nZTogU291cmNlUmFuZ2UsIGlkOiBFeHRlcm5hbElkKSB7XG4gICAgY29uc3Qga2V5ID0gc291cmNlUmFuZ2VLZXkocmFuZ2UpXG4gICAgdGhpcy5yYW5nZVRvRXhwci5zZXQoa2V5LCBpZClcbiAgfVxuXG4gIGdldElmRXhpc3QocmFuZ2U6IFNvdXJjZVJhbmdlKTogRXh0ZXJuYWxJZCB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3Qga2V5ID0gc291cmNlUmFuZ2VLZXkocmFuZ2UpXG4gICAgcmV0dXJuIHRoaXMucmFuZ2VUb0V4cHIuZ2V0KGtleSlcbiAgfVxuXG4gIGdldE9ySW5zZXJ0VW5pcXVlSWQocmFuZ2U6IFNvdXJjZVJhbmdlKTogRXh0ZXJuYWxJZCB7XG4gICAgY29uc3Qga2V5ID0gc291cmNlUmFuZ2VLZXkocmFuZ2UpXG4gICAgY29uc3QgdmFsID0gdGhpcy5yYW5nZVRvRXhwci5nZXQoa2V5KVxuICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHZhbFxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBuZXdJZCA9IHJhbmRvbS51dWlkdjQoKSBhcyBFeHRlcm5hbElkXG4gICAgICB0aGlzLnJhbmdlVG9FeHByLnNldChrZXksIG5ld0lkKVxuICAgICAgcmV0dXJuIG5ld0lkXG4gICAgfVxuICB9XG5cbiAgZW50cmllcygpOiBbU291cmNlUmFuZ2VLZXksIEV4dGVybmFsSWRdW10ge1xuICAgIHJldHVybiBbLi4udGhpcy5yYW5nZVRvRXhwcl0gYXMgW1NvdXJjZVJhbmdlS2V5LCBFeHRlcm5hbElkXVtdXG4gIH1cblxuICBnZXQgc2l6ZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnJhbmdlVG9FeHByLnNpemVcbiAgfVxuXG4gIGNsZWFyKCk6IHZvaWQge1xuICAgIHRoaXMucmFuZ2VUb0V4cHIuY2xlYXIoKVxuICB9XG5cbiAgaXNFcXVhbChvdGhlcjogSWRNYXApOiBib29sZWFuIHtcbiAgICBpZiAob3RoZXIuc2l6ZSAhPT0gdGhpcy5zaXplKSByZXR1cm4gZmFsc2VcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLnJhbmdlVG9FeHByLmVudHJpZXMoKSkge1xuICAgICAgY29uc3Qgb2xkVmFsdWUgPSBvdGhlci5yYW5nZVRvRXhwci5nZXQoa2V5KVxuICAgICAgaWYgKG9sZFZhbHVlICE9PSB2YWx1ZSkgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICB2YWxpZGF0ZSgpIHtcbiAgICBjb25zdCB1bmlxdWVWYWx1ZXMgPSBuZXcgU2V0KHRoaXMucmFuZ2VUb0V4cHIudmFsdWVzKCkpXG4gICAgaWYgKHVuaXF1ZVZhbHVlcy5zaXplIDwgdGhpcy5yYW5nZVRvRXhwci5zaXplKSB7XG4gICAgICBjb25zb2xlLndhcm4oYER1cGxpY2F0ZSBVVUlEIGluIElkTWFwYClcbiAgICB9XG4gIH1cblxuICBjbG9uZSgpOiBJZE1hcCB7XG4gICAgcmV0dXJuIG5ldyBJZE1hcCh0aGlzLmVudHJpZXMoKSlcbiAgfVxuXG4gIC8vIERlYnVnZ2luZy5cbiAgY29tcGFyZShvdGhlcjogSWRNYXApIHtcbiAgICBjb25zb2xlLmluZm8oYElkTWFwLmNvbXBhcmUgLS0tLS0tLWApXG4gICAgY29uc3QgYWxsS2V5cyA9IG5ldyBTZXQ8c3RyaW5nPigpXG4gICAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy5yYW5nZVRvRXhwci5rZXlzKCkpIGFsbEtleXMuYWRkKGtleSlcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBvdGhlci5yYW5nZVRvRXhwci5rZXlzKCkpIGFsbEtleXMuYWRkKGtleSlcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBhbGxLZXlzKSB7XG4gICAgICBjb25zdCBtaW5lID0gdGhpcy5yYW5nZVRvRXhwci5nZXQoa2V5KVxuICAgICAgY29uc3QgeW91cnMgPSBvdGhlci5yYW5nZVRvRXhwci5nZXQoa2V5KVxuICAgICAgaWYgKG1pbmUgIT09IHlvdXJzKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhgSWRNYXAuY29tcGFyZVske2tleX1dOiAke21pbmV9IC0+ICR7eW91cnN9YClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuY29uc3QgdXVpZFJlZ2V4ID0gL15bMC05YS1mXXs4fS0oPzpbMC05YS1mXXs0fS0pezN9WzAtOWEtZl17MTJ9JC9cbmV4cG9ydCBmdW5jdGlvbiBpc1V1aWQoeDogdW5rbm93bik6IHggaXMgVXVpZCB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ3N0cmluZycgJiYgeC5sZW5ndGggPT09IDM2ICYmIHV1aWRSZWdleC50ZXN0KHgpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByYW5nZUVxdWFscyhhOiBTb3VyY2VSYW5nZSwgYjogU291cmNlUmFuZ2UpOiBib29sZWFuIHtcbiAgcmV0dXJuIGFbMF0gPT0gYlswXSAmJiBhWzFdID09IGJbMV1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlSW5jbHVkZXMoYTogU291cmNlUmFuZ2UsIGI6IG51bWJlcik6IGJvb2xlYW4ge1xuICByZXR1cm4gYVswXSA8PSBiICYmIGFbMV0gPj0gYlxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmFuZ2VMZW5ndGgoYTogU291cmNlUmFuZ2UpOiBudW1iZXIge1xuICByZXR1cm4gYVsxXSAtIGFbMF1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlRW5jbG9zZXMoYTogU291cmNlUmFuZ2UsIGI6IFNvdXJjZVJhbmdlKTogYm9vbGVhbiB7XG4gIHJldHVybiBhWzBdIDw9IGJbMF0gJiYgYVsxXSA+PSBiWzFdXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByYW5nZUludGVyc2VjdHMoYTogU291cmNlUmFuZ2UsIGI6IFNvdXJjZVJhbmdlKTogYm9vbGVhbiB7XG4gIHJldHVybiBhWzBdIDw9IGJbMV0gJiYgYVsxXSA+PSBiWzBdXG59XG5cbi8qKiBXaGV0aGVyIHRoZSBnaXZlbiByYW5nZSBpcyBiZWZvcmUgdGhlIG90aGVyIHJhbmdlLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlSXNCZWZvcmUoYTogU291cmNlUmFuZ2UsIGI6IFNvdXJjZVJhbmdlKTogYm9vbGVhbiB7XG4gIHJldHVybiBhWzFdIDw9IGJbMF1cbn1cbiIsICJjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfZGlybmFtZSA9IFwiQzpcXFxcUHJvamVjdHNcXFxcZW5zb1xcXFxlbnNvXFxcXGFwcFxcXFxndWkyXFxcXHNoYXJlZFxcXFxhc3RcIjtjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfZmlsZW5hbWUgPSBcIkM6XFxcXFByb2plY3RzXFxcXGVuc29cXFxcZW5zb1xcXFxhcHBcXFxcZ3VpMlxcXFxzaGFyZWRcXFxcYXN0XFxcXHBhcnNlclN1cHBvcnQudHNcIjtjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfaW1wb3J0X21ldGFfdXJsID0gXCJmaWxlOi8vL0M6L1Byb2plY3RzL2Vuc28vZW5zby9hcHAvZ3VpMi9zaGFyZWQvYXN0L3BhcnNlclN1cHBvcnQudHNcIjsvKiogVGhpcyBmaWxlIHN1cHBvcnRzIHRoZSBtb2R1bGUgaW4gYGdlbmVyYXRlZC9hc3QudHNgIHRoYXQgaXMgcHJvZHVjZWQgYnkgYHBhcnNlci1jb2RlZ2VuYC4gKi9cblxuZXhwb3J0IHsgdHlwZSBSZXN1bHQgfSBmcm9tICcuLi91dGlsL2RhdGEvcmVzdWx0J1xuaW1wb3J0IHsgYmFpbCB9IGZyb20gJy4uL3V0aWwvYXNzZXJ0J1xuaW1wb3J0IHsgRXJyLCBPaywgdHlwZSBSZXN1bHQgfSBmcm9tICcuLi91dGlsL2RhdGEvcmVzdWx0J1xuXG5leHBvcnQgdHlwZSBPYmplY3RWaXNpdG9yID0gKG9iamVjdDogTGF6eU9iamVjdCkgPT4gYm9vbGVhbiB8IHZvaWRcbmV4cG9ydCB0eXBlIE9iamVjdEFkZHJlc3NWaXNpdG9yID0gKHZpZXc6IERhdGFWaWV3LCBhZGRyZXNzOiBudW1iZXIpID0+IGJvb2xlYW4gfCB2b2lkXG5cbi8qKiBCYXNlIGNsYXNzIGZvciBvYmplY3RzIHRoYXQgbGF6aWx5IGRlc2VyaWFsaXplIGZpZWxkcyB3aGVuIGFjY2Vzc2VkLiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIExhenlPYmplY3Qge1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX3Y6IERhdGFWaWV3XG5cbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKHZpZXc6IERhdGFWaWV3KSB7XG4gICAgaWYgKHZpZXcgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKCdXVEY/JylcbiAgICB0aGlzLl92ID0gdmlld1xuICB9XG5cbiAgdmlzaXRDaGlsZHJlbihfdmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY2hpbGRyZW4oKTogTGF6eU9iamVjdFtdIHtcbiAgICBjb25zdCBjaGlsZHJlbjogTGF6eU9iamVjdFtdID0gW11cbiAgICB0aGlzLnZpc2l0Q2hpbGRyZW4oKGNoaWxkKSA9PiB7XG4gICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKVxuICAgIH0pXG4gICAgcmV0dXJuIGNoaWxkcmVuXG4gIH1cbn1cblxudHlwZSBSZWFkZXI8VD4gPSAodmlldzogRGF0YVZpZXcsIGFkZHJlc3M6IG51bWJlcikgPT4gVFxuXG5mdW5jdGlvbiBtYWtlRGF0YVZpZXcoYnVmZmVyOiBBcnJheUJ1ZmZlciwgYWRkcmVzczogbnVtYmVyKSB7XG4gIHJldHVybiBuZXcgRGF0YVZpZXcoYnVmZmVyLCBhZGRyZXNzKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVhZFU4KHZpZXc6IERhdGFWaWV3LCBhZGRyZXNzOiBudW1iZXIpIHtcbiAgcmV0dXJuIHZpZXcuZ2V0VWludDgoYWRkcmVzcylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRVMzIodmlldzogRGF0YVZpZXcsIGFkZHJlc3M6IG51bWJlcikge1xuICByZXR1cm4gdmlldy5nZXRVaW50MzIoYWRkcmVzcywgdHJ1ZSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRJMzIodmlldzogRGF0YVZpZXcsIGFkZHJlc3M6IG51bWJlcikge1xuICByZXR1cm4gdmlldy5nZXRJbnQzMihhZGRyZXNzLCB0cnVlKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVhZFU2NCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKSB7XG4gIHJldHVybiB2aWV3LmdldEJpZ1VpbnQ2NChhZGRyZXNzLCB0cnVlKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVhZEk2NCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKSB7XG4gIHJldHVybiB2aWV3LmdldEJpZ0ludDY0KGFkZHJlc3MsIHRydWUpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWFkQm9vbCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKSB7XG4gIHJldHVybiByZWFkVTgodmlldywgYWRkcmVzcykgIT09IDBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRPZmZzZXQodmlldzogRGF0YVZpZXcsIG9mZnNldDogbnVtYmVyKSB7XG4gIHJldHVybiBtYWtlRGF0YVZpZXcodmlldy5idWZmZXIsIHZpZXcuYnl0ZU9mZnNldCArIG9mZnNldClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRQb2ludGVyKHZpZXc6IERhdGFWaWV3LCBhZGRyZXNzOiBudW1iZXIpOiBEYXRhVmlldyB7XG4gIHJldHVybiBtYWtlRGF0YVZpZXcodmlldy5idWZmZXIsIHJlYWRVMzIodmlldywgYWRkcmVzcykpXG59XG5cbmNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKClcblxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRPcHRpb248VD4oXG4gIHZpZXc6IERhdGFWaWV3LFxuICBhZGRyZXNzOiBudW1iZXIsXG4gIHJlYWRFbGVtZW50OiBSZWFkZXI8VD4sXG4pOiBUIHwgdW5kZWZpbmVkIHtcbiAgbGV0IHJlc3VsdCA9IHVuZGVmaW5lZFxuICB2aXNpdE9wdGlvbih2aWV3LCBhZGRyZXNzLCAodmlldywgYWRkcmVzcykgPT4ge1xuICAgIHJlc3VsdCA9IHJlYWRFbGVtZW50KHZpZXcsIGFkZHJlc3MpXG4gIH0pXG4gIHJldHVybiByZXN1bHRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZpc2l0T3B0aW9uKFxuICB2aWV3OiBEYXRhVmlldyxcbiAgYWRkcmVzczogbnVtYmVyLFxuICB2aXNpdG9yOiBPYmplY3RBZGRyZXNzVmlzaXRvcixcbik6IGJvb2xlYW4ge1xuICBjb25zdCBkaXNjcmltaW5hbnQgPSByZWFkVTgodmlldywgYWRkcmVzcylcbiAgc3dpdGNoIChkaXNjcmltaW5hbnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gISF2aXNpdG9yKHJlYWRQb2ludGVyKHZpZXcsIGFkZHJlc3MgKyAxKSwgMClcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIE9wdGlvbiBkaXNjcmltaW5hbnQ6IDB4JHtkaXNjcmltaW5hbnQudG9TdHJpbmcoMTYpfS5gKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWFkUmVzdWx0PE9rLCBFcnI+KFxuICB2aWV3OiBEYXRhVmlldyxcbiAgYWRkcmVzczogbnVtYmVyLFxuICByZWFkT2s6IFJlYWRlcjxPaz4sXG4gIHJlYWRFcnI6IFJlYWRlcjxFcnI+LFxuKTogUmVzdWx0PE9rLCBFcnI+IHtcbiAgY29uc3QgZGF0YSA9IHJlYWRQb2ludGVyKHZpZXcsIGFkZHJlc3MpXG4gIGNvbnN0IGRpc2NyaW1pbmFudCA9IHJlYWRVMzIoZGF0YSwgMClcbiAgc3dpdGNoIChkaXNjcmltaW5hbnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gT2socmVhZE9rKGRhdGEsIDQpKVxuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBFcnIocmVhZEVycihkYXRhLCA0KSlcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFJlc3VsdCBkaXNjcmltaW5hbnQ6IDB4JHtkaXNjcmltaW5hbnQudG9TdHJpbmcoMTYpfS5gKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2aXNpdFJlc3VsdChcbiAgdmlldzogRGF0YVZpZXcsXG4gIGFkZHJlc3M6IG51bWJlcixcbiAgdmlzaXRPazogT2JqZWN0QWRkcmVzc1Zpc2l0b3IgfCBudWxsLFxuICB2aXNpdEVycjogT2JqZWN0QWRkcmVzc1Zpc2l0b3IgfCBudWxsLFxuKTogYm9vbGVhbiB7XG4gIGNvbnN0IGRhdGEgPSByZWFkUG9pbnRlcih2aWV3LCBhZGRyZXNzKVxuICBjb25zdCBkaXNjcmltaW5hbnQgPSByZWFkVTMyKGRhdGEsIDApXG4gIHN3aXRjaCAoZGlzY3JpbWluYW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgaWYgKHZpc2l0T2s/LihkYXRhLCA0KSkgcmV0dXJuIHRydWVcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIGNhc2UgMTpcbiAgICAgIGlmICh2aXNpdEVycj8uKGRhdGEsIDQpKSByZXR1cm4gdHJ1ZVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBSZXN1bHQgZGlzY3JpbWluYW50OiAweCR7ZGlzY3JpbWluYW50LnRvU3RyaW5nKDE2KX0uYClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmlzaXRTZXF1ZW5jZShcbiAgdmlldzogRGF0YVZpZXcsXG4gIGFkZHJlc3M6IG51bWJlcixcbiAgc2l6ZTogbnVtYmVyLFxuICB2aXNpdG9yOiBPYmplY3RBZGRyZXNzVmlzaXRvcixcbik6IGJvb2xlYW4ge1xuICBjb25zdCBkYXRhID0gcmVhZFBvaW50ZXIodmlldywgYWRkcmVzcylcbiAgbGV0IG9mZnNldCA9IDRcbiAgY29uc3QgZW5kID0gb2Zmc2V0ICsgc2l6ZSAqIHJlYWRVMzIoZGF0YSwgMClcbiAgd2hpbGUgKG9mZnNldCAhPSBlbmQpIHtcbiAgICBpZiAodmlzaXRvcihkYXRhLCBvZmZzZXQpID09PSB0cnVlKSByZXR1cm4gdHJ1ZVxuICAgIG9mZnNldCArPSBzaXplXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWFkU2VxdWVuY2U8VD4oXG4gIHZpZXc6IERhdGFWaWV3LFxuICBhZGRyZXNzOiBudW1iZXIsXG4gIHNpemU6IG51bWJlcixcbiAgcmVhZGVyOiBSZWFkZXI8VD4sXG4pOiBJdGVyYWJsZUl0ZXJhdG9yPFQ+IHtcbiAgY29uc3QgZGF0YSA9IHJlYWRQb2ludGVyKHZpZXcsIGFkZHJlc3MpXG4gIGNvbnN0IG9mZnNldCA9IDRcbiAgY29uc3QgZW5kID0gb2Zmc2V0ICsgc2l6ZSAqIHJlYWRVMzIoZGF0YSwgMClcbiAgcmV0dXJuIG5ldyBMYXp5U2VxdWVuY2Uob2Zmc2V0LCBzaXplLCBlbmQsIChvZmZzZXQ6IG51bWJlcikgPT4gcmVhZGVyKGRhdGEsIG9mZnNldCkpXG59XG5cbmV4cG9ydCBjbGFzcyBMYXp5U2VxdWVuY2U8VD4gaW1wbGVtZW50cyBJdGVyYWJsZUl0ZXJhdG9yPFQ+IHtcbiAgcHJpdmF0ZSBvZmZzZXQ6IG51bWJlclxuICBwcml2YXRlIHJlYWRvbmx5IHN0ZXA6IG51bWJlclxuICBwcml2YXRlIHJlYWRvbmx5IGVuZDogbnVtYmVyXG4gIHByaXZhdGUgcmVhZG9ubHkgcmVhZDogKGFkZHJlc3M6IG51bWJlcikgPT4gVFxuXG4gIGNvbnN0cnVjdG9yKG9mZnNldDogbnVtYmVyLCBzdGVwOiBudW1iZXIsIGVuZDogbnVtYmVyLCByZWFkOiAoYWRkcmVzczogbnVtYmVyKSA9PiBUKSB7XG4gICAgdGhpcy5yZWFkID0gcmVhZFxuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0XG4gICAgdGhpcy5zdGVwID0gc3RlcFxuICAgIHRoaXMuZW5kID0gZW5kXG4gIH1cblxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHVibGljIG5leHQoKTogSXRlcmF0b3JSZXN1bHQ8VD4ge1xuICAgIGlmICh0aGlzLm9mZnNldCA+PSB0aGlzLmVuZCkge1xuICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5yZWFkKHRoaXMub2Zmc2V0KVxuICAgIHRoaXMub2Zmc2V0ICs9IHRoaXMuc3RlcFxuICAgIHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogdmFsdWUgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWFkU3RyaW5nKHZpZXc6IERhdGFWaWV3LCBhZGRyZXNzOiBudW1iZXIpOiBzdHJpbmcge1xuICBjb25zdCBkYXRhID0gcmVhZFBvaW50ZXIodmlldywgYWRkcmVzcylcbiAgY29uc3QgbGVuID0gcmVhZFUzMihkYXRhLCAwKVxuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQgKyA0LCBsZW4pXG4gIHJldHVybiB0ZXh0RGVjb2Rlci5kZWNvZGUoYnl0ZXMpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWFkRW51bTxUPihyZWFkZXJzOiBSZWFkZXI8VD5bXSwgdmlldzogRGF0YVZpZXcsIGFkZHJlc3M6IG51bWJlcik6IFQge1xuICBjb25zdCBkYXRhID0gcmVhZFBvaW50ZXIodmlldywgYWRkcmVzcylcbiAgY29uc3QgZGlzY3JpbWluYW50ID0gcmVhZFUzMihkYXRhLCAwKVxuICBjb25zdCByZWFkZXIgPSByZWFkZXJzW2Rpc2NyaW1pbmFudF0gPz8gYmFpbChgSW52YWxpZCBlbnVtIGRpc2NyaW1pbmFudDogJHtkaXNjcmltaW5hbnR9YClcbiAgcmV0dXJuIHJlYWRlcihkYXRhLCA0KVxufVxuIiwgImNvbnN0IF9fdml0ZV9pbmplY3RlZF9vcmlnaW5hbF9kaXJuYW1lID0gXCJDOlxcXFxQcm9qZWN0c1xcXFxlbnNvXFxcXGVuc29cXFxcYXBwXFxcXGd1aTJcXFxcc2hhcmVkXFxcXGFzdFxcXFxnZW5lcmF0ZWRcIjtjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfZmlsZW5hbWUgPSBcIkM6XFxcXFByb2plY3RzXFxcXGVuc29cXFxcZW5zb1xcXFxhcHBcXFxcZ3VpMlxcXFxzaGFyZWRcXFxcYXN0XFxcXGdlbmVyYXRlZFxcXFxhc3QudHNcIjtjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfaW1wb3J0X21ldGFfdXJsID0gXCJmaWxlOi8vL0M6L1Byb2plY3RzL2Vuc28vZW5zby9hcHAvZ3VpMi9zaGFyZWQvYXN0L2dlbmVyYXRlZC9hc3QudHNcIjsvLyAqKiogVEhJUyBGSUxFIEdFTkVSQVRFRCBCWSBgcGFyc2VyLWNvZGVnZW5gICoqKlxuaW1wb3J0IHsgTGF6eU9iamVjdCwgdHlwZSBPYmplY3RWaXNpdG9yLCB0eXBlIE9iamVjdEFkZHJlc3NWaXNpdG9yLCB0eXBlIFJlc3VsdCwgcmVhZFU4LCByZWFkVTMyLCByZWFkSTMyLCByZWFkVTY0LCByZWFkSTY0LCByZWFkQm9vbCwgcmVhZE9mZnNldCwgcmVhZFBvaW50ZXIsIHJlYWRPcHRpb24sIHJlYWRSZXN1bHQsIHJlYWRFbnVtLCByZWFkU2VxdWVuY2UsIHJlYWRTdHJpbmcsIHZpc2l0U2VxdWVuY2UsIHZpc2l0T3B0aW9uLCB2aXNpdFJlc3VsdCB9IGZyb20gJy4uL3BhcnNlclN1cHBvcnQnXG5leHBvcnQgbW9kdWxlIFRyZWUge1xuICAgIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBYnN0cmFjdEJhc2UgZXh0ZW5kcyBMYXp5T2JqZWN0IHtcbiAgICAgICAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKHZpZXc6IERhdGFWaWV3KSB7IHN1cGVyKHZpZXcpOyB9XG4gICAgICAgIGdldCBzcGFuTGVmdE9mZnNldFZpc2libGUoKTogbnVtYmVyIHsgcmV0dXJuIHJlYWRVMzIodGhpcy5fdiwgMCk7IH1cbiAgICAgICAgZ2V0IHNwYW5MZWZ0T2Zmc2V0Q29kZVJlcHJCZWdpbigpOiBudW1iZXIgeyByZXR1cm4gcmVhZFUzMih0aGlzLl92LCA0KTsgfVxuICAgICAgICBnZXQgc3BhbkxlZnRPZmZzZXRDb2RlUmVwckxlbigpOiBudW1iZXIgeyByZXR1cm4gcmVhZFUzMih0aGlzLl92LCA4KTsgfVxuICAgICAgICBnZXQgc3BhbkxlZnRPZmZzZXRDb2RlU3RhcnRVdGY4KCk6IG51bWJlciB7IHJldHVybiByZWFkVTMyKHRoaXMuX3YsIDEyKTsgfVxuICAgICAgICBnZXQgd2hpdGVzcGFjZVN0YXJ0SW5Db2RlUGFyc2VkKCk6IG51bWJlciB7IHJldHVybiByZWFkVTMyKHRoaXMuX3YsIDE2KTsgfVxuICAgICAgICBnZXQgc3BhbkxlZnRPZmZzZXRDb2RlU3RhcnRMaW5lKCk6IG51bWJlciB7IHJldHVybiByZWFkVTMyKHRoaXMuX3YsIDIwKTsgfVxuICAgICAgICBnZXQgc3BhbkxlZnRPZmZzZXRDb2RlU3RhcnRDb2wxNigpOiBudW1iZXIgeyByZXR1cm4gcmVhZFUzMih0aGlzLl92LCAyNCk7IH1cbiAgICAgICAgZ2V0IHdoaXRlc3BhY2VMZW5ndGhJbkNvZGVQYXJzZWQoKTogbnVtYmVyIHsgcmV0dXJuIHJlYWRVMzIodGhpcy5fdiwgMjgpOyB9XG4gICAgICAgIGdldCBzcGFuTGVmdE9mZnNldENvZGVMZW5OZXdsaW5lcygpOiBudW1iZXIgeyByZXR1cm4gcmVhZFUzMih0aGlzLl92LCAzMik7IH1cbiAgICAgICAgZ2V0IHNwYW5MZWZ0T2Zmc2V0Q29kZUxlbkxpbmVDaGFyczE2KCk6IG51bWJlciB7IHJldHVybiByZWFkVTMyKHRoaXMuX3YsIDM2KTsgfVxuICAgICAgICBnZXQgY2hpbGRyZW5MZW5ndGhJbkNvZGVQYXJzZWQoKTogbnVtYmVyIHsgcmV0dXJuIHJlYWRVMzIodGhpcy5fdiwgNDApOyB9XG4gICAgICAgIGdldCBzcGFuQ29kZUxlbmd0aE5ld2xpbmVzKCk6IG51bWJlciB7IHJldHVybiByZWFkVTMyKHRoaXMuX3YsIDQ0KTsgfVxuICAgICAgICBnZXQgc3BhbkNvZGVMZW5ndGhMaW5lQ2hhcnMxNigpOiBudW1iZXIgeyByZXR1cm4gcmVhZFUzMih0aGlzLl92LCA0OCk7IH1cbiAgICAgICAgdmlzaXRDaGlsZHJlbih2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiBzdXBlci52aXNpdENoaWxkcmVuKHZpc2l0b3IpOyB9XG4gICAgfVxuICAgIGV4cG9ydCBjb25zdCBlbnVtIFR5cGUge1xuICAgICAgICBJbnZhbGlkID0gMCxcbiAgICAgICAgQm9keUJsb2NrID0gMSxcbiAgICAgICAgQXJndW1lbnRCbG9ja0FwcGxpY2F0aW9uID0gMixcbiAgICAgICAgT3BlcmF0b3JCbG9ja0FwcGxpY2F0aW9uID0gMyxcbiAgICAgICAgSWRlbnQgPSA0LFxuICAgICAgICBQcml2YXRlID0gNSxcbiAgICAgICAgTnVtYmVyID0gNixcbiAgICAgICAgV2lsZGNhcmQgPSA3LFxuICAgICAgICBTdXNwZW5kZWREZWZhdWx0QXJndW1lbnRzID0gOCxcbiAgICAgICAgVGV4dExpdGVyYWwgPSA5LFxuICAgICAgICBBcHAgPSAxMCxcbiAgICAgICAgTmFtZWRBcHAgPSAxMSxcbiAgICAgICAgT3ByQXBwID0gMTIsXG4gICAgICAgIFVuYXJ5T3ByQXBwID0gMTMsXG4gICAgICAgIEF1dG9zY29wZWRJZGVudGlmaWVyID0gMTQsXG4gICAgICAgIE9wclNlY3Rpb25Cb3VuZGFyeSA9IDE1LFxuICAgICAgICBUZW1wbGF0ZUZ1bmN0aW9uID0gMTYsXG4gICAgICAgIE11bHRpU2VnbWVudEFwcCA9IDE3LFxuICAgICAgICBUeXBlRGVmID0gMTgsXG4gICAgICAgIEFzc2lnbm1lbnQgPSAxOSxcbiAgICAgICAgRnVuY3Rpb24gPSAyMCxcbiAgICAgICAgRm9yZWlnbkZ1bmN0aW9uID0gMjEsXG4gICAgICAgIEltcG9ydCA9IDIyLFxuICAgICAgICBFeHBvcnQgPSAyMyxcbiAgICAgICAgR3JvdXAgPSAyNCxcbiAgICAgICAgVHlwZVNpZ25hdHVyZSA9IDI1LFxuICAgICAgICBUeXBlQW5ub3RhdGVkID0gMjYsXG4gICAgICAgIENhc2VPZiA9IDI3LFxuICAgICAgICBMYW1iZGEgPSAyOCxcbiAgICAgICAgQXJyYXkgPSAyOSxcbiAgICAgICAgVHVwbGUgPSAzMCxcbiAgICAgICAgQW5ub3RhdGVkID0gMzEsXG4gICAgICAgIEFubm90YXRlZEJ1aWx0aW4gPSAzMixcbiAgICAgICAgRG9jdW1lbnRlZCA9IDMzLFxuICAgICAgICBDb25zdHJ1Y3RvckRlZmluaXRpb24gPSAzNFxuICAgIH1cbiAgICBleHBvcnQgY29uc3QgdHlwZU5hbWVzID0gW1wiSW52YWxpZFwiLCBcIkJvZHlCbG9ja1wiLCBcIkFyZ3VtZW50QmxvY2tBcHBsaWNhdGlvblwiLCBcIk9wZXJhdG9yQmxvY2tBcHBsaWNhdGlvblwiLCBcIklkZW50XCIsIFwiUHJpdmF0ZVwiLCBcIk51bWJlclwiLCBcIldpbGRjYXJkXCIsIFwiU3VzcGVuZGVkRGVmYXVsdEFyZ3VtZW50c1wiLCBcIlRleHRMaXRlcmFsXCIsIFwiQXBwXCIsIFwiTmFtZWRBcHBcIiwgXCJPcHJBcHBcIiwgXCJVbmFyeU9wckFwcFwiLCBcIkF1dG9zY29wZWRJZGVudGlmaWVyXCIsIFwiT3ByU2VjdGlvbkJvdW5kYXJ5XCIsIFwiVGVtcGxhdGVGdW5jdGlvblwiLCBcIk11bHRpU2VnbWVudEFwcFwiLCBcIlR5cGVEZWZcIiwgXCJBc3NpZ25tZW50XCIsIFwiRnVuY3Rpb25cIiwgXCJGb3JlaWduRnVuY3Rpb25cIiwgXCJJbXBvcnRcIiwgXCJFeHBvcnRcIiwgXCJHcm91cFwiLCBcIlR5cGVTaWduYXR1cmVcIiwgXCJUeXBlQW5ub3RhdGVkXCIsIFwiQ2FzZU9mXCIsIFwiTGFtYmRhXCIsIFwiQXJyYXlcIiwgXCJUdXBsZVwiLCBcIkFubm90YXRlZFwiLCBcIkFubm90YXRlZEJ1aWx0aW5cIiwgXCJEb2N1bWVudGVkXCIsIFwiQ29uc3RydWN0b3JEZWZpbml0aW9uXCJdIGFzIGNvbnN0O1xuICAgIGV4cG9ydCBjbGFzcyBJbnZhbGlkIGV4dGVuZHMgQWJzdHJhY3RCYXNlIHtcbiAgICAgICAgcmVhZG9ubHkgdHlwZTogVHlwZS5JbnZhbGlkO1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3OiBEYXRhVmlldykgeyBzdXBlcih2aWV3KTsgdGhpcy50eXBlID0gVHlwZS5JbnZhbGlkOyB9XG4gICAgICAgIHN0YXRpYyByZWFkKHZpZXc6IERhdGFWaWV3LCBhZGRyZXNzOiBudW1iZXIpOiBJbnZhbGlkIHsgcmV0dXJuIG5ldyBJbnZhbGlkKHJlYWRPZmZzZXQodmlldywgYWRkcmVzcykpOyB9XG4gICAgICAgIGdldCBlcnJvcigpOiBzdHJpbmcgeyByZXR1cm4gcmVhZFN0cmluZyh0aGlzLl92LCA1Mik7IH1cbiAgICAgICAgZ2V0IGFzdCgpOiBUcmVlIHsgcmV0dXJuIFRyZWUucmVhZCh0aGlzLl92LCA1Nik7IH1cbiAgICAgICAgdmlzaXRDaGlsZHJlbih2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiBzdXBlci52aXNpdENoaWxkcmVuKHZpc2l0b3IpIHx8ICEhdmlzaXRvcih0aGlzLmFzdCk7IH1cbiAgICB9XG4gICAgZXhwb3J0IGNsYXNzIEJvZHlCbG9jayBleHRlbmRzIEFic3RyYWN0QmFzZSB7XG4gICAgICAgIHJlYWRvbmx5IHR5cGU6IFR5cGUuQm9keUJsb2NrO1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3OiBEYXRhVmlldykgeyBzdXBlcih2aWV3KTsgdGhpcy50eXBlID0gVHlwZS5Cb2R5QmxvY2s7IH1cbiAgICAgICAgc3RhdGljIHJlYWQodmlldzogRGF0YVZpZXcsIGFkZHJlc3M6IG51bWJlcik6IEJvZHlCbG9jayB7IHJldHVybiBuZXcgQm9keUJsb2NrKHJlYWRPZmZzZXQodmlldywgYWRkcmVzcykpOyB9XG4gICAgICAgIGdldCBzdGF0ZW1lbnRzKCk6IEl0ZXJhYmxlSXRlcmF0b3I8TGluZT4geyByZXR1cm4gcmVhZFNlcXVlbmNlKHRoaXMuX3YsIDUyLCA4MSwgTGluZS5yZWFkKTsgfVxuICAgICAgICB2aXNpdFN0YXRlbWVudHModmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gdmlzaXRTZXF1ZW5jZSh0aGlzLl92LCA1MiwgODEsICh2aWV3LCBhZGRyZXNzKSA9PiB2aXNpdG9yKExpbmUucmVhZCh2aWV3LCBhZGRyZXNzKSkpOyB9XG4gICAgICAgIHZpc2l0Q2hpbGRyZW4odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gc3VwZXIudmlzaXRDaGlsZHJlbih2aXNpdG9yKSB8fCAhIXRoaXMudmlzaXRTdGF0ZW1lbnRzKHZpc2l0b3IpOyB9XG4gICAgfVxuICAgIGV4cG9ydCBjbGFzcyBBcmd1bWVudEJsb2NrQXBwbGljYXRpb24gZXh0ZW5kcyBBYnN0cmFjdEJhc2Uge1xuICAgICAgICByZWFkb25seSB0eXBlOiBUeXBlLkFyZ3VtZW50QmxvY2tBcHBsaWNhdGlvbjtcbiAgICAgICAgY29uc3RydWN0b3IodmlldzogRGF0YVZpZXcpIHsgc3VwZXIodmlldyk7IHRoaXMudHlwZSA9IFR5cGUuQXJndW1lbnRCbG9ja0FwcGxpY2F0aW9uOyB9XG4gICAgICAgIHN0YXRpYyByZWFkKHZpZXc6IERhdGFWaWV3LCBhZGRyZXNzOiBudW1iZXIpOiBBcmd1bWVudEJsb2NrQXBwbGljYXRpb24geyByZXR1cm4gbmV3IEFyZ3VtZW50QmxvY2tBcHBsaWNhdGlvbihyZWFkT2Zmc2V0KHZpZXcsIGFkZHJlc3MpKTsgfVxuICAgICAgICBnZXQgbGhzKCk6IFRyZWUgfCB1bmRlZmluZWQgeyByZXR1cm4gcmVhZE9wdGlvbih0aGlzLl92LCA1MiwgVHJlZS5yZWFkKTsgfVxuICAgICAgICBnZXQgYXJndW1lbnRzKCk6IEl0ZXJhYmxlSXRlcmF0b3I8TGluZT4geyByZXR1cm4gcmVhZFNlcXVlbmNlKHRoaXMuX3YsIDU3LCA4MSwgTGluZS5yZWFkKTsgfVxuICAgICAgICB2aXNpdExocyh2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiB2aXNpdE9wdGlvbih0aGlzLl92LCA1MiwgKHZpZXcsIGFkZHJlc3MpID0+IHZpc2l0b3IoVHJlZS5yZWFkKHZpZXcsIGFkZHJlc3MpKSk7IH1cbiAgICAgICAgdmlzaXRBcmd1bWVudHModmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gdmlzaXRTZXF1ZW5jZSh0aGlzLl92LCA1NywgODEsICh2aWV3LCBhZGRyZXNzKSA9PiB2aXNpdG9yKExpbmUucmVhZCh2aWV3LCBhZGRyZXNzKSkpOyB9XG4gICAgICAgIHZpc2l0Q2hpbGRyZW4odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gc3VwZXIudmlzaXRDaGlsZHJlbih2aXNpdG9yKSB8fCAhIXRoaXMudmlzaXRMaHModmlzaXRvcikgfHwgISF0aGlzLnZpc2l0QXJndW1lbnRzKHZpc2l0b3IpOyB9XG4gICAgfVxuICAgIGV4cG9ydCBjbGFzcyBPcGVyYXRvckJsb2NrQXBwbGljYXRpb24gZXh0ZW5kcyBBYnN0cmFjdEJhc2Uge1xuICAgICAgICByZWFkb25seSB0eXBlOiBUeXBlLk9wZXJhdG9yQmxvY2tBcHBsaWNhdGlvbjtcbiAgICAgICAgY29uc3RydWN0b3IodmlldzogRGF0YVZpZXcpIHsgc3VwZXIodmlldyk7IHRoaXMudHlwZSA9IFR5cGUuT3BlcmF0b3JCbG9ja0FwcGxpY2F0aW9uOyB9XG4gICAgICAgIHN0YXRpYyByZWFkKHZpZXc6IERhdGFWaWV3LCBhZGRyZXNzOiBudW1iZXIpOiBPcGVyYXRvckJsb2NrQXBwbGljYXRpb24geyByZXR1cm4gbmV3IE9wZXJhdG9yQmxvY2tBcHBsaWNhdGlvbihyZWFkT2Zmc2V0KHZpZXcsIGFkZHJlc3MpKTsgfVxuICAgICAgICBnZXQgbGhzKCk6IFRyZWUgfCB1bmRlZmluZWQgeyByZXR1cm4gcmVhZE9wdGlvbih0aGlzLl92LCA1MiwgVHJlZS5yZWFkKTsgfVxuICAgICAgICBnZXQgZXhwcmVzc2lvbnMoKTogSXRlcmFibGVJdGVyYXRvcjxPcGVyYXRvckxpbmU+IHsgcmV0dXJuIHJlYWRTZXF1ZW5jZSh0aGlzLl92LCA1NywgODEsIE9wZXJhdG9yTGluZS5yZWFkKTsgfVxuICAgICAgICBnZXQgZXhjZXNzKCk6IEl0ZXJhYmxlSXRlcmF0b3I8TGluZT4geyByZXR1cm4gcmVhZFNlcXVlbmNlKHRoaXMuX3YsIDYxLCA4MSwgTGluZS5yZWFkKTsgfVxuICAgICAgICB2aXNpdExocyh2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiB2aXNpdE9wdGlvbih0aGlzLl92LCA1MiwgKHZpZXcsIGFkZHJlc3MpID0+IHZpc2l0b3IoVHJlZS5yZWFkKHZpZXcsIGFkZHJlc3MpKSk7IH1cbiAgICAgICAgdmlzaXRFeHByZXNzaW9ucyh2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiB2aXNpdFNlcXVlbmNlKHRoaXMuX3YsIDU3LCA4MSwgKHZpZXcsIGFkZHJlc3MpID0+IHZpc2l0b3IoT3BlcmF0b3JMaW5lLnJlYWQodmlldywgYWRkcmVzcykpKTsgfVxuICAgICAgICB2aXNpdEV4Y2Vzcyh2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiB2aXNpdFNlcXVlbmNlKHRoaXMuX3YsIDYxLCA4MSwgKHZpZXcsIGFkZHJlc3MpID0+IHZpc2l0b3IoTGluZS5yZWFkKHZpZXcsIGFkZHJlc3MpKSk7IH1cbiAgICAgICAgdmlzaXRDaGlsZHJlbih2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiBzdXBlci52aXNpdENoaWxkcmVuKHZpc2l0b3IpIHx8ICEhdGhpcy52aXNpdExocyh2aXNpdG9yKSB8fCAhIXRoaXMudmlzaXRFeHByZXNzaW9ucyh2aXNpdG9yKSB8fCAhIXRoaXMudmlzaXRFeGNlc3ModmlzaXRvcik7IH1cbiAgICB9XG4gICAgZXhwb3J0IGNsYXNzIElkZW50IGV4dGVuZHMgQWJzdHJhY3RCYXNlIHtcbiAgICAgICAgcmVhZG9ubHkgdHlwZTogVHlwZS5JZGVudDtcbiAgICAgICAgY29uc3RydWN0b3IodmlldzogRGF0YVZpZXcpIHsgc3VwZXIodmlldyk7IHRoaXMudHlwZSA9IFR5cGUuSWRlbnQ7IH1cbiAgICAgICAgc3RhdGljIHJlYWQodmlldzogRGF0YVZpZXcsIGFkZHJlc3M6IG51bWJlcik6IElkZW50IHsgcmV0dXJuIG5ldyBJZGVudChyZWFkT2Zmc2V0KHZpZXcsIGFkZHJlc3MpKTsgfVxuICAgICAgICBnZXQgdG9rZW4oKTogVG9rZW4uSWRlbnQgeyByZXR1cm4gVG9rZW4uSWRlbnQucmVhZCh0aGlzLl92LCA1Mik7IH1cbiAgICAgICAgdmlzaXRDaGlsZHJlbih2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiBzdXBlci52aXNpdENoaWxkcmVuKHZpc2l0b3IpIHx8ICEhdmlzaXRvcih0aGlzLnRva2VuKTsgfVxuICAgIH1cbiAgICBleHBvcnQgY2xhc3MgUHJpdmF0ZSBleHRlbmRzIEFic3RyYWN0QmFzZSB7XG4gICAgICAgIHJlYWRvbmx5IHR5cGU6IFR5cGUuUHJpdmF0ZTtcbiAgICAgICAgY29uc3RydWN0b3IodmlldzogRGF0YVZpZXcpIHsgc3VwZXIodmlldyk7IHRoaXMudHlwZSA9IFR5cGUuUHJpdmF0ZTsgfVxuICAgICAgICBzdGF0aWMgcmVhZCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKTogUHJpdmF0ZSB7IHJldHVybiBuZXcgUHJpdmF0ZShyZWFkT2Zmc2V0KHZpZXcsIGFkZHJlc3MpKTsgfVxuICAgICAgICBnZXQga2V5d29yZCgpOiBUb2tlbi5Qcml2YXRlIHsgcmV0dXJuIFRva2VuLlByaXZhdGUucmVhZCh0aGlzLl92LCA1Mik7IH1cbiAgICAgICAgZ2V0IGJvZHkoKTogVHJlZSB8IHVuZGVmaW5lZCB7IHJldHVybiByZWFkT3B0aW9uKHRoaXMuX3YsIDEyOCwgVHJlZS5yZWFkKTsgfVxuICAgICAgICB2aXNpdEJvZHkodmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gdmlzaXRPcHRpb24odGhpcy5fdiwgMTI4LCAodmlldywgYWRkcmVzcykgPT4gdmlzaXRvcihUcmVlLnJlYWQodmlldywgYWRkcmVzcykpKTsgfVxuICAgICAgICB2aXNpdENoaWxkcmVuKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHN1cGVyLnZpc2l0Q2hpbGRyZW4odmlzaXRvcikgfHwgISF2aXNpdG9yKHRoaXMua2V5d29yZCkgfHwgISF0aGlzLnZpc2l0Qm9keSh2aXNpdG9yKTsgfVxuICAgIH1cbiAgICBleHBvcnQgY2xhc3MgTnVtYmVyIGV4dGVuZHMgQWJzdHJhY3RCYXNlIHtcbiAgICAgICAgcmVhZG9ubHkgdHlwZTogVHlwZS5OdW1iZXI7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXc6IERhdGFWaWV3KSB7IHN1cGVyKHZpZXcpOyB0aGlzLnR5cGUgPSBUeXBlLk51bWJlcjsgfVxuICAgICAgICBzdGF0aWMgcmVhZCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKTogTnVtYmVyIHsgcmV0dXJuIG5ldyBOdW1iZXIocmVhZE9mZnNldCh2aWV3LCBhZGRyZXNzKSk7IH1cbiAgICAgICAgZ2V0IGJhc2UoKTogVG9rZW4uTnVtYmVyQmFzZSB8IHVuZGVmaW5lZCB7IHJldHVybiByZWFkT3B0aW9uKHRoaXMuX3YsIDUyLCBUb2tlbi5OdW1iZXJCYXNlLnJlYWQpOyB9XG4gICAgICAgIGdldCBpbnRlZ2VyKCk6IFRva2VuLkRpZ2l0cyB8IHVuZGVmaW5lZCB7IHJldHVybiByZWFkT3B0aW9uKHRoaXMuX3YsIDU3LCBUb2tlbi5EaWdpdHMucmVhZCk7IH1cbiAgICAgICAgZ2V0IGZyYWN0aW9uYWxEaWdpdHMoKTogRnJhY3Rpb25hbERpZ2l0cyB8IHVuZGVmaW5lZCB7IHJldHVybiByZWFkT3B0aW9uKHRoaXMuX3YsIDYyLCBGcmFjdGlvbmFsRGlnaXRzLnJlYWQpOyB9XG4gICAgICAgIHZpc2l0QmFzZSh2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiB2aXNpdE9wdGlvbih0aGlzLl92LCA1MiwgKHZpZXcsIGFkZHJlc3MpID0+IHZpc2l0b3IoVG9rZW4uTnVtYmVyQmFzZS5yZWFkKHZpZXcsIGFkZHJlc3MpKSk7IH1cbiAgICAgICAgdmlzaXRJbnRlZ2VyKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHZpc2l0T3B0aW9uKHRoaXMuX3YsIDU3LCAodmlldywgYWRkcmVzcykgPT4gdmlzaXRvcihUb2tlbi5EaWdpdHMucmVhZCh2aWV3LCBhZGRyZXNzKSkpOyB9XG4gICAgICAgIHZpc2l0RnJhY3Rpb25hbERpZ2l0cyh2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiB2aXNpdE9wdGlvbih0aGlzLl92LCA2MiwgKHZpZXcsIGFkZHJlc3MpID0+IHZpc2l0b3IoRnJhY3Rpb25hbERpZ2l0cy5yZWFkKHZpZXcsIGFkZHJlc3MpKSk7IH1cbiAgICAgICAgdmlzaXRDaGlsZHJlbih2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiBzdXBlci52aXNpdENoaWxkcmVuKHZpc2l0b3IpIHx8ICEhdGhpcy52aXNpdEJhc2UodmlzaXRvcikgfHwgISF0aGlzLnZpc2l0SW50ZWdlcih2aXNpdG9yKSB8fCAhIXRoaXMudmlzaXRGcmFjdGlvbmFsRGlnaXRzKHZpc2l0b3IpOyB9XG4gICAgfVxuICAgIGV4cG9ydCBjbGFzcyBXaWxkY2FyZCBleHRlbmRzIEFic3RyYWN0QmFzZSB7XG4gICAgICAgIHJlYWRvbmx5IHR5cGU6IFR5cGUuV2lsZGNhcmQ7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXc6IERhdGFWaWV3KSB7IHN1cGVyKHZpZXcpOyB0aGlzLnR5cGUgPSBUeXBlLldpbGRjYXJkOyB9XG4gICAgICAgIHN0YXRpYyByZWFkKHZpZXc6IERhdGFWaWV3LCBhZGRyZXNzOiBudW1iZXIpOiBXaWxkY2FyZCB7IHJldHVybiBuZXcgV2lsZGNhcmQocmVhZE9mZnNldCh2aWV3LCBhZGRyZXNzKSk7IH1cbiAgICAgICAgZ2V0IHRva2VuKCk6IFRva2VuLldpbGRjYXJkIHsgcmV0dXJuIFRva2VuLldpbGRjYXJkLnJlYWQodGhpcy5fdiwgNTIpOyB9XG4gICAgICAgIGdldCBkZUJydWlqbkluZGV4KCk6IG51bWJlciB7IHJldHVybiByZWFkSTMyKHRoaXMuX3YsIDEzMik7IH1cbiAgICAgICAgdmlzaXRDaGlsZHJlbih2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiBzdXBlci52aXNpdENoaWxkcmVuKHZpc2l0b3IpIHx8ICEhdmlzaXRvcih0aGlzLnRva2VuKTsgfVxuICAgIH1cbiAgICBleHBvcnQgY2xhc3MgU3VzcGVuZGVkRGVmYXVsdEFyZ3VtZW50cyBleHRlbmRzIEFic3RyYWN0QmFzZSB7XG4gICAgICAgIHJlYWRvbmx5IHR5cGU6IFR5cGUuU3VzcGVuZGVkRGVmYXVsdEFyZ3VtZW50cztcbiAgICAgICAgY29uc3RydWN0b3IodmlldzogRGF0YVZpZXcpIHsgc3VwZXIodmlldyk7IHRoaXMudHlwZSA9IFR5cGUuU3VzcGVuZGVkRGVmYXVsdEFyZ3VtZW50czsgfVxuICAgICAgICBzdGF0aWMgcmVhZCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKTogU3VzcGVuZGVkRGVmYXVsdEFyZ3VtZW50cyB7IHJldHVybiBuZXcgU3VzcGVuZGVkRGVmYXVsdEFyZ3VtZW50cyhyZWFkT2Zmc2V0KHZpZXcsIGFkZHJlc3MpKTsgfVxuICAgICAgICBnZXQgdG9rZW4oKTogVG9rZW4uU3VzcGVuZGVkRGVmYXVsdEFyZ3VtZW50cyB7IHJldHVybiBUb2tlbi5TdXNwZW5kZWREZWZhdWx0QXJndW1lbnRzLnJlYWQodGhpcy5fdiwgNTIpOyB9XG4gICAgICAgIHZpc2l0Q2hpbGRyZW4odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gc3VwZXIudmlzaXRDaGlsZHJlbih2aXNpdG9yKSB8fCAhIXZpc2l0b3IodGhpcy50b2tlbik7IH1cbiAgICB9XG4gICAgZXhwb3J0IGNsYXNzIFRleHRMaXRlcmFsIGV4dGVuZHMgQWJzdHJhY3RCYXNlIHtcbiAgICAgICAgcmVhZG9ubHkgdHlwZTogVHlwZS5UZXh0TGl0ZXJhbDtcbiAgICAgICAgY29uc3RydWN0b3IodmlldzogRGF0YVZpZXcpIHsgc3VwZXIodmlldyk7IHRoaXMudHlwZSA9IFR5cGUuVGV4dExpdGVyYWw7IH1cbiAgICAgICAgc3RhdGljIHJlYWQodmlldzogRGF0YVZpZXcsIGFkZHJlc3M6IG51bWJlcik6IFRleHRMaXRlcmFsIHsgcmV0dXJuIG5ldyBUZXh0TGl0ZXJhbChyZWFkT2Zmc2V0KHZpZXcsIGFkZHJlc3MpKTsgfVxuICAgICAgICBnZXQgb3BlbigpOiBUb2tlbi5UZXh0U3RhcnQgfCB1bmRlZmluZWQgeyByZXR1cm4gcmVhZE9wdGlvbih0aGlzLl92LCA1MiwgVG9rZW4uVGV4dFN0YXJ0LnJlYWQpOyB9XG4gICAgICAgIGdldCBuZXdsaW5lKCk6IFRva2VuLk5ld2xpbmUgfCB1bmRlZmluZWQgeyByZXR1cm4gcmVhZE9wdGlvbih0aGlzLl92LCA1NywgVG9rZW4uTmV3bGluZS5yZWFkKTsgfVxuICAgICAgICBnZXQgZWxlbWVudHMoKTogSXRlcmFibGVJdGVyYXRvcjxUZXh0RWxlbWVudD4geyByZXR1cm4gcmVhZFNlcXVlbmNlKHRoaXMuX3YsIDYyLCA0LCBUZXh0RWxlbWVudC5yZWFkKTsgfVxuICAgICAgICBnZXQgY2xvc2UoKTogVG9rZW4uVGV4dEVuZCB8IHVuZGVmaW5lZCB7IHJldHVybiByZWFkT3B0aW9uKHRoaXMuX3YsIDY2LCBUb2tlbi5UZXh0RW5kLnJlYWQpOyB9XG4gICAgICAgIHZpc2l0T3Blbih2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiB2aXNpdE9wdGlvbih0aGlzLl92LCA1MiwgKHZpZXcsIGFkZHJlc3MpID0+IHZpc2l0b3IoVG9rZW4uVGV4dFN0YXJ0LnJlYWQodmlldywgYWRkcmVzcykpKTsgfVxuICAgICAgICB2aXNpdE5ld2xpbmUodmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gdmlzaXRPcHRpb24odGhpcy5fdiwgNTcsICh2aWV3LCBhZGRyZXNzKSA9PiB2aXNpdG9yKFRva2VuLk5ld2xpbmUucmVhZCh2aWV3LCBhZGRyZXNzKSkpOyB9XG4gICAgICAgIHZpc2l0RWxlbWVudHModmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gdmlzaXRTZXF1ZW5jZSh0aGlzLl92LCA2MiwgNCwgKHZpZXcsIGFkZHJlc3MpID0+IHZpc2l0b3IoVGV4dEVsZW1lbnQucmVhZCh2aWV3LCBhZGRyZXNzKSkpOyB9XG4gICAgICAgIHZpc2l0Q2xvc2UodmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gdmlzaXRPcHRpb24odGhpcy5fdiwgNjYsICh2aWV3LCBhZGRyZXNzKSA9PiB2aXNpdG9yKFRva2VuLlRleHRFbmQucmVhZCh2aWV3LCBhZGRyZXNzKSkpOyB9XG4gICAgICAgIHZpc2l0Q2hpbGRyZW4odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gc3VwZXIudmlzaXRDaGlsZHJlbih2aXNpdG9yKSB8fCAhIXRoaXMudmlzaXRPcGVuKHZpc2l0b3IpIHx8ICEhdGhpcy52aXNpdE5ld2xpbmUodmlzaXRvcikgfHwgISF0aGlzLnZpc2l0RWxlbWVudHModmlzaXRvcikgfHwgISF0aGlzLnZpc2l0Q2xvc2UodmlzaXRvcik7IH1cbiAgICB9XG4gICAgZXhwb3J0IGNsYXNzIEFwcCBleHRlbmRzIEFic3RyYWN0QmFzZSB7XG4gICAgICAgIHJlYWRvbmx5IHR5cGU6IFR5cGUuQXBwO1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3OiBEYXRhVmlldykgeyBzdXBlcih2aWV3KTsgdGhpcy50eXBlID0gVHlwZS5BcHA7IH1cbiAgICAgICAgc3RhdGljIHJlYWQodmlldzogRGF0YVZpZXcsIGFkZHJlc3M6IG51bWJlcik6IEFwcCB7IHJldHVybiBuZXcgQXBwKHJlYWRPZmZzZXQodmlldywgYWRkcmVzcykpOyB9XG4gICAgICAgIGdldCBmdW5jKCk6IFRyZWUgeyByZXR1cm4gVHJlZS5yZWFkKHRoaXMuX3YsIDUyKTsgfVxuICAgICAgICBnZXQgYXJnKCk6IFRyZWUgeyByZXR1cm4gVHJlZS5yZWFkKHRoaXMuX3YsIDU2KTsgfVxuICAgICAgICB2aXNpdENoaWxkcmVuKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHN1cGVyLnZpc2l0Q2hpbGRyZW4odmlzaXRvcikgfHwgISF2aXNpdG9yKHRoaXMuZnVuYykgfHwgISF2aXNpdG9yKHRoaXMuYXJnKTsgfVxuICAgIH1cbiAgICBleHBvcnQgY2xhc3MgTmFtZWRBcHAgZXh0ZW5kcyBBYnN0cmFjdEJhc2Uge1xuICAgICAgICByZWFkb25seSB0eXBlOiBUeXBlLk5hbWVkQXBwO1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3OiBEYXRhVmlldykgeyBzdXBlcih2aWV3KTsgdGhpcy50eXBlID0gVHlwZS5OYW1lZEFwcDsgfVxuICAgICAgICBzdGF0aWMgcmVhZCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKTogTmFtZWRBcHAgeyByZXR1cm4gbmV3IE5hbWVkQXBwKHJlYWRPZmZzZXQodmlldywgYWRkcmVzcykpOyB9XG4gICAgICAgIGdldCBmdW5jKCk6IFRyZWUgeyByZXR1cm4gVHJlZS5yZWFkKHRoaXMuX3YsIDUyKTsgfVxuICAgICAgICBnZXQgb3BlbigpOiBUb2tlbi5PcGVuU3ltYm9sIHwgdW5kZWZpbmVkIHsgcmV0dXJuIHJlYWRPcHRpb24odGhpcy5fdiwgNTYsIFRva2VuLk9wZW5TeW1ib2wucmVhZCk7IH1cbiAgICAgICAgZ2V0IG5hbWUoKTogVG9rZW4uSWRlbnQgeyByZXR1cm4gVG9rZW4uSWRlbnQucmVhZCh0aGlzLl92LCA2MSk7IH1cbiAgICAgICAgZ2V0IGVxdWFscygpOiBUb2tlbi5PcGVyYXRvciB7IHJldHVybiBUb2tlbi5PcGVyYXRvci5yZWFkKHRoaXMuX3YsIDE0NCk7IH1cbiAgICAgICAgZ2V0IGFyZygpOiBUcmVlIHsgcmV0dXJuIFRyZWUucmVhZCh0aGlzLl92LCAyMjApOyB9XG4gICAgICAgIGdldCBjbG9zZSgpOiBUb2tlbi5DbG9zZVN5bWJvbCB8IHVuZGVmaW5lZCB7IHJldHVybiByZWFkT3B0aW9uKHRoaXMuX3YsIDIyNCwgVG9rZW4uQ2xvc2VTeW1ib2wucmVhZCk7IH1cbiAgICAgICAgdmlzaXRPcGVuKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHZpc2l0T3B0aW9uKHRoaXMuX3YsIDU2LCAodmlldywgYWRkcmVzcykgPT4gdmlzaXRvcihUb2tlbi5PcGVuU3ltYm9sLnJlYWQodmlldywgYWRkcmVzcykpKTsgfVxuICAgICAgICB2aXNpdENsb3NlKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHZpc2l0T3B0aW9uKHRoaXMuX3YsIDIyNCwgKHZpZXcsIGFkZHJlc3MpID0+IHZpc2l0b3IoVG9rZW4uQ2xvc2VTeW1ib2wucmVhZCh2aWV3LCBhZGRyZXNzKSkpOyB9XG4gICAgICAgIHZpc2l0Q2hpbGRyZW4odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gc3VwZXIudmlzaXRDaGlsZHJlbih2aXNpdG9yKSB8fCAhIXZpc2l0b3IodGhpcy5mdW5jKSB8fCAhIXRoaXMudmlzaXRPcGVuKHZpc2l0b3IpIHx8ICEhdmlzaXRvcih0aGlzLm5hbWUpIHx8ICEhdmlzaXRvcih0aGlzLmVxdWFscykgfHwgISF2aXNpdG9yKHRoaXMuYXJnKSB8fCAhIXRoaXMudmlzaXRDbG9zZSh2aXNpdG9yKTsgfVxuICAgIH1cbiAgICBleHBvcnQgY2xhc3MgT3ByQXBwIGV4dGVuZHMgQWJzdHJhY3RCYXNlIHtcbiAgICAgICAgcmVhZG9ubHkgdHlwZTogVHlwZS5PcHJBcHA7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXc6IERhdGFWaWV3KSB7IHN1cGVyKHZpZXcpOyB0aGlzLnR5cGUgPSBUeXBlLk9wckFwcDsgfVxuICAgICAgICBzdGF0aWMgcmVhZCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKTogT3ByQXBwIHsgcmV0dXJuIG5ldyBPcHJBcHAocmVhZE9mZnNldCh2aWV3LCBhZGRyZXNzKSk7IH1cbiAgICAgICAgZ2V0IGxocygpOiBUcmVlIHwgdW5kZWZpbmVkIHsgcmV0dXJuIHJlYWRPcHRpb24odGhpcy5fdiwgNTIsIFRyZWUucmVhZCk7IH1cbiAgICAgICAgZ2V0IG9wcigpOiBSZXN1bHQ8VG9rZW4uT3BlcmF0b3IsIE11bHRpcGxlT3BlcmF0b3JFcnJvcj4geyByZXR1cm4gcmVhZFJlc3VsdCh0aGlzLl92LCA1NywgVG9rZW4uT3BlcmF0b3IucmVhZCwgTXVsdGlwbGVPcGVyYXRvckVycm9yLnJlYWQpOyB9XG4gICAgICAgIGdldCByaHMoKTogVHJlZSB8IHVuZGVmaW5lZCB7IHJldHVybiByZWFkT3B0aW9uKHRoaXMuX3YsIDYxLCBUcmVlLnJlYWQpOyB9XG4gICAgICAgIHZpc2l0TGhzKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHZpc2l0T3B0aW9uKHRoaXMuX3YsIDUyLCAodmlldywgYWRkcmVzcykgPT4gdmlzaXRvcihUcmVlLnJlYWQodmlldywgYWRkcmVzcykpKTsgfVxuICAgICAgICB2aXNpdE9wcih2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiB2aXNpdFJlc3VsdCh0aGlzLl92LCA1NywgKHZpZXcsIGFkZHJlc3MpID0+IHZpc2l0b3IoVG9rZW4uT3BlcmF0b3IucmVhZCh2aWV3LCBhZGRyZXNzKSksICh2aWV3LCBhZGRyZXNzKSA9PiB2aXNpdG9yKE11bHRpcGxlT3BlcmF0b3JFcnJvci5yZWFkKHZpZXcsIGFkZHJlc3MpKSk7IH1cbiAgICAgICAgdmlzaXRSaHModmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gdmlzaXRPcHRpb24odGhpcy5fdiwgNjEsICh2aWV3LCBhZGRyZXNzKSA9PiB2aXNpdG9yKFRyZWUucmVhZCh2aWV3LCBhZGRyZXNzKSkpOyB9XG4gICAgICAgIHZpc2l0Q2hpbGRyZW4odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gc3VwZXIudmlzaXRDaGlsZHJlbih2aXNpdG9yKSB8fCAhIXRoaXMudmlzaXRMaHModmlzaXRvcikgfHwgISF0aGlzLnZpc2l0T3ByKHZpc2l0b3IpIHx8ICEhdGhpcy52aXNpdFJocyh2aXNpdG9yKTsgfVxuICAgIH1cbiAgICBleHBvcnQgY2xhc3MgVW5hcnlPcHJBcHAgZXh0ZW5kcyBBYnN0cmFjdEJhc2Uge1xuICAgICAgICByZWFkb25seSB0eXBlOiBUeXBlLlVuYXJ5T3ByQXBwO1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3OiBEYXRhVmlldykgeyBzdXBlcih2aWV3KTsgdGhpcy50eXBlID0gVHlwZS5VbmFyeU9wckFwcDsgfVxuICAgICAgICBzdGF0aWMgcmVhZCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKTogVW5hcnlPcHJBcHAgeyByZXR1cm4gbmV3IFVuYXJ5T3ByQXBwKHJlYWRPZmZzZXQodmlldywgYWRkcmVzcykpOyB9XG4gICAgICAgIGdldCBvcHIoKTogVG9rZW4uT3BlcmF0b3IgeyByZXR1cm4gVG9rZW4uT3BlcmF0b3IucmVhZCh0aGlzLl92LCA1Mik7IH1cbiAgICAgICAgZ2V0IHJocygpOiBUcmVlIHwgdW5kZWZpbmVkIHsgcmV0dXJuIHJlYWRPcHRpb24odGhpcy5fdiwgMTI4LCBUcmVlLnJlYWQpOyB9XG4gICAgICAgIHZpc2l0UmhzKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHZpc2l0T3B0aW9uKHRoaXMuX3YsIDEyOCwgKHZpZXcsIGFkZHJlc3MpID0+IHZpc2l0b3IoVHJlZS5yZWFkKHZpZXcsIGFkZHJlc3MpKSk7IH1cbiAgICAgICAgdmlzaXRDaGlsZHJlbih2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiBzdXBlci52aXNpdENoaWxkcmVuKHZpc2l0b3IpIHx8ICEhdmlzaXRvcih0aGlzLm9wcikgfHwgISF0aGlzLnZpc2l0UmhzKHZpc2l0b3IpOyB9XG4gICAgfVxuICAgIGV4cG9ydCBjbGFzcyBBdXRvc2NvcGVkSWRlbnRpZmllciBleHRlbmRzIEFic3RyYWN0QmFzZSB7XG4gICAgICAgIHJlYWRvbmx5IHR5cGU6IFR5cGUuQXV0b3Njb3BlZElkZW50aWZpZXI7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXc6IERhdGFWaWV3KSB7IHN1cGVyKHZpZXcpOyB0aGlzLnR5cGUgPSBUeXBlLkF1dG9zY29wZWRJZGVudGlmaWVyOyB9XG4gICAgICAgIHN0YXRpYyByZWFkKHZpZXc6IERhdGFWaWV3LCBhZGRyZXNzOiBudW1iZXIpOiBBdXRvc2NvcGVkSWRlbnRpZmllciB7IHJldHVybiBuZXcgQXV0b3Njb3BlZElkZW50aWZpZXIocmVhZE9mZnNldCh2aWV3LCBhZGRyZXNzKSk7IH1cbiAgICAgICAgZ2V0IG9wcigpOiBUb2tlbi5PcGVyYXRvciB7IHJldHVybiBUb2tlbi5PcGVyYXRvci5yZWFkKHRoaXMuX3YsIDUyKTsgfVxuICAgICAgICBnZXQgaWRlbnQoKTogVG9rZW4uSWRlbnQgeyByZXR1cm4gVG9rZW4uSWRlbnQucmVhZCh0aGlzLl92LCAxMjgpOyB9XG4gICAgICAgIHZpc2l0Q2hpbGRyZW4odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gc3VwZXIudmlzaXRDaGlsZHJlbih2aXNpdG9yKSB8fCAhIXZpc2l0b3IodGhpcy5vcHIpIHx8ICEhdmlzaXRvcih0aGlzLmlkZW50KTsgfVxuICAgIH1cbiAgICBleHBvcnQgY2xhc3MgT3ByU2VjdGlvbkJvdW5kYXJ5IGV4dGVuZHMgQWJzdHJhY3RCYXNlIHtcbiAgICAgICAgcmVhZG9ubHkgdHlwZTogVHlwZS5PcHJTZWN0aW9uQm91bmRhcnk7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXc6IERhdGFWaWV3KSB7IHN1cGVyKHZpZXcpOyB0aGlzLnR5cGUgPSBUeXBlLk9wclNlY3Rpb25Cb3VuZGFyeTsgfVxuICAgICAgICBzdGF0aWMgcmVhZCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKTogT3ByU2VjdGlvbkJvdW5kYXJ5IHsgcmV0dXJuIG5ldyBPcHJTZWN0aW9uQm91bmRhcnkocmVhZE9mZnNldCh2aWV3LCBhZGRyZXNzKSk7IH1cbiAgICAgICAgZ2V0IGFyZ3VtZW50cygpOiBudW1iZXIgeyByZXR1cm4gcmVhZFUzMih0aGlzLl92LCA1Mik7IH1cbiAgICAgICAgZ2V0IGFzdCgpOiBUcmVlIHsgcmV0dXJuIFRyZWUucmVhZCh0aGlzLl92LCA1Nik7IH1cbiAgICAgICAgdmlzaXRDaGlsZHJlbih2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiBzdXBlci52aXNpdENoaWxkcmVuKHZpc2l0b3IpIHx8ICEhdmlzaXRvcih0aGlzLmFzdCk7IH1cbiAgICB9XG4gICAgZXhwb3J0IGNsYXNzIFRlbXBsYXRlRnVuY3Rpb24gZXh0ZW5kcyBBYnN0cmFjdEJhc2Uge1xuICAgICAgICByZWFkb25seSB0eXBlOiBUeXBlLlRlbXBsYXRlRnVuY3Rpb247XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXc6IERhdGFWaWV3KSB7IHN1cGVyKHZpZXcpOyB0aGlzLnR5cGUgPSBUeXBlLlRlbXBsYXRlRnVuY3Rpb247IH1cbiAgICAgICAgc3RhdGljIHJlYWQodmlldzogRGF0YVZpZXcsIGFkZHJlc3M6IG51bWJlcik6IFRlbXBsYXRlRnVuY3Rpb24geyByZXR1cm4gbmV3IFRlbXBsYXRlRnVuY3Rpb24ocmVhZE9mZnNldCh2aWV3LCBhZGRyZXNzKSk7IH1cbiAgICAgICAgZ2V0IGFyZ3VtZW50cygpOiBudW1iZXIgeyByZXR1cm4gcmVhZFUzMih0aGlzLl92LCA1Mik7IH1cbiAgICAgICAgZ2V0IGFzdCgpOiBUcmVlIHsgcmV0dXJuIFRyZWUucmVhZCh0aGlzLl92LCA1Nik7IH1cbiAgICAgICAgdmlzaXRDaGlsZHJlbih2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiBzdXBlci52aXNpdENoaWxkcmVuKHZpc2l0b3IpIHx8ICEhdmlzaXRvcih0aGlzLmFzdCk7IH1cbiAgICB9XG4gICAgZXhwb3J0IGNsYXNzIE11bHRpU2VnbWVudEFwcCBleHRlbmRzIEFic3RyYWN0QmFzZSB7XG4gICAgICAgIHJlYWRvbmx5IHR5cGU6IFR5cGUuTXVsdGlTZWdtZW50QXBwO1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3OiBEYXRhVmlldykgeyBzdXBlcih2aWV3KTsgdGhpcy50eXBlID0gVHlwZS5NdWx0aVNlZ21lbnRBcHA7IH1cbiAgICAgICAgc3RhdGljIHJlYWQodmlldzogRGF0YVZpZXcsIGFkZHJlc3M6IG51bWJlcik6IE11bHRpU2VnbWVudEFwcCB7IHJldHVybiBuZXcgTXVsdGlTZWdtZW50QXBwKHJlYWRPZmZzZXQodmlldywgYWRkcmVzcykpOyB9XG4gICAgICAgIGdldCBzZWdtZW50cygpOiBJdGVyYWJsZUl0ZXJhdG9yPE11bHRpU2VnbWVudEFwcFNlZ21lbnQ+IHsgcmV0dXJuIHJlYWRTZXF1ZW5jZSh0aGlzLl92LCA1MiwgOSwgTXVsdGlTZWdtZW50QXBwU2VnbWVudC5yZWFkKTsgfVxuICAgICAgICB2aXNpdFNlZ21lbnRzKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHZpc2l0U2VxdWVuY2UodGhpcy5fdiwgNTIsIDksICh2aWV3LCBhZGRyZXNzKSA9PiB2aXNpdG9yKE11bHRpU2VnbWVudEFwcFNlZ21lbnQucmVhZCh2aWV3LCBhZGRyZXNzKSkpOyB9XG4gICAgICAgIHZpc2l0Q2hpbGRyZW4odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gc3VwZXIudmlzaXRDaGlsZHJlbih2aXNpdG9yKSB8fCAhIXRoaXMudmlzaXRTZWdtZW50cyh2aXNpdG9yKTsgfVxuICAgIH1cbiAgICBleHBvcnQgY2xhc3MgVHlwZURlZiBleHRlbmRzIEFic3RyYWN0QmFzZSB7XG4gICAgICAgIHJlYWRvbmx5IHR5cGU6IFR5cGUuVHlwZURlZjtcbiAgICAgICAgY29uc3RydWN0b3IodmlldzogRGF0YVZpZXcpIHsgc3VwZXIodmlldyk7IHRoaXMudHlwZSA9IFR5cGUuVHlwZURlZjsgfVxuICAgICAgICBzdGF0aWMgcmVhZCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKTogVHlwZURlZiB7IHJldHVybiBuZXcgVHlwZURlZihyZWFkT2Zmc2V0KHZpZXcsIGFkZHJlc3MpKTsgfVxuICAgICAgICBnZXQga2V5d29yZCgpOiBUb2tlbi5JZGVudCB7IHJldHVybiBUb2tlbi5JZGVudC5yZWFkKHRoaXMuX3YsIDUyKTsgfVxuICAgICAgICBnZXQgbmFtZSgpOiBUb2tlbi5JZGVudCB7IHJldHVybiBUb2tlbi5JZGVudC5yZWFkKHRoaXMuX3YsIDEzNSk7IH1cbiAgICAgICAgZ2V0IHBhcmFtcygpOiBJdGVyYWJsZUl0ZXJhdG9yPEFyZ3VtZW50RGVmaW5pdGlvbj4geyByZXR1cm4gcmVhZFNlcXVlbmNlKHRoaXMuX3YsIDIxOCwgMzksIEFyZ3VtZW50RGVmaW5pdGlvbi5yZWFkKTsgfVxuICAgICAgICBnZXQgYm9keSgpOiBJdGVyYWJsZUl0ZXJhdG9yPExpbmU+IHsgcmV0dXJuIHJlYWRTZXF1ZW5jZSh0aGlzLl92LCAyMjIsIDgxLCBMaW5lLnJlYWQpOyB9XG4gICAgICAgIHZpc2l0UGFyYW1zKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHZpc2l0U2VxdWVuY2UodGhpcy5fdiwgMjE4LCAzOSwgKHZpZXcsIGFkZHJlc3MpID0+IHZpc2l0b3IoQXJndW1lbnREZWZpbml0aW9uLnJlYWQodmlldywgYWRkcmVzcykpKTsgfVxuICAgICAgICB2aXNpdEJvZHkodmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gdmlzaXRTZXF1ZW5jZSh0aGlzLl92LCAyMjIsIDgxLCAodmlldywgYWRkcmVzcykgPT4gdmlzaXRvcihMaW5lLnJlYWQodmlldywgYWRkcmVzcykpKTsgfVxuICAgICAgICB2aXNpdENoaWxkcmVuKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHN1cGVyLnZpc2l0Q2hpbGRyZW4odmlzaXRvcikgfHwgISF2aXNpdG9yKHRoaXMua2V5d29yZCkgfHwgISF2aXNpdG9yKHRoaXMubmFtZSkgfHwgISF0aGlzLnZpc2l0UGFyYW1zKHZpc2l0b3IpIHx8ICEhdGhpcy52aXNpdEJvZHkodmlzaXRvcik7IH1cbiAgICB9XG4gICAgZXhwb3J0IGNsYXNzIEFzc2lnbm1lbnQgZXh0ZW5kcyBBYnN0cmFjdEJhc2Uge1xuICAgICAgICByZWFkb25seSB0eXBlOiBUeXBlLkFzc2lnbm1lbnQ7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXc6IERhdGFWaWV3KSB7IHN1cGVyKHZpZXcpOyB0aGlzLnR5cGUgPSBUeXBlLkFzc2lnbm1lbnQ7IH1cbiAgICAgICAgc3RhdGljIHJlYWQodmlldzogRGF0YVZpZXcsIGFkZHJlc3M6IG51bWJlcik6IEFzc2lnbm1lbnQgeyByZXR1cm4gbmV3IEFzc2lnbm1lbnQocmVhZE9mZnNldCh2aWV3LCBhZGRyZXNzKSk7IH1cbiAgICAgICAgZ2V0IHBhdHRlcm4oKTogVHJlZSB7IHJldHVybiBUcmVlLnJlYWQodGhpcy5fdiwgNTIpOyB9XG4gICAgICAgIGdldCBlcXVhbHMoKTogVG9rZW4uT3BlcmF0b3IgeyByZXR1cm4gVG9rZW4uT3BlcmF0b3IucmVhZCh0aGlzLl92LCA1Nik7IH1cbiAgICAgICAgZ2V0IGV4cHIoKTogVHJlZSB7IHJldHVybiBUcmVlLnJlYWQodGhpcy5fdiwgMTMyKTsgfVxuICAgICAgICB2aXNpdENoaWxkcmVuKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHN1cGVyLnZpc2l0Q2hpbGRyZW4odmlzaXRvcikgfHwgISF2aXNpdG9yKHRoaXMucGF0dGVybikgfHwgISF2aXNpdG9yKHRoaXMuZXF1YWxzKSB8fCAhIXZpc2l0b3IodGhpcy5leHByKTsgfVxuICAgIH1cbiAgICBleHBvcnQgY2xhc3MgRnVuY3Rpb24gZXh0ZW5kcyBBYnN0cmFjdEJhc2Uge1xuICAgICAgICByZWFkb25seSB0eXBlOiBUeXBlLkZ1bmN0aW9uO1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3OiBEYXRhVmlldykgeyBzdXBlcih2aWV3KTsgdGhpcy50eXBlID0gVHlwZS5GdW5jdGlvbjsgfVxuICAgICAgICBzdGF0aWMgcmVhZCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKTogRnVuY3Rpb24geyByZXR1cm4gbmV3IEZ1bmN0aW9uKHJlYWRPZmZzZXQodmlldywgYWRkcmVzcykpOyB9XG4gICAgICAgIGdldCBuYW1lKCk6IFRyZWUgeyByZXR1cm4gVHJlZS5yZWFkKHRoaXMuX3YsIDUyKTsgfVxuICAgICAgICBnZXQgYXJncygpOiBJdGVyYWJsZUl0ZXJhdG9yPEFyZ3VtZW50RGVmaW5pdGlvbj4geyByZXR1cm4gcmVhZFNlcXVlbmNlKHRoaXMuX3YsIDU2LCAzOSwgQXJndW1lbnREZWZpbml0aW9uLnJlYWQpOyB9XG4gICAgICAgIGdldCByZXR1cm5zKCk6IFJldHVyblNwZWNpZmljYXRpb24gfCB1bmRlZmluZWQgeyByZXR1cm4gcmVhZE9wdGlvbih0aGlzLl92LCA2MCwgUmV0dXJuU3BlY2lmaWNhdGlvbi5yZWFkKTsgfVxuICAgICAgICBnZXQgZXF1YWxzKCk6IFRva2VuLk9wZXJhdG9yIHsgcmV0dXJuIFRva2VuLk9wZXJhdG9yLnJlYWQodGhpcy5fdiwgNjUpOyB9XG4gICAgICAgIGdldCBib2R5KCk6IFRyZWUgfCB1bmRlZmluZWQgeyByZXR1cm4gcmVhZE9wdGlvbih0aGlzLl92LCAxNDEsIFRyZWUucmVhZCk7IH1cbiAgICAgICAgdmlzaXRBcmdzKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHZpc2l0U2VxdWVuY2UodGhpcy5fdiwgNTYsIDM5LCAodmlldywgYWRkcmVzcykgPT4gdmlzaXRvcihBcmd1bWVudERlZmluaXRpb24ucmVhZCh2aWV3LCBhZGRyZXNzKSkpOyB9XG4gICAgICAgIHZpc2l0UmV0dXJucyh2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiB2aXNpdE9wdGlvbih0aGlzLl92LCA2MCwgKHZpZXcsIGFkZHJlc3MpID0+IHZpc2l0b3IoUmV0dXJuU3BlY2lmaWNhdGlvbi5yZWFkKHZpZXcsIGFkZHJlc3MpKSk7IH1cbiAgICAgICAgdmlzaXRCb2R5KHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHZpc2l0T3B0aW9uKHRoaXMuX3YsIDE0MSwgKHZpZXcsIGFkZHJlc3MpID0+IHZpc2l0b3IoVHJlZS5yZWFkKHZpZXcsIGFkZHJlc3MpKSk7IH1cbiAgICAgICAgdmlzaXRDaGlsZHJlbih2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiBzdXBlci52aXNpdENoaWxkcmVuKHZpc2l0b3IpIHx8ICEhdmlzaXRvcih0aGlzLm5hbWUpIHx8ICEhdGhpcy52aXNpdEFyZ3ModmlzaXRvcikgfHwgISF0aGlzLnZpc2l0UmV0dXJucyh2aXNpdG9yKSB8fCAhIXZpc2l0b3IodGhpcy5lcXVhbHMpIHx8ICEhdGhpcy52aXNpdEJvZHkodmlzaXRvcik7IH1cbiAgICB9XG4gICAgZXhwb3J0IGNsYXNzIEZvcmVpZ25GdW5jdGlvbiBleHRlbmRzIEFic3RyYWN0QmFzZSB7XG4gICAgICAgIHJlYWRvbmx5IHR5cGU6IFR5cGUuRm9yZWlnbkZ1bmN0aW9uO1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3OiBEYXRhVmlldykgeyBzdXBlcih2aWV3KTsgdGhpcy50eXBlID0gVHlwZS5Gb3JlaWduRnVuY3Rpb247IH1cbiAgICAgICAgc3RhdGljIHJlYWQodmlldzogRGF0YVZpZXcsIGFkZHJlc3M6IG51bWJlcik6IEZvcmVpZ25GdW5jdGlvbiB7IHJldHVybiBuZXcgRm9yZWlnbkZ1bmN0aW9uKHJlYWRPZmZzZXQodmlldywgYWRkcmVzcykpOyB9XG4gICAgICAgIGdldCBmb3JlaWduKCk6IFRva2VuLklkZW50IHsgcmV0dXJuIFRva2VuLklkZW50LnJlYWQodGhpcy5fdiwgNTIpOyB9XG4gICAgICAgIGdldCBsYW5ndWFnZSgpOiBUb2tlbi5JZGVudCB7IHJldHVybiBUb2tlbi5JZGVudC5yZWFkKHRoaXMuX3YsIDEzNSk7IH1cbiAgICAgICAgZ2V0IG5hbWUoKTogVG9rZW4uSWRlbnQgeyByZXR1cm4gVG9rZW4uSWRlbnQucmVhZCh0aGlzLl92LCAyMTgpOyB9XG4gICAgICAgIGdldCBhcmdzKCk6IEl0ZXJhYmxlSXRlcmF0b3I8QXJndW1lbnREZWZpbml0aW9uPiB7IHJldHVybiByZWFkU2VxdWVuY2UodGhpcy5fdiwgMzAxLCAzOSwgQXJndW1lbnREZWZpbml0aW9uLnJlYWQpOyB9XG4gICAgICAgIGdldCBlcXVhbHMoKTogVG9rZW4uT3BlcmF0b3IgeyByZXR1cm4gVG9rZW4uT3BlcmF0b3IucmVhZCh0aGlzLl92LCAzMDUpOyB9XG4gICAgICAgIGdldCBib2R5KCk6IFRyZWUgeyByZXR1cm4gVHJlZS5yZWFkKHRoaXMuX3YsIDM4MSk7IH1cbiAgICAgICAgdmlzaXRBcmdzKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHZpc2l0U2VxdWVuY2UodGhpcy5fdiwgMzAxLCAzOSwgKHZpZXcsIGFkZHJlc3MpID0+IHZpc2l0b3IoQXJndW1lbnREZWZpbml0aW9uLnJlYWQodmlldywgYWRkcmVzcykpKTsgfVxuICAgICAgICB2aXNpdENoaWxkcmVuKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHN1cGVyLnZpc2l0Q2hpbGRyZW4odmlzaXRvcikgfHwgISF2aXNpdG9yKHRoaXMuZm9yZWlnbikgfHwgISF2aXNpdG9yKHRoaXMubGFuZ3VhZ2UpIHx8ICEhdmlzaXRvcih0aGlzLm5hbWUpIHx8ICEhdGhpcy52aXNpdEFyZ3ModmlzaXRvcikgfHwgISF2aXNpdG9yKHRoaXMuZXF1YWxzKSB8fCAhIXZpc2l0b3IodGhpcy5ib2R5KTsgfVxuICAgIH1cbiAgICBleHBvcnQgY2xhc3MgSW1wb3J0IGV4dGVuZHMgQWJzdHJhY3RCYXNlIHtcbiAgICAgICAgcmVhZG9ubHkgdHlwZTogVHlwZS5JbXBvcnQ7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXc6IERhdGFWaWV3KSB7IHN1cGVyKHZpZXcpOyB0aGlzLnR5cGUgPSBUeXBlLkltcG9ydDsgfVxuICAgICAgICBzdGF0aWMgcmVhZCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKTogSW1wb3J0IHsgcmV0dXJuIG5ldyBJbXBvcnQocmVhZE9mZnNldCh2aWV3LCBhZGRyZXNzKSk7IH1cbiAgICAgICAgZ2V0IHBvbHlnbG90KCk6IE11bHRpU2VnbWVudEFwcFNlZ21lbnQgfCB1bmRlZmluZWQgeyByZXR1cm4gcmVhZE9wdGlvbih0aGlzLl92LCA1MiwgTXVsdGlTZWdtZW50QXBwU2VnbWVudC5yZWFkKTsgfVxuICAgICAgICBnZXQgZnJvbSgpOiBNdWx0aVNlZ21lbnRBcHBTZWdtZW50IHwgdW5kZWZpbmVkIHsgcmV0dXJuIHJlYWRPcHRpb24odGhpcy5fdiwgNTcsIE11bHRpU2VnbWVudEFwcFNlZ21lbnQucmVhZCk7IH1cbiAgICAgICAgZ2V0IGltcG9ydCgpOiBNdWx0aVNlZ21lbnRBcHBTZWdtZW50IHsgcmV0dXJuIE11bHRpU2VnbWVudEFwcFNlZ21lbnQucmVhZCh0aGlzLl92LCA2Mik7IH1cbiAgICAgICAgZ2V0IGFsbCgpOiBUb2tlbi5JZGVudCB8IHVuZGVmaW5lZCB7IHJldHVybiByZWFkT3B0aW9uKHRoaXMuX3YsIDcxLCBUb2tlbi5JZGVudC5yZWFkKTsgfVxuICAgICAgICBnZXQgYXMoKTogTXVsdGlTZWdtZW50QXBwU2VnbWVudCB8IHVuZGVmaW5lZCB7IHJldHVybiByZWFkT3B0aW9uKHRoaXMuX3YsIDc2LCBNdWx0aVNlZ21lbnRBcHBTZWdtZW50LnJlYWQpOyB9XG4gICAgICAgIGdldCBoaWRpbmcoKTogTXVsdGlTZWdtZW50QXBwU2VnbWVudCB8IHVuZGVmaW5lZCB7IHJldHVybiByZWFkT3B0aW9uKHRoaXMuX3YsIDgxLCBNdWx0aVNlZ21lbnRBcHBTZWdtZW50LnJlYWQpOyB9XG4gICAgICAgIHZpc2l0UG9seWdsb3QodmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gdmlzaXRPcHRpb24odGhpcy5fdiwgNTIsICh2aWV3LCBhZGRyZXNzKSA9PiB2aXNpdG9yKE11bHRpU2VnbWVudEFwcFNlZ21lbnQucmVhZCh2aWV3LCBhZGRyZXNzKSkpOyB9XG4gICAgICAgIHZpc2l0RnJvbSh2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiB2aXNpdE9wdGlvbih0aGlzLl92LCA1NywgKHZpZXcsIGFkZHJlc3MpID0+IHZpc2l0b3IoTXVsdGlTZWdtZW50QXBwU2VnbWVudC5yZWFkKHZpZXcsIGFkZHJlc3MpKSk7IH1cbiAgICAgICAgdmlzaXRBbGwodmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gdmlzaXRPcHRpb24odGhpcy5fdiwgNzEsICh2aWV3LCBhZGRyZXNzKSA9PiB2aXNpdG9yKFRva2VuLklkZW50LnJlYWQodmlldywgYWRkcmVzcykpKTsgfVxuICAgICAgICB2aXNpdEFzKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHZpc2l0T3B0aW9uKHRoaXMuX3YsIDc2LCAodmlldywgYWRkcmVzcykgPT4gdmlzaXRvcihNdWx0aVNlZ21lbnRBcHBTZWdtZW50LnJlYWQodmlldywgYWRkcmVzcykpKTsgfVxuICAgICAgICB2aXNpdEhpZGluZyh2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiB2aXNpdE9wdGlvbih0aGlzLl92LCA4MSwgKHZpZXcsIGFkZHJlc3MpID0+IHZpc2l0b3IoTXVsdGlTZWdtZW50QXBwU2VnbWVudC5yZWFkKHZpZXcsIGFkZHJlc3MpKSk7IH1cbiAgICAgICAgdmlzaXRDaGlsZHJlbih2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiBzdXBlci52aXNpdENoaWxkcmVuKHZpc2l0b3IpIHx8ICEhdGhpcy52aXNpdFBvbHlnbG90KHZpc2l0b3IpIHx8ICEhdGhpcy52aXNpdEZyb20odmlzaXRvcikgfHwgISF2aXNpdG9yKHRoaXMuaW1wb3J0KSB8fCAhIXRoaXMudmlzaXRBbGwodmlzaXRvcikgfHwgISF0aGlzLnZpc2l0QXModmlzaXRvcikgfHwgISF0aGlzLnZpc2l0SGlkaW5nKHZpc2l0b3IpOyB9XG4gICAgfVxuICAgIGV4cG9ydCBjbGFzcyBFeHBvcnQgZXh0ZW5kcyBBYnN0cmFjdEJhc2Uge1xuICAgICAgICByZWFkb25seSB0eXBlOiBUeXBlLkV4cG9ydDtcbiAgICAgICAgY29uc3RydWN0b3IodmlldzogRGF0YVZpZXcpIHsgc3VwZXIodmlldyk7IHRoaXMudHlwZSA9IFR5cGUuRXhwb3J0OyB9XG4gICAgICAgIHN0YXRpYyByZWFkKHZpZXc6IERhdGFWaWV3LCBhZGRyZXNzOiBudW1iZXIpOiBFeHBvcnQgeyByZXR1cm4gbmV3IEV4cG9ydChyZWFkT2Zmc2V0KHZpZXcsIGFkZHJlc3MpKTsgfVxuICAgICAgICBnZXQgZnJvbSgpOiBNdWx0aVNlZ21lbnRBcHBTZWdtZW50IHwgdW5kZWZpbmVkIHsgcmV0dXJuIHJlYWRPcHRpb24odGhpcy5fdiwgNTIsIE11bHRpU2VnbWVudEFwcFNlZ21lbnQucmVhZCk7IH1cbiAgICAgICAgZ2V0IGV4cG9ydCgpOiBNdWx0aVNlZ21lbnRBcHBTZWdtZW50IHsgcmV0dXJuIE11bHRpU2VnbWVudEFwcFNlZ21lbnQucmVhZCh0aGlzLl92LCA1Nyk7IH1cbiAgICAgICAgZ2V0IGFsbCgpOiBUb2tlbi5JZGVudCB8IHVuZGVmaW5lZCB7IHJldHVybiByZWFkT3B0aW9uKHRoaXMuX3YsIDY2LCBUb2tlbi5JZGVudC5yZWFkKTsgfVxuICAgICAgICBnZXQgYXMoKTogTXVsdGlTZWdtZW50QXBwU2VnbWVudCB8IHVuZGVmaW5lZCB7IHJldHVybiByZWFkT3B0aW9uKHRoaXMuX3YsIDcxLCBNdWx0aVNlZ21lbnRBcHBTZWdtZW50LnJlYWQpOyB9XG4gICAgICAgIGdldCBoaWRpbmcoKTogTXVsdGlTZWdtZW50QXBwU2VnbWVudCB8IHVuZGVmaW5lZCB7IHJldHVybiByZWFkT3B0aW9uKHRoaXMuX3YsIDc2LCBNdWx0aVNlZ21lbnRBcHBTZWdtZW50LnJlYWQpOyB9XG4gICAgICAgIHZpc2l0RnJvbSh2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiB2aXNpdE9wdGlvbih0aGlzLl92LCA1MiwgKHZpZXcsIGFkZHJlc3MpID0+IHZpc2l0b3IoTXVsdGlTZWdtZW50QXBwU2VnbWVudC5yZWFkKHZpZXcsIGFkZHJlc3MpKSk7IH1cbiAgICAgICAgdmlzaXRBbGwodmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gdmlzaXRPcHRpb24odGhpcy5fdiwgNjYsICh2aWV3LCBhZGRyZXNzKSA9PiB2aXNpdG9yKFRva2VuLklkZW50LnJlYWQodmlldywgYWRkcmVzcykpKTsgfVxuICAgICAgICB2aXNpdEFzKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHZpc2l0T3B0aW9uKHRoaXMuX3YsIDcxLCAodmlldywgYWRkcmVzcykgPT4gdmlzaXRvcihNdWx0aVNlZ21lbnRBcHBTZWdtZW50LnJlYWQodmlldywgYWRkcmVzcykpKTsgfVxuICAgICAgICB2aXNpdEhpZGluZyh2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiB2aXNpdE9wdGlvbih0aGlzLl92LCA3NiwgKHZpZXcsIGFkZHJlc3MpID0+IHZpc2l0b3IoTXVsdGlTZWdtZW50QXBwU2VnbWVudC5yZWFkKHZpZXcsIGFkZHJlc3MpKSk7IH1cbiAgICAgICAgdmlzaXRDaGlsZHJlbih2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiBzdXBlci52aXNpdENoaWxkcmVuKHZpc2l0b3IpIHx8ICEhdGhpcy52aXNpdEZyb20odmlzaXRvcikgfHwgISF2aXNpdG9yKHRoaXMuZXhwb3J0KSB8fCAhIXRoaXMudmlzaXRBbGwodmlzaXRvcikgfHwgISF0aGlzLnZpc2l0QXModmlzaXRvcikgfHwgISF0aGlzLnZpc2l0SGlkaW5nKHZpc2l0b3IpOyB9XG4gICAgfVxuICAgIGV4cG9ydCBjbGFzcyBHcm91cCBleHRlbmRzIEFic3RyYWN0QmFzZSB7XG4gICAgICAgIHJlYWRvbmx5IHR5cGU6IFR5cGUuR3JvdXA7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXc6IERhdGFWaWV3KSB7IHN1cGVyKHZpZXcpOyB0aGlzLnR5cGUgPSBUeXBlLkdyb3VwOyB9XG4gICAgICAgIHN0YXRpYyByZWFkKHZpZXc6IERhdGFWaWV3LCBhZGRyZXNzOiBudW1iZXIpOiBHcm91cCB7IHJldHVybiBuZXcgR3JvdXAocmVhZE9mZnNldCh2aWV3LCBhZGRyZXNzKSk7IH1cbiAgICAgICAgZ2V0IG9wZW4oKTogVG9rZW4uT3BlblN5bWJvbCB8IHVuZGVmaW5lZCB7IHJldHVybiByZWFkT3B0aW9uKHRoaXMuX3YsIDUyLCBUb2tlbi5PcGVuU3ltYm9sLnJlYWQpOyB9XG4gICAgICAgIGdldCBib2R5KCk6IFRyZWUgfCB1bmRlZmluZWQgeyByZXR1cm4gcmVhZE9wdGlvbih0aGlzLl92LCA1NywgVHJlZS5yZWFkKTsgfVxuICAgICAgICBnZXQgY2xvc2UoKTogVG9rZW4uQ2xvc2VTeW1ib2wgfCB1bmRlZmluZWQgeyByZXR1cm4gcmVhZE9wdGlvbih0aGlzLl92LCA2MiwgVG9rZW4uQ2xvc2VTeW1ib2wucmVhZCk7IH1cbiAgICAgICAgdmlzaXRPcGVuKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHZpc2l0T3B0aW9uKHRoaXMuX3YsIDUyLCAodmlldywgYWRkcmVzcykgPT4gdmlzaXRvcihUb2tlbi5PcGVuU3ltYm9sLnJlYWQodmlldywgYWRkcmVzcykpKTsgfVxuICAgICAgICB2aXNpdEJvZHkodmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gdmlzaXRPcHRpb24odGhpcy5fdiwgNTcsICh2aWV3LCBhZGRyZXNzKSA9PiB2aXNpdG9yKFRyZWUucmVhZCh2aWV3LCBhZGRyZXNzKSkpOyB9XG4gICAgICAgIHZpc2l0Q2xvc2UodmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gdmlzaXRPcHRpb24odGhpcy5fdiwgNjIsICh2aWV3LCBhZGRyZXNzKSA9PiB2aXNpdG9yKFRva2VuLkNsb3NlU3ltYm9sLnJlYWQodmlldywgYWRkcmVzcykpKTsgfVxuICAgICAgICB2aXNpdENoaWxkcmVuKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHN1cGVyLnZpc2l0Q2hpbGRyZW4odmlzaXRvcikgfHwgISF0aGlzLnZpc2l0T3Blbih2aXNpdG9yKSB8fCAhIXRoaXMudmlzaXRCb2R5KHZpc2l0b3IpIHx8ICEhdGhpcy52aXNpdENsb3NlKHZpc2l0b3IpOyB9XG4gICAgfVxuICAgIGV4cG9ydCBjbGFzcyBUeXBlU2lnbmF0dXJlIGV4dGVuZHMgQWJzdHJhY3RCYXNlIHtcbiAgICAgICAgcmVhZG9ubHkgdHlwZTogVHlwZS5UeXBlU2lnbmF0dXJlO1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3OiBEYXRhVmlldykgeyBzdXBlcih2aWV3KTsgdGhpcy50eXBlID0gVHlwZS5UeXBlU2lnbmF0dXJlOyB9XG4gICAgICAgIHN0YXRpYyByZWFkKHZpZXc6IERhdGFWaWV3LCBhZGRyZXNzOiBudW1iZXIpOiBUeXBlU2lnbmF0dXJlIHsgcmV0dXJuIG5ldyBUeXBlU2lnbmF0dXJlKHJlYWRPZmZzZXQodmlldywgYWRkcmVzcykpOyB9XG4gICAgICAgIGdldCB2YXJpYWJsZSgpOiBUcmVlIHsgcmV0dXJuIFRyZWUucmVhZCh0aGlzLl92LCA1Mik7IH1cbiAgICAgICAgZ2V0IG9wZXJhdG9yKCk6IFRva2VuLk9wZXJhdG9yIHsgcmV0dXJuIFRva2VuLk9wZXJhdG9yLnJlYWQodGhpcy5fdiwgNTYpOyB9XG4gICAgICAgIGdldCB0eXBlTm9kZSgpOiBUcmVlIHsgcmV0dXJuIFRyZWUucmVhZCh0aGlzLl92LCAxMzIpOyB9XG4gICAgICAgIHZpc2l0Q2hpbGRyZW4odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gc3VwZXIudmlzaXRDaGlsZHJlbih2aXNpdG9yKSB8fCAhIXZpc2l0b3IodGhpcy52YXJpYWJsZSkgfHwgISF2aXNpdG9yKHRoaXMub3BlcmF0b3IpIHx8ICEhdmlzaXRvcih0aGlzLnR5cGVOb2RlKTsgfVxuICAgIH1cbiAgICBleHBvcnQgY2xhc3MgVHlwZUFubm90YXRlZCBleHRlbmRzIEFic3RyYWN0QmFzZSB7XG4gICAgICAgIHJlYWRvbmx5IHR5cGU6IFR5cGUuVHlwZUFubm90YXRlZDtcbiAgICAgICAgY29uc3RydWN0b3IodmlldzogRGF0YVZpZXcpIHsgc3VwZXIodmlldyk7IHRoaXMudHlwZSA9IFR5cGUuVHlwZUFubm90YXRlZDsgfVxuICAgICAgICBzdGF0aWMgcmVhZCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKTogVHlwZUFubm90YXRlZCB7IHJldHVybiBuZXcgVHlwZUFubm90YXRlZChyZWFkT2Zmc2V0KHZpZXcsIGFkZHJlc3MpKTsgfVxuICAgICAgICBnZXQgZXhwcmVzc2lvbigpOiBUcmVlIHsgcmV0dXJuIFRyZWUucmVhZCh0aGlzLl92LCA1Mik7IH1cbiAgICAgICAgZ2V0IG9wZXJhdG9yKCk6IFRva2VuLk9wZXJhdG9yIHsgcmV0dXJuIFRva2VuLk9wZXJhdG9yLnJlYWQodGhpcy5fdiwgNTYpOyB9XG4gICAgICAgIGdldCB0eXBlTm9kZSgpOiBUcmVlIHsgcmV0dXJuIFRyZWUucmVhZCh0aGlzLl92LCAxMzIpOyB9XG4gICAgICAgIHZpc2l0Q2hpbGRyZW4odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gc3VwZXIudmlzaXRDaGlsZHJlbih2aXNpdG9yKSB8fCAhIXZpc2l0b3IodGhpcy5leHByZXNzaW9uKSB8fCAhIXZpc2l0b3IodGhpcy5vcGVyYXRvcikgfHwgISF2aXNpdG9yKHRoaXMudHlwZU5vZGUpOyB9XG4gICAgfVxuICAgIGV4cG9ydCBjbGFzcyBDYXNlT2YgZXh0ZW5kcyBBYnN0cmFjdEJhc2Uge1xuICAgICAgICByZWFkb25seSB0eXBlOiBUeXBlLkNhc2VPZjtcbiAgICAgICAgY29uc3RydWN0b3IodmlldzogRGF0YVZpZXcpIHsgc3VwZXIodmlldyk7IHRoaXMudHlwZSA9IFR5cGUuQ2FzZU9mOyB9XG4gICAgICAgIHN0YXRpYyByZWFkKHZpZXc6IERhdGFWaWV3LCBhZGRyZXNzOiBudW1iZXIpOiBDYXNlT2YgeyByZXR1cm4gbmV3IENhc2VPZihyZWFkT2Zmc2V0KHZpZXcsIGFkZHJlc3MpKTsgfVxuICAgICAgICBnZXQgY2FzZSgpOiBUb2tlbi5JZGVudCB7IHJldHVybiBUb2tlbi5JZGVudC5yZWFkKHRoaXMuX3YsIDUyKTsgfVxuICAgICAgICBnZXQgZXhwcmVzc2lvbigpOiBUcmVlIHwgdW5kZWZpbmVkIHsgcmV0dXJuIHJlYWRPcHRpb24odGhpcy5fdiwgMTM1LCBUcmVlLnJlYWQpOyB9XG4gICAgICAgIGdldCBvZigpOiBUb2tlbi5JZGVudCB7IHJldHVybiBUb2tlbi5JZGVudC5yZWFkKHRoaXMuX3YsIDE0MCk7IH1cbiAgICAgICAgZ2V0IGNhc2VzKCk6IEl0ZXJhYmxlSXRlcmF0b3I8Q2FzZUxpbmU+IHsgcmV0dXJuIHJlYWRTZXF1ZW5jZSh0aGlzLl92LCAyMjMsIDEwLCBDYXNlTGluZS5yZWFkKTsgfVxuICAgICAgICB2aXNpdEV4cHJlc3Npb24odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gdmlzaXRPcHRpb24odGhpcy5fdiwgMTM1LCAodmlldywgYWRkcmVzcykgPT4gdmlzaXRvcihUcmVlLnJlYWQodmlldywgYWRkcmVzcykpKTsgfVxuICAgICAgICB2aXNpdENhc2VzKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHZpc2l0U2VxdWVuY2UodGhpcy5fdiwgMjIzLCAxMCwgKHZpZXcsIGFkZHJlc3MpID0+IHZpc2l0b3IoQ2FzZUxpbmUucmVhZCh2aWV3LCBhZGRyZXNzKSkpOyB9XG4gICAgICAgIHZpc2l0Q2hpbGRyZW4odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gc3VwZXIudmlzaXRDaGlsZHJlbih2aXNpdG9yKSB8fCAhIXZpc2l0b3IodGhpcy5jYXNlKSB8fCAhIXRoaXMudmlzaXRFeHByZXNzaW9uKHZpc2l0b3IpIHx8ICEhdmlzaXRvcih0aGlzLm9mKSB8fCAhIXRoaXMudmlzaXRDYXNlcyh2aXNpdG9yKTsgfVxuICAgIH1cbiAgICBleHBvcnQgY2xhc3MgTGFtYmRhIGV4dGVuZHMgQWJzdHJhY3RCYXNlIHtcbiAgICAgICAgcmVhZG9ubHkgdHlwZTogVHlwZS5MYW1iZGE7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXc6IERhdGFWaWV3KSB7IHN1cGVyKHZpZXcpOyB0aGlzLnR5cGUgPSBUeXBlLkxhbWJkYTsgfVxuICAgICAgICBzdGF0aWMgcmVhZCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKTogTGFtYmRhIHsgcmV0dXJuIG5ldyBMYW1iZGEocmVhZE9mZnNldCh2aWV3LCBhZGRyZXNzKSk7IH1cbiAgICAgICAgZ2V0IG9wZXJhdG9yKCk6IFRva2VuLk9wZXJhdG9yIHsgcmV0dXJuIFRva2VuLk9wZXJhdG9yLnJlYWQodGhpcy5fdiwgNTIpOyB9XG4gICAgICAgIGdldCBhcnJvdygpOiBUcmVlIHwgdW5kZWZpbmVkIHsgcmV0dXJuIHJlYWRPcHRpb24odGhpcy5fdiwgMTI4LCBUcmVlLnJlYWQpOyB9XG4gICAgICAgIHZpc2l0QXJyb3codmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gdmlzaXRPcHRpb24odGhpcy5fdiwgMTI4LCAodmlldywgYWRkcmVzcykgPT4gdmlzaXRvcihUcmVlLnJlYWQodmlldywgYWRkcmVzcykpKTsgfVxuICAgICAgICB2aXNpdENoaWxkcmVuKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHN1cGVyLnZpc2l0Q2hpbGRyZW4odmlzaXRvcikgfHwgISF2aXNpdG9yKHRoaXMub3BlcmF0b3IpIHx8ICEhdGhpcy52aXNpdEFycm93KHZpc2l0b3IpOyB9XG4gICAgfVxuICAgIGV4cG9ydCBjbGFzcyBBcnJheSBleHRlbmRzIEFic3RyYWN0QmFzZSB7XG4gICAgICAgIHJlYWRvbmx5IHR5cGU6IFR5cGUuQXJyYXk7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXc6IERhdGFWaWV3KSB7IHN1cGVyKHZpZXcpOyB0aGlzLnR5cGUgPSBUeXBlLkFycmF5OyB9XG4gICAgICAgIHN0YXRpYyByZWFkKHZpZXc6IERhdGFWaWV3LCBhZGRyZXNzOiBudW1iZXIpOiBBcnJheSB7IHJldHVybiBuZXcgQXJyYXkocmVhZE9mZnNldCh2aWV3LCBhZGRyZXNzKSk7IH1cbiAgICAgICAgZ2V0IGxlZnQoKTogVG9rZW4uT3BlblN5bWJvbCB7IHJldHVybiBUb2tlbi5PcGVuU3ltYm9sLnJlYWQodGhpcy5fdiwgNTIpOyB9XG4gICAgICAgIGdldCBmaXJzdCgpOiBUcmVlIHwgdW5kZWZpbmVkIHsgcmV0dXJuIHJlYWRPcHRpb24odGhpcy5fdiwgMTI4LCBUcmVlLnJlYWQpOyB9XG4gICAgICAgIGdldCByZXN0KCk6IEl0ZXJhYmxlSXRlcmF0b3I8T3BlcmF0b3JEZWxpbWl0ZWRUcmVlPiB7IHJldHVybiByZWFkU2VxdWVuY2UodGhpcy5fdiwgMTMzLCA4MSwgT3BlcmF0b3JEZWxpbWl0ZWRUcmVlLnJlYWQpOyB9XG4gICAgICAgIGdldCByaWdodCgpOiBUb2tlbi5DbG9zZVN5bWJvbCB7IHJldHVybiBUb2tlbi5DbG9zZVN5bWJvbC5yZWFkKHRoaXMuX3YsIDEzNyk7IH1cbiAgICAgICAgdmlzaXRGaXJzdCh2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiB2aXNpdE9wdGlvbih0aGlzLl92LCAxMjgsICh2aWV3LCBhZGRyZXNzKSA9PiB2aXNpdG9yKFRyZWUucmVhZCh2aWV3LCBhZGRyZXNzKSkpOyB9XG4gICAgICAgIHZpc2l0UmVzdCh2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiB2aXNpdFNlcXVlbmNlKHRoaXMuX3YsIDEzMywgODEsICh2aWV3LCBhZGRyZXNzKSA9PiB2aXNpdG9yKE9wZXJhdG9yRGVsaW1pdGVkVHJlZS5yZWFkKHZpZXcsIGFkZHJlc3MpKSk7IH1cbiAgICAgICAgdmlzaXRDaGlsZHJlbih2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiBzdXBlci52aXNpdENoaWxkcmVuKHZpc2l0b3IpIHx8ICEhdmlzaXRvcih0aGlzLmxlZnQpIHx8ICEhdGhpcy52aXNpdEZpcnN0KHZpc2l0b3IpIHx8ICEhdGhpcy52aXNpdFJlc3QodmlzaXRvcikgfHwgISF2aXNpdG9yKHRoaXMucmlnaHQpOyB9XG4gICAgfVxuICAgIGV4cG9ydCBjbGFzcyBUdXBsZSBleHRlbmRzIEFic3RyYWN0QmFzZSB7XG4gICAgICAgIHJlYWRvbmx5IHR5cGU6IFR5cGUuVHVwbGU7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXc6IERhdGFWaWV3KSB7IHN1cGVyKHZpZXcpOyB0aGlzLnR5cGUgPSBUeXBlLlR1cGxlOyB9XG4gICAgICAgIHN0YXRpYyByZWFkKHZpZXc6IERhdGFWaWV3LCBhZGRyZXNzOiBudW1iZXIpOiBUdXBsZSB7IHJldHVybiBuZXcgVHVwbGUocmVhZE9mZnNldCh2aWV3LCBhZGRyZXNzKSk7IH1cbiAgICAgICAgZ2V0IGxlZnQoKTogVG9rZW4uT3BlblN5bWJvbCB7IHJldHVybiBUb2tlbi5PcGVuU3ltYm9sLnJlYWQodGhpcy5fdiwgNTIpOyB9XG4gICAgICAgIGdldCBmaXJzdCgpOiBUcmVlIHwgdW5kZWZpbmVkIHsgcmV0dXJuIHJlYWRPcHRpb24odGhpcy5fdiwgMTI4LCBUcmVlLnJlYWQpOyB9XG4gICAgICAgIGdldCByZXN0KCk6IEl0ZXJhYmxlSXRlcmF0b3I8T3BlcmF0b3JEZWxpbWl0ZWRUcmVlPiB7IHJldHVybiByZWFkU2VxdWVuY2UodGhpcy5fdiwgMTMzLCA4MSwgT3BlcmF0b3JEZWxpbWl0ZWRUcmVlLnJlYWQpOyB9XG4gICAgICAgIGdldCByaWdodCgpOiBUb2tlbi5DbG9zZVN5bWJvbCB7IHJldHVybiBUb2tlbi5DbG9zZVN5bWJvbC5yZWFkKHRoaXMuX3YsIDEzNyk7IH1cbiAgICAgICAgdmlzaXRGaXJzdCh2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiB2aXNpdE9wdGlvbih0aGlzLl92LCAxMjgsICh2aWV3LCBhZGRyZXNzKSA9PiB2aXNpdG9yKFRyZWUucmVhZCh2aWV3LCBhZGRyZXNzKSkpOyB9XG4gICAgICAgIHZpc2l0UmVzdCh2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiB2aXNpdFNlcXVlbmNlKHRoaXMuX3YsIDEzMywgODEsICh2aWV3LCBhZGRyZXNzKSA9PiB2aXNpdG9yKE9wZXJhdG9yRGVsaW1pdGVkVHJlZS5yZWFkKHZpZXcsIGFkZHJlc3MpKSk7IH1cbiAgICAgICAgdmlzaXRDaGlsZHJlbih2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiBzdXBlci52aXNpdENoaWxkcmVuKHZpc2l0b3IpIHx8ICEhdmlzaXRvcih0aGlzLmxlZnQpIHx8ICEhdGhpcy52aXNpdEZpcnN0KHZpc2l0b3IpIHx8ICEhdGhpcy52aXNpdFJlc3QodmlzaXRvcikgfHwgISF2aXNpdG9yKHRoaXMucmlnaHQpOyB9XG4gICAgfVxuICAgIGV4cG9ydCBjbGFzcyBBbm5vdGF0ZWQgZXh0ZW5kcyBBYnN0cmFjdEJhc2Uge1xuICAgICAgICByZWFkb25seSB0eXBlOiBUeXBlLkFubm90YXRlZDtcbiAgICAgICAgY29uc3RydWN0b3IodmlldzogRGF0YVZpZXcpIHsgc3VwZXIodmlldyk7IHRoaXMudHlwZSA9IFR5cGUuQW5ub3RhdGVkOyB9XG4gICAgICAgIHN0YXRpYyByZWFkKHZpZXc6IERhdGFWaWV3LCBhZGRyZXNzOiBudW1iZXIpOiBBbm5vdGF0ZWQgeyByZXR1cm4gbmV3IEFubm90YXRlZChyZWFkT2Zmc2V0KHZpZXcsIGFkZHJlc3MpKTsgfVxuICAgICAgICBnZXQgdG9rZW4oKTogVG9rZW4uT3BlcmF0b3IgeyByZXR1cm4gVG9rZW4uT3BlcmF0b3IucmVhZCh0aGlzLl92LCA1Mik7IH1cbiAgICAgICAgZ2V0IGFubm90YXRpb24oKTogVG9rZW4uSWRlbnQgeyByZXR1cm4gVG9rZW4uSWRlbnQucmVhZCh0aGlzLl92LCAxMjgpOyB9XG4gICAgICAgIGdldCBhcmd1bWVudCgpOiBUcmVlIHwgdW5kZWZpbmVkIHsgcmV0dXJuIHJlYWRPcHRpb24odGhpcy5fdiwgMjExLCBUcmVlLnJlYWQpOyB9XG4gICAgICAgIGdldCBuZXdsaW5lcygpOiBJdGVyYWJsZUl0ZXJhdG9yPFRva2VuLk5ld2xpbmU+IHsgcmV0dXJuIHJlYWRTZXF1ZW5jZSh0aGlzLl92LCAyMTYsIDc2LCBUb2tlbi5OZXdsaW5lLnJlYWQpOyB9XG4gICAgICAgIGdldCBleHByZXNzaW9uKCk6IFRyZWUgfCB1bmRlZmluZWQgeyByZXR1cm4gcmVhZE9wdGlvbih0aGlzLl92LCAyMjAsIFRyZWUucmVhZCk7IH1cbiAgICAgICAgdmlzaXRBcmd1bWVudCh2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiB2aXNpdE9wdGlvbih0aGlzLl92LCAyMTEsICh2aWV3LCBhZGRyZXNzKSA9PiB2aXNpdG9yKFRyZWUucmVhZCh2aWV3LCBhZGRyZXNzKSkpOyB9XG4gICAgICAgIHZpc2l0TmV3bGluZXModmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gdmlzaXRTZXF1ZW5jZSh0aGlzLl92LCAyMTYsIDc2LCAodmlldywgYWRkcmVzcykgPT4gdmlzaXRvcihUb2tlbi5OZXdsaW5lLnJlYWQodmlldywgYWRkcmVzcykpKTsgfVxuICAgICAgICB2aXNpdEV4cHJlc3Npb24odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gdmlzaXRPcHRpb24odGhpcy5fdiwgMjIwLCAodmlldywgYWRkcmVzcykgPT4gdmlzaXRvcihUcmVlLnJlYWQodmlldywgYWRkcmVzcykpKTsgfVxuICAgICAgICB2aXNpdENoaWxkcmVuKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHN1cGVyLnZpc2l0Q2hpbGRyZW4odmlzaXRvcikgfHwgISF2aXNpdG9yKHRoaXMudG9rZW4pIHx8ICEhdmlzaXRvcih0aGlzLmFubm90YXRpb24pIHx8ICEhdGhpcy52aXNpdEFyZ3VtZW50KHZpc2l0b3IpIHx8ICEhdGhpcy52aXNpdE5ld2xpbmVzKHZpc2l0b3IpIHx8ICEhdGhpcy52aXNpdEV4cHJlc3Npb24odmlzaXRvcik7IH1cbiAgICB9XG4gICAgZXhwb3J0IGNsYXNzIEFubm90YXRlZEJ1aWx0aW4gZXh0ZW5kcyBBYnN0cmFjdEJhc2Uge1xuICAgICAgICByZWFkb25seSB0eXBlOiBUeXBlLkFubm90YXRlZEJ1aWx0aW47XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXc6IERhdGFWaWV3KSB7IHN1cGVyKHZpZXcpOyB0aGlzLnR5cGUgPSBUeXBlLkFubm90YXRlZEJ1aWx0aW47IH1cbiAgICAgICAgc3RhdGljIHJlYWQodmlldzogRGF0YVZpZXcsIGFkZHJlc3M6IG51bWJlcik6IEFubm90YXRlZEJ1aWx0aW4geyByZXR1cm4gbmV3IEFubm90YXRlZEJ1aWx0aW4ocmVhZE9mZnNldCh2aWV3LCBhZGRyZXNzKSk7IH1cbiAgICAgICAgZ2V0IHRva2VuKCk6IFRva2VuLk9wZXJhdG9yIHsgcmV0dXJuIFRva2VuLk9wZXJhdG9yLnJlYWQodGhpcy5fdiwgNTIpOyB9XG4gICAgICAgIGdldCBhbm5vdGF0aW9uKCk6IFRva2VuLklkZW50IHsgcmV0dXJuIFRva2VuLklkZW50LnJlYWQodGhpcy5fdiwgMTI4KTsgfVxuICAgICAgICBnZXQgbmV3bGluZXMoKTogSXRlcmFibGVJdGVyYXRvcjxUb2tlbi5OZXdsaW5lPiB7IHJldHVybiByZWFkU2VxdWVuY2UodGhpcy5fdiwgMjExLCA3NiwgVG9rZW4uTmV3bGluZS5yZWFkKTsgfVxuICAgICAgICBnZXQgZXhwcmVzc2lvbigpOiBUcmVlIHwgdW5kZWZpbmVkIHsgcmV0dXJuIHJlYWRPcHRpb24odGhpcy5fdiwgMjE1LCBUcmVlLnJlYWQpOyB9XG4gICAgICAgIHZpc2l0TmV3bGluZXModmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gdmlzaXRTZXF1ZW5jZSh0aGlzLl92LCAyMTEsIDc2LCAodmlldywgYWRkcmVzcykgPT4gdmlzaXRvcihUb2tlbi5OZXdsaW5lLnJlYWQodmlldywgYWRkcmVzcykpKTsgfVxuICAgICAgICB2aXNpdEV4cHJlc3Npb24odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gdmlzaXRPcHRpb24odGhpcy5fdiwgMjE1LCAodmlldywgYWRkcmVzcykgPT4gdmlzaXRvcihUcmVlLnJlYWQodmlldywgYWRkcmVzcykpKTsgfVxuICAgICAgICB2aXNpdENoaWxkcmVuKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHN1cGVyLnZpc2l0Q2hpbGRyZW4odmlzaXRvcikgfHwgISF2aXNpdG9yKHRoaXMudG9rZW4pIHx8ICEhdmlzaXRvcih0aGlzLmFubm90YXRpb24pIHx8ICEhdGhpcy52aXNpdE5ld2xpbmVzKHZpc2l0b3IpIHx8ICEhdGhpcy52aXNpdEV4cHJlc3Npb24odmlzaXRvcik7IH1cbiAgICB9XG4gICAgZXhwb3J0IGNsYXNzIERvY3VtZW50ZWQgZXh0ZW5kcyBBYnN0cmFjdEJhc2Uge1xuICAgICAgICByZWFkb25seSB0eXBlOiBUeXBlLkRvY3VtZW50ZWQ7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXc6IERhdGFWaWV3KSB7IHN1cGVyKHZpZXcpOyB0aGlzLnR5cGUgPSBUeXBlLkRvY3VtZW50ZWQ7IH1cbiAgICAgICAgc3RhdGljIHJlYWQodmlldzogRGF0YVZpZXcsIGFkZHJlc3M6IG51bWJlcik6IERvY3VtZW50ZWQgeyByZXR1cm4gbmV3IERvY3VtZW50ZWQocmVhZE9mZnNldCh2aWV3LCBhZGRyZXNzKSk7IH1cbiAgICAgICAgZ2V0IGRvY3VtZW50YXRpb24oKTogRG9jQ29tbWVudCB7IHJldHVybiBEb2NDb21tZW50LnJlYWQodGhpcy5fdiwgNTIpOyB9XG4gICAgICAgIGdldCBleHByZXNzaW9uKCk6IFRyZWUgfCB1bmRlZmluZWQgeyByZXR1cm4gcmVhZE9wdGlvbih0aGlzLl92LCAxMzYsIFRyZWUucmVhZCk7IH1cbiAgICAgICAgdmlzaXRFeHByZXNzaW9uKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHZpc2l0T3B0aW9uKHRoaXMuX3YsIDEzNiwgKHZpZXcsIGFkZHJlc3MpID0+IHZpc2l0b3IoVHJlZS5yZWFkKHZpZXcsIGFkZHJlc3MpKSk7IH1cbiAgICAgICAgdmlzaXRDaGlsZHJlbih2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiBzdXBlci52aXNpdENoaWxkcmVuKHZpc2l0b3IpIHx8ICEhdmlzaXRvcih0aGlzLmRvY3VtZW50YXRpb24pIHx8ICEhdGhpcy52aXNpdEV4cHJlc3Npb24odmlzaXRvcik7IH1cbiAgICB9XG4gICAgZXhwb3J0IGNsYXNzIENvbnN0cnVjdG9yRGVmaW5pdGlvbiBleHRlbmRzIEFic3RyYWN0QmFzZSB7XG4gICAgICAgIHJlYWRvbmx5IHR5cGU6IFR5cGUuQ29uc3RydWN0b3JEZWZpbml0aW9uO1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3OiBEYXRhVmlldykgeyBzdXBlcih2aWV3KTsgdGhpcy50eXBlID0gVHlwZS5Db25zdHJ1Y3RvckRlZmluaXRpb247IH1cbiAgICAgICAgc3RhdGljIHJlYWQodmlldzogRGF0YVZpZXcsIGFkZHJlc3M6IG51bWJlcik6IENvbnN0cnVjdG9yRGVmaW5pdGlvbiB7IHJldHVybiBuZXcgQ29uc3RydWN0b3JEZWZpbml0aW9uKHJlYWRPZmZzZXQodmlldywgYWRkcmVzcykpOyB9XG4gICAgICAgIGdldCBpZGVudCgpOiBUb2tlbi5JZGVudCB7IHJldHVybiBUb2tlbi5JZGVudC5yZWFkKHRoaXMuX3YsIDUyKTsgfVxuICAgICAgICBnZXQgYXJndW1lbnRzKCk6IEl0ZXJhYmxlSXRlcmF0b3I8QXJndW1lbnREZWZpbml0aW9uPiB7IHJldHVybiByZWFkU2VxdWVuY2UodGhpcy5fdiwgMTM1LCAzOSwgQXJndW1lbnREZWZpbml0aW9uLnJlYWQpOyB9XG4gICAgICAgIGdldCBibG9jaygpOiBJdGVyYWJsZUl0ZXJhdG9yPEFyZ3VtZW50RGVmaW5pdGlvbkxpbmU+IHsgcmV0dXJuIHJlYWRTZXF1ZW5jZSh0aGlzLl92LCAxMzksIDgxLCBBcmd1bWVudERlZmluaXRpb25MaW5lLnJlYWQpOyB9XG4gICAgICAgIHZpc2l0QXJndW1lbnRzKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHZpc2l0U2VxdWVuY2UodGhpcy5fdiwgMTM1LCAzOSwgKHZpZXcsIGFkZHJlc3MpID0+IHZpc2l0b3IoQXJndW1lbnREZWZpbml0aW9uLnJlYWQodmlldywgYWRkcmVzcykpKTsgfVxuICAgICAgICB2aXNpdEJsb2NrKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHZpc2l0U2VxdWVuY2UodGhpcy5fdiwgMTM5LCA4MSwgKHZpZXcsIGFkZHJlc3MpID0+IHZpc2l0b3IoQXJndW1lbnREZWZpbml0aW9uTGluZS5yZWFkKHZpZXcsIGFkZHJlc3MpKSk7IH1cbiAgICAgICAgdmlzaXRDaGlsZHJlbih2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiBzdXBlci52aXNpdENoaWxkcmVuKHZpc2l0b3IpIHx8ICEhdmlzaXRvcih0aGlzLmlkZW50KSB8fCAhIXRoaXMudmlzaXRBcmd1bWVudHModmlzaXRvcikgfHwgISF0aGlzLnZpc2l0QmxvY2sodmlzaXRvcik7IH1cbiAgICB9XG4gICAgZXhwb3J0IHR5cGUgVHJlZSA9IEludmFsaWQgfCBCb2R5QmxvY2sgfCBBcmd1bWVudEJsb2NrQXBwbGljYXRpb24gfCBPcGVyYXRvckJsb2NrQXBwbGljYXRpb24gfCBJZGVudCB8IFByaXZhdGUgfCBOdW1iZXIgfCBXaWxkY2FyZCB8IFN1c3BlbmRlZERlZmF1bHRBcmd1bWVudHMgfCBUZXh0TGl0ZXJhbCB8IEFwcCB8IE5hbWVkQXBwIHwgT3ByQXBwIHwgVW5hcnlPcHJBcHAgfCBBdXRvc2NvcGVkSWRlbnRpZmllciB8IE9wclNlY3Rpb25Cb3VuZGFyeSB8IFRlbXBsYXRlRnVuY3Rpb24gfCBNdWx0aVNlZ21lbnRBcHAgfCBUeXBlRGVmIHwgQXNzaWdubWVudCB8IEZ1bmN0aW9uIHwgRm9yZWlnbkZ1bmN0aW9uIHwgSW1wb3J0IHwgRXhwb3J0IHwgR3JvdXAgfCBUeXBlU2lnbmF0dXJlIHwgVHlwZUFubm90YXRlZCB8IENhc2VPZiB8IExhbWJkYSB8IEFycmF5IHwgVHVwbGUgfCBBbm5vdGF0ZWQgfCBBbm5vdGF0ZWRCdWlsdGluIHwgRG9jdW1lbnRlZCB8IENvbnN0cnVjdG9yRGVmaW5pdGlvbjtcbiAgICBjb25zdCBWQVJJQU5UX1JFQURFUlMgPSBbSW52YWxpZC5yZWFkLCBCb2R5QmxvY2sucmVhZCwgQXJndW1lbnRCbG9ja0FwcGxpY2F0aW9uLnJlYWQsIE9wZXJhdG9yQmxvY2tBcHBsaWNhdGlvbi5yZWFkLCBJZGVudC5yZWFkLCBQcml2YXRlLnJlYWQsIE51bWJlci5yZWFkLCBXaWxkY2FyZC5yZWFkLCBTdXNwZW5kZWREZWZhdWx0QXJndW1lbnRzLnJlYWQsIFRleHRMaXRlcmFsLnJlYWQsIEFwcC5yZWFkLCBOYW1lZEFwcC5yZWFkLCBPcHJBcHAucmVhZCwgVW5hcnlPcHJBcHAucmVhZCwgQXV0b3Njb3BlZElkZW50aWZpZXIucmVhZCwgT3ByU2VjdGlvbkJvdW5kYXJ5LnJlYWQsIFRlbXBsYXRlRnVuY3Rpb24ucmVhZCwgTXVsdGlTZWdtZW50QXBwLnJlYWQsIFR5cGVEZWYucmVhZCwgQXNzaWdubWVudC5yZWFkLCBGdW5jdGlvbi5yZWFkLCBGb3JlaWduRnVuY3Rpb24ucmVhZCwgSW1wb3J0LnJlYWQsIEV4cG9ydC5yZWFkLCBHcm91cC5yZWFkLCBUeXBlU2lnbmF0dXJlLnJlYWQsIFR5cGVBbm5vdGF0ZWQucmVhZCwgQ2FzZU9mLnJlYWQsIExhbWJkYS5yZWFkLCBBcnJheS5yZWFkLCBUdXBsZS5yZWFkLCBBbm5vdGF0ZWQucmVhZCwgQW5ub3RhdGVkQnVpbHRpbi5yZWFkLCBEb2N1bWVudGVkLnJlYWQsIENvbnN0cnVjdG9yRGVmaW5pdGlvbi5yZWFkXTtcbiAgICBleHBvcnQgZnVuY3Rpb24gcmVhZCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKTogVHJlZSB7IHJldHVybiByZWFkRW51bTxUcmVlPihWQVJJQU5UX1JFQURFUlMsIHZpZXcsIGFkZHJlc3MpOyB9XG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzSW5zdGFuY2Uob2JqOiB1bmtub3duKTogb2JqIGlzIFRyZWUgeyByZXR1cm4gb2JqIGluc3RhbmNlb2YgQWJzdHJhY3RCYXNlOyB9XG59XG5leHBvcnQgdHlwZSBUcmVlID0gVHJlZS5UcmVlXG5leHBvcnQgY2xhc3MgTXVsdGlTZWdtZW50QXBwU2VnbWVudCBleHRlbmRzIExhenlPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKHZpZXc6IERhdGFWaWV3KSB7IHN1cGVyKHZpZXcpOyB9XG4gICAgc3RhdGljIHJlYWQodmlldzogRGF0YVZpZXcsIGFkZHJlc3M6IG51bWJlcik6IE11bHRpU2VnbWVudEFwcFNlZ21lbnQgeyByZXR1cm4gbmV3IE11bHRpU2VnbWVudEFwcFNlZ21lbnQocmVhZE9mZnNldCh2aWV3LCBhZGRyZXNzKSk7IH1cbiAgICBnZXQgaGVhZGVyKCk6IFRva2VuIHsgcmV0dXJuIFRva2VuLnJlYWQodGhpcy5fdiwgMCk7IH1cbiAgICBnZXQgYm9keSgpOiBUcmVlIHwgdW5kZWZpbmVkIHsgcmV0dXJuIHJlYWRPcHRpb24odGhpcy5fdiwgNCwgVHJlZS5yZWFkKTsgfVxuICAgIHZpc2l0Qm9keSh2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiB2aXNpdE9wdGlvbih0aGlzLl92LCA0LCAodmlldywgYWRkcmVzcykgPT4gdmlzaXRvcihUcmVlLnJlYWQodmlldywgYWRkcmVzcykpKTsgfVxuICAgIHZpc2l0Q2hpbGRyZW4odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gc3VwZXIudmlzaXRDaGlsZHJlbih2aXNpdG9yKSB8fCAhIXZpc2l0b3IodGhpcy5oZWFkZXIpIHx8ICEhdGhpcy52aXNpdEJvZHkodmlzaXRvcik7IH1cbn1cbmV4cG9ydCBjbGFzcyBDYXNlTGluZSBleHRlbmRzIExhenlPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKHZpZXc6IERhdGFWaWV3KSB7IHN1cGVyKHZpZXcpOyB9XG4gICAgc3RhdGljIHJlYWQodmlldzogRGF0YVZpZXcsIGFkZHJlc3M6IG51bWJlcik6IENhc2VMaW5lIHsgcmV0dXJuIG5ldyBDYXNlTGluZShyZWFkT2Zmc2V0KHZpZXcsIGFkZHJlc3MpKTsgfVxuICAgIGdldCBuZXdsaW5lKCk6IFRva2VuLk5ld2xpbmUgfCB1bmRlZmluZWQgeyByZXR1cm4gcmVhZE9wdGlvbih0aGlzLl92LCAwLCBUb2tlbi5OZXdsaW5lLnJlYWQpOyB9XG4gICAgZ2V0IGNhc2UoKTogQ2FzZSB8IHVuZGVmaW5lZCB7IHJldHVybiByZWFkT3B0aW9uKHRoaXMuX3YsIDUsIENhc2UucmVhZCk7IH1cbiAgICB2aXNpdE5ld2xpbmUodmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gdmlzaXRPcHRpb24odGhpcy5fdiwgMCwgKHZpZXcsIGFkZHJlc3MpID0+IHZpc2l0b3IoVG9rZW4uTmV3bGluZS5yZWFkKHZpZXcsIGFkZHJlc3MpKSk7IH1cbiAgICB2aXNpdENhc2UodmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gdmlzaXRPcHRpb24odGhpcy5fdiwgNSwgKHZpZXcsIGFkZHJlc3MpID0+IHZpc2l0b3IoQ2FzZS5yZWFkKHZpZXcsIGFkZHJlc3MpKSk7IH1cbiAgICB2aXNpdENoaWxkcmVuKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHN1cGVyLnZpc2l0Q2hpbGRyZW4odmlzaXRvcikgfHwgISF0aGlzLnZpc2l0TmV3bGluZSh2aXNpdG9yKSB8fCAhIXRoaXMudmlzaXRDYXNlKHZpc2l0b3IpOyB9XG59XG5leHBvcnQgbW9kdWxlIEJhc2Uge1xuICAgIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBYnN0cmFjdEJhc2UgZXh0ZW5kcyBMYXp5T2JqZWN0IHtcbiAgICAgICAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKHZpZXc6IERhdGFWaWV3KSB7IHN1cGVyKHZpZXcpOyB9XG4gICAgICAgIHZpc2l0Q2hpbGRyZW4odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gc3VwZXIudmlzaXRDaGlsZHJlbih2aXNpdG9yKTsgfVxuICAgIH1cbiAgICBleHBvcnQgY29uc3QgZW51bSBUeXBlIHtcbiAgICAgICAgQmluYXJ5ID0gMCxcbiAgICAgICAgT2N0YWwgPSAxLFxuICAgICAgICBIZXhhZGVjaW1hbCA9IDJcbiAgICB9XG4gICAgZXhwb3J0IGNvbnN0IHR5cGVOYW1lcyA9IFtcIkJpbmFyeVwiLCBcIk9jdGFsXCIsIFwiSGV4YWRlY2ltYWxcIl0gYXMgY29uc3Q7XG4gICAgZXhwb3J0IGNsYXNzIEJpbmFyeSBleHRlbmRzIEFic3RyYWN0QmFzZSB7XG4gICAgICAgIHJlYWRvbmx5IHR5cGU6IFR5cGUuQmluYXJ5O1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3OiBEYXRhVmlldykgeyBzdXBlcih2aWV3KTsgdGhpcy50eXBlID0gVHlwZS5CaW5hcnk7IH1cbiAgICAgICAgc3RhdGljIHJlYWQodmlldzogRGF0YVZpZXcsIGFkZHJlc3M6IG51bWJlcik6IEJpbmFyeSB7IHJldHVybiBuZXcgQmluYXJ5KHJlYWRPZmZzZXQodmlldywgYWRkcmVzcykpOyB9XG4gICAgICAgIHZpc2l0Q2hpbGRyZW4odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gc3VwZXIudmlzaXRDaGlsZHJlbih2aXNpdG9yKTsgfVxuICAgIH1cbiAgICBleHBvcnQgY2xhc3MgT2N0YWwgZXh0ZW5kcyBBYnN0cmFjdEJhc2Uge1xuICAgICAgICByZWFkb25seSB0eXBlOiBUeXBlLk9jdGFsO1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3OiBEYXRhVmlldykgeyBzdXBlcih2aWV3KTsgdGhpcy50eXBlID0gVHlwZS5PY3RhbDsgfVxuICAgICAgICBzdGF0aWMgcmVhZCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKTogT2N0YWwgeyByZXR1cm4gbmV3IE9jdGFsKHJlYWRPZmZzZXQodmlldywgYWRkcmVzcykpOyB9XG4gICAgICAgIHZpc2l0Q2hpbGRyZW4odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gc3VwZXIudmlzaXRDaGlsZHJlbih2aXNpdG9yKTsgfVxuICAgIH1cbiAgICBleHBvcnQgY2xhc3MgSGV4YWRlY2ltYWwgZXh0ZW5kcyBBYnN0cmFjdEJhc2Uge1xuICAgICAgICByZWFkb25seSB0eXBlOiBUeXBlLkhleGFkZWNpbWFsO1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3OiBEYXRhVmlldykgeyBzdXBlcih2aWV3KTsgdGhpcy50eXBlID0gVHlwZS5IZXhhZGVjaW1hbDsgfVxuICAgICAgICBzdGF0aWMgcmVhZCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKTogSGV4YWRlY2ltYWwgeyByZXR1cm4gbmV3IEhleGFkZWNpbWFsKHJlYWRPZmZzZXQodmlldywgYWRkcmVzcykpOyB9XG4gICAgICAgIHZpc2l0Q2hpbGRyZW4odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gc3VwZXIudmlzaXRDaGlsZHJlbih2aXNpdG9yKTsgfVxuICAgIH1cbiAgICBleHBvcnQgdHlwZSBCYXNlID0gQmluYXJ5IHwgT2N0YWwgfCBIZXhhZGVjaW1hbDtcbiAgICBjb25zdCBWQVJJQU5UX1JFQURFUlMgPSBbQmluYXJ5LnJlYWQsIE9jdGFsLnJlYWQsIEhleGFkZWNpbWFsLnJlYWRdO1xuICAgIGV4cG9ydCBmdW5jdGlvbiByZWFkKHZpZXc6IERhdGFWaWV3LCBhZGRyZXNzOiBudW1iZXIpOiBCYXNlIHsgcmV0dXJuIHJlYWRFbnVtPEJhc2U+KFZBUklBTlRfUkVBREVSUywgdmlldywgYWRkcmVzcyk7IH1cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNJbnN0YW5jZShvYmo6IHVua25vd24pOiBvYmogaXMgQmFzZSB7IHJldHVybiBvYmogaW5zdGFuY2VvZiBBYnN0cmFjdEJhc2U7IH1cbn1cbmV4cG9ydCB0eXBlIEJhc2UgPSBCYXNlLkJhc2VcbmV4cG9ydCBjbGFzcyBBcmd1bWVudERlZmluaXRpb25MaW5lIGV4dGVuZHMgTGF6eU9iamVjdCB7XG4gICAgY29uc3RydWN0b3IodmlldzogRGF0YVZpZXcpIHsgc3VwZXIodmlldyk7IH1cbiAgICBzdGF0aWMgcmVhZCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKTogQXJndW1lbnREZWZpbml0aW9uTGluZSB7IHJldHVybiBuZXcgQXJndW1lbnREZWZpbml0aW9uTGluZShyZWFkT2Zmc2V0KHZpZXcsIGFkZHJlc3MpKTsgfVxuICAgIGdldCBuZXdsaW5lKCk6IFRva2VuLk5ld2xpbmUgeyByZXR1cm4gVG9rZW4uTmV3bGluZS5yZWFkKHRoaXMuX3YsIDApOyB9XG4gICAgZ2V0IGFyZ3VtZW50KCk6IEFyZ3VtZW50RGVmaW5pdGlvbiB8IHVuZGVmaW5lZCB7IHJldHVybiByZWFkT3B0aW9uKHRoaXMuX3YsIDc2LCBBcmd1bWVudERlZmluaXRpb24ucmVhZCk7IH1cbiAgICB2aXNpdEFyZ3VtZW50KHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHZpc2l0T3B0aW9uKHRoaXMuX3YsIDc2LCAodmlldywgYWRkcmVzcykgPT4gdmlzaXRvcihBcmd1bWVudERlZmluaXRpb24ucmVhZCh2aWV3LCBhZGRyZXNzKSkpOyB9XG4gICAgdmlzaXRDaGlsZHJlbih2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiBzdXBlci52aXNpdENoaWxkcmVuKHZpc2l0b3IpIHx8ICEhdmlzaXRvcih0aGlzLm5ld2xpbmUpIHx8ICEhdGhpcy52aXNpdEFyZ3VtZW50KHZpc2l0b3IpOyB9XG59XG5leHBvcnQgY2xhc3MgQXJndW1lbnREZWZhdWx0IGV4dGVuZHMgTGF6eU9iamVjdCB7XG4gICAgY29uc3RydWN0b3IodmlldzogRGF0YVZpZXcpIHsgc3VwZXIodmlldyk7IH1cbiAgICBzdGF0aWMgcmVhZCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKTogQXJndW1lbnREZWZhdWx0IHsgcmV0dXJuIG5ldyBBcmd1bWVudERlZmF1bHQocmVhZE9mZnNldCh2aWV3LCBhZGRyZXNzKSk7IH1cbiAgICBnZXQgZXF1YWxzKCk6IFRva2VuLk9wZXJhdG9yIHsgcmV0dXJuIFRva2VuLk9wZXJhdG9yLnJlYWQodGhpcy5fdiwgMCk7IH1cbiAgICBnZXQgZXhwcmVzc2lvbigpOiBUcmVlIHsgcmV0dXJuIFRyZWUucmVhZCh0aGlzLl92LCA3Nik7IH1cbiAgICB2aXNpdENoaWxkcmVuKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHN1cGVyLnZpc2l0Q2hpbGRyZW4odmlzaXRvcikgfHwgISF2aXNpdG9yKHRoaXMuZXF1YWxzKSB8fCAhIXZpc2l0b3IodGhpcy5leHByZXNzaW9uKTsgfVxufVxuZXhwb3J0IGNsYXNzIE9wZXJhdG9yQmxvY2tFeHByZXNzaW9uIGV4dGVuZHMgTGF6eU9iamVjdCB7XG4gICAgY29uc3RydWN0b3IodmlldzogRGF0YVZpZXcpIHsgc3VwZXIodmlldyk7IH1cbiAgICBzdGF0aWMgcmVhZCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKTogT3BlcmF0b3JCbG9ja0V4cHJlc3Npb24geyByZXR1cm4gbmV3IE9wZXJhdG9yQmxvY2tFeHByZXNzaW9uKHJlYWRPZmZzZXQodmlldywgYWRkcmVzcykpOyB9XG4gICAgZ2V0IG9wZXJhdG9yKCk6IFJlc3VsdDxUb2tlbi5PcGVyYXRvciwgTXVsdGlwbGVPcGVyYXRvckVycm9yPiB7IHJldHVybiByZWFkUmVzdWx0KHRoaXMuX3YsIDAsIFRva2VuLk9wZXJhdG9yLnJlYWQsIE11bHRpcGxlT3BlcmF0b3JFcnJvci5yZWFkKTsgfVxuICAgIGdldCBleHByZXNzaW9uKCk6IFRyZWUgeyByZXR1cm4gVHJlZS5yZWFkKHRoaXMuX3YsIDQpOyB9XG4gICAgdmlzaXRPcGVyYXRvcih2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiB2aXNpdFJlc3VsdCh0aGlzLl92LCAwLCAodmlldywgYWRkcmVzcykgPT4gdmlzaXRvcihUb2tlbi5PcGVyYXRvci5yZWFkKHZpZXcsIGFkZHJlc3MpKSwgKHZpZXcsIGFkZHJlc3MpID0+IHZpc2l0b3IoTXVsdGlwbGVPcGVyYXRvckVycm9yLnJlYWQodmlldywgYWRkcmVzcykpKTsgfVxuICAgIHZpc2l0Q2hpbGRyZW4odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gc3VwZXIudmlzaXRDaGlsZHJlbih2aXNpdG9yKSB8fCAhIXRoaXMudmlzaXRPcGVyYXRvcih2aXNpdG9yKSB8fCAhIXZpc2l0b3IodGhpcy5leHByZXNzaW9uKTsgfVxufVxuZXhwb3J0IGNsYXNzIFJldHVyblNwZWNpZmljYXRpb24gZXh0ZW5kcyBMYXp5T2JqZWN0IHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3OiBEYXRhVmlldykgeyBzdXBlcih2aWV3KTsgfVxuICAgIHN0YXRpYyByZWFkKHZpZXc6IERhdGFWaWV3LCBhZGRyZXNzOiBudW1iZXIpOiBSZXR1cm5TcGVjaWZpY2F0aW9uIHsgcmV0dXJuIG5ldyBSZXR1cm5TcGVjaWZpY2F0aW9uKHJlYWRPZmZzZXQodmlldywgYWRkcmVzcykpOyB9XG4gICAgZ2V0IGFycm93KCk6IFRva2VuLk9wZXJhdG9yIHsgcmV0dXJuIFRva2VuLk9wZXJhdG9yLnJlYWQodGhpcy5fdiwgMCk7IH1cbiAgICBnZXQgdHlwZU5vZGUoKTogVHJlZSB7IHJldHVybiBUcmVlLnJlYWQodGhpcy5fdiwgNzYpOyB9XG4gICAgdmlzaXRDaGlsZHJlbih2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiBzdXBlci52aXNpdENoaWxkcmVuKHZpc2l0b3IpIHx8ICEhdmlzaXRvcih0aGlzLmFycm93KSB8fCAhIXZpc2l0b3IodGhpcy50eXBlTm9kZSk7IH1cbn1cbmV4cG9ydCBjbGFzcyBMaW5lIGV4dGVuZHMgTGF6eU9iamVjdCB7XG4gICAgY29uc3RydWN0b3IodmlldzogRGF0YVZpZXcpIHsgc3VwZXIodmlldyk7IH1cbiAgICBzdGF0aWMgcmVhZCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKTogTGluZSB7IHJldHVybiBuZXcgTGluZShyZWFkT2Zmc2V0KHZpZXcsIGFkZHJlc3MpKTsgfVxuICAgIGdldCBuZXdsaW5lKCk6IFRva2VuLk5ld2xpbmUgeyByZXR1cm4gVG9rZW4uTmV3bGluZS5yZWFkKHRoaXMuX3YsIDApOyB9XG4gICAgZ2V0IGV4cHJlc3Npb24oKTogVHJlZSB8IHVuZGVmaW5lZCB7IHJldHVybiByZWFkT3B0aW9uKHRoaXMuX3YsIDc2LCBUcmVlLnJlYWQpOyB9XG4gICAgdmlzaXRFeHByZXNzaW9uKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHZpc2l0T3B0aW9uKHRoaXMuX3YsIDc2LCAodmlldywgYWRkcmVzcykgPT4gdmlzaXRvcihUcmVlLnJlYWQodmlldywgYWRkcmVzcykpKTsgfVxuICAgIHZpc2l0Q2hpbGRyZW4odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gc3VwZXIudmlzaXRDaGlsZHJlbih2aXNpdG9yKSB8fCAhIXZpc2l0b3IodGhpcy5uZXdsaW5lKSB8fCAhIXRoaXMudmlzaXRFeHByZXNzaW9uKHZpc2l0b3IpOyB9XG59XG5leHBvcnQgY2xhc3MgT3BlcmF0b3JMaW5lIGV4dGVuZHMgTGF6eU9iamVjdCB7XG4gICAgY29uc3RydWN0b3IodmlldzogRGF0YVZpZXcpIHsgc3VwZXIodmlldyk7IH1cbiAgICBzdGF0aWMgcmVhZCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKTogT3BlcmF0b3JMaW5lIHsgcmV0dXJuIG5ldyBPcGVyYXRvckxpbmUocmVhZE9mZnNldCh2aWV3LCBhZGRyZXNzKSk7IH1cbiAgICBnZXQgbmV3bGluZSgpOiBUb2tlbi5OZXdsaW5lIHsgcmV0dXJuIFRva2VuLk5ld2xpbmUucmVhZCh0aGlzLl92LCAwKTsgfVxuICAgIGdldCBleHByZXNzaW9uKCk6IE9wZXJhdG9yQmxvY2tFeHByZXNzaW9uIHwgdW5kZWZpbmVkIHsgcmV0dXJuIHJlYWRPcHRpb24odGhpcy5fdiwgNzYsIE9wZXJhdG9yQmxvY2tFeHByZXNzaW9uLnJlYWQpOyB9XG4gICAgdmlzaXRFeHByZXNzaW9uKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHZpc2l0T3B0aW9uKHRoaXMuX3YsIDc2LCAodmlldywgYWRkcmVzcykgPT4gdmlzaXRvcihPcGVyYXRvckJsb2NrRXhwcmVzc2lvbi5yZWFkKHZpZXcsIGFkZHJlc3MpKSk7IH1cbiAgICB2aXNpdENoaWxkcmVuKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHN1cGVyLnZpc2l0Q2hpbGRyZW4odmlzaXRvcikgfHwgISF2aXNpdG9yKHRoaXMubmV3bGluZSkgfHwgISF0aGlzLnZpc2l0RXhwcmVzc2lvbih2aXNpdG9yKTsgfVxufVxuZXhwb3J0IGNsYXNzIEFyZ3VtZW50VHlwZSBleHRlbmRzIExhenlPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKHZpZXc6IERhdGFWaWV3KSB7IHN1cGVyKHZpZXcpOyB9XG4gICAgc3RhdGljIHJlYWQodmlldzogRGF0YVZpZXcsIGFkZHJlc3M6IG51bWJlcik6IEFyZ3VtZW50VHlwZSB7IHJldHVybiBuZXcgQXJndW1lbnRUeXBlKHJlYWRPZmZzZXQodmlldywgYWRkcmVzcykpOyB9XG4gICAgZ2V0IG9wZXJhdG9yKCk6IFRva2VuLk9wZXJhdG9yIHsgcmV0dXJuIFRva2VuLk9wZXJhdG9yLnJlYWQodGhpcy5fdiwgMCk7IH1cbiAgICBnZXQgdHlwZU5vZGUoKTogVHJlZSB7IHJldHVybiBUcmVlLnJlYWQodGhpcy5fdiwgNzYpOyB9XG4gICAgdmlzaXRDaGlsZHJlbih2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiBzdXBlci52aXNpdENoaWxkcmVuKHZpc2l0b3IpIHx8ICEhdmlzaXRvcih0aGlzLm9wZXJhdG9yKSB8fCAhIXZpc2l0b3IodGhpcy50eXBlTm9kZSk7IH1cbn1cbmV4cG9ydCBjbGFzcyBDYXNlIGV4dGVuZHMgTGF6eU9iamVjdCB7XG4gICAgY29uc3RydWN0b3IodmlldzogRGF0YVZpZXcpIHsgc3VwZXIodmlldyk7IH1cbiAgICBzdGF0aWMgcmVhZCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKTogQ2FzZSB7IHJldHVybiBuZXcgQ2FzZShyZWFkT2Zmc2V0KHZpZXcsIGFkZHJlc3MpKTsgfVxuICAgIGdldCBkb2N1bWVudGF0aW9uKCk6IERvY0NvbW1lbnQgfCB1bmRlZmluZWQgeyByZXR1cm4gcmVhZE9wdGlvbih0aGlzLl92LCAwLCBEb2NDb21tZW50LnJlYWQpOyB9XG4gICAgZ2V0IHBhdHRlcm4oKTogVHJlZSB8IHVuZGVmaW5lZCB7IHJldHVybiByZWFkT3B0aW9uKHRoaXMuX3YsIDUsIFRyZWUucmVhZCk7IH1cbiAgICBnZXQgYXJyb3coKTogVG9rZW4uT3BlcmF0b3IgfCB1bmRlZmluZWQgeyByZXR1cm4gcmVhZE9wdGlvbih0aGlzLl92LCAxMCwgVG9rZW4uT3BlcmF0b3IucmVhZCk7IH1cbiAgICBnZXQgZXhwcmVzc2lvbigpOiBUcmVlIHwgdW5kZWZpbmVkIHsgcmV0dXJuIHJlYWRPcHRpb24odGhpcy5fdiwgMTUsIFRyZWUucmVhZCk7IH1cbiAgICB2aXNpdERvY3VtZW50YXRpb24odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gdmlzaXRPcHRpb24odGhpcy5fdiwgMCwgKHZpZXcsIGFkZHJlc3MpID0+IHZpc2l0b3IoRG9jQ29tbWVudC5yZWFkKHZpZXcsIGFkZHJlc3MpKSk7IH1cbiAgICB2aXNpdFBhdHRlcm4odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gdmlzaXRPcHRpb24odGhpcy5fdiwgNSwgKHZpZXcsIGFkZHJlc3MpID0+IHZpc2l0b3IoVHJlZS5yZWFkKHZpZXcsIGFkZHJlc3MpKSk7IH1cbiAgICB2aXNpdEFycm93KHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHZpc2l0T3B0aW9uKHRoaXMuX3YsIDEwLCAodmlldywgYWRkcmVzcykgPT4gdmlzaXRvcihUb2tlbi5PcGVyYXRvci5yZWFkKHZpZXcsIGFkZHJlc3MpKSk7IH1cbiAgICB2aXNpdEV4cHJlc3Npb24odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gdmlzaXRPcHRpb24odGhpcy5fdiwgMTUsICh2aWV3LCBhZGRyZXNzKSA9PiB2aXNpdG9yKFRyZWUucmVhZCh2aWV3LCBhZGRyZXNzKSkpOyB9XG4gICAgdmlzaXRDaGlsZHJlbih2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiBzdXBlci52aXNpdENoaWxkcmVuKHZpc2l0b3IpIHx8ICEhdGhpcy52aXNpdERvY3VtZW50YXRpb24odmlzaXRvcikgfHwgISF0aGlzLnZpc2l0UGF0dGVybih2aXNpdG9yKSB8fCAhIXRoaXMudmlzaXRBcnJvdyh2aXNpdG9yKSB8fCAhIXRoaXMudmlzaXRFeHByZXNzaW9uKHZpc2l0b3IpOyB9XG59XG5leHBvcnQgbW9kdWxlIFRva2VuIHtcbiAgICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgQWJzdHJhY3RCYXNlIGV4dGVuZHMgTGF6eU9iamVjdCB7XG4gICAgICAgIHByb3RlY3RlZCBjb25zdHJ1Y3Rvcih2aWV3OiBEYXRhVmlldykgeyBzdXBlcih2aWV3KTsgfVxuICAgICAgICBnZXQgbGVmdE9mZnNldFZpc2libGUoKTogbnVtYmVyIHsgcmV0dXJuIHJlYWRVMzIodGhpcy5fdiwgMCk7IH1cbiAgICAgICAgZ2V0IGxlZnRPZmZzZXRDb2RlUmVwckJlZ2luKCk6IG51bWJlciB7IHJldHVybiByZWFkVTMyKHRoaXMuX3YsIDQpOyB9XG4gICAgICAgIGdldCBsZWZ0T2Zmc2V0Q29kZVJlcHJMZW4oKTogbnVtYmVyIHsgcmV0dXJuIHJlYWRVMzIodGhpcy5fdiwgOCk7IH1cbiAgICAgICAgZ2V0IGxlZnRPZmZzZXRDb2RlU3RhcnRVdGY4KCk6IG51bWJlciB7IHJldHVybiByZWFkVTMyKHRoaXMuX3YsIDEyKTsgfVxuICAgICAgICBnZXQgd2hpdGVzcGFjZVN0YXJ0SW5Db2RlQnVmZmVyKCk6IG51bWJlciB7IHJldHVybiByZWFkVTMyKHRoaXMuX3YsIDE2KTsgfVxuICAgICAgICBnZXQgbGVmdE9mZnNldENvZGVTdGFydExpbmUoKTogbnVtYmVyIHsgcmV0dXJuIHJlYWRVMzIodGhpcy5fdiwgMjApOyB9XG4gICAgICAgIGdldCBsZWZ0T2Zmc2V0Q29kZVN0YXJ0Q29sMTYoKTogbnVtYmVyIHsgcmV0dXJuIHJlYWRVMzIodGhpcy5fdiwgMjQpOyB9XG4gICAgICAgIGdldCB3aGl0ZXNwYWNlTGVuZ3RoSW5Db2RlQnVmZmVyKCk6IG51bWJlciB7IHJldHVybiByZWFkVTMyKHRoaXMuX3YsIDI4KTsgfVxuICAgICAgICBnZXQgbGVmdE9mZnNldENvZGVMZW5OZXdsaW5lcygpOiBudW1iZXIgeyByZXR1cm4gcmVhZFUzMih0aGlzLl92LCAzMik7IH1cbiAgICAgICAgZ2V0IGxlZnRPZmZzZXRDb2RlTGVuTGluZUNoYXJzMTYoKTogbnVtYmVyIHsgcmV0dXJuIHJlYWRVMzIodGhpcy5fdiwgMzYpOyB9XG4gICAgICAgIGdldCBjb2RlUmVwckJlZ2luKCk6IG51bWJlciB7IHJldHVybiByZWFkVTMyKHRoaXMuX3YsIDQwKTsgfVxuICAgICAgICBnZXQgY29kZVJlcHJMZW4oKTogbnVtYmVyIHsgcmV0dXJuIHJlYWRVMzIodGhpcy5fdiwgNDQpOyB9XG4gICAgICAgIGdldCBjb2RlU3RhcnRVdGY4KCk6IG51bWJlciB7IHJldHVybiByZWFkVTMyKHRoaXMuX3YsIDQ4KTsgfVxuICAgICAgICBnZXQgc3RhcnRJbkNvZGVCdWZmZXIoKTogbnVtYmVyIHsgcmV0dXJuIHJlYWRVMzIodGhpcy5fdiwgNTIpOyB9XG4gICAgICAgIGdldCBjb2RlU3RhcnRMaW5lKCk6IG51bWJlciB7IHJldHVybiByZWFkVTMyKHRoaXMuX3YsIDU2KTsgfVxuICAgICAgICBnZXQgY29kZVN0YXJ0Q29sMTYoKTogbnVtYmVyIHsgcmV0dXJuIHJlYWRVMzIodGhpcy5fdiwgNjApOyB9XG4gICAgICAgIGdldCBsZW5ndGhJbkNvZGVCdWZmZXIoKTogbnVtYmVyIHsgcmV0dXJuIHJlYWRVMzIodGhpcy5fdiwgNjQpOyB9XG4gICAgICAgIGdldCBjb2RlTGVuTmV3bGluZXMoKTogbnVtYmVyIHsgcmV0dXJuIHJlYWRVMzIodGhpcy5fdiwgNjgpOyB9XG4gICAgICAgIGdldCBjb2RlTGVuTGluZUNoYXJzMTYoKTogbnVtYmVyIHsgcmV0dXJuIHJlYWRVMzIodGhpcy5fdiwgNzIpOyB9XG4gICAgICAgIHZpc2l0Q2hpbGRyZW4odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gc3VwZXIudmlzaXRDaGlsZHJlbih2aXNpdG9yKTsgfVxuICAgIH1cbiAgICBleHBvcnQgY29uc3QgZW51bSBUeXBlIHtcbiAgICAgICAgTmV3bGluZSA9IDAsXG4gICAgICAgIE9wZW5TeW1ib2wgPSAxLFxuICAgICAgICBDbG9zZVN5bWJvbCA9IDIsXG4gICAgICAgIEJsb2NrU3RhcnQgPSAzLFxuICAgICAgICBCbG9ja0VuZCA9IDQsXG4gICAgICAgIFdpbGRjYXJkID0gNSxcbiAgICAgICAgU3VzcGVuZGVkRGVmYXVsdEFyZ3VtZW50cyA9IDYsXG4gICAgICAgIElkZW50ID0gNyxcbiAgICAgICAgT3BlcmF0b3IgPSA4LFxuICAgICAgICBEaWdpdHMgPSA5LFxuICAgICAgICBOdW1iZXJCYXNlID0gMTAsXG4gICAgICAgIFByaXZhdGUgPSAxMSxcbiAgICAgICAgVGV4dFN0YXJ0ID0gMTIsXG4gICAgICAgIFRleHRFbmQgPSAxMyxcbiAgICAgICAgVGV4dFNlY3Rpb24gPSAxNCxcbiAgICAgICAgVGV4dEVzY2FwZSA9IDE1LFxuICAgICAgICBUZXh0SW5pdGlhbE5ld2xpbmUgPSAxNixcbiAgICAgICAgVGV4dE5ld2xpbmUgPSAxNyxcbiAgICAgICAgSW52YWxpZCA9IDE4XG4gICAgfVxuICAgIGV4cG9ydCBjb25zdCB0eXBlTmFtZXMgPSBbXCJOZXdsaW5lXCIsIFwiT3BlblN5bWJvbFwiLCBcIkNsb3NlU3ltYm9sXCIsIFwiQmxvY2tTdGFydFwiLCBcIkJsb2NrRW5kXCIsIFwiV2lsZGNhcmRcIiwgXCJTdXNwZW5kZWREZWZhdWx0QXJndW1lbnRzXCIsIFwiSWRlbnRcIiwgXCJPcGVyYXRvclwiLCBcIkRpZ2l0c1wiLCBcIk51bWJlckJhc2VcIiwgXCJQcml2YXRlXCIsIFwiVGV4dFN0YXJ0XCIsIFwiVGV4dEVuZFwiLCBcIlRleHRTZWN0aW9uXCIsIFwiVGV4dEVzY2FwZVwiLCBcIlRleHRJbml0aWFsTmV3bGluZVwiLCBcIlRleHROZXdsaW5lXCIsIFwiSW52YWxpZFwiXSBhcyBjb25zdDtcbiAgICBleHBvcnQgY2xhc3MgTmV3bGluZSBleHRlbmRzIEFic3RyYWN0QmFzZSB7XG4gICAgICAgIHJlYWRvbmx5IHR5cGU6IFR5cGUuTmV3bGluZTtcbiAgICAgICAgY29uc3RydWN0b3IodmlldzogRGF0YVZpZXcpIHsgc3VwZXIodmlldyk7IHRoaXMudHlwZSA9IFR5cGUuTmV3bGluZTsgfVxuICAgICAgICBzdGF0aWMgcmVhZCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKTogTmV3bGluZSB7IHJldHVybiBuZXcgTmV3bGluZShyZWFkT2Zmc2V0KHZpZXcsIGFkZHJlc3MpKTsgfVxuICAgICAgICB2aXNpdENoaWxkcmVuKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHN1cGVyLnZpc2l0Q2hpbGRyZW4odmlzaXRvcik7IH1cbiAgICB9XG4gICAgZXhwb3J0IGNsYXNzIE9wZW5TeW1ib2wgZXh0ZW5kcyBBYnN0cmFjdEJhc2Uge1xuICAgICAgICByZWFkb25seSB0eXBlOiBUeXBlLk9wZW5TeW1ib2w7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXc6IERhdGFWaWV3KSB7IHN1cGVyKHZpZXcpOyB0aGlzLnR5cGUgPSBUeXBlLk9wZW5TeW1ib2w7IH1cbiAgICAgICAgc3RhdGljIHJlYWQodmlldzogRGF0YVZpZXcsIGFkZHJlc3M6IG51bWJlcik6IE9wZW5TeW1ib2wgeyByZXR1cm4gbmV3IE9wZW5TeW1ib2wocmVhZE9mZnNldCh2aWV3LCBhZGRyZXNzKSk7IH1cbiAgICAgICAgdmlzaXRDaGlsZHJlbih2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiBzdXBlci52aXNpdENoaWxkcmVuKHZpc2l0b3IpOyB9XG4gICAgfVxuICAgIGV4cG9ydCBjbGFzcyBDbG9zZVN5bWJvbCBleHRlbmRzIEFic3RyYWN0QmFzZSB7XG4gICAgICAgIHJlYWRvbmx5IHR5cGU6IFR5cGUuQ2xvc2VTeW1ib2w7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXc6IERhdGFWaWV3KSB7IHN1cGVyKHZpZXcpOyB0aGlzLnR5cGUgPSBUeXBlLkNsb3NlU3ltYm9sOyB9XG4gICAgICAgIHN0YXRpYyByZWFkKHZpZXc6IERhdGFWaWV3LCBhZGRyZXNzOiBudW1iZXIpOiBDbG9zZVN5bWJvbCB7IHJldHVybiBuZXcgQ2xvc2VTeW1ib2wocmVhZE9mZnNldCh2aWV3LCBhZGRyZXNzKSk7IH1cbiAgICAgICAgdmlzaXRDaGlsZHJlbih2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiBzdXBlci52aXNpdENoaWxkcmVuKHZpc2l0b3IpOyB9XG4gICAgfVxuICAgIGV4cG9ydCBjbGFzcyBCbG9ja1N0YXJ0IGV4dGVuZHMgQWJzdHJhY3RCYXNlIHtcbiAgICAgICAgcmVhZG9ubHkgdHlwZTogVHlwZS5CbG9ja1N0YXJ0O1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3OiBEYXRhVmlldykgeyBzdXBlcih2aWV3KTsgdGhpcy50eXBlID0gVHlwZS5CbG9ja1N0YXJ0OyB9XG4gICAgICAgIHN0YXRpYyByZWFkKHZpZXc6IERhdGFWaWV3LCBhZGRyZXNzOiBudW1iZXIpOiBCbG9ja1N0YXJ0IHsgcmV0dXJuIG5ldyBCbG9ja1N0YXJ0KHJlYWRPZmZzZXQodmlldywgYWRkcmVzcykpOyB9XG4gICAgICAgIHZpc2l0Q2hpbGRyZW4odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gc3VwZXIudmlzaXRDaGlsZHJlbih2aXNpdG9yKTsgfVxuICAgIH1cbiAgICBleHBvcnQgY2xhc3MgQmxvY2tFbmQgZXh0ZW5kcyBBYnN0cmFjdEJhc2Uge1xuICAgICAgICByZWFkb25seSB0eXBlOiBUeXBlLkJsb2NrRW5kO1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3OiBEYXRhVmlldykgeyBzdXBlcih2aWV3KTsgdGhpcy50eXBlID0gVHlwZS5CbG9ja0VuZDsgfVxuICAgICAgICBzdGF0aWMgcmVhZCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKTogQmxvY2tFbmQgeyByZXR1cm4gbmV3IEJsb2NrRW5kKHJlYWRPZmZzZXQodmlldywgYWRkcmVzcykpOyB9XG4gICAgICAgIHZpc2l0Q2hpbGRyZW4odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gc3VwZXIudmlzaXRDaGlsZHJlbih2aXNpdG9yKTsgfVxuICAgIH1cbiAgICBleHBvcnQgY2xhc3MgV2lsZGNhcmQgZXh0ZW5kcyBBYnN0cmFjdEJhc2Uge1xuICAgICAgICByZWFkb25seSB0eXBlOiBUeXBlLldpbGRjYXJkO1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3OiBEYXRhVmlldykgeyBzdXBlcih2aWV3KTsgdGhpcy50eXBlID0gVHlwZS5XaWxkY2FyZDsgfVxuICAgICAgICBzdGF0aWMgcmVhZCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKTogV2lsZGNhcmQgeyByZXR1cm4gbmV3IFdpbGRjYXJkKHJlYWRPZmZzZXQodmlldywgYWRkcmVzcykpOyB9XG4gICAgICAgIGdldCBsaWZ0TGV2ZWwoKTogbnVtYmVyIHsgcmV0dXJuIHJlYWRVMzIodGhpcy5fdiwgNzYpOyB9XG4gICAgICAgIHZpc2l0Q2hpbGRyZW4odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gc3VwZXIudmlzaXRDaGlsZHJlbih2aXNpdG9yKTsgfVxuICAgIH1cbiAgICBleHBvcnQgY2xhc3MgU3VzcGVuZGVkRGVmYXVsdEFyZ3VtZW50cyBleHRlbmRzIEFic3RyYWN0QmFzZSB7XG4gICAgICAgIHJlYWRvbmx5IHR5cGU6IFR5cGUuU3VzcGVuZGVkRGVmYXVsdEFyZ3VtZW50cztcbiAgICAgICAgY29uc3RydWN0b3IodmlldzogRGF0YVZpZXcpIHsgc3VwZXIodmlldyk7IHRoaXMudHlwZSA9IFR5cGUuU3VzcGVuZGVkRGVmYXVsdEFyZ3VtZW50czsgfVxuICAgICAgICBzdGF0aWMgcmVhZCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKTogU3VzcGVuZGVkRGVmYXVsdEFyZ3VtZW50cyB7IHJldHVybiBuZXcgU3VzcGVuZGVkRGVmYXVsdEFyZ3VtZW50cyhyZWFkT2Zmc2V0KHZpZXcsIGFkZHJlc3MpKTsgfVxuICAgICAgICB2aXNpdENoaWxkcmVuKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHN1cGVyLnZpc2l0Q2hpbGRyZW4odmlzaXRvcik7IH1cbiAgICB9XG4gICAgZXhwb3J0IGNsYXNzIElkZW50IGV4dGVuZHMgQWJzdHJhY3RCYXNlIHtcbiAgICAgICAgcmVhZG9ubHkgdHlwZTogVHlwZS5JZGVudDtcbiAgICAgICAgY29uc3RydWN0b3IodmlldzogRGF0YVZpZXcpIHsgc3VwZXIodmlldyk7IHRoaXMudHlwZSA9IFR5cGUuSWRlbnQ7IH1cbiAgICAgICAgc3RhdGljIHJlYWQodmlldzogRGF0YVZpZXcsIGFkZHJlc3M6IG51bWJlcik6IElkZW50IHsgcmV0dXJuIG5ldyBJZGVudChyZWFkT2Zmc2V0KHZpZXcsIGFkZHJlc3MpKTsgfVxuICAgICAgICBnZXQgaXNGcmVlKCk6IGJvb2xlYW4geyByZXR1cm4gcmVhZEJvb2wodGhpcy5fdiwgNzYpOyB9XG4gICAgICAgIGdldCBsaWZ0TGV2ZWwoKTogbnVtYmVyIHsgcmV0dXJuIHJlYWRVMzIodGhpcy5fdiwgNzcpOyB9XG4gICAgICAgIGdldCBpc1R5cGVPckNvbnN0cnVjdG9yKCk6IGJvb2xlYW4geyByZXR1cm4gcmVhZEJvb2wodGhpcy5fdiwgODEpOyB9XG4gICAgICAgIGdldCBpc09wZXJhdG9yTGV4aWNhbGx5KCk6IGJvb2xlYW4geyByZXR1cm4gcmVhZEJvb2wodGhpcy5fdiwgODIpOyB9XG4gICAgICAgIHZpc2l0Q2hpbGRyZW4odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gc3VwZXIudmlzaXRDaGlsZHJlbih2aXNpdG9yKTsgfVxuICAgIH1cbiAgICBleHBvcnQgY2xhc3MgT3BlcmF0b3IgZXh0ZW5kcyBBYnN0cmFjdEJhc2Uge1xuICAgICAgICByZWFkb25seSB0eXBlOiBUeXBlLk9wZXJhdG9yO1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3OiBEYXRhVmlldykgeyBzdXBlcih2aWV3KTsgdGhpcy50eXBlID0gVHlwZS5PcGVyYXRvcjsgfVxuICAgICAgICBzdGF0aWMgcmVhZCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKTogT3BlcmF0b3IgeyByZXR1cm4gbmV3IE9wZXJhdG9yKHJlYWRPZmZzZXQodmlldywgYWRkcmVzcykpOyB9XG4gICAgICAgIHZpc2l0Q2hpbGRyZW4odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gc3VwZXIudmlzaXRDaGlsZHJlbih2aXNpdG9yKTsgfVxuICAgIH1cbiAgICBleHBvcnQgY2xhc3MgRGlnaXRzIGV4dGVuZHMgQWJzdHJhY3RCYXNlIHtcbiAgICAgICAgcmVhZG9ubHkgdHlwZTogVHlwZS5EaWdpdHM7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXc6IERhdGFWaWV3KSB7IHN1cGVyKHZpZXcpOyB0aGlzLnR5cGUgPSBUeXBlLkRpZ2l0czsgfVxuICAgICAgICBzdGF0aWMgcmVhZCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKTogRGlnaXRzIHsgcmV0dXJuIG5ldyBEaWdpdHMocmVhZE9mZnNldCh2aWV3LCBhZGRyZXNzKSk7IH1cbiAgICAgICAgZ2V0IGJhc2UoKTogQmFzZSB8IHVuZGVmaW5lZCB7IHJldHVybiByZWFkT3B0aW9uKHRoaXMuX3YsIDc2LCBCYXNlLnJlYWQpOyB9XG4gICAgICAgIHZpc2l0QmFzZSh2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiB2aXNpdE9wdGlvbih0aGlzLl92LCA3NiwgKHZpZXcsIGFkZHJlc3MpID0+IHZpc2l0b3IoQmFzZS5yZWFkKHZpZXcsIGFkZHJlc3MpKSk7IH1cbiAgICAgICAgdmlzaXRDaGlsZHJlbih2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiBzdXBlci52aXNpdENoaWxkcmVuKHZpc2l0b3IpIHx8ICEhdGhpcy52aXNpdEJhc2UodmlzaXRvcik7IH1cbiAgICB9XG4gICAgZXhwb3J0IGNsYXNzIE51bWJlckJhc2UgZXh0ZW5kcyBBYnN0cmFjdEJhc2Uge1xuICAgICAgICByZWFkb25seSB0eXBlOiBUeXBlLk51bWJlckJhc2U7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXc6IERhdGFWaWV3KSB7IHN1cGVyKHZpZXcpOyB0aGlzLnR5cGUgPSBUeXBlLk51bWJlckJhc2U7IH1cbiAgICAgICAgc3RhdGljIHJlYWQodmlldzogRGF0YVZpZXcsIGFkZHJlc3M6IG51bWJlcik6IE51bWJlckJhc2UgeyByZXR1cm4gbmV3IE51bWJlckJhc2UocmVhZE9mZnNldCh2aWV3LCBhZGRyZXNzKSk7IH1cbiAgICAgICAgdmlzaXRDaGlsZHJlbih2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiBzdXBlci52aXNpdENoaWxkcmVuKHZpc2l0b3IpOyB9XG4gICAgfVxuICAgIGV4cG9ydCBjbGFzcyBQcml2YXRlIGV4dGVuZHMgQWJzdHJhY3RCYXNlIHtcbiAgICAgICAgcmVhZG9ubHkgdHlwZTogVHlwZS5Qcml2YXRlO1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3OiBEYXRhVmlldykgeyBzdXBlcih2aWV3KTsgdGhpcy50eXBlID0gVHlwZS5Qcml2YXRlOyB9XG4gICAgICAgIHN0YXRpYyByZWFkKHZpZXc6IERhdGFWaWV3LCBhZGRyZXNzOiBudW1iZXIpOiBQcml2YXRlIHsgcmV0dXJuIG5ldyBQcml2YXRlKHJlYWRPZmZzZXQodmlldywgYWRkcmVzcykpOyB9XG4gICAgICAgIHZpc2l0Q2hpbGRyZW4odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gc3VwZXIudmlzaXRDaGlsZHJlbih2aXNpdG9yKTsgfVxuICAgIH1cbiAgICBleHBvcnQgY2xhc3MgVGV4dFN0YXJ0IGV4dGVuZHMgQWJzdHJhY3RCYXNlIHtcbiAgICAgICAgcmVhZG9ubHkgdHlwZTogVHlwZS5UZXh0U3RhcnQ7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXc6IERhdGFWaWV3KSB7IHN1cGVyKHZpZXcpOyB0aGlzLnR5cGUgPSBUeXBlLlRleHRTdGFydDsgfVxuICAgICAgICBzdGF0aWMgcmVhZCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKTogVGV4dFN0YXJ0IHsgcmV0dXJuIG5ldyBUZXh0U3RhcnQocmVhZE9mZnNldCh2aWV3LCBhZGRyZXNzKSk7IH1cbiAgICAgICAgdmlzaXRDaGlsZHJlbih2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiBzdXBlci52aXNpdENoaWxkcmVuKHZpc2l0b3IpOyB9XG4gICAgfVxuICAgIGV4cG9ydCBjbGFzcyBUZXh0RW5kIGV4dGVuZHMgQWJzdHJhY3RCYXNlIHtcbiAgICAgICAgcmVhZG9ubHkgdHlwZTogVHlwZS5UZXh0RW5kO1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3OiBEYXRhVmlldykgeyBzdXBlcih2aWV3KTsgdGhpcy50eXBlID0gVHlwZS5UZXh0RW5kOyB9XG4gICAgICAgIHN0YXRpYyByZWFkKHZpZXc6IERhdGFWaWV3LCBhZGRyZXNzOiBudW1iZXIpOiBUZXh0RW5kIHsgcmV0dXJuIG5ldyBUZXh0RW5kKHJlYWRPZmZzZXQodmlldywgYWRkcmVzcykpOyB9XG4gICAgICAgIHZpc2l0Q2hpbGRyZW4odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gc3VwZXIudmlzaXRDaGlsZHJlbih2aXNpdG9yKTsgfVxuICAgIH1cbiAgICBleHBvcnQgY2xhc3MgVGV4dFNlY3Rpb24gZXh0ZW5kcyBBYnN0cmFjdEJhc2Uge1xuICAgICAgICByZWFkb25seSB0eXBlOiBUeXBlLlRleHRTZWN0aW9uO1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3OiBEYXRhVmlldykgeyBzdXBlcih2aWV3KTsgdGhpcy50eXBlID0gVHlwZS5UZXh0U2VjdGlvbjsgfVxuICAgICAgICBzdGF0aWMgcmVhZCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKTogVGV4dFNlY3Rpb24geyByZXR1cm4gbmV3IFRleHRTZWN0aW9uKHJlYWRPZmZzZXQodmlldywgYWRkcmVzcykpOyB9XG4gICAgICAgIHZpc2l0Q2hpbGRyZW4odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gc3VwZXIudmlzaXRDaGlsZHJlbih2aXNpdG9yKTsgfVxuICAgIH1cbiAgICBleHBvcnQgY2xhc3MgVGV4dEVzY2FwZSBleHRlbmRzIEFic3RyYWN0QmFzZSB7XG4gICAgICAgIHJlYWRvbmx5IHR5cGU6IFR5cGUuVGV4dEVzY2FwZTtcbiAgICAgICAgY29uc3RydWN0b3IodmlldzogRGF0YVZpZXcpIHsgc3VwZXIodmlldyk7IHRoaXMudHlwZSA9IFR5cGUuVGV4dEVzY2FwZTsgfVxuICAgICAgICBzdGF0aWMgcmVhZCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKTogVGV4dEVzY2FwZSB7IHJldHVybiBuZXcgVGV4dEVzY2FwZShyZWFkT2Zmc2V0KHZpZXcsIGFkZHJlc3MpKTsgfVxuICAgICAgICBnZXQgdmFsdWUoKTogbnVtYmVyIHsgcmV0dXJuIHJlYWRVMzIodGhpcy5fdiwgNzYpOyB9XG4gICAgICAgIHZpc2l0Q2hpbGRyZW4odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gc3VwZXIudmlzaXRDaGlsZHJlbih2aXNpdG9yKTsgfVxuICAgIH1cbiAgICBleHBvcnQgY2xhc3MgVGV4dEluaXRpYWxOZXdsaW5lIGV4dGVuZHMgQWJzdHJhY3RCYXNlIHtcbiAgICAgICAgcmVhZG9ubHkgdHlwZTogVHlwZS5UZXh0SW5pdGlhbE5ld2xpbmU7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXc6IERhdGFWaWV3KSB7IHN1cGVyKHZpZXcpOyB0aGlzLnR5cGUgPSBUeXBlLlRleHRJbml0aWFsTmV3bGluZTsgfVxuICAgICAgICBzdGF0aWMgcmVhZCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKTogVGV4dEluaXRpYWxOZXdsaW5lIHsgcmV0dXJuIG5ldyBUZXh0SW5pdGlhbE5ld2xpbmUocmVhZE9mZnNldCh2aWV3LCBhZGRyZXNzKSk7IH1cbiAgICAgICAgdmlzaXRDaGlsZHJlbih2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiBzdXBlci52aXNpdENoaWxkcmVuKHZpc2l0b3IpOyB9XG4gICAgfVxuICAgIGV4cG9ydCBjbGFzcyBUZXh0TmV3bGluZSBleHRlbmRzIEFic3RyYWN0QmFzZSB7XG4gICAgICAgIHJlYWRvbmx5IHR5cGU6IFR5cGUuVGV4dE5ld2xpbmU7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXc6IERhdGFWaWV3KSB7IHN1cGVyKHZpZXcpOyB0aGlzLnR5cGUgPSBUeXBlLlRleHROZXdsaW5lOyB9XG4gICAgICAgIHN0YXRpYyByZWFkKHZpZXc6IERhdGFWaWV3LCBhZGRyZXNzOiBudW1iZXIpOiBUZXh0TmV3bGluZSB7IHJldHVybiBuZXcgVGV4dE5ld2xpbmUocmVhZE9mZnNldCh2aWV3LCBhZGRyZXNzKSk7IH1cbiAgICAgICAgdmlzaXRDaGlsZHJlbih2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiBzdXBlci52aXNpdENoaWxkcmVuKHZpc2l0b3IpOyB9XG4gICAgfVxuICAgIGV4cG9ydCBjbGFzcyBJbnZhbGlkIGV4dGVuZHMgQWJzdHJhY3RCYXNlIHtcbiAgICAgICAgcmVhZG9ubHkgdHlwZTogVHlwZS5JbnZhbGlkO1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3OiBEYXRhVmlldykgeyBzdXBlcih2aWV3KTsgdGhpcy50eXBlID0gVHlwZS5JbnZhbGlkOyB9XG4gICAgICAgIHN0YXRpYyByZWFkKHZpZXc6IERhdGFWaWV3LCBhZGRyZXNzOiBudW1iZXIpOiBJbnZhbGlkIHsgcmV0dXJuIG5ldyBJbnZhbGlkKHJlYWRPZmZzZXQodmlldywgYWRkcmVzcykpOyB9XG4gICAgICAgIHZpc2l0Q2hpbGRyZW4odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gc3VwZXIudmlzaXRDaGlsZHJlbih2aXNpdG9yKTsgfVxuICAgIH1cbiAgICBleHBvcnQgdHlwZSBUb2tlbiA9IE5ld2xpbmUgfCBPcGVuU3ltYm9sIHwgQ2xvc2VTeW1ib2wgfCBCbG9ja1N0YXJ0IHwgQmxvY2tFbmQgfCBXaWxkY2FyZCB8IFN1c3BlbmRlZERlZmF1bHRBcmd1bWVudHMgfCBJZGVudCB8IE9wZXJhdG9yIHwgRGlnaXRzIHwgTnVtYmVyQmFzZSB8IFByaXZhdGUgfCBUZXh0U3RhcnQgfCBUZXh0RW5kIHwgVGV4dFNlY3Rpb24gfCBUZXh0RXNjYXBlIHwgVGV4dEluaXRpYWxOZXdsaW5lIHwgVGV4dE5ld2xpbmUgfCBJbnZhbGlkO1xuICAgIGNvbnN0IFZBUklBTlRfUkVBREVSUyA9IFtOZXdsaW5lLnJlYWQsIE9wZW5TeW1ib2wucmVhZCwgQ2xvc2VTeW1ib2wucmVhZCwgQmxvY2tTdGFydC5yZWFkLCBCbG9ja0VuZC5yZWFkLCBXaWxkY2FyZC5yZWFkLCBTdXNwZW5kZWREZWZhdWx0QXJndW1lbnRzLnJlYWQsIElkZW50LnJlYWQsIE9wZXJhdG9yLnJlYWQsIERpZ2l0cy5yZWFkLCBOdW1iZXJCYXNlLnJlYWQsIFByaXZhdGUucmVhZCwgVGV4dFN0YXJ0LnJlYWQsIFRleHRFbmQucmVhZCwgVGV4dFNlY3Rpb24ucmVhZCwgVGV4dEVzY2FwZS5yZWFkLCBUZXh0SW5pdGlhbE5ld2xpbmUucmVhZCwgVGV4dE5ld2xpbmUucmVhZCwgSW52YWxpZC5yZWFkXTtcbiAgICBleHBvcnQgZnVuY3Rpb24gcmVhZCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKTogVG9rZW4geyByZXR1cm4gcmVhZEVudW08VG9rZW4+KFZBUklBTlRfUkVBREVSUywgdmlldywgYWRkcmVzcyk7IH1cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNJbnN0YW5jZShvYmo6IHVua25vd24pOiBvYmogaXMgVG9rZW4geyByZXR1cm4gb2JqIGluc3RhbmNlb2YgQWJzdHJhY3RCYXNlOyB9XG59XG5leHBvcnQgdHlwZSBUb2tlbiA9IFRva2VuLlRva2VuXG5leHBvcnQgbW9kdWxlIFRleHRFbGVtZW50IHtcbiAgICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgQWJzdHJhY3RCYXNlIGV4dGVuZHMgTGF6eU9iamVjdCB7XG4gICAgICAgIHByb3RlY3RlZCBjb25zdHJ1Y3Rvcih2aWV3OiBEYXRhVmlldykgeyBzdXBlcih2aWV3KTsgfVxuICAgICAgICB2aXNpdENoaWxkcmVuKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHN1cGVyLnZpc2l0Q2hpbGRyZW4odmlzaXRvcik7IH1cbiAgICB9XG4gICAgZXhwb3J0IGNvbnN0IGVudW0gVHlwZSB7XG4gICAgICAgIFNlY3Rpb24gPSAwLFxuICAgICAgICBFc2NhcGUgPSAxLFxuICAgICAgICBOZXdsaW5lID0gMixcbiAgICAgICAgU3BsaWNlID0gM1xuICAgIH1cbiAgICBleHBvcnQgY29uc3QgdHlwZU5hbWVzID0gW1wiU2VjdGlvblwiLCBcIkVzY2FwZVwiLCBcIk5ld2xpbmVcIiwgXCJTcGxpY2VcIl0gYXMgY29uc3Q7XG4gICAgZXhwb3J0IGNsYXNzIFNlY3Rpb24gZXh0ZW5kcyBBYnN0cmFjdEJhc2Uge1xuICAgICAgICByZWFkb25seSB0eXBlOiBUeXBlLlNlY3Rpb247XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXc6IERhdGFWaWV3KSB7IHN1cGVyKHZpZXcpOyB0aGlzLnR5cGUgPSBUeXBlLlNlY3Rpb247IH1cbiAgICAgICAgc3RhdGljIHJlYWQodmlldzogRGF0YVZpZXcsIGFkZHJlc3M6IG51bWJlcik6IFNlY3Rpb24geyByZXR1cm4gbmV3IFNlY3Rpb24ocmVhZE9mZnNldCh2aWV3LCBhZGRyZXNzKSk7IH1cbiAgICAgICAgZ2V0IHRleHQoKTogVG9rZW4uVGV4dFNlY3Rpb24geyByZXR1cm4gVG9rZW4uVGV4dFNlY3Rpb24ucmVhZCh0aGlzLl92LCAwKTsgfVxuICAgICAgICB2aXNpdENoaWxkcmVuKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHN1cGVyLnZpc2l0Q2hpbGRyZW4odmlzaXRvcikgfHwgISF2aXNpdG9yKHRoaXMudGV4dCk7IH1cbiAgICB9XG4gICAgZXhwb3J0IGNsYXNzIEVzY2FwZSBleHRlbmRzIEFic3RyYWN0QmFzZSB7XG4gICAgICAgIHJlYWRvbmx5IHR5cGU6IFR5cGUuRXNjYXBlO1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3OiBEYXRhVmlldykgeyBzdXBlcih2aWV3KTsgdGhpcy50eXBlID0gVHlwZS5Fc2NhcGU7IH1cbiAgICAgICAgc3RhdGljIHJlYWQodmlldzogRGF0YVZpZXcsIGFkZHJlc3M6IG51bWJlcik6IEVzY2FwZSB7IHJldHVybiBuZXcgRXNjYXBlKHJlYWRPZmZzZXQodmlldywgYWRkcmVzcykpOyB9XG4gICAgICAgIGdldCB0b2tlbigpOiBUb2tlbi5UZXh0RXNjYXBlIHsgcmV0dXJuIFRva2VuLlRleHRFc2NhcGUucmVhZCh0aGlzLl92LCAwKTsgfVxuICAgICAgICB2aXNpdENoaWxkcmVuKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHN1cGVyLnZpc2l0Q2hpbGRyZW4odmlzaXRvcikgfHwgISF2aXNpdG9yKHRoaXMudG9rZW4pOyB9XG4gICAgfVxuICAgIGV4cG9ydCBjbGFzcyBOZXdsaW5lIGV4dGVuZHMgQWJzdHJhY3RCYXNlIHtcbiAgICAgICAgcmVhZG9ubHkgdHlwZTogVHlwZS5OZXdsaW5lO1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3OiBEYXRhVmlldykgeyBzdXBlcih2aWV3KTsgdGhpcy50eXBlID0gVHlwZS5OZXdsaW5lOyB9XG4gICAgICAgIHN0YXRpYyByZWFkKHZpZXc6IERhdGFWaWV3LCBhZGRyZXNzOiBudW1iZXIpOiBOZXdsaW5lIHsgcmV0dXJuIG5ldyBOZXdsaW5lKHJlYWRPZmZzZXQodmlldywgYWRkcmVzcykpOyB9XG4gICAgICAgIGdldCBuZXdsaW5lKCk6IFRva2VuLk5ld2xpbmUgeyByZXR1cm4gVG9rZW4uTmV3bGluZS5yZWFkKHRoaXMuX3YsIDApOyB9XG4gICAgICAgIHZpc2l0Q2hpbGRyZW4odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gc3VwZXIudmlzaXRDaGlsZHJlbih2aXNpdG9yKSB8fCAhIXZpc2l0b3IodGhpcy5uZXdsaW5lKTsgfVxuICAgIH1cbiAgICBleHBvcnQgY2xhc3MgU3BsaWNlIGV4dGVuZHMgQWJzdHJhY3RCYXNlIHtcbiAgICAgICAgcmVhZG9ubHkgdHlwZTogVHlwZS5TcGxpY2U7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXc6IERhdGFWaWV3KSB7IHN1cGVyKHZpZXcpOyB0aGlzLnR5cGUgPSBUeXBlLlNwbGljZTsgfVxuICAgICAgICBzdGF0aWMgcmVhZCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKTogU3BsaWNlIHsgcmV0dXJuIG5ldyBTcGxpY2UocmVhZE9mZnNldCh2aWV3LCBhZGRyZXNzKSk7IH1cbiAgICAgICAgZ2V0IG9wZW4oKTogVG9rZW4uT3BlblN5bWJvbCB7IHJldHVybiBUb2tlbi5PcGVuU3ltYm9sLnJlYWQodGhpcy5fdiwgMCk7IH1cbiAgICAgICAgZ2V0IGV4cHJlc3Npb24oKTogVHJlZSB8IHVuZGVmaW5lZCB7IHJldHVybiByZWFkT3B0aW9uKHRoaXMuX3YsIDc2LCBUcmVlLnJlYWQpOyB9XG4gICAgICAgIGdldCBjbG9zZSgpOiBUb2tlbi5DbG9zZVN5bWJvbCB7IHJldHVybiBUb2tlbi5DbG9zZVN5bWJvbC5yZWFkKHRoaXMuX3YsIDgxKTsgfVxuICAgICAgICB2aXNpdEV4cHJlc3Npb24odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gdmlzaXRPcHRpb24odGhpcy5fdiwgNzYsICh2aWV3LCBhZGRyZXNzKSA9PiB2aXNpdG9yKFRyZWUucmVhZCh2aWV3LCBhZGRyZXNzKSkpOyB9XG4gICAgICAgIHZpc2l0Q2hpbGRyZW4odmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gc3VwZXIudmlzaXRDaGlsZHJlbih2aXNpdG9yKSB8fCAhIXZpc2l0b3IodGhpcy5vcGVuKSB8fCAhIXRoaXMudmlzaXRFeHByZXNzaW9uKHZpc2l0b3IpIHx8ICEhdmlzaXRvcih0aGlzLmNsb3NlKTsgfVxuICAgIH1cbiAgICBleHBvcnQgdHlwZSBUZXh0RWxlbWVudCA9IFNlY3Rpb24gfCBFc2NhcGUgfCBOZXdsaW5lIHwgU3BsaWNlO1xuICAgIGNvbnN0IFZBUklBTlRfUkVBREVSUyA9IFtTZWN0aW9uLnJlYWQsIEVzY2FwZS5yZWFkLCBOZXdsaW5lLnJlYWQsIFNwbGljZS5yZWFkXTtcbiAgICBleHBvcnQgZnVuY3Rpb24gcmVhZCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKTogVGV4dEVsZW1lbnQgeyByZXR1cm4gcmVhZEVudW08VGV4dEVsZW1lbnQ+KFZBUklBTlRfUkVBREVSUywgdmlldywgYWRkcmVzcyk7IH1cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNJbnN0YW5jZShvYmo6IHVua25vd24pOiBvYmogaXMgVGV4dEVsZW1lbnQgeyByZXR1cm4gb2JqIGluc3RhbmNlb2YgQWJzdHJhY3RCYXNlOyB9XG59XG5leHBvcnQgdHlwZSBUZXh0RWxlbWVudCA9IFRleHRFbGVtZW50LlRleHRFbGVtZW50XG5leHBvcnQgY2xhc3MgRnJhY3Rpb25hbERpZ2l0cyBleHRlbmRzIExhenlPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKHZpZXc6IERhdGFWaWV3KSB7IHN1cGVyKHZpZXcpOyB9XG4gICAgc3RhdGljIHJlYWQodmlldzogRGF0YVZpZXcsIGFkZHJlc3M6IG51bWJlcik6IEZyYWN0aW9uYWxEaWdpdHMgeyByZXR1cm4gbmV3IEZyYWN0aW9uYWxEaWdpdHMocmVhZE9mZnNldCh2aWV3LCBhZGRyZXNzKSk7IH1cbiAgICBnZXQgZG90KCk6IFRva2VuLk9wZXJhdG9yIHsgcmV0dXJuIFRva2VuLk9wZXJhdG9yLnJlYWQodGhpcy5fdiwgMCk7IH1cbiAgICBnZXQgZGlnaXRzKCk6IFRva2VuLkRpZ2l0cyB7IHJldHVybiBUb2tlbi5EaWdpdHMucmVhZCh0aGlzLl92LCA3Nik7IH1cbiAgICB2aXNpdENoaWxkcmVuKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHN1cGVyLnZpc2l0Q2hpbGRyZW4odmlzaXRvcikgfHwgISF2aXNpdG9yKHRoaXMuZG90KSB8fCAhIXZpc2l0b3IodGhpcy5kaWdpdHMpOyB9XG59XG5leHBvcnQgY2xhc3MgTXVsdGlwbGVPcGVyYXRvckVycm9yIGV4dGVuZHMgTGF6eU9iamVjdCB7XG4gICAgY29uc3RydWN0b3IodmlldzogRGF0YVZpZXcpIHsgc3VwZXIodmlldyk7IH1cbiAgICBzdGF0aWMgcmVhZCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKTogTXVsdGlwbGVPcGVyYXRvckVycm9yIHsgcmV0dXJuIG5ldyBNdWx0aXBsZU9wZXJhdG9yRXJyb3IocmVhZE9mZnNldCh2aWV3LCBhZGRyZXNzKSk7IH1cbiAgICBnZXQgb3BlcmF0b3JzKCk6IEl0ZXJhYmxlSXRlcmF0b3I8VG9rZW4uT3BlcmF0b3I+IHsgcmV0dXJuIHJlYWRTZXF1ZW5jZSh0aGlzLl92LCAwLCA3NiwgVG9rZW4uT3BlcmF0b3IucmVhZCk7IH1cbiAgICB2aXNpdE9wZXJhdG9ycyh2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiB2aXNpdFNlcXVlbmNlKHRoaXMuX3YsIDAsIDc2LCAodmlldywgYWRkcmVzcykgPT4gdmlzaXRvcihUb2tlbi5PcGVyYXRvci5yZWFkKHZpZXcsIGFkZHJlc3MpKSk7IH1cbiAgICB2aXNpdENoaWxkcmVuKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHN1cGVyLnZpc2l0Q2hpbGRyZW4odmlzaXRvcikgfHwgISF0aGlzLnZpc2l0T3BlcmF0b3JzKHZpc2l0b3IpOyB9XG59XG5leHBvcnQgY2xhc3MgT3BlcmF0b3JEZWxpbWl0ZWRUcmVlIGV4dGVuZHMgTGF6eU9iamVjdCB7XG4gICAgY29uc3RydWN0b3IodmlldzogRGF0YVZpZXcpIHsgc3VwZXIodmlldyk7IH1cbiAgICBzdGF0aWMgcmVhZCh2aWV3OiBEYXRhVmlldywgYWRkcmVzczogbnVtYmVyKTogT3BlcmF0b3JEZWxpbWl0ZWRUcmVlIHsgcmV0dXJuIG5ldyBPcGVyYXRvckRlbGltaXRlZFRyZWUocmVhZE9mZnNldCh2aWV3LCBhZGRyZXNzKSk7IH1cbiAgICBnZXQgb3BlcmF0b3IoKTogVG9rZW4uT3BlcmF0b3IgeyByZXR1cm4gVG9rZW4uT3BlcmF0b3IucmVhZCh0aGlzLl92LCAwKTsgfVxuICAgIGdldCBib2R5KCk6IFRyZWUgfCB1bmRlZmluZWQgeyByZXR1cm4gcmVhZE9wdGlvbih0aGlzLl92LCA3NiwgVHJlZS5yZWFkKTsgfVxuICAgIHZpc2l0Qm9keSh2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiB2aXNpdE9wdGlvbih0aGlzLl92LCA3NiwgKHZpZXcsIGFkZHJlc3MpID0+IHZpc2l0b3IoVHJlZS5yZWFkKHZpZXcsIGFkZHJlc3MpKSk7IH1cbiAgICB2aXNpdENoaWxkcmVuKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHN1cGVyLnZpc2l0Q2hpbGRyZW4odmlzaXRvcikgfHwgISF2aXNpdG9yKHRoaXMub3BlcmF0b3IpIHx8ICEhdGhpcy52aXNpdEJvZHkodmlzaXRvcik7IH1cbn1cbmV4cG9ydCBjbGFzcyBBcmd1bWVudERlZmluaXRpb24gZXh0ZW5kcyBMYXp5T2JqZWN0IHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3OiBEYXRhVmlldykgeyBzdXBlcih2aWV3KTsgfVxuICAgIHN0YXRpYyByZWFkKHZpZXc6IERhdGFWaWV3LCBhZGRyZXNzOiBudW1iZXIpOiBBcmd1bWVudERlZmluaXRpb24geyByZXR1cm4gbmV3IEFyZ3VtZW50RGVmaW5pdGlvbihyZWFkT2Zmc2V0KHZpZXcsIGFkZHJlc3MpKTsgfVxuICAgIGdldCBvcGVuKCk6IFRva2VuLk9wZW5TeW1ib2wgfCB1bmRlZmluZWQgeyByZXR1cm4gcmVhZE9wdGlvbih0aGlzLl92LCAwLCBUb2tlbi5PcGVuU3ltYm9sLnJlYWQpOyB9XG4gICAgZ2V0IG9wZW4yKCk6IFRva2VuLk9wZW5TeW1ib2wgfCB1bmRlZmluZWQgeyByZXR1cm4gcmVhZE9wdGlvbih0aGlzLl92LCA1LCBUb2tlbi5PcGVuU3ltYm9sLnJlYWQpOyB9XG4gICAgZ2V0IHN1c3BlbnNpb24oKTogVG9rZW4uT3BlcmF0b3IgfCB1bmRlZmluZWQgeyByZXR1cm4gcmVhZE9wdGlvbih0aGlzLl92LCAxMCwgVG9rZW4uT3BlcmF0b3IucmVhZCk7IH1cbiAgICBnZXQgcGF0dGVybigpOiBUcmVlIHsgcmV0dXJuIFRyZWUucmVhZCh0aGlzLl92LCAxNSk7IH1cbiAgICBnZXQgdHlwZU5vZGUoKTogQXJndW1lbnRUeXBlIHwgdW5kZWZpbmVkIHsgcmV0dXJuIHJlYWRPcHRpb24odGhpcy5fdiwgMTksIEFyZ3VtZW50VHlwZS5yZWFkKTsgfVxuICAgIGdldCBjbG9zZTIoKTogVG9rZW4uQ2xvc2VTeW1ib2wgfCB1bmRlZmluZWQgeyByZXR1cm4gcmVhZE9wdGlvbih0aGlzLl92LCAyNCwgVG9rZW4uQ2xvc2VTeW1ib2wucmVhZCk7IH1cbiAgICBnZXQgZGVmYXVsdCgpOiBBcmd1bWVudERlZmF1bHQgfCB1bmRlZmluZWQgeyByZXR1cm4gcmVhZE9wdGlvbih0aGlzLl92LCAyOSwgQXJndW1lbnREZWZhdWx0LnJlYWQpOyB9XG4gICAgZ2V0IGNsb3NlKCk6IFRva2VuLkNsb3NlU3ltYm9sIHwgdW5kZWZpbmVkIHsgcmV0dXJuIHJlYWRPcHRpb24odGhpcy5fdiwgMzQsIFRva2VuLkNsb3NlU3ltYm9sLnJlYWQpOyB9XG4gICAgdmlzaXRPcGVuKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHZpc2l0T3B0aW9uKHRoaXMuX3YsIDAsICh2aWV3LCBhZGRyZXNzKSA9PiB2aXNpdG9yKFRva2VuLk9wZW5TeW1ib2wucmVhZCh2aWV3LCBhZGRyZXNzKSkpOyB9XG4gICAgdmlzaXRPcGVuMih2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiB2aXNpdE9wdGlvbih0aGlzLl92LCA1LCAodmlldywgYWRkcmVzcykgPT4gdmlzaXRvcihUb2tlbi5PcGVuU3ltYm9sLnJlYWQodmlldywgYWRkcmVzcykpKTsgfVxuICAgIHZpc2l0U3VzcGVuc2lvbih2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiB2aXNpdE9wdGlvbih0aGlzLl92LCAxMCwgKHZpZXcsIGFkZHJlc3MpID0+IHZpc2l0b3IoVG9rZW4uT3BlcmF0b3IucmVhZCh2aWV3LCBhZGRyZXNzKSkpOyB9XG4gICAgdmlzaXRUeXBlTm9kZSh2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiB2aXNpdE9wdGlvbih0aGlzLl92LCAxOSwgKHZpZXcsIGFkZHJlc3MpID0+IHZpc2l0b3IoQXJndW1lbnRUeXBlLnJlYWQodmlldywgYWRkcmVzcykpKTsgfVxuICAgIHZpc2l0Q2xvc2UyKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHZpc2l0T3B0aW9uKHRoaXMuX3YsIDI0LCAodmlldywgYWRkcmVzcykgPT4gdmlzaXRvcihUb2tlbi5DbG9zZVN5bWJvbC5yZWFkKHZpZXcsIGFkZHJlc3MpKSk7IH1cbiAgICB2aXNpdERlZmF1bHQodmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gdmlzaXRPcHRpb24odGhpcy5fdiwgMjksICh2aWV3LCBhZGRyZXNzKSA9PiB2aXNpdG9yKEFyZ3VtZW50RGVmYXVsdC5yZWFkKHZpZXcsIGFkZHJlc3MpKSk7IH1cbiAgICB2aXNpdENsb3NlKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHZpc2l0T3B0aW9uKHRoaXMuX3YsIDM0LCAodmlldywgYWRkcmVzcykgPT4gdmlzaXRvcihUb2tlbi5DbG9zZVN5bWJvbC5yZWFkKHZpZXcsIGFkZHJlc3MpKSk7IH1cbiAgICB2aXNpdENoaWxkcmVuKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHN1cGVyLnZpc2l0Q2hpbGRyZW4odmlzaXRvcikgfHwgISF0aGlzLnZpc2l0T3Blbih2aXNpdG9yKSB8fCAhIXRoaXMudmlzaXRPcGVuMih2aXNpdG9yKSB8fCAhIXRoaXMudmlzaXRTdXNwZW5zaW9uKHZpc2l0b3IpIHx8ICEhdmlzaXRvcih0aGlzLnBhdHRlcm4pIHx8ICEhdGhpcy52aXNpdFR5cGVOb2RlKHZpc2l0b3IpIHx8ICEhdGhpcy52aXNpdENsb3NlMih2aXNpdG9yKSB8fCAhIXRoaXMudmlzaXREZWZhdWx0KHZpc2l0b3IpIHx8ICEhdGhpcy52aXNpdENsb3NlKHZpc2l0b3IpOyB9XG59XG5leHBvcnQgY2xhc3MgRG9jQ29tbWVudCBleHRlbmRzIExhenlPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKHZpZXc6IERhdGFWaWV3KSB7IHN1cGVyKHZpZXcpOyB9XG4gICAgc3RhdGljIHJlYWQodmlldzogRGF0YVZpZXcsIGFkZHJlc3M6IG51bWJlcik6IERvY0NvbW1lbnQgeyByZXR1cm4gbmV3IERvY0NvbW1lbnQocmVhZE9mZnNldCh2aWV3LCBhZGRyZXNzKSk7IH1cbiAgICBnZXQgb3BlbigpOiBUb2tlbi5UZXh0U3RhcnQgeyByZXR1cm4gVG9rZW4uVGV4dFN0YXJ0LnJlYWQodGhpcy5fdiwgMCk7IH1cbiAgICBnZXQgZWxlbWVudHMoKTogSXRlcmFibGVJdGVyYXRvcjxUZXh0RWxlbWVudD4geyByZXR1cm4gcmVhZFNlcXVlbmNlKHRoaXMuX3YsIDc2LCA0LCBUZXh0RWxlbWVudC5yZWFkKTsgfVxuICAgIGdldCBuZXdsaW5lcygpOiBJdGVyYWJsZUl0ZXJhdG9yPFRva2VuLk5ld2xpbmU+IHsgcmV0dXJuIHJlYWRTZXF1ZW5jZSh0aGlzLl92LCA4MCwgNzYsIFRva2VuLk5ld2xpbmUucmVhZCk7IH1cbiAgICB2aXNpdEVsZW1lbnRzKHZpc2l0b3I6IE9iamVjdFZpc2l0b3IpOiBib29sZWFuIHsgcmV0dXJuIHZpc2l0U2VxdWVuY2UodGhpcy5fdiwgNzYsIDQsICh2aWV3LCBhZGRyZXNzKSA9PiB2aXNpdG9yKFRleHRFbGVtZW50LnJlYWQodmlldywgYWRkcmVzcykpKTsgfVxuICAgIHZpc2l0TmV3bGluZXModmlzaXRvcjogT2JqZWN0VmlzaXRvcik6IGJvb2xlYW4geyByZXR1cm4gdmlzaXRTZXF1ZW5jZSh0aGlzLl92LCA4MCwgNzYsICh2aWV3LCBhZGRyZXNzKSA9PiB2aXNpdG9yKFRva2VuLk5ld2xpbmUucmVhZCh2aWV3LCBhZGRyZXNzKSkpOyB9XG4gICAgdmlzaXRDaGlsZHJlbih2aXNpdG9yOiBPYmplY3RWaXNpdG9yKTogYm9vbGVhbiB7IHJldHVybiBzdXBlci52aXNpdENoaWxkcmVuKHZpc2l0b3IpIHx8ICEhdmlzaXRvcih0aGlzLm9wZW4pIHx8ICEhdGhpcy52aXNpdEVsZW1lbnRzKHZpc2l0b3IpIHx8ICEhdGhpcy52aXNpdE5ld2xpbmVzKHZpc2l0b3IpOyB9XG59XG4iLCAiY29uc3QgX192aXRlX2luamVjdGVkX29yaWdpbmFsX2Rpcm5hbWUgPSBcIkM6XFxcXFByb2plY3RzXFxcXGVuc29cXFxcZW5zb1xcXFxhcHBcXFxcZ3VpMlxcXFxzaGFyZWRcXFxcYXN0XCI7Y29uc3QgX192aXRlX2luamVjdGVkX29yaWdpbmFsX2ZpbGVuYW1lID0gXCJDOlxcXFxQcm9qZWN0c1xcXFxlbnNvXFxcXGVuc29cXFxcYXBwXFxcXGd1aTJcXFxcc2hhcmVkXFxcXGFzdFxcXFxwYXJzZS50c1wiO2NvbnN0IF9fdml0ZV9pbmplY3RlZF9vcmlnaW5hbF9pbXBvcnRfbWV0YV91cmwgPSBcImZpbGU6Ly8vQzovUHJvamVjdHMvZW5zby9lbnNvL2FwcC9ndWkyL3NoYXJlZC9hc3QvcGFyc2UudHNcIjtpbXBvcnQgKiBhcyBtYXAgZnJvbSAnbGliMC9tYXAnXG5pbXBvcnQgdHlwZSB7IEFzdElkLCBNb2R1bGUsIE5vZGVDaGlsZCwgT3duZWQsIE93bmVkUmVmcywgVGV4dEVsZW1lbnQsIFRleHRUb2tlbiB9IGZyb20gJy4nXG5pbXBvcnQge1xuICBUb2tlbixcbiAgYXNPd25lZCxcbiAgaXNUb2tlbklkLFxuICBuZXdFeHRlcm5hbElkLFxuICBwYXJlbnRJZCxcbiAgcmV3cml0ZVJlZnMsXG4gIHN1YnRyZWVSb290cyxcbiAgc3luY0ZpZWxkcyxcbiAgc3luY05vZGVNZXRhZGF0YSxcbn0gZnJvbSAnLidcbmltcG9ydCB7IGFzc2VydCwgYXNzZXJ0RGVmaW5lZCwgYXNzZXJ0RXF1YWwgfSBmcm9tICcuLi91dGlsL2Fzc2VydCdcbmltcG9ydCB7IHRyeUdldFNvbGVWYWx1ZSwgemlwIH0gZnJvbSAnLi4vdXRpbC9kYXRhL2l0ZXJhYmxlJ1xuaW1wb3J0IHR5cGUgeyBTb3VyY2VSYW5nZUVkaXQsIFNwYW5UcmVlIH0gZnJvbSAnLi4vdXRpbC9kYXRhL3RleHQnXG5pbXBvcnQge1xuICBhcHBseVRleHRFZGl0cyxcbiAgYXBwbHlUZXh0RWRpdHNUb1NwYW5zLFxuICBlbmNsb3NpbmdTcGFucyxcbiAgdGV4dENoYW5nZVRvRWRpdHMsXG4gIHRyaW1FbmQsXG59IGZyb20gJy4uL3V0aWwvZGF0YS90ZXh0J1xuaW1wb3J0IHtcbiAgSWRNYXAsXG4gIGlzVXVpZCxcbiAgcmFuZ2VMZW5ndGgsXG4gIHNvdXJjZVJhbmdlRnJvbUtleSxcbiAgc291cmNlUmFuZ2VLZXksXG4gIHR5cGUgU291cmNlUmFuZ2UsXG4gIHR5cGUgU291cmNlUmFuZ2VLZXksXG59IGZyb20gJy4uL3lqc01vZGVsJ1xuaW1wb3J0IHsgZ3JhcGhQYXJlbnRQb2ludGVycyB9IGZyb20gJy4vZGVidWcnXG5pbXBvcnQgeyBwYXJzZV90cmVlLCB4eEhhc2gxMjggfSBmcm9tICcuL2ZmaSdcbmltcG9ydCAqIGFzIFJhd0FzdCBmcm9tICcuL2dlbmVyYXRlZC9hc3QnXG5pbXBvcnQgeyBNdXRhYmxlTW9kdWxlIH0gZnJvbSAnLi9tdXRhYmxlTW9kdWxlJ1xuaW1wb3J0IHR5cGUgeyBMYXp5T2JqZWN0IH0gZnJvbSAnLi9wYXJzZXJTdXBwb3J0J1xuaW1wb3J0IHtcbiAgQXBwLFxuICBBc3NpZ25tZW50LFxuICBBc3QsXG4gIEJvZHlCbG9jayxcbiAgRG9jdW1lbnRlZCxcbiAgRnVuY3Rpb24sXG4gIEdlbmVyaWMsXG4gIEdyb3VwLFxuICBJZGVudCxcbiAgSW1wb3J0LFxuICBJbnZhbGlkLFxuICBNdXRhYmxlQXNzaWdubWVudCxcbiAgTXV0YWJsZUFzdCxcbiAgTXV0YWJsZUJvZHlCbG9jayxcbiAgTXV0YWJsZUlkZW50LFxuICBOZWdhdGlvbkFwcCxcbiAgTnVtZXJpY0xpdGVyYWwsXG4gIE9wckFwcCxcbiAgUHJvcGVydHlBY2Nlc3MsXG4gIFRleHRMaXRlcmFsLFxuICBVbmFyeU9wckFwcCxcbiAgVmVjdG9yLFxuICBXaWxkY2FyZCxcbn0gZnJvbSAnLi90cmVlJ1xuXG4vKiogUmV0dXJuIHRoZSByYXcgcGFyc2VyIG91dHB1dCBmb3IgdGhlIGdpdmVuIGNvZGUuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VFbnNvKGNvZGU6IHN0cmluZyk6IFJhd0FzdC5UcmVlLkJvZHlCbG9jayB7XG4gIGNvbnN0IGJsb2IgPSBwYXJzZV90cmVlKGNvZGUpXG4gIGNvbnN0IHRyZWUgPSBSYXdBc3QuVHJlZS5yZWFkKG5ldyBEYXRhVmlldyhibG9iLmJ1ZmZlciksIGJsb2IuYnl0ZUxlbmd0aCAtIDQpXG4gIC8vIFRoZSByb290IG9mIHRoZSBwYXJzZXIgb3V0cHV0IGlzIGFsd2F5cyBhIGJvZHkgYmxvY2suXG4gIGFzc2VydCh0cmVlLnR5cGUgPT09IFJhd0FzdC5UcmVlLlR5cGUuQm9keUJsb2NrKVxuICByZXR1cm4gdHJlZVxufVxuXG4vKiogUHJpbnQgdGhlIEFTVCBhbmQgcmUtcGFyc2UgaXQsIGNvcHlpbmcgYGV4dGVybmFsSWRgcyAoYnV0IG5vdCBvdGhlciBtZXRhZGF0YSkgZnJvbSB0aGUgb3JpZ2luYWwuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKHJvb3RJbjogQXN0KTogQXN0IHtcbiAgY29uc3QgcHJpbnRlZCA9IHByaW50KHJvb3RJbilcbiAgY29uc3QgaWRNYXAgPSBzcGFuTWFwVG9JZE1hcChwcmludGVkLmluZm8pXG4gIGNvbnN0IG1vZHVsZSA9IE11dGFibGVNb2R1bGUuVHJhbnNpZW50KClcbiAgY29uc3QgdHJlZSA9IHBhcnNlRW5zbyhwcmludGVkLmNvZGUpXG4gIGNvbnN0IHsgcm9vdDogcGFyc2VkLCBzcGFucyB9ID0gYWJzdHJhY3QobW9kdWxlLCB0cmVlLCBwcmludGVkLmNvZGUpXG4gIG1vZHVsZS5yZXBsYWNlUm9vdChwYXJzZWQpXG4gIHNldEV4dGVybmFsSWRzKG1vZHVsZSwgc3BhbnMsIGlkTWFwKVxuICByZXR1cm4gcGFyc2VkXG59XG5cbi8qKiBQcm9kdWNlIGBBc3RgIHR5cGVzIGZyb20gYFJhd0FzdGAgcGFyc2VyIG91dHB1dC4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhYnN0cmFjdChcbiAgbW9kdWxlOiBNdXRhYmxlTW9kdWxlLFxuICB0cmVlOiBSYXdBc3QuVHJlZS5Cb2R5QmxvY2ssXG4gIGNvZGU6IHN0cmluZyxcbiAgc3Vic3RpdHV0b3I/OiAoa2V5OiBOb2RlS2V5KSA9PiBPd25lZCB8IHVuZGVmaW5lZCxcbik6IHsgcm9vdDogT3duZWQ8TXV0YWJsZUJvZHlCbG9jaz47IHNwYW5zOiBTcGFuTWFwOyB0b1JhdzogTWFwPEFzdElkLCBSYXdBc3QuVHJlZT4gfVxuZXhwb3J0IGZ1bmN0aW9uIGFic3RyYWN0KFxuICBtb2R1bGU6IE11dGFibGVNb2R1bGUsXG4gIHRyZWU6IFJhd0FzdC5UcmVlLFxuICBjb2RlOiBzdHJpbmcsXG4gIHN1YnN0aXR1dG9yPzogKGtleTogTm9kZUtleSkgPT4gT3duZWQgfCB1bmRlZmluZWQsXG4pOiB7IHJvb3Q6IE93bmVkOyBzcGFuczogU3Bhbk1hcDsgdG9SYXc6IE1hcDxBc3RJZCwgUmF3QXN0LlRyZWU+IH1cbmV4cG9ydCBmdW5jdGlvbiBhYnN0cmFjdChcbiAgbW9kdWxlOiBNdXRhYmxlTW9kdWxlLFxuICB0cmVlOiBSYXdBc3QuVHJlZSxcbiAgY29kZTogc3RyaW5nLFxuICBzdWJzdGl0dXRvcj86IChrZXk6IE5vZGVLZXkpID0+IE93bmVkIHwgdW5kZWZpbmVkLFxuKTogeyByb290OiBPd25lZDsgc3BhbnM6IFNwYW5NYXA7IHRvUmF3OiBNYXA8QXN0SWQsIFJhd0FzdC5UcmVlPiB9IHtcbiAgY29uc3QgYWJzdHJhY3RvciA9IG5ldyBBYnN0cmFjdG9yKG1vZHVsZSwgY29kZSwgc3Vic3RpdHV0b3IpXG4gIGNvbnN0IHJvb3QgPSBhYnN0cmFjdG9yLmFic3RyYWN0VHJlZSh0cmVlKS5ub2RlXG4gIGNvbnN0IHNwYW5zID0geyB0b2tlbnM6IGFic3RyYWN0b3IudG9rZW5zLCBub2RlczogYWJzdHJhY3Rvci5ub2RlcyB9XG4gIHJldHVybiB7IHJvb3Q6IHJvb3QgYXMgT3duZWQ8TXV0YWJsZUJvZHlCbG9jaz4sIHNwYW5zLCB0b1JhdzogYWJzdHJhY3Rvci50b1JhdyB9XG59XG5cbi8qKiBQcm9kdWNlcyBgQXN0YCB0eXBlcyBmcm9tIGBSYXdBc3RgIHBhcnNlciBvdXRwdXQuICovXG5jbGFzcyBBYnN0cmFjdG9yIHtcbiAgcHJpdmF0ZSByZWFkb25seSBtb2R1bGU6IE11dGFibGVNb2R1bGVcbiAgcHJpdmF0ZSByZWFkb25seSBjb2RlOiBzdHJpbmdcbiAgcHJpdmF0ZSByZWFkb25seSBzdWJzdGl0dXRvcjogKChrZXk6IE5vZGVLZXkpID0+IE93bmVkIHwgdW5kZWZpbmVkKSB8IHVuZGVmaW5lZFxuICByZWFkb25seSBub2RlczogTm9kZVNwYW5NYXBcbiAgcmVhZG9ubHkgdG9rZW5zOiBUb2tlblNwYW5NYXBcbiAgcmVhZG9ubHkgdG9SYXc6IE1hcDxBc3RJZCwgUmF3QXN0LlRyZWU+XG5cbiAgLyoqXG4gICAqICBAcGFyYW0gbW9kdWxlIC0gV2hlcmUgdG8gYWxsb2NhdGUgdGhlIG5ldyBub2Rlcy5cbiAgICogIEBwYXJhbSBjb2RlIC0gU291cmNlIGNvZGUgdGhhdCB3aWxsIGJlIHVzZWQgdG8gcmVzb2x2ZSByZWZlcmVuY2VzIGluIGFueSBwYXNzZWQgYFJhd0FzdGAgb2JqZWN0cy5cbiAgICogIEBwYXJhbSBzdWJzdGl0dXRvciAtIEEgZnVuY3Rpb24gdGhhdCBjYW4gaW5qZWN0IHN1YnRyZWVzIGZvciBzb21lIHNwYW5zLCBpbnN0ZWFkIG9mIHRoZSBhYnN0cmFjdG9yIHByb2R1Y2luZyB0aGVtLlxuICAgKiAgICBUaGlzIGNhbiBiZSB1c2VkIGZvciBpbmNyZW1lbnRhbCBhYnN0cmFjdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIG1vZHVsZTogTXV0YWJsZU1vZHVsZSxcbiAgICBjb2RlOiBzdHJpbmcsXG4gICAgc3Vic3RpdHV0b3I/OiAoa2V5OiBOb2RlS2V5KSA9PiBPd25lZCB8IHVuZGVmaW5lZCxcbiAgKSB7XG4gICAgdGhpcy5tb2R1bGUgPSBtb2R1bGVcbiAgICB0aGlzLmNvZGUgPSBjb2RlXG4gICAgdGhpcy5zdWJzdGl0dXRvciA9IHN1YnN0aXR1dG9yXG4gICAgdGhpcy5ub2RlcyA9IG5ldyBNYXAoKVxuICAgIHRoaXMudG9rZW5zID0gbmV3IE1hcCgpXG4gICAgdGhpcy50b1JhdyA9IG5ldyBNYXAoKVxuICB9XG5cbiAgYWJzdHJhY3RUcmVlKHRyZWU6IFJhd0FzdC5UcmVlKTogeyB3aGl0ZXNwYWNlOiBzdHJpbmcgfCB1bmRlZmluZWQ7IG5vZGU6IE93bmVkIH0ge1xuICAgIGNvbnN0IHdoaXRlc3BhY2VTdGFydCA9IHRyZWUud2hpdGVzcGFjZVN0YXJ0SW5Db2RlUGFyc2VkXG4gICAgY29uc3Qgd2hpdGVzcGFjZUVuZCA9IHdoaXRlc3BhY2VTdGFydCArIHRyZWUud2hpdGVzcGFjZUxlbmd0aEluQ29kZVBhcnNlZFxuICAgIGNvbnN0IHdoaXRlc3BhY2UgPSB0aGlzLmNvZGUuc3Vic3RyaW5nKHdoaXRlc3BhY2VTdGFydCwgd2hpdGVzcGFjZUVuZClcbiAgICBjb25zdCBjb2RlU3RhcnQgPSB3aGl0ZXNwYWNlRW5kXG4gICAgY29uc3QgY29kZUVuZCA9IGNvZGVTdGFydCArIHRyZWUuY2hpbGRyZW5MZW5ndGhJbkNvZGVQYXJzZWRcbiAgICBjb25zdCBzcGFuS2V5ID0gbm9kZUtleShjb2RlU3RhcnQsIGNvZGVFbmQgLSBjb2RlU3RhcnQpXG4gICAgY29uc3Qgc3Vic3RpdHV0ZSA9IHRoaXMuc3Vic3RpdHV0b3I/LihzcGFuS2V5KVxuICAgIGlmIChzdWJzdGl0dXRlKSByZXR1cm4geyBub2RlOiBzdWJzdGl0dXRlLCB3aGl0ZXNwYWNlIH1cbiAgICBsZXQgbm9kZTogT3duZWRcbiAgICBzd2l0Y2ggKHRyZWUudHlwZSkge1xuICAgICAgY2FzZSBSYXdBc3QuVHJlZS5UeXBlLkJvZHlCbG9jazoge1xuICAgICAgICBjb25zdCBsaW5lcyA9IEFycmF5LmZyb20odHJlZS5zdGF0ZW1lbnRzLCAobGluZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IG5ld2xpbmUgPSB0aGlzLmFic3RyYWN0VG9rZW4obGluZS5uZXdsaW5lKVxuICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBsaW5lLmV4cHJlc3Npb24gPyB0aGlzLmFic3RyYWN0VHJlZShsaW5lLmV4cHJlc3Npb24pIDogdW5kZWZpbmVkXG4gICAgICAgICAgcmV0dXJuIHsgbmV3bGluZSwgZXhwcmVzc2lvbiB9XG4gICAgICAgIH0pXG4gICAgICAgIG5vZGUgPSBCb2R5QmxvY2suY29uY3JldGUodGhpcy5tb2R1bGUsIGxpbmVzKVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSBSYXdBc3QuVHJlZS5UeXBlLkZ1bmN0aW9uOiB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLmFic3RyYWN0VHJlZSh0cmVlLm5hbWUpXG4gICAgICAgIGNvbnN0IGFyZ3VtZW50RGVmaW5pdGlvbnMgPSBBcnJheS5mcm9tKHRyZWUuYXJncywgKGFyZykgPT4gdGhpcy5hYnN0cmFjdENoaWxkcmVuKGFyZykpXG4gICAgICAgIGNvbnN0IGVxdWFscyA9IHRoaXMuYWJzdHJhY3RUb2tlbih0cmVlLmVxdWFscylcbiAgICAgICAgY29uc3QgYm9keSA9IHRyZWUuYm9keSAhPT0gdW5kZWZpbmVkID8gdGhpcy5hYnN0cmFjdFRyZWUodHJlZS5ib2R5KSA6IHVuZGVmaW5lZFxuICAgICAgICBub2RlID0gRnVuY3Rpb24uY29uY3JldGUodGhpcy5tb2R1bGUsIG5hbWUsIGFyZ3VtZW50RGVmaW5pdGlvbnMsIGVxdWFscywgYm9keSlcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgUmF3QXN0LlRyZWUuVHlwZS5JZGVudDoge1xuICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMuYWJzdHJhY3RUb2tlbih0cmVlLnRva2VuKVxuICAgICAgICBub2RlID0gSWRlbnQuY29uY3JldGUodGhpcy5tb2R1bGUsIHRva2VuKVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSBSYXdBc3QuVHJlZS5UeXBlLkFzc2lnbm1lbnQ6IHtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IHRoaXMuYWJzdHJhY3RUcmVlKHRyZWUucGF0dGVybilcbiAgICAgICAgY29uc3QgZXF1YWxzID0gdGhpcy5hYnN0cmFjdFRva2VuKHRyZWUuZXF1YWxzKVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuYWJzdHJhY3RUcmVlKHRyZWUuZXhwcilcbiAgICAgICAgbm9kZSA9IEFzc2lnbm1lbnQuY29uY3JldGUodGhpcy5tb2R1bGUsIHBhdHRlcm4sIGVxdWFscywgdmFsdWUpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlIFJhd0FzdC5UcmVlLlR5cGUuQXBwOiB7XG4gICAgICAgIGNvbnN0IGZ1bmMgPSB0aGlzLmFic3RyYWN0VHJlZSh0cmVlLmZ1bmMpXG4gICAgICAgIGNvbnN0IGFyZyA9IHRoaXMuYWJzdHJhY3RUcmVlKHRyZWUuYXJnKVxuICAgICAgICBub2RlID0gQXBwLmNvbmNyZXRlKHRoaXMubW9kdWxlLCBmdW5jLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJnKVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSBSYXdBc3QuVHJlZS5UeXBlLk5hbWVkQXBwOiB7XG4gICAgICAgIGNvbnN0IGZ1bmMgPSB0aGlzLmFic3RyYWN0VHJlZSh0cmVlLmZ1bmMpXG4gICAgICAgIGNvbnN0IG9wZW4gPSB0cmVlLm9wZW4gPyB0aGlzLmFic3RyYWN0VG9rZW4odHJlZS5vcGVuKSA6IHVuZGVmaW5lZFxuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5hYnN0cmFjdFRva2VuKHRyZWUubmFtZSlcbiAgICAgICAgY29uc3QgZXF1YWxzID0gdGhpcy5hYnN0cmFjdFRva2VuKHRyZWUuZXF1YWxzKVxuICAgICAgICBjb25zdCBhcmcgPSB0aGlzLmFic3RyYWN0VHJlZSh0cmVlLmFyZylcbiAgICAgICAgY29uc3QgY2xvc2UgPSB0cmVlLmNsb3NlID8gdGhpcy5hYnN0cmFjdFRva2VuKHRyZWUuY2xvc2UpIDogdW5kZWZpbmVkXG4gICAgICAgIGNvbnN0IHBhcmVucyA9IG9wZW4gJiYgY2xvc2UgPyB7IG9wZW4sIGNsb3NlIH0gOiB1bmRlZmluZWRcbiAgICAgICAgY29uc3QgbmFtZVNwZWNpZmljYXRpb24gPSB7IG5hbWUsIGVxdWFscyB9XG4gICAgICAgIG5vZGUgPSBBcHAuY29uY3JldGUodGhpcy5tb2R1bGUsIGZ1bmMsIHBhcmVucywgbmFtZVNwZWNpZmljYXRpb24sIGFyZylcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgUmF3QXN0LlRyZWUuVHlwZS5VbmFyeU9wckFwcDoge1xuICAgICAgICBjb25zdCBvcHIgPSB0aGlzLmFic3RyYWN0VG9rZW4odHJlZS5vcHIpXG4gICAgICAgIGNvbnN0IGFyZyA9IHRyZWUucmhzID8gdGhpcy5hYnN0cmFjdFRyZWUodHJlZS5yaHMpIDogdW5kZWZpbmVkXG4gICAgICAgIGlmIChhcmcgJiYgb3ByLm5vZGUuY29kZSgpID09PSAnLScpIHtcbiAgICAgICAgICBub2RlID0gTmVnYXRpb25BcHAuY29uY3JldGUodGhpcy5tb2R1bGUsIG9wciwgYXJnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUgPSBVbmFyeU9wckFwcC5jb25jcmV0ZSh0aGlzLm1vZHVsZSwgb3ByLCBhcmcpXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgUmF3QXN0LlRyZWUuVHlwZS5PcHJBcHA6IHtcbiAgICAgICAgY29uc3QgbGhzID0gdHJlZS5saHMgPyB0aGlzLmFic3RyYWN0VHJlZSh0cmVlLmxocykgOiB1bmRlZmluZWRcbiAgICAgICAgY29uc3Qgb3ByID1cbiAgICAgICAgICB0cmVlLm9wci5vayA/XG4gICAgICAgICAgICBbdGhpcy5hYnN0cmFjdFRva2VuKHRyZWUub3ByLnZhbHVlKV1cbiAgICAgICAgICA6IEFycmF5LmZyb20odHJlZS5vcHIuZXJyb3IucGF5bG9hZC5vcGVyYXRvcnMsIHRoaXMuYWJzdHJhY3RUb2tlbi5iaW5kKHRoaXMpKVxuICAgICAgICBjb25zdCByaHMgPSB0cmVlLnJocyA/IHRoaXMuYWJzdHJhY3RUcmVlKHRyZWUucmhzKSA6IHVuZGVmaW5lZFxuICAgICAgICBjb25zdCBzb2xlT3ByID0gdHJ5R2V0U29sZVZhbHVlKG9wcilcbiAgICAgICAgaWYgKHNvbGVPcHI/Lm5vZGUuY29kZSgpID09PSAnLicgJiYgcmhzPy5ub2RlIGluc3RhbmNlb2YgTXV0YWJsZUlkZW50KSB7XG4gICAgICAgICAgLy8gUHJvcGFnYXRlIHR5cGUuXG4gICAgICAgICAgY29uc3QgcmhzXyA9IHsgLi4ucmhzLCBub2RlOiByaHMubm9kZSB9XG4gICAgICAgICAgbm9kZSA9IFByb3BlcnR5QWNjZXNzLmNvbmNyZXRlKHRoaXMubW9kdWxlLCBsaHMsIHNvbGVPcHIsIHJoc18pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZSA9IE9wckFwcC5jb25jcmV0ZSh0aGlzLm1vZHVsZSwgbGhzLCBvcHIsIHJocylcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSBSYXdBc3QuVHJlZS5UeXBlLk51bWJlcjoge1xuICAgICAgICBjb25zdCB0b2tlbnMgPSBbXVxuICAgICAgICBpZiAodHJlZS5iYXNlKSB0b2tlbnMucHVzaCh0aGlzLmFic3RyYWN0VG9rZW4odHJlZS5iYXNlKSlcbiAgICAgICAgaWYgKHRyZWUuaW50ZWdlcikgdG9rZW5zLnB1c2godGhpcy5hYnN0cmFjdFRva2VuKHRyZWUuaW50ZWdlcikpXG4gICAgICAgIGlmICh0cmVlLmZyYWN0aW9uYWxEaWdpdHMpIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0aGlzLmFic3RyYWN0VG9rZW4odHJlZS5mcmFjdGlvbmFsRGlnaXRzLmRvdCkpXG4gICAgICAgICAgdG9rZW5zLnB1c2godGhpcy5hYnN0cmFjdFRva2VuKHRyZWUuZnJhY3Rpb25hbERpZ2l0cy5kaWdpdHMpKVxuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBOdW1lcmljTGl0ZXJhbC5jb25jcmV0ZSh0aGlzLm1vZHVsZSwgdG9rZW5zKVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSBSYXdBc3QuVHJlZS5UeXBlLldpbGRjYXJkOiB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5hYnN0cmFjdFRva2VuKHRyZWUudG9rZW4pXG4gICAgICAgIG5vZGUgPSBXaWxkY2FyZC5jb25jcmV0ZSh0aGlzLm1vZHVsZSwgdG9rZW4pXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICAvLyBUaGVzZSBleHByZXNzaW9uIHR5cGVzIGFyZSAob3Igd2lsbCBiZSkgdXNlZCBmb3IgYmFja2VuZCBhbmFseXNpcy5cbiAgICAgIC8vIFRoZSBmcm9udGVuZCBjYW4gaWdub3JlIHRoZW0sIGF2b2lkaW5nIHNvbWUgcHJvYmxlbXMgd2l0aCBleHByZXNzaW9ucyBzaGFyaW5nIHNwYW5zXG4gICAgICAvLyAod2hpY2ggbWFrZXMgaXQgaW1wb3NzaWJsZSB0byBnaXZlIHRoZW0gdW5pcXVlIElEcyBpbiB0aGUgY3VycmVudCBJZE1hcCBmb3JtYXQpLlxuICAgICAgY2FzZSBSYXdBc3QuVHJlZS5UeXBlLk9wclNlY3Rpb25Cb3VuZGFyeTpcbiAgICAgIGNhc2UgUmF3QXN0LlRyZWUuVHlwZS5UZW1wbGF0ZUZ1bmN0aW9uOlxuICAgICAgICByZXR1cm4geyB3aGl0ZXNwYWNlLCBub2RlOiB0aGlzLmFic3RyYWN0VHJlZSh0cmVlLmFzdCkubm9kZSB9XG4gICAgICBjYXNlIFJhd0FzdC5UcmVlLlR5cGUuSW52YWxpZDoge1xuICAgICAgICBjb25zdCBleHByZXNzaW9uID0gdGhpcy5hYnN0cmFjdFRyZWUodHJlZS5hc3QpXG4gICAgICAgIG5vZGUgPSBJbnZhbGlkLmNvbmNyZXRlKHRoaXMubW9kdWxlLCBleHByZXNzaW9uKVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSBSYXdBc3QuVHJlZS5UeXBlLkdyb3VwOiB7XG4gICAgICAgIGNvbnN0IG9wZW4gPSB0cmVlLm9wZW4gPyB0aGlzLmFic3RyYWN0VG9rZW4odHJlZS5vcGVuKSA6IHVuZGVmaW5lZFxuICAgICAgICBjb25zdCBleHByZXNzaW9uID0gdHJlZS5ib2R5ID8gdGhpcy5hYnN0cmFjdFRyZWUodHJlZS5ib2R5KSA6IHVuZGVmaW5lZFxuICAgICAgICBjb25zdCBjbG9zZSA9IHRyZWUuY2xvc2UgPyB0aGlzLmFic3RyYWN0VG9rZW4odHJlZS5jbG9zZSkgOiB1bmRlZmluZWRcbiAgICAgICAgbm9kZSA9IEdyb3VwLmNvbmNyZXRlKHRoaXMubW9kdWxlLCBvcGVuLCBleHByZXNzaW9uLCBjbG9zZSlcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgUmF3QXN0LlRyZWUuVHlwZS5UZXh0TGl0ZXJhbDoge1xuICAgICAgICBjb25zdCBvcGVuID0gdHJlZS5vcGVuID8gdGhpcy5hYnN0cmFjdFRva2VuKHRyZWUub3BlbikgOiB1bmRlZmluZWRcbiAgICAgICAgY29uc3QgbmV3bGluZSA9IHRyZWUubmV3bGluZSA/IHRoaXMuYWJzdHJhY3RUb2tlbih0cmVlLm5ld2xpbmUpIDogdW5kZWZpbmVkXG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gQXJyYXkuZnJvbSh0cmVlLmVsZW1lbnRzLCAocmF3KSA9PiB0aGlzLmFic3RyYWN0VGV4dEVsZW1lbnQocmF3KSlcbiAgICAgICAgY29uc3QgY2xvc2UgPSB0cmVlLmNsb3NlID8gdGhpcy5hYnN0cmFjdFRva2VuKHRyZWUuY2xvc2UpIDogdW5kZWZpbmVkXG4gICAgICAgIG5vZGUgPSBUZXh0TGl0ZXJhbC5jb25jcmV0ZSh0aGlzLm1vZHVsZSwgb3BlbiwgbmV3bGluZSwgZWxlbWVudHMsIGNsb3NlKVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSBSYXdBc3QuVHJlZS5UeXBlLkRvY3VtZW50ZWQ6IHtcbiAgICAgICAgY29uc3Qgb3BlbiA9IHRoaXMuYWJzdHJhY3RUb2tlbih0cmVlLmRvY3VtZW50YXRpb24ub3BlbilcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBBcnJheS5mcm9tKHRyZWUuZG9jdW1lbnRhdGlvbi5lbGVtZW50cywgKHJhdykgPT5cbiAgICAgICAgICB0aGlzLmFic3RyYWN0VGV4dFRva2VuKHJhdyksXG4gICAgICAgIClcbiAgICAgICAgY29uc3QgbmV3bGluZXMgPSBBcnJheS5mcm9tKHRyZWUuZG9jdW1lbnRhdGlvbi5uZXdsaW5lcywgdGhpcy5hYnN0cmFjdFRva2VuLmJpbmQodGhpcykpXG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSB0cmVlLmV4cHJlc3Npb24gPyB0aGlzLmFic3RyYWN0VHJlZSh0cmVlLmV4cHJlc3Npb24pIDogdW5kZWZpbmVkXG4gICAgICAgIG5vZGUgPSBEb2N1bWVudGVkLmNvbmNyZXRlKHRoaXMubW9kdWxlLCBvcGVuLCBlbGVtZW50cywgbmV3bGluZXMsIGV4cHJlc3Npb24pXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlIFJhd0FzdC5UcmVlLlR5cGUuSW1wb3J0OiB7XG4gICAgICAgIGNvbnN0IHJlY3Vyc2VCb2R5ID0gKHRyZWU6IFJhd0FzdC5UcmVlKSA9PiB7XG4gICAgICAgICAgY29uc3QgYm9keSA9IHRoaXMuYWJzdHJhY3RUcmVlKHRyZWUpXG4gICAgICAgICAgaWYgKGJvZHkubm9kZSBpbnN0YW5jZW9mIEludmFsaWQgJiYgYm9keS5ub2RlLmNvZGUoKSA9PT0gJycpIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgICByZXR1cm4gYm9keVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlY3Vyc2VTZWdtZW50ID0gKHNlZ21lbnQ6IFJhd0FzdC5NdWx0aVNlZ21lbnRBcHBTZWdtZW50KSA9PiAoe1xuICAgICAgICAgIGhlYWRlcjogdGhpcy5hYnN0cmFjdFRva2VuKHNlZ21lbnQuaGVhZGVyKSxcbiAgICAgICAgICBib2R5OiBzZWdtZW50LmJvZHkgPyByZWN1cnNlQm9keShzZWdtZW50LmJvZHkpIDogdW5kZWZpbmVkLFxuICAgICAgICB9KVxuICAgICAgICBjb25zdCBwb2x5Z2xvdCA9IHRyZWUucG9seWdsb3QgPyByZWN1cnNlU2VnbWVudCh0cmVlLnBvbHlnbG90KSA6IHVuZGVmaW5lZFxuICAgICAgICBjb25zdCBmcm9tID0gdHJlZS5mcm9tID8gcmVjdXJzZVNlZ21lbnQodHJlZS5mcm9tKSA6IHVuZGVmaW5lZFxuICAgICAgICBjb25zdCBpbXBvcnRfID0gcmVjdXJzZVNlZ21lbnQodHJlZS5pbXBvcnQpXG4gICAgICAgIGNvbnN0IGFsbCA9IHRyZWUuYWxsID8gdGhpcy5hYnN0cmFjdFRva2VuKHRyZWUuYWxsKSA6IHVuZGVmaW5lZFxuICAgICAgICBjb25zdCBhcyA9IHRyZWUuYXMgPyByZWN1cnNlU2VnbWVudCh0cmVlLmFzKSA6IHVuZGVmaW5lZFxuICAgICAgICBjb25zdCBoaWRpbmcgPSB0cmVlLmhpZGluZyA/IHJlY3Vyc2VTZWdtZW50KHRyZWUuaGlkaW5nKSA6IHVuZGVmaW5lZFxuICAgICAgICBub2RlID0gSW1wb3J0LmNvbmNyZXRlKHRoaXMubW9kdWxlLCBwb2x5Z2xvdCwgZnJvbSwgaW1wb3J0XywgYWxsLCBhcywgaGlkaW5nKVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSBSYXdBc3QuVHJlZS5UeXBlLkFycmF5OiB7XG4gICAgICAgIGNvbnN0IGxlZnQgPSB0aGlzLmFic3RyYWN0VG9rZW4odHJlZS5sZWZ0KVxuICAgICAgICBjb25zdCBlbGVtZW50cyA9IFtdXG4gICAgICAgIGlmICh0cmVlLmZpcnN0KSBlbGVtZW50cy5wdXNoKHsgdmFsdWU6IHRoaXMuYWJzdHJhY3RUcmVlKHRyZWUuZmlyc3QpIH0pXG4gICAgICAgIGZvciAoY29uc3QgcmF3RWxlbWVudCBvZiB0cmVlLnJlc3QpIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKHtcbiAgICAgICAgICAgIGRlbGltaXRlcjogdGhpcy5hYnN0cmFjdFRva2VuKHJhd0VsZW1lbnQub3BlcmF0b3IpLFxuICAgICAgICAgICAgdmFsdWU6IHJhd0VsZW1lbnQuYm9keSAmJiB0aGlzLmFic3RyYWN0VHJlZShyYXdFbGVtZW50LmJvZHkpLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmlnaHQgPSB0aGlzLmFic3RyYWN0VG9rZW4odHJlZS5yaWdodClcbiAgICAgICAgbm9kZSA9IFZlY3Rvci5jb25jcmV0ZSh0aGlzLm1vZHVsZSwgbGVmdCwgZWxlbWVudHMsIHJpZ2h0KVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBub2RlID0gR2VuZXJpYy5jb25jcmV0ZSh0aGlzLm1vZHVsZSwgdGhpcy5hYnN0cmFjdENoaWxkcmVuKHRyZWUpKVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnRvUmF3LnNldChub2RlLmlkLCB0cmVlKVxuICAgIG1hcC5zZXRJZlVuZGVmaW5lZCh0aGlzLm5vZGVzLCBzcGFuS2V5LCAoKTogQXN0W10gPT4gW10pLnVuc2hpZnQobm9kZSlcbiAgICByZXR1cm4geyBub2RlLCB3aGl0ZXNwYWNlIH1cbiAgfVxuXG4gIHByaXZhdGUgYWJzdHJhY3RUb2tlbih0b2tlbjogUmF3QXN0LlRva2VuKTogeyB3aGl0ZXNwYWNlOiBzdHJpbmc7IG5vZGU6IFRva2VuIH0ge1xuICAgIGNvbnN0IHdoaXRlc3BhY2VTdGFydCA9IHRva2VuLndoaXRlc3BhY2VTdGFydEluQ29kZUJ1ZmZlclxuICAgIGNvbnN0IHdoaXRlc3BhY2VFbmQgPSB3aGl0ZXNwYWNlU3RhcnQgKyB0b2tlbi53aGl0ZXNwYWNlTGVuZ3RoSW5Db2RlQnVmZmVyXG4gICAgY29uc3Qgd2hpdGVzcGFjZSA9IHRoaXMuY29kZS5zdWJzdHJpbmcod2hpdGVzcGFjZVN0YXJ0LCB3aGl0ZXNwYWNlRW5kKVxuICAgIGNvbnN0IGNvZGVTdGFydCA9IHRva2VuLnN0YXJ0SW5Db2RlQnVmZmVyXG4gICAgY29uc3QgY29kZUVuZCA9IGNvZGVTdGFydCArIHRva2VuLmxlbmd0aEluQ29kZUJ1ZmZlclxuICAgIGNvbnN0IHRva2VuQ29kZSA9IHRoaXMuY29kZS5zdWJzdHJpbmcoY29kZVN0YXJ0LCBjb2RlRW5kKVxuICAgIGNvbnN0IGtleSA9IHRva2VuS2V5KGNvZGVTdGFydCwgY29kZUVuZCAtIGNvZGVTdGFydClcbiAgICBjb25zdCBub2RlID0gVG9rZW4ubmV3KHRva2VuQ29kZSwgdG9rZW4udHlwZSlcbiAgICB0aGlzLnRva2Vucy5zZXQoa2V5LCBub2RlKVxuICAgIHJldHVybiB7IHdoaXRlc3BhY2UsIG5vZGUgfVxuICB9XG5cbiAgcHJpdmF0ZSBhYnN0cmFjdENoaWxkcmVuKHRyZWU6IExhenlPYmplY3QpOiAoTm9kZUNoaWxkPE93bmVkPiB8IE5vZGVDaGlsZDxUb2tlbj4pW10ge1xuICAgIGNvbnN0IGNoaWxkcmVuOiAoTm9kZUNoaWxkPE93bmVkPiB8IE5vZGVDaGlsZDxUb2tlbj4pW10gPSBbXVxuICAgIGNvbnN0IHZpc2l0b3IgPSAoY2hpbGQ6IExhenlPYmplY3QpID0+IHtcbiAgICAgIGlmIChSYXdBc3QuVHJlZS5pc0luc3RhbmNlKGNoaWxkKSkge1xuICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMuYWJzdHJhY3RUcmVlKGNoaWxkKSlcbiAgICAgIH0gZWxzZSBpZiAoUmF3QXN0LlRva2VuLmlzSW5zdGFuY2UoY2hpbGQpKSB7XG4gICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5hYnN0cmFjdFRva2VuKGNoaWxkKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoaWxkLnZpc2l0Q2hpbGRyZW4odmlzaXRvcilcbiAgICAgIH1cbiAgICB9XG4gICAgdHJlZS52aXNpdENoaWxkcmVuKHZpc2l0b3IpXG4gICAgcmV0dXJuIGNoaWxkcmVuXG4gIH1cblxuICBwcml2YXRlIGFic3RyYWN0VGV4dEVsZW1lbnQocmF3OiBSYXdBc3QuVGV4dEVsZW1lbnQpOiBUZXh0RWxlbWVudDxPd25lZFJlZnM+IHtcbiAgICBzd2l0Y2ggKHJhdy50eXBlKSB7XG4gICAgICBjYXNlIFJhd0FzdC5UZXh0RWxlbWVudC5UeXBlLk5ld2xpbmU6XG4gICAgICBjYXNlIFJhd0FzdC5UZXh0RWxlbWVudC5UeXBlLkVzY2FwZTpcbiAgICAgIGNhc2UgUmF3QXN0LlRleHRFbGVtZW50LlR5cGUuU2VjdGlvbjpcbiAgICAgICAgcmV0dXJuIHRoaXMuYWJzdHJhY3RUZXh0VG9rZW4ocmF3KVxuICAgICAgY2FzZSBSYXdBc3QuVGV4dEVsZW1lbnQuVHlwZS5TcGxpY2U6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ3NwbGljZScsXG4gICAgICAgICAgb3BlbjogdGhpcy5hYnN0cmFjdFRva2VuKHJhdy5vcGVuKSxcbiAgICAgICAgICBleHByZXNzaW9uOiByYXcuZXhwcmVzc2lvbiAmJiB0aGlzLmFic3RyYWN0VHJlZShyYXcuZXhwcmVzc2lvbiksXG4gICAgICAgICAgY2xvc2U6IHRoaXMuYWJzdHJhY3RUb2tlbihyYXcuY2xvc2UpLFxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhYnN0cmFjdFRleHRUb2tlbihyYXc6IFJhd0FzdC5UZXh0RWxlbWVudCk6IFRleHRUb2tlbjxPd25lZFJlZnM+IHtcbiAgICBzd2l0Y2ggKHJhdy50eXBlKSB7XG4gICAgICBjYXNlIFJhd0FzdC5UZXh0RWxlbWVudC5UeXBlLk5ld2xpbmU6XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICd0b2tlbicsIHRva2VuOiB0aGlzLmFic3RyYWN0VG9rZW4ocmF3Lm5ld2xpbmUpIH1cbiAgICAgIGNhc2UgUmF3QXN0LlRleHRFbGVtZW50LlR5cGUuRXNjYXBlOiB7XG4gICAgICAgIGNvbnN0IG5lZ2F0aXZlT25lVTMyID0gNDI5NDk2NzI5NVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICd0b2tlbicsXG4gICAgICAgICAgdG9rZW46IHRoaXMuYWJzdHJhY3RUb2tlbihyYXcudG9rZW4pLFxuICAgICAgICAgIGludGVycHJldGVkOlxuICAgICAgICAgICAgcmF3LnRva2VuLnZhbHVlICE9PSBuZWdhdGl2ZU9uZVUzMiA/IFN0cmluZy5mcm9tQ29kZVBvaW50KHJhdy50b2tlbi52YWx1ZSkgOiB1bmRlZmluZWQsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNhc2UgUmF3QXN0LlRleHRFbGVtZW50LlR5cGUuU2VjdGlvbjpcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ3Rva2VuJywgdG9rZW46IHRoaXMuYWJzdHJhY3RUb2tlbihyYXcudGV4dCkgfVxuICAgICAgY2FzZSBSYXdBc3QuVGV4dEVsZW1lbnQuVHlwZS5TcGxpY2U6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5yZWFjaGFibGU6IFNwbGljZSBpbiBub24taW50ZXJwb2xhdGVkIHRleHQgZmllbGQnKVxuICAgIH1cbiAgfVxufVxuXG5kZWNsYXJlIGNvbnN0IG5vZGVLZXlCcmFuZDogdW5pcXVlIHN5bWJvbFxuLyoqIEEgc291cmNlLXJhbmdlIGtleSBmb3IgYW4gYEFzdGAuICovXG5leHBvcnQgdHlwZSBOb2RlS2V5ID0gU291cmNlUmFuZ2VLZXkgJiB7IFtub2RlS2V5QnJhbmRdOiBuZXZlciB9XG5kZWNsYXJlIGNvbnN0IHRva2VuS2V5QnJhbmQ6IHVuaXF1ZSBzeW1ib2xcbi8qKiBBIHNvdXJjZS1yYW5nZSBrZXkgZm9yIGEgYFRva2VuYC4gKi9cbmV4cG9ydCB0eXBlIFRva2VuS2V5ID0gU291cmNlUmFuZ2VLZXkgJiB7IFt0b2tlbktleUJyYW5kXTogbmV2ZXIgfVxuLyoqIENyZWF0ZSBhIHNvdXJjZS1yYW5nZSBrZXkgZm9yIGFuIGBBc3RgLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vZGVLZXkoc3RhcnQ6IG51bWJlciwgbGVuZ3RoOiBudW1iZXIpOiBOb2RlS2V5IHtcbiAgcmV0dXJuIHNvdXJjZVJhbmdlS2V5KFtzdGFydCwgc3RhcnQgKyBsZW5ndGhdKSBhcyBOb2RlS2V5XG59XG4vKiogQ3JlYXRlIGEgc291cmNlLXJhbmdlIGtleSBmb3IgYSBgVG9rZW5gLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRva2VuS2V5KHN0YXJ0OiBudW1iZXIsIGxlbmd0aDogbnVtYmVyKTogVG9rZW5LZXkge1xuICByZXR1cm4gc291cmNlUmFuZ2VLZXkoW3N0YXJ0LCBzdGFydCArIGxlbmd0aF0pIGFzIFRva2VuS2V5XG59XG5cbi8qKiBNYXBzIGZyb20gc291cmNlIHJhbmdlcyB0byBgQXN0YHMuICovXG5leHBvcnQgdHlwZSBOb2RlU3Bhbk1hcCA9IE1hcDxOb2RlS2V5LCBBc3RbXT5cbi8qKiBNYXBzIGZyb20gc291cmNlIHJhbmdlcyB0byBgVG9rZW5gcy4gKi9cbmV4cG9ydCB0eXBlIFRva2VuU3Bhbk1hcCA9IE1hcDxUb2tlbktleSwgVG9rZW4+XG5cbi8qKiBNYXBzIGZyb20gc291cmNlIHJhbmdlcyB0byBgQXN0YHMgYW5kIGBUb2tlbmBzLiAqL1xuZXhwb3J0IGludGVyZmFjZSBTcGFuTWFwIHtcbiAgbm9kZXM6IE5vZGVTcGFuTWFwXG4gIHRva2VuczogVG9rZW5TcGFuTWFwXG59XG5cbi8qKiBDb2RlIHdpdGggYW4gYXNzb2NpYXRlZCBtYXBwaW5nIHRvIGBBc3RgIHR5cGVzLiAqL1xuaW50ZXJmYWNlIFByaW50ZWRTb3VyY2Uge1xuICBpbmZvOiBTcGFuTWFwXG4gIGNvZGU6IHN0cmluZ1xufVxuXG4vKiogR2VuZXJhdGUgYW4gYElkTWFwYCBmcm9tIGEgYFNwYW5NYXBgLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNwYW5NYXBUb0lkTWFwKHNwYW5zOiBTcGFuTWFwKTogSWRNYXAge1xuICBjb25zdCBpZE1hcCA9IG5ldyBJZE1hcCgpXG4gIGZvciAoY29uc3QgW2tleSwgdG9rZW5dIG9mIHNwYW5zLnRva2Vucy5lbnRyaWVzKCkpIHtcbiAgICBhc3NlcnQoaXNVdWlkKHRva2VuLmlkKSlcbiAgICBpZE1hcC5pbnNlcnRLbm93bklkKHNvdXJjZVJhbmdlRnJvbUtleShrZXkpLCB0b2tlbi5pZClcbiAgfVxuICBmb3IgKGNvbnN0IFtrZXksIGFzdHNdIG9mIHNwYW5zLm5vZGVzLmVudHJpZXMoKSkge1xuICAgIGZvciAoY29uc3QgYXN0IG9mIGFzdHMpIHtcbiAgICAgIGFzc2VydChpc1V1aWQoYXN0LmV4dGVybmFsSWQpKVxuICAgICAgaWRNYXAuaW5zZXJ0S25vd25JZChzb3VyY2VSYW5nZUZyb21LZXkoa2V5KSwgYXN0LmV4dGVybmFsSWQpXG4gICAgfVxuICB9XG4gIHJldHVybiBpZE1hcFxufVxuXG4vKiogR2l2ZW4gYSBgU3Bhbk1hcGAsIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgY2FuIGxvb2sgdXAgc291cmNlIHJhbmdlcyBieSBBU1QgSUQuICovXG5leHBvcnQgZnVuY3Rpb24gc3Bhbk1hcFRvU3BhbkdldHRlcihzcGFuczogU3Bhbk1hcCk6IChpZDogQXN0SWQpID0+IFNvdXJjZVJhbmdlIHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgcmV2ZXJzZU1hcCA9IG5ldyBNYXA8QXN0SWQsIFNvdXJjZVJhbmdlPigpXG4gIGZvciAoY29uc3QgW2tleSwgYXN0c10gb2Ygc3BhbnMubm9kZXMpIHtcbiAgICBmb3IgKGNvbnN0IGFzdCBvZiBhc3RzKSB7XG4gICAgICByZXZlcnNlTWFwLnNldChhc3QuaWQsIHNvdXJjZVJhbmdlRnJvbUtleShrZXkpKVxuICAgIH1cbiAgfVxuICByZXR1cm4gKGlkKSA9PiByZXZlcnNlTWFwLmdldChpZClcbn1cblxuLyoqIFJldHVybiBzdHJpbmdpZmljYXRpb24gd2l0aCBhc3NvY2lhdGVkIElEIG1hcC4gVGhpcyBpcyBvbmx5IGV4cG9ydGVkIGZvciB0ZXN0aW5nLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByaW50KGFzdDogQXN0KTogUHJpbnRlZFNvdXJjZSB7XG4gIGNvbnN0IGluZm86IFNwYW5NYXAgPSB7XG4gICAgbm9kZXM6IG5ldyBNYXAoKSxcbiAgICB0b2tlbnM6IG5ldyBNYXAoKSxcbiAgfVxuICBjb25zdCBjb2RlID0gYXN0LnByaW50U3VidHJlZShpbmZvLCAwLCB1bmRlZmluZWQpXG4gIHJldHVybiB7IGluZm8sIGNvZGUgfVxufVxuXG4vKiogQGludGVybmFsIFVzZWQgYnkgYEFzdC5wcmludFN1YnRyZWVgLiBOb3RlIHRoYXQgc29tZSBBU1QgdHlwZXMgaGF2ZSBvdmVycmlkZXMuICovXG5leHBvcnQgZnVuY3Rpb24gcHJpbnRBc3QoXG4gIGFzdDogQXN0LFxuICBpbmZvOiBTcGFuTWFwLFxuICBvZmZzZXQ6IG51bWJlcixcbiAgcGFyZW50SW5kZW50OiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gIHZlcmJhdGltPzogYm9vbGVhbixcbik6IHN0cmluZyB7XG4gIGxldCBjb2RlID0gJydcbiAgZm9yIChjb25zdCBjaGlsZCBvZiBhc3QuY29uY3JldGVDaGlsZHJlbih2ZXJiYXRpbSkpIHtcbiAgICBpZiAoIWlzVG9rZW5JZChjaGlsZC5ub2RlKSAmJiBhc3QubW9kdWxlLmdldChjaGlsZC5ub2RlKSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZVxuICAgIGlmIChjaGlsZC53aGl0ZXNwYWNlICE9IG51bGwpIHtcbiAgICAgIGNvZGUgKz0gY2hpbGQud2hpdGVzcGFjZVxuICAgIH0gZWxzZSBpZiAoY29kZS5sZW5ndGggIT0gMCkge1xuICAgICAgY29kZSArPSAnICdcbiAgICB9XG4gICAgaWYgKGlzVG9rZW5JZChjaGlsZC5ub2RlKSkge1xuICAgICAgY29uc3QgdG9rZW5TdGFydCA9IG9mZnNldCArIGNvZGUubGVuZ3RoXG4gICAgICBjb25zdCB0b2tlbiA9IGFzdC5tb2R1bGUuZ2V0VG9rZW4oY2hpbGQubm9kZSlcbiAgICAgIGNvbnN0IHNwYW4gPSB0b2tlbktleSh0b2tlblN0YXJ0LCB0b2tlbi5jb2RlKCkubGVuZ3RoKVxuICAgICAgaW5mby50b2tlbnMuc2V0KHNwYW4sIHRva2VuKVxuICAgICAgY29kZSArPSB0b2tlbi5jb2RlKClcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2hpbGROb2RlID0gYXN0Lm1vZHVsZS5nZXQoY2hpbGQubm9kZSlcbiAgICAgIGNvZGUgKz0gY2hpbGROb2RlLnByaW50U3VidHJlZShpbmZvLCBvZmZzZXQgKyBjb2RlLmxlbmd0aCwgcGFyZW50SW5kZW50LCB2ZXJiYXRpbSlcbiAgICAgIC8vIEV4dHJhIHN0cnVjdHVyYWwgdmFsaWRhdGlvbi5cbiAgICAgIGFzc2VydEVxdWFsKGNoaWxkTm9kZS5pZCwgY2hpbGQubm9kZSlcbiAgICAgIGlmIChwYXJlbnRJZChjaGlsZE5vZGUpICE9PSBhc3QuaWQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBgSW5jb25zaXN0ZW50IHBhcmVudCBwb2ludGVyIChleHBlY3RlZCAke2FzdC5pZH0pYCxcbiAgICAgICAgICBjaGlsZE5vZGUsXG4gICAgICAgICAgZ3JhcGhQYXJlbnRQb2ludGVycyhhc3QubW9kdWxlLnJvb3QoKSEpLFxuICAgICAgICApXG4gICAgICB9XG4gICAgICBhc3NlcnRFcXVhbChwYXJlbnRJZChjaGlsZE5vZGUpLCBhc3QuaWQpXG4gICAgfVxuICB9XG4gIGNvbnN0IHNwYW4gPSBub2RlS2V5KG9mZnNldCwgY29kZS5sZW5ndGgpXG4gIG1hcC5zZXRJZlVuZGVmaW5lZChpbmZvLm5vZGVzLCBzcGFuLCAoKTogQXN0W10gPT4gW10pLnVuc2hpZnQoYXN0KVxuICByZXR1cm4gY29kZVxufVxuXG4vKiogQGludGVybmFsIFVzZSBgQXN0LmNvZGUoKScgdG8gc3RyaW5naWZ5LiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByaW50QmxvY2soXG4gIGJsb2NrOiBCb2R5QmxvY2ssXG4gIGluZm86IFNwYW5NYXAsXG4gIG9mZnNldDogbnVtYmVyLFxuICBwYXJlbnRJbmRlbnQ6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgdmVyYmF0aW0/OiBib29sZWFuLFxuKTogc3RyaW5nIHtcbiAgbGV0IGJsb2NrSW5kZW50OiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgbGV0IGNvZGUgPSAnJ1xuICBmb3IgKGNvbnN0IGxpbmUgb2YgYmxvY2suZmllbGRzLmdldCgnbGluZXMnKSkge1xuICAgIGNvZGUgKz0gbGluZS5uZXdsaW5lLndoaXRlc3BhY2UgPz8gJydcbiAgICBjb25zdCBuZXdsaW5lQ29kZSA9IGJsb2NrLm1vZHVsZS5nZXRUb2tlbihsaW5lLm5ld2xpbmUubm9kZSkuY29kZSgpXG4gICAgLy8gT25seSBwcmludCBhIG5ld2xpbmUgaWYgdGhpcyBpc24ndCB0aGUgZmlyc3QgbGluZSBpbiB0aGUgb3V0cHV0LCBvciBpdCdzIGEgY29tbWVudC5cbiAgICBpZiAob2Zmc2V0IHx8IGNvZGUgfHwgbmV3bGluZUNvZGUuc3RhcnRzV2l0aCgnIycpKSB7XG4gICAgICAvLyBJZiB0aGlzIGlzbid0IHRoZSBmaXJzdCBsaW5lIGluIHRoZSBvdXRwdXQsIGJ1dCB0aGVyZSBpcyBhIGNvbmNyZXRlIG5ld2xpbmUgdG9rZW46XG4gICAgICAvLyBpZiBpdCdzIGEgemVyby1sZW5ndGggbmV3bGluZSwgaWdub3JlIGl0IGFuZCBwcmludCBhIG5vcm1hbCBuZXdsaW5lLlxuICAgICAgY29kZSArPSBuZXdsaW5lQ29kZSB8fCAnXFxuJ1xuICAgIH1cbiAgICBpZiAobGluZS5leHByZXNzaW9uKSB7XG4gICAgICBpZiAoYmxvY2tJbmRlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoKGxpbmUuZXhwcmVzc2lvbi53aGl0ZXNwYWNlPy5sZW5ndGggPz8gMCkgPiAocGFyZW50SW5kZW50Py5sZW5ndGggPz8gMCkpIHtcbiAgICAgICAgICBibG9ja0luZGVudCA9IGxpbmUuZXhwcmVzc2lvbi53aGl0ZXNwYWNlIVxuICAgICAgICB9IGVsc2UgaWYgKHBhcmVudEluZGVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYmxvY2tJbmRlbnQgPSBwYXJlbnRJbmRlbnQgKyAnICAgICdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBibG9ja0luZGVudCA9ICcnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbGlkSW5kZW50ID0gKGxpbmUuZXhwcmVzc2lvbi53aGl0ZXNwYWNlPy5sZW5ndGggPz8gMCkgPiAocGFyZW50SW5kZW50Py5sZW5ndGggPz8gMClcbiAgICAgIGNvZGUgKz0gdmFsaWRJbmRlbnQgPyBsaW5lLmV4cHJlc3Npb24ud2hpdGVzcGFjZSA6IGJsb2NrSW5kZW50XG4gICAgICBjb25zdCBsaW5lTm9kZSA9IGJsb2NrLm1vZHVsZS5nZXQobGluZS5leHByZXNzaW9uLm5vZGUpXG4gICAgICBhc3NlcnRFcXVhbChsaW5lTm9kZS5pZCwgbGluZS5leHByZXNzaW9uLm5vZGUpXG4gICAgICBhc3NlcnRFcXVhbChwYXJlbnRJZChsaW5lTm9kZSksIGJsb2NrLmlkKVxuICAgICAgY29kZSArPSBsaW5lTm9kZS5wcmludFN1YnRyZWUoaW5mbywgb2Zmc2V0ICsgY29kZS5sZW5ndGgsIGJsb2NrSW5kZW50LCB2ZXJiYXRpbSlcbiAgICB9XG4gIH1cbiAgY29uc3Qgc3BhbiA9IG5vZGVLZXkob2Zmc2V0LCBjb2RlLmxlbmd0aClcbiAgbWFwLnNldElmVW5kZWZpbmVkKGluZm8ubm9kZXMsIHNwYW4sICgpOiBBc3RbXSA9PiBbXSkudW5zaGlmdChibG9jaylcbiAgcmV0dXJuIGNvZGVcbn1cblxuLyoqIEBpbnRlcm5hbCBVc2UgYEFzdC5jb2RlKCknIHRvIHN0cmluZ2lmeS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmludERvY3VtZW50ZWQoXG4gIGRvY3VtZW50ZWQ6IERvY3VtZW50ZWQsXG4gIGluZm86IFNwYW5NYXAsXG4gIG9mZnNldDogbnVtYmVyLFxuICBwYXJlbnRJbmRlbnQ6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgdmVyYmF0aW0/OiBib29sZWFuLFxuKTogc3RyaW5nIHtcbiAgY29uc3Qgb3BlbiA9IGRvY3VtZW50ZWQuZmllbGRzLmdldCgnb3BlbicpXG4gIGNvbnN0IHRvcEluZGVudCA9IHBhcmVudEluZGVudCA/PyBvcGVuLndoaXRlc3BhY2UgPz8gJydcbiAgbGV0IGNvZGUgPSAnJ1xuICBjb2RlICs9IG9wZW4ubm9kZS5jb2RlX1xuICBjb25zdCBtaW5XaGl0ZXNwYWNlTGVuZ3RoID0gdG9wSW5kZW50Lmxlbmd0aCArIDFcbiAgbGV0IHByZWZlcnJlZFdoaXRlc3BhY2UgPSB0b3BJbmRlbnQgKyAnICAnXG4gIGRvY3VtZW50ZWQuZmllbGRzLmdldCgnZWxlbWVudHMnKS5mb3JFYWNoKCh7IHRva2VuIH0sIGkpID0+IHtcbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgY29uc3Qgd2hpdGVzcGFjZSA9IHRva2VuLndoaXRlc3BhY2UgPz8gJyAnXG4gICAgICBjb2RlICs9IHdoaXRlc3BhY2VcbiAgICAgIGNvZGUgKz0gdG9rZW4ubm9kZS5jb2RlX1xuICAgICAgcHJlZmVycmVkV2hpdGVzcGFjZSArPSB3aGl0ZXNwYWNlXG4gICAgfSBlbHNlIGlmICh0b2tlbi5ub2RlLnRva2VuVHlwZV8gPT09IFJhd0FzdC5Ub2tlbi5UeXBlLlRleHRTZWN0aW9uKSB7XG4gICAgICBpZiAodG9rZW4ud2hpdGVzcGFjZSAmJiAodmVyYmF0aW0gfHwgdG9rZW4ud2hpdGVzcGFjZS5sZW5ndGggPj0gbWluV2hpdGVzcGFjZUxlbmd0aCkpXG4gICAgICAgIGNvZGUgKz0gdG9rZW4ud2hpdGVzcGFjZVxuICAgICAgZWxzZSBjb2RlICs9IHByZWZlcnJlZFdoaXRlc3BhY2VcbiAgICAgIGNvZGUgKz0gdG9rZW4ubm9kZS5jb2RlX1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlICs9IHRva2VuLndoaXRlc3BhY2UgPz8gJydcbiAgICAgIGNvZGUgKz0gdG9rZW4ubm9kZS5jb2RlX1xuICAgIH1cbiAgfSlcbiAgY29kZSArPSBkb2N1bWVudGVkLmZpZWxkc1xuICAgIC5nZXQoJ25ld2xpbmVzJylcbiAgICAubWFwKCh7IHdoaXRlc3BhY2UsIG5vZGUgfSkgPT4gKHdoaXRlc3BhY2UgPz8gJycpICsgbm9kZS5jb2RlXylcbiAgICAuam9pbignJylcbiAgaWYgKGRvY3VtZW50ZWQuZXhwcmVzc2lvbikge1xuICAgIGNvZGUgKz0gZG9jdW1lbnRlZC5maWVsZHMuZ2V0KCdleHByZXNzaW9uJyk/LndoaXRlc3BhY2UgPz8gdG9wSW5kZW50XG4gICAgY29kZSArPSBkb2N1bWVudGVkLmV4cHJlc3Npb24ucHJpbnRTdWJ0cmVlKGluZm8sIG9mZnNldCArIGNvZGUubGVuZ3RoLCB0b3BJbmRlbnQsIHZlcmJhdGltKVxuICB9XG4gIGNvbnN0IHNwYW4gPSBub2RlS2V5KG9mZnNldCwgY29kZS5sZW5ndGgpXG4gIG1hcC5zZXRJZlVuZGVmaW5lZChpbmZvLm5vZGVzLCBzcGFuLCAoKTogQXN0W10gPT4gW10pLnVuc2hpZnQoZG9jdW1lbnRlZClcbiAgcmV0dXJuIGNvZGVcbn1cblxuLyoqIFBhcnNlIHRoZSBpbnB1dCBhcyBhIGJsb2NrLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQmxvY2soY29kZTogc3RyaW5nLCBpbk1vZHVsZT86IE11dGFibGVNb2R1bGUpOiBPd25lZDxNdXRhYmxlQm9keUJsb2NrPiB7XG4gIHJldHVybiBwYXJzZUJsb2NrV2l0aFNwYW5zKGNvZGUsIGluTW9kdWxlKS5yb290XG59XG5cbi8qKiBQYXJzZSB0aGUgaW5wdXQuIElmIGl0IGNvbnRhaW5zIGEgc2luZ2xlIGV4cHJlc3Npb24gYXQgdGhlIHRvcCBsZXZlbCwgcmV0dXJuIGl0OyBvdGhlcndpc2UsIHJldHVybiBhIGJsb2NrLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlKGNvZGU6IHN0cmluZywgbW9kdWxlPzogTXV0YWJsZU1vZHVsZSk6IE93bmVkIHtcbiAgY29uc3QgbW9kdWxlXyA9IG1vZHVsZSA/PyBNdXRhYmxlTW9kdWxlLlRyYW5zaWVudCgpXG4gIGNvbnN0IGFzdCA9IHBhcnNlQmxvY2soY29kZSwgbW9kdWxlXylcbiAgY29uc3Qgc29sZVN0YXRlbWVudCA9IHRyeUdldFNvbGVWYWx1ZShhc3Quc3RhdGVtZW50cygpKVxuICBpZiAoIXNvbGVTdGF0ZW1lbnQpIHJldHVybiBhc3RcbiAgY29uc3QgcGFyZW50ID0gcGFyZW50SWQoc29sZVN0YXRlbWVudClcbiAgaWYgKHBhcmVudCkgbW9kdWxlXy5kZWxldGUocGFyZW50KVxuICBzb2xlU3RhdGVtZW50LmZpZWxkcy5zZXQoJ3BhcmVudCcsIHVuZGVmaW5lZClcbiAgcmV0dXJuIGFzT3duZWQoc29sZVN0YXRlbWVudClcbn1cblxuLyoqIFBhcnNlIGEgYmxvY2ssIGFuZCByZXR1cm4gaXQgYWxvbmcgd2l0aCBhIG1hcHBpbmcgZnJvbSBzb3VyY2UgbG9jYXRpb25zIHRvIHBhcnNlZCBvYmplY3RzLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQmxvY2tXaXRoU3BhbnMoXG4gIGNvZGU6IHN0cmluZyxcbiAgaW5Nb2R1bGU/OiBNdXRhYmxlTW9kdWxlLFxuKTogeyByb290OiBPd25lZDxNdXRhYmxlQm9keUJsb2NrPjsgc3BhbnM6IFNwYW5NYXAgfSB7XG4gIGNvbnN0IHRyZWUgPSBwYXJzZUVuc28oY29kZSlcbiAgY29uc3QgbW9kdWxlID0gaW5Nb2R1bGUgPz8gTXV0YWJsZU1vZHVsZS5UcmFuc2llbnQoKVxuICByZXR1cm4gYWJzdHJhY3QobW9kdWxlLCB0cmVlLCBjb2RlKVxufVxuXG4vKiogUGFyc2UgdGhlIGlucHV0LCBhbmQgYXBwbHkgdGhlIGdpdmVuIGBJZE1hcGAuIFJldHVybiB0aGUgcGFyc2VkIHRyZWUsIHRoZSB1cGRhdGVkIGBJZE1hcGAsIHRoZSBzcGFuIG1hcCwgYW5kIGFcbiAqICBtYXBwaW5nIHRvIHRoZSBgUmF3QXN0YCByZXByZXNlbnRhdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRXh0ZW5kZWQoY29kZTogc3RyaW5nLCBpZE1hcD86IElkTWFwIHwgdW5kZWZpbmVkLCBpbk1vZHVsZT86IE11dGFibGVNb2R1bGUpIHtcbiAgY29uc3QgcmF3Um9vdCA9IHBhcnNlRW5zbyhjb2RlKVxuICBjb25zdCBtb2R1bGUgPSBpbk1vZHVsZSA/PyBNdXRhYmxlTW9kdWxlLlRyYW5zaWVudCgpXG4gIGNvbnN0IHsgcm9vdCwgc3BhbnMsIHRvUmF3IH0gPSBtb2R1bGUudHJhbnNhY3QoKCkgPT4ge1xuICAgIGNvbnN0IHsgcm9vdCwgc3BhbnMsIHRvUmF3IH0gPSBhYnN0cmFjdChtb2R1bGUsIHJhd1Jvb3QsIGNvZGUpXG4gICAgcm9vdC5tb2R1bGUucmVwbGFjZVJvb3Qocm9vdClcbiAgICBpZiAoaWRNYXApIHNldEV4dGVybmFsSWRzKHJvb3QubW9kdWxlLCBzcGFucywgaWRNYXApXG4gICAgcmV0dXJuIHsgcm9vdCwgc3BhbnMsIHRvUmF3IH1cbiAgfSlcbiAgY29uc3QgZ2V0U3BhbiA9IHNwYW5NYXBUb1NwYW5HZXR0ZXIoc3BhbnMpXG4gIGNvbnN0IGlkTWFwT3V0ID0gc3Bhbk1hcFRvSWRNYXAoc3BhbnMpXG4gIHJldHVybiB7IHJvb3QsIGlkTWFwOiBpZE1hcE91dCwgZ2V0U3BhbiwgdG9SYXcgfVxufVxuXG4vKiogUmV0dXJuIHRoZSBudW1iZXIgb2YgYEFzdGBzIGluIHRoZSB0cmVlLCBpbmNsdWRpbmcgdGhlIHByb3ZpZGVkIHJvb3QuICovXG5leHBvcnQgZnVuY3Rpb24gYXN0Q291bnQoYXN0OiBBc3QpOiBudW1iZXIge1xuICBsZXQgY291bnQgPSAwXG4gIGFzdC52aXNpdFJlY3Vyc2l2ZUFzdCgoX3N1YnRyZWUpID0+IHtcbiAgICBjb3VudCArPSAxXG4gIH0pXG4gIHJldHVybiBjb3VudFxufVxuXG4vKiogQXBwbHkgYW4gYElkTWFwYCB0byBhIG1vZHVsZSwgdXNpbmcgdGhlIGdpdmVuIGBTcGFuTWFwYC5cbiAqICBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIElEcyB0aGF0IHdlcmUgYXNzaWduZWQgZnJvbSB0aGUgbWFwLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0RXh0ZXJuYWxJZHMoZWRpdDogTXV0YWJsZU1vZHVsZSwgc3BhbnM6IFNwYW5NYXAsIGlkczogSWRNYXApOiBudW1iZXIge1xuICBsZXQgYXN0c01hdGNoZWQgPSAwXG4gIGZvciAoY29uc3QgW2tleSwgZXh0ZXJuYWxJZF0gb2YgaWRzLmVudHJpZXMoKSkge1xuICAgIGNvbnN0IGFzdHMgPSBzcGFucy5ub2Rlcy5nZXQoa2V5IGFzIE5vZGVLZXkpXG4gICAgaWYgKGFzdHMpIHtcbiAgICAgIGZvciAoY29uc3QgYXN0IG9mIGFzdHMpIHtcbiAgICAgICAgYXN0c01hdGNoZWQgKz0gMVxuICAgICAgICBjb25zdCBlZGl0QXN0ID0gZWRpdC5nZXRWZXJzaW9uKGFzdClcbiAgICAgICAgaWYgKGVkaXRBc3QuZXh0ZXJuYWxJZCAhPT0gZXh0ZXJuYWxJZCkgZWRpdEFzdC5zZXRFeHRlcm5hbElkKGV4dGVybmFsSWQpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhc3RzTWF0Y2hlZFxufVxuXG4vKiogVHJ5IHRvIGZpbmQgYWxsIHRoZSBzcGFucyBpbiBgZXhwZWN0ZWRgIGluIGBlbmNvdW50ZXJlZGAuIElmIGFueSBhcmUgbWlzc2luZywgdXNlIHRoZSBwcm92aWRlZCBgY29kZWAgdG8gZGV0ZXJtaW5lXG4gKiAgd2hldGhlciB0aGUgbG9zdCBzcGFucyBhcmUgc2luZ2xlLWxpbmUgb3IgbXVsdGktbGluZS5cbiAqL1xuZnVuY3Rpb24gY2hlY2tTcGFucyhleHBlY3RlZDogTm9kZVNwYW5NYXAsIGVuY291bnRlcmVkOiBOb2RlU3Bhbk1hcCwgY29kZTogc3RyaW5nKSB7XG4gIGNvbnN0IGxvc3QgPSBuZXcgQXJyYXk8cmVhZG9ubHkgW05vZGVLZXksIEFzdF0+KClcbiAgZm9yIChjb25zdCBba2V5LCBhc3RzXSBvZiBleHBlY3RlZCkge1xuICAgIGNvbnN0IG91dGVybW9zdFByaW50ZWQgPSBhc3RzWzBdXG4gICAgaWYgKCFvdXRlcm1vc3RQcmludGVkKSBjb250aW51ZVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXN0cy5sZW5ndGg7ICsraSkgYXNzZXJ0RXF1YWwoYXN0c1tpXT8ucGFyZW50SWQsIGFzdHNbaSAtIDFdPy5pZClcbiAgICBjb25zdCBlbmNvdW50ZXJlZEFzdHMgPSBlbmNvdW50ZXJlZC5nZXQoa2V5KVxuICAgIGlmIChlbmNvdW50ZXJlZEFzdHMgPT09IHVuZGVmaW5lZCkgbG9zdC5wdXNoKFtrZXksIG91dGVybW9zdFByaW50ZWRdKVxuICB9XG4gIGNvbnN0IGxvc3RJbmxpbmUgPSBuZXcgQXJyYXk8QXN0PigpXG4gIGNvbnN0IGxvc3RCbG9jayA9IG5ldyBBcnJheTxBc3Q+KClcbiAgZm9yIChjb25zdCBba2V5LCBhc3RdIG9mIGxvc3QpIHtcbiAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSBzb3VyY2VSYW5nZUZyb21LZXkoa2V5KVxuICAgIDsoY29kZS5zdWJzdHJpbmcoc3RhcnQsIGVuZCkubWF0Y2goL1tcXHJcXG5dLykgPyBsb3N0QmxvY2sgOiBsb3N0SW5saW5lKS5wdXNoKGFzdClcbiAgfVxuICByZXR1cm4geyBsb3N0SW5saW5lLCBsb3N0QmxvY2sgfVxufVxuXG4vKiogSWYgdGhlIGlucHV0IHRyZWUncyBjb25jcmV0ZSBzeW50YXggaGFzIHByZWNlZGVuY2UgZXJyb3JzIChpLmUuIGl0cyBleHBlY3RlZCBjb2RlIHdvdWxkIG5vdCBwYXJzZSBiYWNrIHRvIHRoZSBzYW1lXG4gKiAgc3RydWN0dXJlKSwgdHJ5IHRvIGZpeCBpdC4gSWYgcG9zc2libGUsIGl0IHdpbGwgYmUgcmVwYWlyZWQgYnkgaW5zZXJ0aW5nIHBhcmVudGhlc2VzOyBpZiB0aGF0IGRvZXNuJ3QgZml4IGl0LCB0aGVcbiAqICBhZmZlY3RlZCBzdWJ0cmVlIHdpbGwgYmUgcmUtc3luY2VkIHRvIGZhaXRoZnVsbHkgcmVwcmVzZW50IHRoZSBzb3VyY2UgY29kZSB0aGUgaW5jb3JyZWN0IHRyZWUgcHJpbnRzIHRvLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwYWlyKFxuICByb290OiBCb2R5QmxvY2ssXG4gIG1vZHVsZT86IE11dGFibGVNb2R1bGUsXG4pOiB7IGNvZGU6IHN0cmluZzsgZml4ZXM6IE11dGFibGVNb2R1bGUgfCB1bmRlZmluZWQgfSB7XG4gIC8vIFByaW50IHRoZSBpbnB1dCB0byBzZWUgd2hhdCBzcGFucyBpdHMgbm9kZXMgZXhwZWN0IHRvIGhhdmUgaW4gdGhlIG91dHB1dC5cbiAgY29uc3QgcHJpbnRlZCA9IHByaW50KHJvb3QpXG4gIC8vIFBhcnNlIHRoZSBwcmludGVkIG91dHB1dCB0byBzZWUgd2hhdCBzcGFucyBhY3R1YWxseSBjb3JyZXNwb25kIHRvIG5vZGVzIGluIHRoZSBwcmludGVkIGNvZGUuXG4gIGNvbnN0IHJlcGFyc2VkID0gcGFyc2VCbG9ja1dpdGhTcGFucyhwcmludGVkLmNvZGUpXG4gIC8vIFNlZSBpZiBhbnkgc3BhbiB3ZSBleHBlY3RlZCB0byBiZSBhIG5vZGUgaXNuJ3Q7IGlmIHNvLCBpdCBsaWtlbHkgbWVyZ2VkIHdpdGggaXRzIHBhcmVudCBkdWUgdG8gd3JvbmcgcHJlY2VkZW5jZS5cbiAgY29uc3QgeyBsb3N0SW5saW5lLCBsb3N0QmxvY2sgfSA9IGNoZWNrU3BhbnMoXG4gICAgcHJpbnRlZC5pbmZvLm5vZGVzLFxuICAgIHJlcGFyc2VkLnNwYW5zLm5vZGVzLFxuICAgIHByaW50ZWQuY29kZSxcbiAgKVxuICBpZiAobG9zdElubGluZS5sZW5ndGggPT09IDApIHtcbiAgICBpZiAobG9zdEJsb2NrLmxlbmd0aCAhPT0gMCkge1xuICAgICAgY29uc29sZS53YXJuKGByZXBhaXI6IEJhZCBibG9jayBlbGVtZW50cywgYnV0IGFsbCBpbmxpbmUgZWxlbWVudHMgT0s/YClcbiAgICAgIGNvbnN0IGZpeGVzID0gbW9kdWxlID8/IHJvb3QubW9kdWxlLmVkaXQoKVxuICAgICAgcmVzeW5jKGxvc3RCbG9jaywgcHJpbnRlZC5pbmZvLm5vZGVzLCByZXBhcnNlZC5zcGFucy5ub2RlcywgZml4ZXMpXG4gICAgICByZXR1cm4geyBjb2RlOiBwcmludGVkLmNvZGUsIGZpeGVzIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgY29kZTogcHJpbnRlZC5jb2RlLCBmaXhlczogdW5kZWZpbmVkIH1cbiAgfVxuXG4gIC8vIFdyYXAgYW55IFwibG9zdFwiIG5vZGVzIGluIHBhcmVudGhlc2VzLlxuICBjb25zdCBmaXhlcyA9IG1vZHVsZSA/PyByb290Lm1vZHVsZS5lZGl0KClcbiAgZm9yIChjb25zdCBhc3Qgb2YgbG9zdElubGluZSkge1xuICAgIGlmIChhc3QgaW5zdGFuY2VvZiBHcm91cCkgY29udGludWVcbiAgICBmaXhlcy5nZXRWZXJzaW9uKGFzdCkudXBkYXRlKChhc3QpID0+IEdyb3VwLm5ldyhmaXhlcywgYXN0KSlcbiAgfVxuXG4gIC8vIFZlcmlmeSB0aGF0IGl0J3MgZml4ZWQuXG4gIGNvbnN0IHByaW50ZWQyID0gcHJpbnQoZml4ZXMuZ2V0VmVyc2lvbihyb290KSlcbiAgY29uc3QgcmVwYXJzZWQyID0gcGFyc2VCbG9ja1dpdGhTcGFucyhwcmludGVkMi5jb2RlKVxuICBjb25zdCB7IGxvc3RJbmxpbmU6IGxvc3RJbmxpbmUyLCBsb3N0QmxvY2s6IGxvc3RCbG9jazIgfSA9IGNoZWNrU3BhbnMoXG4gICAgcHJpbnRlZDIuaW5mby5ub2RlcyxcbiAgICByZXBhcnNlZDIuc3BhbnMubm9kZXMsXG4gICAgcHJpbnRlZDIuY29kZSxcbiAgKVxuICBpZiAobG9zdElubGluZTIubGVuZ3RoICE9PSAwIHx8IGxvc3RCbG9jazIubGVuZ3RoICE9PSAwKVxuICAgIHJlc3luYyhbLi4ubG9zdElubGluZTIsIC4uLmxvc3RCbG9jazJdLCBwcmludGVkMi5pbmZvLm5vZGVzLCByZXBhcnNlZDIuc3BhbnMubm9kZXMsIGZpeGVzKVxuXG4gIHJldHVybiB7IGNvZGU6IHByaW50ZWQyLmNvZGUsIGZpeGVzIH1cbn1cblxuLyoqXG4gKiBSZXBsYWNlIHN1YnRyZWVzIGluIHRoZSBtb2R1bGUgdG8gZW5zdXJlIHRoYXQgdGhlIG1vZHVsZSBjb250ZW50cyBhcmUgY29uc2lzdGVudCB3aXRoIHRoZSBtb2R1bGUncyBjb2RlLlxuICpcbiAqIEBwYXJhbSBiYWRBc3RzIC0gQVNUcyB0aGF0LCBpZiBwcmludGVkLCB3b3VsZCBub3QgcGFyc2UgdG8gZXhhY3RseSB0aGVpciBjdXJyZW50IGNvbnRlbnQuXG4gKiBAcGFyYW0gYmFkU3BhbnMgLSBTcGFuIG1hcCBwcm9kdWNlZCBieSBwcmludGluZyB0aGUgYGJhZEFzdHNgIG5vZGVzIGFuZCBhbGwgdGhlaXIgcGFyZW50cy5cbiAqIEBwYXJhbSBnb29kU3BhbnMgLSBTcGFuIG1hcCBwcm9kdWNlZCBieSBwYXJzaW5nIHRoZSBjb2RlIGZyb20gdGhlIG1vZHVsZSBvZiBgYmFkQXN0c2AuXG4gKiBAcGFyYW0gZWRpdCAtIE1vZHVsZSB0byBhcHBseSB0aGUgZml4ZXMgdG87IG11c3QgY29udGFpbiBhbGwgQVNUcyBpbiBgYmFkQXN0c2AuXG4gKi9cbmZ1bmN0aW9uIHJlc3luYyhcbiAgYmFkQXN0czogSXRlcmFibGU8QXN0PixcbiAgYmFkU3BhbnM6IE5vZGVTcGFuTWFwLFxuICBnb29kU3BhbnM6IE5vZGVTcGFuTWFwLFxuICBlZGl0OiBNdXRhYmxlTW9kdWxlLFxuKSB7XG4gIGNvbnN0IHBhcmVudHNPZkJhZFN1YnRyZWVzID0gbmV3IFNldDxBc3RJZD4oKVxuICBjb25zdCBiYWRBc3RJZHMgPSBuZXcgU2V0KEFycmF5LmZyb20oYmFkQXN0cywgKGFzdCkgPT4gYXN0LmlkKSlcbiAgZm9yIChjb25zdCBpZCBvZiBzdWJ0cmVlUm9vdHMoZWRpdCwgYmFkQXN0SWRzKSkge1xuICAgIGNvbnN0IHBhcmVudCA9IGVkaXQuZ2V0KGlkKT8ucGFyZW50SWRcbiAgICBpZiAocGFyZW50KSBwYXJlbnRzT2ZCYWRTdWJ0cmVlcy5hZGQocGFyZW50KVxuICB9XG5cbiAgY29uc3Qgc3Bhbk9mQmFkUGFyZW50ID0gbmV3IEFycmF5PHJlYWRvbmx5IFtBc3RJZCwgTm9kZUtleV0+KClcbiAgZm9yIChjb25zdCBbc3BhbiwgYXN0c10gb2YgYmFkU3BhbnMpIHtcbiAgICBmb3IgKGNvbnN0IGFzdCBvZiBhc3RzKSB7XG4gICAgICBpZiAocGFyZW50c09mQmFkU3VidHJlZXMuaGFzKGFzdC5pZCkpIHNwYW5PZkJhZFBhcmVudC5wdXNoKFthc3QuaWQsIHNwYW5dKVxuICAgIH1cbiAgfVxuICAvLyBBbGwgQVNUcyBpbiB0aGUgbW9kdWxlIG9mIGJhZEFzdHMgc2hvdWxkIGhhdmUgZW50cmllcyBpbiBiYWRTcGFucy5cbiAgYXNzZXJ0RXF1YWwoc3Bhbk9mQmFkUGFyZW50Lmxlbmd0aCwgcGFyZW50c09mQmFkU3VidHJlZXMuc2l6ZSlcblxuICBmb3IgKGNvbnN0IFtpZCwgc3Bhbl0gb2Ygc3Bhbk9mQmFkUGFyZW50KSB7XG4gICAgY29uc3QgcGFyZW50ID0gZWRpdC5nZXQoaWQpXG4gICAgY29uc3QgZ29vZEFzdCA9IGdvb2RTcGFucy5nZXQoc3Bhbik/LlswXVxuICAgIC8vIFRoZSBwYXJlbnQgb2YgdGhlIHJvb3Qgb2YgYSBiYWQgc3VidHJlZSBtdXN0IGJlIGEgZ29vZCBBU1QuXG4gICAgYXNzZXJ0RGVmaW5lZChnb29kQXN0KVxuICAgIHBhcmVudC5zeW5jVG9Db2RlKGdvb2RBc3QuY29kZSgpKVxuICB9XG5cbiAgY29uc29sZS53YXJuKFxuICAgIGByZXBhaXI6IFJlcGxhY2VkICR7cGFyZW50c09mQmFkU3VidHJlZXMuc2l6ZX0gc3VidHJlZXMgd2l0aCB0aGVpciByZXBhcnNlZCBlcXVpdmFsZW50cy5gLFxuICAgIHBhcmVudHNPZkJhZFN1YnRyZWVzLFxuICApXG59XG5cbi8qKiBAaW50ZXJuYWwgUmVjdXJzaW9uIGhlbHBlciBmb3Ige0BsaW5rIHN5bnRheEhhc2h9LiAqL1xuZnVuY3Rpb24gaGFzaFN1YnRyZWVTeW50YXgoYXN0OiBBc3QsIGhhc2hlc091dDogTWFwPFN5bnRheEhhc2gsIEFzdFtdPik6IFN5bnRheEhhc2gge1xuICBsZXQgY29udGVudCA9ICcnXG4gIGNvbnRlbnQgKz0gYXN0LnR5cGVOYW1lICsgJzonXG4gIGZvciAoY29uc3QgY2hpbGQgb2YgYXN0LmNvbmNyZXRlQ2hpbGRyZW4oKSkge1xuICAgIGNvbnRlbnQgKz0gY2hpbGQud2hpdGVzcGFjZSA/PyAnPydcbiAgICBpZiAoaXNUb2tlbklkKGNoaWxkLm5vZGUpKSB7XG4gICAgICBjb250ZW50ICs9ICdUb2tlbjonICsgaGFzaFN0cmluZyhhc3QubW9kdWxlLmdldFRva2VuKGNoaWxkLm5vZGUpLmNvZGUoKSlcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudCArPSBoYXNoU3VidHJlZVN5bnRheChhc3QubW9kdWxlLmdldChjaGlsZC5ub2RlKSwgaGFzaGVzT3V0KVxuICAgIH1cbiAgfVxuICBjb25zdCBhc3RIYXNoID0gaGFzaFN0cmluZyhjb250ZW50KVxuICBtYXAuc2V0SWZVbmRlZmluZWQoaGFzaGVzT3V0LCBhc3RIYXNoLCAoKTogQXN0W10gPT4gW10pLnVuc2hpZnQoYXN0KVxuICByZXR1cm4gYXN0SGFzaFxufVxuXG5kZWNsYXJlIGNvbnN0IGJyYW5kSGFzaDogdW5pcXVlIHN5bWJvbFxuLyoqIFNlZSB7QGxpbmsgc3ludGF4SGFzaH0uICovXG50eXBlIFN5bnRheEhhc2ggPSBzdHJpbmcgJiB7IFticmFuZEhhc2hdOiBuZXZlciB9XG4vKiogQXBwbGllcyB0aGUgc3ludGF4LWRhdGEgaGFzaGluZyBmdW5jdGlvbiB0byB0aGUgaW5wdXQsIGFuZCBicmFuZHMgdGhlIHJlc3VsdCBhcyBhIGBTeW50YXhIYXNoYC4gKi9cbmZ1bmN0aW9uIGhhc2hTdHJpbmcoaW5wdXQ6IHN0cmluZyk6IFN5bnRheEhhc2gge1xuICByZXR1cm4geHhIYXNoMTI4KGlucHV0KSBhcyBTeW50YXhIYXNoXG59XG5cbi8qKiBDYWxjdWxhdGVzIGBTeW50YXhIYXNoYGVzIGZvciB0aGUgZ2l2ZW4gbm9kZSBhbmQgYWxsIGl0cyBjaGlsZHJlbi5cbiAqXG4gKiAgRWFjaCBgU3ludGF4SGFzaGAgc3VtbWFyaXplcyB0aGUgc3ludGFjdGljIGNvbnRlbnQgb2YgYW4gQVNULiBJZiB0d28gQVNUcyBoYXZlIHRoZSBzYW1lIGNvZGUgYW5kIHdlcmUgcGFyc2VkIHRoZVxuICogIHNhbWUgd2F5IChpLmUuIG9uZSB3YXMgbm90IHBhcnNlZCBpbiBhIGNvbnRleHQgdGhhdCByZXN1bHRlZCBpbiBhIGRpZmZlcmVudCBpbnRlcnByZXRhdGlvbiksIHRoZXkgd2lsbCBoYXZlIHRoZSBzYW1lXG4gKiAgaGFzaC4gTm90ZSB0aGF0IHRoZSBoYXNoIGlzIGludmFyaWFudCB0byBtZXRhZGF0YSwgaW5jbHVkaW5nIGBleHRlcm5hbElkYCBhc3NpZ25tZW50cy5cbiAqL1xuZnVuY3Rpb24gc3ludGF4SGFzaChyb290OiBBc3QpIHtcbiAgY29uc3QgaGFzaGVzID0gbmV3IE1hcDxTeW50YXhIYXNoLCBBc3RbXT4oKVxuICBjb25zdCByb290SGFzaCA9IGhhc2hTdWJ0cmVlU3ludGF4KHJvb3QsIGhhc2hlcylcbiAgcmV0dXJuIHsgcm9vdDogcm9vdEhhc2gsIGhhc2hlcyB9XG59XG5cbi8qKiBJZiB0aGUgaW5wdXQgaXMgYSBibG9jayBjb250YWluaW5nIGEgc2luZ2xlIGV4cHJlc3Npb24sIHJldHVybiB0aGUgZXhwcmVzc2lvbjsgb3RoZXJ3aXNlIHJldHVybiB0aGUgaW5wdXQuICovXG5mdW5jdGlvbiByYXdCbG9ja1RvSW5saW5lKHRyZWU6IFJhd0FzdC5UcmVlLlRyZWUpIHtcbiAgaWYgKHRyZWUudHlwZSAhPT0gUmF3QXN0LlRyZWUuVHlwZS5Cb2R5QmxvY2spIHJldHVybiB0cmVlXG4gIHJldHVybiB0cnlHZXRTb2xlVmFsdWUodHJlZS5zdGF0ZW1lbnRzKT8uZXhwcmVzc2lvbiA/PyB0cmVlXG59XG5cbi8qKiBVcGRhdGUgYGFzdGAgdG8gbWF0Y2ggdGhlIGdpdmVuIHNvdXJjZSBjb2RlLCB3aGlsZSBtb2RpZnlpbmcgaXQgYXMgbGl0dGxlIGFzIHBvc3NpYmxlLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN5bmNUb0NvZGUoYXN0OiBNdXRhYmxlQXN0LCBjb2RlOiBzdHJpbmcsIG1ldGFkYXRhU291cmNlPzogTW9kdWxlKSB7XG4gIGNvbnN0IGNvZGVCZWZvcmUgPSBhc3QuY29kZSgpXG4gIGNvbnN0IHRleHRFZGl0cyA9IHRleHRDaGFuZ2VUb0VkaXRzKGNvZGVCZWZvcmUsIGNvZGUpXG4gIGFwcGx5VGV4dEVkaXRzVG9Bc3QoYXN0LCB0ZXh0RWRpdHMsIG1ldGFkYXRhU291cmNlID8/IGFzdC5tb2R1bGUpXG59XG5cbi8qKiBGaW5kIG5vZGVzIGluIHRoZSBpbnB1dCBgYXN0YCB0aGF0IHNob3VsZCBiZSB0cmVhdGVkIGFzIGVxdWl2YWxlbnRzIG9mIG5vZGVzIGluIGBwYXJzZWRSb290YC4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNvcnJlc3BvbmRlbmNlKFxuICBhc3Q6IEFzdCxcbiAgYXN0U3BhbnM6IE5vZGVTcGFuTWFwLFxuICBwYXJzZWRSb290OiBBc3QsXG4gIHBhcnNlZFNwYW5zOiBOb2RlU3Bhbk1hcCxcbiAgdGV4dEVkaXRzOiBTb3VyY2VSYW5nZUVkaXRbXSxcbiAgY29kZUFmdGVyOiBzdHJpbmcsXG4pOiBNYXA8QXN0SWQsIEFzdD4ge1xuICBjb25zdCBuZXdTcGFucyA9IG5ldyBNYXA8QXN0SWQsIFNvdXJjZVJhbmdlPigpXG4gIGZvciAoY29uc3QgW2tleSwgYXN0c10gb2YgcGFyc2VkU3BhbnMpIHtcbiAgICBmb3IgKGNvbnN0IGFzdCBvZiBhc3RzKSBuZXdTcGFucy5zZXQoYXN0LmlkLCBzb3VyY2VSYW5nZUZyb21LZXkoa2V5KSlcbiAgfVxuXG4gIC8vIFJldGFpbmVkLWNvZGUgbWF0Y2hpbmc6IEZvciBlYWNoIG5ldyB0cmVlLCBjaGVjayBmb3Igc29tZSBvbGQgdHJlZSBvZiB0aGUgc2FtZSB0eXBlIHN1Y2ggdGhhdCB0aGUgbmV3IHRyZWUgaXMgdGhlXG4gIC8vIHNtYWxsZXN0IG5vZGUgdG8gY29udGFpbiBhbGwgY2hhcmFjdGVycyBvZiB0aGUgb2xkIHRyZWUncyBjb2RlIHRoYXQgd2VyZSBub3QgZGVsZXRlZCBpbiB0aGUgZWRpdC5cbiAgLy9cbiAgLy8gSWYgdGhlIG5ldyBub2RlJ3Mgc3BhbiBleGFjdGx5IG1hdGNoZXMgdGhlIHJldGFpbmVkIGNvZGUsIGFkZCB0aGUgbWF0Y2ggdG8gYHRvU3luY2AuIElmIHRoZSBuZXcgbm9kZSdzIHNwYW5cbiAgLy8gY29udGFpbnMgYWRkaXRpb25hbCBjb2RlLCBhZGQgdGhlIG1hdGNoIHRvIGBjYW5kaWRhdGVzYC5cbiAgY29uc3QgdG9TeW5jID0gbmV3IE1hcDxBc3RJZCwgQXN0PigpXG4gIGNvbnN0IGNhbmRpZGF0ZXMgPSBuZXcgTWFwPEFzdElkLCBBc3Q+KClcbiAgY29uc3QgYWxsU3BhbnNCZWZvcmUgPSBBcnJheS5mcm9tKGFzdFNwYW5zLmtleXMoKSwgc291cmNlUmFuZ2VGcm9tS2V5KVxuICBjb25zdCBzcGFuc0JlZm9yZUFuZEFmdGVyID0gYXBwbHlUZXh0RWRpdHNUb1NwYW5zKHRleHRFZGl0cywgYWxsU3BhbnNCZWZvcmUpLm1hcChcbiAgICAoW2JlZm9yZSwgYWZ0ZXJdKSA9PiBbYmVmb3JlLCB0cmltRW5kKGFmdGVyLCBjb2RlQWZ0ZXIpXSBzYXRpc2ZpZXMgW2FueSwgYW55XSxcbiAgKVxuICBjb25zdCBwYXJ0QWZ0ZXJUb0FzdEJlZm9yZSA9IG5ldyBNYXA8U291cmNlUmFuZ2VLZXksIEFzdD4oKVxuICBmb3IgKGNvbnN0IFtzcGFuQmVmb3JlLCBwYXJ0QWZ0ZXJdIG9mIHNwYW5zQmVmb3JlQW5kQWZ0ZXIpIHtcbiAgICBjb25zdCBhc3RCZWZvcmUgPSBhc3RTcGFucy5nZXQoc291cmNlUmFuZ2VLZXkoc3BhbkJlZm9yZSkgYXMgTm9kZUtleSk/LlswXSFcbiAgICBwYXJ0QWZ0ZXJUb0FzdEJlZm9yZS5zZXQoc291cmNlUmFuZ2VLZXkocGFydEFmdGVyKSwgYXN0QmVmb3JlKVxuICB9XG4gIGNvbnN0IG1hdGNoaW5nUGFydHNBZnRlciA9IHNwYW5zQmVmb3JlQW5kQWZ0ZXIubWFwKChbX2JlZm9yZSwgYWZ0ZXJdKSA9PiBhZnRlcilcbiAgY29uc3QgcGFyc2VkU3BhblRyZWUgPSBuZXcgQXN0V2l0aFNwYW5zKHBhcnNlZFJvb3QsIChpZCkgPT4gbmV3U3BhbnMuZ2V0KGlkKSEpXG4gIGNvbnN0IGFzdHNNYXRjaGluZ1BhcnRzQWZ0ZXIgPSBlbmNsb3NpbmdTcGFucyhwYXJzZWRTcGFuVHJlZSwgbWF0Y2hpbmdQYXJ0c0FmdGVyKVxuICBmb3IgKGNvbnN0IFthc3RBZnRlciwgcGFydHNBZnRlcl0gb2YgYXN0c01hdGNoaW5nUGFydHNBZnRlcikge1xuICAgIGZvciAoY29uc3QgcGFydEFmdGVyIG9mIHBhcnRzQWZ0ZXIpIHtcbiAgICAgIGNvbnN0IGFzdEJlZm9yZSA9IHBhcnRBZnRlclRvQXN0QmVmb3JlLmdldChzb3VyY2VSYW5nZUtleShwYXJ0QWZ0ZXIpKSFcbiAgICAgIGlmIChhc3RCZWZvcmUudHlwZU5hbWUoKSA9PT0gYXN0QWZ0ZXIudHlwZU5hbWUoKSkge1xuICAgICAgICA7KHJhbmdlTGVuZ3RoKG5ld1NwYW5zLmdldChhc3RBZnRlci5pZCkhKSA9PT0gcmFuZ2VMZW5ndGgocGFydEFmdGVyKSA/XG4gICAgICAgICAgdG9TeW5jXG4gICAgICAgIDogY2FuZGlkYXRlc1xuICAgICAgICApLnNldChhc3RCZWZvcmUuaWQsIGFzdEFmdGVyKVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEluZGV4IHRoZSBtYXRjaGVkIG5vZGVzLlxuICBjb25zdCBvbGRJZHNNYXRjaGVkID0gbmV3IFNldDxBc3RJZD4oKVxuICBjb25zdCBuZXdJZHNNYXRjaGVkID0gbmV3IFNldDxBc3RJZD4oKVxuICBmb3IgKGNvbnN0IFtvbGRJZCwgbmV3QXN0XSBvZiB0b1N5bmMpIHtcbiAgICBvbGRJZHNNYXRjaGVkLmFkZChvbGRJZClcbiAgICBuZXdJZHNNYXRjaGVkLmFkZChuZXdBc3QuaWQpXG4gIH1cblxuICAvLyBNb3ZlbWVudCBtYXRjaGluZzogRm9yIGVhY2ggbmV3IHRyZWUgdGhhdCBoYXNuJ3QgYmVlbiBtYXRjaGVkLCBtYXRjaCBpdCB3aXRoIGFueSBpZGVudGljYWwgdW5tYXRjaGVkIG9sZCB0cmVlLlxuICBjb25zdCBuZXdIYXNoZXMgPSBzeW50YXhIYXNoKHBhcnNlZFJvb3QpLmhhc2hlc1xuICBjb25zdCBvbGRIYXNoZXMgPSBzeW50YXhIYXNoKGFzdCkuaGFzaGVzXG4gIGZvciAoY29uc3QgW2hhc2gsIG5ld0FzdHNdIG9mIG5ld0hhc2hlcykge1xuICAgIGNvbnN0IHVubWF0Y2hlZE5ld0FzdHMgPSBuZXdBc3RzLmZpbHRlcigoYXN0KSA9PiAhbmV3SWRzTWF0Y2hlZC5oYXMoYXN0LmlkKSlcbiAgICBjb25zdCB1bm1hdGNoZWRPbGRBc3RzID0gb2xkSGFzaGVzLmdldChoYXNoKT8uZmlsdGVyKChhc3QpID0+ICFvbGRJZHNNYXRjaGVkLmhhcyhhc3QuaWQpKSA/PyBbXVxuICAgIGZvciAoY29uc3QgW3VubWF0Y2hlZE5ldywgdW5tYXRjaGVkT2xkXSBvZiB6aXAodW5tYXRjaGVkTmV3QXN0cywgdW5tYXRjaGVkT2xkQXN0cykpIHtcbiAgICAgIHRvU3luYy5zZXQodW5tYXRjaGVkT2xkLmlkLCB1bm1hdGNoZWROZXcpXG4gICAgICAvLyBVcGRhdGUgdGhlIG1hdGNoZWQtSURzIGluZGljZXMuXG4gICAgICBvbGRJZHNNYXRjaGVkLmFkZCh1bm1hdGNoZWRPbGQuaWQpXG4gICAgICBuZXdJZHNNYXRjaGVkLmFkZCh1bm1hdGNoZWROZXcuaWQpXG4gICAgfVxuICB9XG5cbiAgLy8gQXBwbHkgYW55IG5vbi1vcHRpbWFsIHNwYW4gbWF0Y2hlcyBmcm9tIGBjYW5kaWRhdGVzYCwgaWYgdGhlIG5vZGVzIGludm9sdmVkIHdlcmUgbm90IG1hdGNoZWQgZHVyaW5nXG4gIC8vIG1vdmVtZW50LW1hdGNoaW5nLlxuICBmb3IgKGNvbnN0IFtiZWZvcmVJZCwgYWZ0ZXJdIG9mIGNhbmRpZGF0ZXMpIHtcbiAgICBpZiAob2xkSWRzTWF0Y2hlZC5oYXMoYmVmb3JlSWQpIHx8IG5ld0lkc01hdGNoZWQuaGFzKGFmdGVyLmlkKSkgY29udGludWVcbiAgICB0b1N5bmMuc2V0KGJlZm9yZUlkLCBhZnRlcilcbiAgfVxuXG4gIHJldHVybiB0b1N5bmNcbn1cblxuLyoqIFVwZGF0ZSBgYXN0YCBhY2NvcmRpbmcgdG8gY2hhbmdlcyB0byBpdHMgY29ycmVzcG9uZGluZyBzb3VyY2UgY29kZS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVRleHRFZGl0c1RvQXN0KFxuICBhc3Q6IE11dGFibGVBc3QsXG4gIHRleHRFZGl0czogU291cmNlUmFuZ2VFZGl0W10sXG4gIG1ldGFkYXRhU291cmNlOiBNb2R1bGUsXG4pIHtcbiAgY29uc3QgcHJpbnRlZCA9IHByaW50KGFzdClcbiAgY29uc3QgY29kZSA9IGFwcGx5VGV4dEVkaXRzKHByaW50ZWQuY29kZSwgdGV4dEVkaXRzKVxuICBjb25zdCByYXdQYXJzZWRCbG9jayA9IHBhcnNlRW5zbyhjb2RlKVxuICBjb25zdCByYXdQYXJzZWQgPVxuICAgIGFzdCBpbnN0YW5jZW9mIE11dGFibGVCb2R5QmxvY2sgPyByYXdQYXJzZWRCbG9jayA6IHJhd0Jsb2NrVG9JbmxpbmUocmF3UGFyc2VkQmxvY2spXG4gIGNvbnN0IHBhcnNlZCA9IGFic3RyYWN0KGFzdC5tb2R1bGUsIHJhd1BhcnNlZCwgY29kZSlcbiAgY29uc3QgdG9TeW5jID0gY2FsY3VsYXRlQ29ycmVzcG9uZGVuY2UoXG4gICAgYXN0LFxuICAgIHByaW50ZWQuaW5mby5ub2RlcyxcbiAgICBwYXJzZWQucm9vdCxcbiAgICBwYXJzZWQuc3BhbnMubm9kZXMsXG4gICAgdGV4dEVkaXRzLFxuICAgIGNvZGUsXG4gIClcbiAgc3luY1RyZWUoYXN0LCBwYXJzZWQucm9vdCwgdG9TeW5jLCBhc3QubW9kdWxlLCBtZXRhZGF0YVNvdXJjZSlcbn1cblxuLyoqIFJlcGxhY2UgYHRhcmdldGAgd2l0aCBgbmV3Q29udGVudGAsIHJldXNpbmcgbm9kZXMgYWNjb3JkaW5nIHRvIHRoZSBjb3JyZXNwb25kZW5jZSBpbiBgdG9TeW5jYC4gKi9cbmZ1bmN0aW9uIHN5bmNUcmVlKFxuICB0YXJnZXQ6IEFzdCxcbiAgbmV3Q29udGVudDogT3duZWQsXG4gIHRvU3luYzogTWFwPEFzdElkLCBBc3Q+LFxuICBlZGl0OiBNdXRhYmxlTW9kdWxlLFxuICBtZXRhZGF0YVNvdXJjZTogTW9kdWxlLFxuKSB7XG4gIGNvbnN0IG5ld0lkVG9FcXVpdmFsZW50ID0gbmV3IE1hcDxBc3RJZCwgQXN0SWQ+KClcbiAgZm9yIChjb25zdCBbYmVmb3JlSWQsIGFmdGVyXSBvZiB0b1N5bmMpIG5ld0lkVG9FcXVpdmFsZW50LnNldChhZnRlci5pZCwgYmVmb3JlSWQpXG4gIGNvbnN0IGNoaWxkUmVwbGFjZXJGb3IgPSAocGFyZW50SWQ6IEFzdElkKSA9PiAoaWQ6IEFzdElkKSA9PiB7XG4gICAgY29uc3Qgb3JpZ2luYWwgPSBuZXdJZFRvRXF1aXZhbGVudC5nZXQoaWQpXG4gICAgaWYgKG9yaWdpbmFsKSB7XG4gICAgICBjb25zdCByZXBsYWNlbWVudCA9IGVkaXQuZ2V0KG9yaWdpbmFsKVxuICAgICAgaWYgKHJlcGxhY2VtZW50LnBhcmVudElkICE9PSBwYXJlbnRJZCkgcmVwbGFjZW1lbnQuZmllbGRzLnNldCgncGFyZW50JywgcGFyZW50SWQpXG4gICAgICByZXR1cm4gb3JpZ2luYWxcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2hpbGQgPSBlZGl0LmdldChpZClcbiAgICAgIGlmIChjaGlsZC5wYXJlbnRJZCAhPT0gcGFyZW50SWQpIGNoaWxkLmZpZWxkcy5zZXQoJ3BhcmVudCcsIHBhcmVudElkKVxuICAgIH1cbiAgfVxuICBjb25zdCBwYXJlbnRJZCA9IHRhcmdldC5maWVsZHMuZ2V0KCdwYXJlbnQnKVxuICBhc3NlcnREZWZpbmVkKHBhcmVudElkKVxuICBjb25zdCBwYXJlbnQgPSBlZGl0LmdldChwYXJlbnRJZClcbiAgY29uc3QgdGFyZ2V0U3luY0VxdWl2YWxlbnQgPSB0b1N5bmMuZ2V0KHRhcmdldC5pZClcbiAgY29uc3Qgc3luY1Jvb3QgPSB0YXJnZXRTeW5jRXF1aXZhbGVudD8uaWQgPT09IG5ld0NvbnRlbnQuaWQgPyB0YXJnZXRTeW5jRXF1aXZhbGVudCA6IHVuZGVmaW5lZFxuICBpZiAoIXN5bmNSb290KSB7XG4gICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0YXJnZXQuaWQsIG5ld0NvbnRlbnQpXG4gICAgbmV3Q29udGVudC5maWVsZHMuc2V0KCdtZXRhZGF0YScsIHRhcmdldC5maWVsZHMuZ2V0KCdtZXRhZGF0YScpLmNsb25lKCkpXG4gICAgdGFyZ2V0LmZpZWxkcy5nZXQoJ21ldGFkYXRhJykuc2V0KCdleHRlcm5hbElkJywgbmV3RXh0ZXJuYWxJZCgpKVxuICB9XG4gIGNvbnN0IG5ld1Jvb3QgPSBzeW5jUm9vdCA/IHRhcmdldCA6IG5ld0NvbnRlbnRcbiAgbmV3Um9vdC52aXNpdFJlY3Vyc2l2ZUFzdCgoYXN0KSA9PiB7XG4gICAgY29uc3Qgc3luY0ZpZWxkc0Zyb20gPSB0b1N5bmMuZ2V0KGFzdC5pZClcbiAgICBjb25zdCBlZGl0QXN0ID0gZWRpdC5nZXRWZXJzaW9uKGFzdClcbiAgICBpZiAoc3luY0ZpZWxkc0Zyb20pIHtcbiAgICAgIGNvbnN0IG9yaWdpbmFsQXNzaWdubWVudEV4cHJlc3Npb24gPVxuICAgICAgICBhc3QgaW5zdGFuY2VvZiBBc3NpZ25tZW50ID9cbiAgICAgICAgICBtZXRhZGF0YVNvdXJjZS5nZXQoYXN0LmZpZWxkcy5nZXQoJ2V4cHJlc3Npb24nKS5ub2RlKVxuICAgICAgICA6IHVuZGVmaW5lZFxuICAgICAgc3luY0ZpZWxkcyhlZGl0LmdldFZlcnNpb24oYXN0KSwgc3luY0ZpZWxkc0Zyb20sIGNoaWxkUmVwbGFjZXJGb3IoYXN0LmlkKSlcbiAgICAgIGlmIChlZGl0QXN0IGluc3RhbmNlb2YgTXV0YWJsZUFzc2lnbm1lbnQgJiYgb3JpZ2luYWxBc3NpZ25tZW50RXhwcmVzc2lvbikge1xuICAgICAgICBpZiAoZWRpdEFzdC5leHByZXNzaW9uLmV4dGVybmFsSWQgIT09IG9yaWdpbmFsQXNzaWdubWVudEV4cHJlc3Npb24uZXh0ZXJuYWxJZClcbiAgICAgICAgICBlZGl0QXN0LmV4cHJlc3Npb24uc2V0RXh0ZXJuYWxJZChvcmlnaW5hbEFzc2lnbm1lbnRFeHByZXNzaW9uLmV4dGVybmFsSWQpXG4gICAgICAgIHN5bmNOb2RlTWV0YWRhdGEoXG4gICAgICAgICAgZWRpdEFzdC5leHByZXNzaW9uLm11dGFibGVOb2RlTWV0YWRhdGEoKSxcbiAgICAgICAgICBvcmlnaW5hbEFzc2lnbm1lbnRFeHByZXNzaW9uLm5vZGVNZXRhZGF0YSxcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXdyaXRlUmVmcyhlZGl0QXN0LCBjaGlsZFJlcGxhY2VyRm9yKGFzdC5pZCkpXG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH0pXG4gIHJldHVybiBuZXdSb290XG59XG5cbi8qKiBQcm92aWRlcyBhIGBTcGFuVHJlZWAgdmlldyBvZiBhbiBgQXN0YCwgZ2l2ZW4gc3BhbiBpbmZvcm1hdGlvbi4gKi9cbmNsYXNzIEFzdFdpdGhTcGFucyBpbXBsZW1lbnRzIFNwYW5UcmVlPEFzdD4ge1xuICBwcml2YXRlIHJlYWRvbmx5IGFzdDogQXN0XG4gIHByaXZhdGUgcmVhZG9ubHkgZ2V0U3BhbjogKGFzdElkOiBBc3RJZCkgPT4gU291cmNlUmFuZ2VcblxuICBjb25zdHJ1Y3Rvcihhc3Q6IEFzdCwgZ2V0U3BhbjogKGFzdElkOiBBc3RJZCkgPT4gU291cmNlUmFuZ2UpIHtcbiAgICB0aGlzLmFzdCA9IGFzdFxuICAgIHRoaXMuZ2V0U3BhbiA9IGdldFNwYW5cbiAgfVxuXG4gIGlkKCk6IEFzdCB7XG4gICAgcmV0dXJuIHRoaXMuYXN0XG4gIH1cblxuICBzcGFuKCk6IFNvdXJjZVJhbmdlIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTcGFuKHRoaXMuYXN0LmlkKVxuICB9XG5cbiAgKmNoaWxkcmVuKCk6IEl0ZXJhYmxlSXRlcmF0b3I8U3BhblRyZWU8QXN0Pj4ge1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5hc3QuY2hpbGRyZW4oKSkge1xuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgQXN0KSB5aWVsZCBuZXcgQXN0V2l0aFNwYW5zKGNoaWxkLCB0aGlzLmdldFNwYW4pXG4gICAgfVxuICB9XG59XG4iLCAiY29uc3QgX192aXRlX2luamVjdGVkX29yaWdpbmFsX2Rpcm5hbWUgPSBcIkM6XFxcXFByb2plY3RzXFxcXGVuc29cXFxcZW5zb1xcXFxhcHBcXFxcZ3VpMlxcXFxzaGFyZWRcXFxcdXRpbFxcXFxkYXRhXCI7Y29uc3QgX192aXRlX2luamVjdGVkX29yaWdpbmFsX2ZpbGVuYW1lID0gXCJDOlxcXFxQcm9qZWN0c1xcXFxlbnNvXFxcXGVuc29cXFxcYXBwXFxcXGd1aTJcXFxcc2hhcmVkXFxcXHV0aWxcXFxcZGF0YVxcXFxpdGVyYWJsZS50c1wiO2NvbnN0IF9fdml0ZV9pbmplY3RlZF9vcmlnaW5hbF9pbXBvcnRfbWV0YV91cmwgPSBcImZpbGU6Ly8vQzovUHJvamVjdHMvZW5zby9lbnNvL2FwcC9ndWkyL3NoYXJlZC91dGlsL2RhdGEvaXRlcmFibGUudHNcIjsvKiogQGZpbGUgRnVuY3Rpb25zIGZvciBtYW5pcHVsYXRpbmcge0BsaW5rIEl0ZXJhYmxlfXMuICovXG5cbmV4cG9ydCBmdW5jdGlvbiogZW1wdHkoKTogR2VuZXJhdG9yPG5ldmVyPiB7fVxuXG5leHBvcnQgZnVuY3Rpb24qIHJhbmdlKHN0YXJ0OiBudW1iZXIsIHN0b3A6IG51bWJlciwgc3RlcCA9IHN0YXJ0IDw9IHN0b3AgPyAxIDogLTEpIHtcbiAgaWYgKChzdGVwID4gMCAmJiBzdGFydCA+IHN0b3ApIHx8IChzdGVwIDwgMCAmJiBzdGFydCA8IHN0b3ApKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJUaGUgcmFuZ2UncyBzdGVwIGlzIGluIHRoZSB3cm9uZyBkaXJlY3Rpb24gLSBwbGVhc2UgdXNlIEluZmluaXR5IG9yIC1JbmZpbml0eSBhcyB0aGUgZW5kcG9pbnQgZm9yIGFuIGluZmluaXRlIHJhbmdlLlwiLFxuICAgIClcbiAgfVxuICBpZiAoc3RhcnQgPD0gc3RvcCkge1xuICAgIHdoaWxlIChzdGFydCA8IHN0b3ApIHtcbiAgICAgIHlpZWxkIHN0YXJ0XG4gICAgICBzdGFydCArPSBzdGVwXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdGFydCA+IHN0b3ApIHtcbiAgICAgIHlpZWxkIHN0YXJ0XG4gICAgICBzdGFydCArPSBzdGVwXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogbWFwPFQsIFU+KGl0ZXI6IEl0ZXJhYmxlPFQ+LCBtYXA6ICh2YWx1ZTogVCkgPT4gVSkge1xuICBmb3IgKGNvbnN0IHZhbHVlIG9mIGl0ZXIpIHtcbiAgICB5aWVsZCBtYXAodmFsdWUpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiBjaGFpbjxUPiguLi5pdGVyczogSXRlcmFibGU8VD5bXSkge1xuICBmb3IgKGNvbnN0IGl0ZXIgb2YgaXRlcnMpIHtcbiAgICB5aWVsZCogaXRlclxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogemlwPFQsIFU+KGxlZnQ6IEl0ZXJhYmxlPFQ+LCByaWdodDogSXRlcmFibGU8VT4pOiBHZW5lcmF0b3I8W1QsIFVdPiB7XG4gIGNvbnN0IGxlZnRJdGVyYXRvciA9IGxlZnRbU3ltYm9sLml0ZXJhdG9yXSgpXG4gIGNvbnN0IHJpZ2h0SXRlcmF0b3IgPSByaWdodFtTeW1ib2wuaXRlcmF0b3JdKClcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCBsZWZ0UmVzdWx0ID0gbGVmdEl0ZXJhdG9yLm5leHQoKVxuICAgIGNvbnN0IHJpZ2h0UmVzdWx0ID0gcmlnaHRJdGVyYXRvci5uZXh0KClcbiAgICBpZiAobGVmdFJlc3VsdC5kb25lIHx8IHJpZ2h0UmVzdWx0LmRvbmUpIGJyZWFrXG4gICAgeWllbGQgW2xlZnRSZXN1bHQudmFsdWUsIHJpZ2h0UmVzdWx0LnZhbHVlXVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogemlwTG9uZ2VzdDxULCBVPihcbiAgbGVmdDogSXRlcmFibGU8VD4sXG4gIHJpZ2h0OiBJdGVyYWJsZTxVPixcbik6IEdlbmVyYXRvcjxbVCB8IHVuZGVmaW5lZCwgVSB8IHVuZGVmaW5lZF0+IHtcbiAgY29uc3QgbGVmdEl0ZXJhdG9yID0gbGVmdFtTeW1ib2wuaXRlcmF0b3JdKClcbiAgY29uc3QgcmlnaHRJdGVyYXRvciA9IHJpZ2h0W1N5bWJvbC5pdGVyYXRvcl0oKVxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IGxlZnRSZXN1bHQgPSBsZWZ0SXRlcmF0b3IubmV4dCgpXG4gICAgY29uc3QgcmlnaHRSZXN1bHQgPSByaWdodEl0ZXJhdG9yLm5leHQoKVxuICAgIGlmIChsZWZ0UmVzdWx0LmRvbmUgJiYgcmlnaHRSZXN1bHQuZG9uZSkgYnJlYWtcbiAgICB5aWVsZCBbXG4gICAgICBsZWZ0UmVzdWx0LmRvbmUgPyB1bmRlZmluZWQgOiBsZWZ0UmVzdWx0LnZhbHVlLFxuICAgICAgcmlnaHRSZXN1bHQuZG9uZSA/IHVuZGVmaW5lZCA6IHJpZ2h0UmVzdWx0LnZhbHVlLFxuICAgIF1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJ5R2V0U29sZVZhbHVlPFQ+KGl0ZXI6IEl0ZXJhYmxlPFQ+KTogVCB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IGl0ZXJhdG9yID0gaXRlcltTeW1ib2wuaXRlcmF0b3JdKClcbiAgY29uc3QgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpXG4gIGlmIChyZXN1bHQuZG9uZSkgcmV0dXJuXG4gIGNvbnN0IGV4Y2Vzc1Jlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKVxuICBpZiAoIWV4Y2Vzc1Jlc3VsdC5kb25lKSByZXR1cm5cbiAgcmV0dXJuIHJlc3VsdC52YWx1ZVxufVxuXG4vKiogVXRpbGl0eSB0byBzaW1wbGlmeSBjb25zdW1pbmcgYW4gaXRlcmF0b3IgYSBwYXJ0IGF0IGEgdGltZS4gKi9cbmV4cG9ydCBjbGFzcyBSZXN1bWFibGU8VD4ge1xuICBwcml2YXRlIHJlYWRvbmx5IGl0ZXJhdG9yOiBJdGVyYXRvcjxUPlxuICBwcml2YXRlIGN1cnJlbnQ6IEl0ZXJhdG9yUmVzdWx0PFQ+XG4gIGNvbnN0cnVjdG9yKGl0ZXJhYmxlOiBJdGVyYWJsZTxUPikge1xuICAgIHRoaXMuaXRlcmF0b3IgPSBpdGVyYWJsZVtTeW1ib2wuaXRlcmF0b3JdKClcbiAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLml0ZXJhdG9yLm5leHQoKVxuICB9XG5cbiAgLyoqIFRoZSBnaXZlbiBmdW5jdGlvbiBwZWVrcyBhdCB0aGUgY3VycmVudCB2YWx1ZS4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYHRydWVgLCB0aGUgY3VycmVudCB2YWx1ZSB3aWxsIGJlIGFkdmFuY2VkXG4gICAqICBhbmQgdGhlIGZ1bmN0aW9uIGNhbGxlZCBhZ2FpbjsgaWYgaXQgcmV0dXJucyBgZmFsc2VgLCB0aGUgcGVla2VkIHZhbHVlIHJlbWFpbnMgY3VycmVudCBhbmQgYGFkdmFuY2VXaGlsZWAgcmV0dXJucy5cbiAgICovXG4gIGFkdmFuY2VXaGlsZShmOiAodmFsdWU6IFQpID0+IGJvb2xlYW4pIHtcbiAgICB3aGlsZSAoIXRoaXMuY3VycmVudC5kb25lICYmIGYodGhpcy5jdXJyZW50LnZhbHVlKSkge1xuICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5pdGVyYXRvci5uZXh0KClcbiAgICB9XG4gIH1cblxuICAvKiogQXBwbHkgdGhlIGdpdmVuIGZ1bmN0aW9uIHRvIGFsbCB2YWx1ZXMgcmVtYWluaW5nIGluIHRoZSBpdGVyYXRvci4gKi9cbiAgZm9yRWFjaChmOiAodmFsdWU6IFQpID0+IHZvaWQpIHtcbiAgICB3aGlsZSAoIXRoaXMuY3VycmVudC5kb25lKSB7XG4gICAgICBmKHRoaXMuY3VycmVudC52YWx1ZSlcbiAgICAgIHRoaXMuY3VycmVudCA9IHRoaXMuaXRlcmF0b3IubmV4dCgpXG4gICAgfVxuICB9XG59XG4iLCAiY29uc3QgX192aXRlX2luamVjdGVkX29yaWdpbmFsX2Rpcm5hbWUgPSBcIkM6XFxcXFByb2plY3RzXFxcXGVuc29cXFxcZW5zb1xcXFxhcHBcXFxcZ3VpMlxcXFxzaGFyZWRcXFxcdXRpbFxcXFxkYXRhXCI7Y29uc3QgX192aXRlX2luamVjdGVkX29yaWdpbmFsX2ZpbGVuYW1lID0gXCJDOlxcXFxQcm9qZWN0c1xcXFxlbnNvXFxcXGVuc29cXFxcYXBwXFxcXGd1aTJcXFxcc2hhcmVkXFxcXHV0aWxcXFxcZGF0YVxcXFx0ZXh0LnRzXCI7Y29uc3QgX192aXRlX2luamVjdGVkX29yaWdpbmFsX2ltcG9ydF9tZXRhX3VybCA9IFwiZmlsZTovLy9DOi9Qcm9qZWN0cy9lbnNvL2Vuc28vYXBwL2d1aTIvc2hhcmVkL3V0aWwvZGF0YS90ZXh0LnRzXCI7aW1wb3J0IGRpZmYgZnJvbSAnZmFzdC1kaWZmJ1xuaW1wb3J0IHsgcmFuZ2VFbmNsb3NlcywgcmFuZ2VMZW5ndGgsIHR5cGUgU291cmNlUmFuZ2UgfSBmcm9tICcuLi8uLi95anNNb2RlbCdcbmltcG9ydCB7IFJlc3VtYWJsZSB9IGZyb20gJy4vaXRlcmFibGUnXG5cbmV4cG9ydCB0eXBlIFNvdXJjZVJhbmdlRWRpdCA9IHsgcmFuZ2U6IFNvdXJjZVJhbmdlOyBpbnNlcnQ6IHN0cmluZyB9XG5cbi8qKiBHaXZlbiB0ZXh0IGFuZCBhIHNldCBvZiBgVGV4dEVkaXRgcywgcmV0dXJuIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIGVkaXRzIHRvIHRoZSB0ZXh0LiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5VGV4dEVkaXRzKG9sZFRleHQ6IHN0cmluZywgdGV4dEVkaXRzOiBTb3VyY2VSYW5nZUVkaXRbXSkge1xuICB0ZXh0RWRpdHMuc29ydCgoYSwgYikgPT4gYS5yYW5nZVswXSAtIGIucmFuZ2VbMF0pXG4gIGxldCBzdGFydCA9IDBcbiAgbGV0IG5ld1RleHQgPSAnJ1xuICBmb3IgKGNvbnN0IHRleHRFZGl0IG9mIHRleHRFZGl0cykge1xuICAgIG5ld1RleHQgKz0gb2xkVGV4dC5zbGljZShzdGFydCwgdGV4dEVkaXQucmFuZ2VbMF0pXG4gICAgbmV3VGV4dCArPSB0ZXh0RWRpdC5pbnNlcnRcbiAgICBzdGFydCA9IHRleHRFZGl0LnJhbmdlWzFdXG4gIH1cbiAgbmV3VGV4dCArPSBvbGRUZXh0LnNsaWNlKHN0YXJ0KVxuICByZXR1cm4gbmV3VGV4dFxufVxuXG4vKiogR2l2ZW4gdGV4dCBiZWZvcmUgYW5kIGFmdGVyIGEgY2hhbmdlLCByZXR1cm4gb25lIHBvc3NpYmxlIHNldCBvZiB7QGxpbmsgU291cmNlUmFuZ2VFZGl0fXMgZGVzY3JpYmluZyB0aGUgY2hhbmdlLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRleHRDaGFuZ2VUb0VkaXRzKGJlZm9yZTogc3RyaW5nLCBhZnRlcjogc3RyaW5nKTogU291cmNlUmFuZ2VFZGl0W10ge1xuICBjb25zdCB0ZXh0RWRpdHM6IFNvdXJjZVJhbmdlRWRpdFtdID0gW11cbiAgbGV0IG5leHRFZGl0OiB1bmRlZmluZWQgfCBTb3VyY2VSYW5nZUVkaXRcbiAgbGV0IHBvcyA9IDBcbiAgLy8gU2VxdWVuY2VzIGZhc3QtZGlmZiBlbWl0czpcbiAgLy8gRVFVQUwsIElOU0VSVFxuICAvLyBFUVVBTCwgREVMRVRFXG4gIC8vIERFTEVURSwgRVFVQUxcbiAgLy8gREVMRVRFLCBJTlNFUlRcbiAgLy8gSU5TRVJULCBFUVVBTFxuICBmb3IgKGNvbnN0IFtvcCwgdGV4dF0gb2YgZGlmZihiZWZvcmUsIGFmdGVyKSkge1xuICAgIHN3aXRjaCAob3ApIHtcbiAgICAgIGNhc2UgZGlmZi5JTlNFUlQ6XG4gICAgICAgIGlmICghbmV4dEVkaXQpIG5leHRFZGl0ID0geyByYW5nZTogW3BvcywgcG9zXSwgaW5zZXJ0OiAnJyB9XG4gICAgICAgIG5leHRFZGl0Lmluc2VydCA9IHRleHRcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgZGlmZi5FUVVBTDpcbiAgICAgICAgaWYgKG5leHRFZGl0KSB7XG4gICAgICAgICAgdGV4dEVkaXRzLnB1c2gobmV4dEVkaXQpXG4gICAgICAgICAgbmV4dEVkaXQgPSB1bmRlZmluZWRcbiAgICAgICAgfVxuICAgICAgICBwb3MgKz0gdGV4dC5sZW5ndGhcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgZGlmZi5ERUxFVEU6IHtcbiAgICAgICAgaWYgKG5leHRFZGl0KSB0ZXh0RWRpdHMucHVzaChuZXh0RWRpdClcbiAgICAgICAgY29uc3QgZW5kUG9zID0gcG9zICsgdGV4dC5sZW5ndGhcbiAgICAgICAgbmV4dEVkaXQgPSB7IHJhbmdlOiBbcG9zLCBlbmRQb3NdLCBpbnNlcnQ6ICcnIH1cbiAgICAgICAgcG9zID0gZW5kUG9zXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChuZXh0RWRpdCkgdGV4dEVkaXRzLnB1c2gobmV4dEVkaXQpXG4gIHJldHVybiB0ZXh0RWRpdHNcbn1cblxuLyoqIFRyYW5zbGF0ZSBhIGBUZXh0RWRpdGAgYnkgdGhlIHNwZWNpZmllZCBvZmZzZXQuICovXG5leHBvcnQgZnVuY3Rpb24gb2Zmc2V0RWRpdCh0ZXh0RWRpdDogU291cmNlUmFuZ2VFZGl0LCBvZmZzZXQ6IG51bWJlcik6IFNvdXJjZVJhbmdlRWRpdCB7XG4gIHJldHVybiB7IC4uLnRleHRFZGl0LCByYW5nZTogW3RleHRFZGl0LnJhbmdlWzBdICsgb2Zmc2V0LCB0ZXh0RWRpdC5yYW5nZVsxXSArIG9mZnNldF0gfVxufVxuXG4vKiogR2l2ZW46XG4gKiAgQHBhcmFtIHRleHRFZGl0cyAtIEEgY2hhbmdlIGRlc2NyaWJlZCBieSBhIHNldCBvZiB0ZXh0IGVkaXRzLlxuICogIEBwYXJhbSBzcGFuc0JlZm9yZSAtIEEgY29sbGVjdGlvbiBvZiBzcGFucyBpbiB0aGUgdGV4dCBiZWZvcmUgdGhlIGVkaXQuXG4gKiAgQHJldHVybnMgLSBBIHNlcXVlbmNlIG9mOiBFYWNoIHNwYW4gZnJvbSBgc3BhbnNCZWZvcmVgIHBhaXJlZCB3aXRoIHRoZSBzbWFsbGVzdCBzcGFuIG9mIHRoZSB0ZXh0IGFmdGVyIHRoZSBlZGl0IHRoYXRcbiAqICBjb250YWlucyBhbGwgdGV4dCB0aGF0IHdhcyBpbiB0aGUgb3JpZ2luYWwgc3BhbiBhbmQgaGFzIG5vdCBiZWVuIGRlbGV0ZWQuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlUZXh0RWRpdHNUb1NwYW5zKHRleHRFZGl0czogU291cmNlUmFuZ2VFZGl0W10sIHNwYW5zQmVmb3JlOiBTb3VyY2VSYW5nZVtdKSB7XG4gIC8vIEdhdGhlciBzdGFydCBhbmQgZW5kIHBvaW50cy5cbiAgY29uc3QgbnVtZXJpY2FsbHkgPSAoYTogbnVtYmVyLCBiOiBudW1iZXIpID0+IGEgLSBiXG4gIGNvbnN0IHN0YXJ0cyA9IG5ldyBSZXN1bWFibGUoc3BhbnNCZWZvcmUubWFwKChbc3RhcnQsIF9lbmRdKSA9PiBzdGFydCkuc29ydChudW1lcmljYWxseSkpXG4gIGNvbnN0IGVuZHMgPSBuZXcgUmVzdW1hYmxlKHNwYW5zQmVmb3JlLm1hcCgoW19zdGFydCwgZW5kXSkgPT4gZW5kKS5zb3J0KG51bWVyaWNhbGx5KSlcblxuICAvLyBDb25zdHJ1Y3QgdHJhbnNsYXRpb25zIGZyb20gb2xkIGxvY2F0aW9ucyB0byBuZXcgbG9jYXRpb25zIGZvciBhbGwgc3RhcnQgYW5kIGVuZCBwb2ludHMuXG4gIGNvbnN0IHN0YXJ0TWFwID0gbmV3IE1hcDxudW1iZXIsIG51bWJlcj4oKVxuICBjb25zdCBlbmRNYXAgPSBuZXcgTWFwPG51bWJlciwgbnVtYmVyPigpXG4gIGxldCBvZmZzZXQgPSAwXG4gIGZvciAoY29uc3QgeyByYW5nZSwgaW5zZXJ0IH0gb2YgdGV4dEVkaXRzKSB7XG4gICAgc3RhcnRzLmFkdmFuY2VXaGlsZSgoc3RhcnQpID0+IHtcbiAgICAgIGlmIChzdGFydCA8IHJhbmdlWzBdKSB7XG4gICAgICAgIHN0YXJ0TWFwLnNldChzdGFydCwgc3RhcnQgKyBvZmZzZXQpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0IDw9IHJhbmdlWzFdKSB7XG4gICAgICAgIHN0YXJ0TWFwLnNldChzdGFydCwgcmFuZ2VbMF0gKyBvZmZzZXQgKyBpbnNlcnQubGVuZ3RoKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSlcbiAgICBlbmRzLmFkdmFuY2VXaGlsZSgoZW5kKSA9PiB7XG4gICAgICBpZiAoZW5kIDw9IHJhbmdlWzBdKSB7XG4gICAgICAgIGVuZE1hcC5zZXQoZW5kLCBlbmQgKyBvZmZzZXQpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGVsc2UgaWYgKGVuZCA8PSByYW5nZVsxXSkge1xuICAgICAgICBlbmRNYXAuc2V0KGVuZCwgcmFuZ2VbMF0gKyBvZmZzZXQpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9KVxuICAgIG9mZnNldCArPSBpbnNlcnQubGVuZ3RoIC0gcmFuZ2VMZW5ndGgocmFuZ2UpXG4gIH1cbiAgc3RhcnRzLmZvckVhY2goKHN0YXJ0KSA9PiBzdGFydE1hcC5zZXQoc3RhcnQsIHN0YXJ0ICsgb2Zmc2V0KSlcbiAgZW5kcy5mb3JFYWNoKChlbmQpID0+IGVuZE1hcC5zZXQoZW5kLCBlbmQgKyBvZmZzZXQpKVxuXG4gIC8vIEFwcGx5IHRoZSB0cmFuc2xhdGlvbnMgdG8gdGhlIG1hcC5cbiAgY29uc3Qgc3BhbnNCZWZvcmVBbmRBZnRlciA9IG5ldyBBcnJheTxyZWFkb25seSBbU291cmNlUmFuZ2UsIFNvdXJjZVJhbmdlXT4oKVxuICBmb3IgKGNvbnN0IHNwYW5CZWZvcmUgb2Ygc3BhbnNCZWZvcmUpIHtcbiAgICBjb25zdCBzdGFydEFmdGVyID0gc3RhcnRNYXAuZ2V0KHNwYW5CZWZvcmVbMF0pIVxuICAgIGNvbnN0IGVuZEFmdGVyID0gZW5kTWFwLmdldChzcGFuQmVmb3JlWzFdKSFcbiAgICBpZiAoZW5kQWZ0ZXIgPiBzdGFydEFmdGVyKSBzcGFuc0JlZm9yZUFuZEFmdGVyLnB1c2goW3NwYW5CZWZvcmUsIFtzdGFydEFmdGVyLCBlbmRBZnRlcl1dKVxuICB9XG4gIHJldHVybiBzcGFuc0JlZm9yZUFuZEFmdGVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3BhblRyZWU8Tm9kZUlkPiB7XG4gIGlkKCk6IE5vZGVJZFxuICBzcGFuKCk6IFNvdXJjZVJhbmdlXG4gIGNoaWxkcmVuKCk6IEl0ZXJhYmxlSXRlcmF0b3I8U3BhblRyZWU8Tm9kZUlkPj5cbn1cblxuLyoqIEdpdmVuIGEgc3BhbiB0cmVlIGFuZCBzb21lIHJhbmdlcywgZm9yIGVhY2ggcmFuZ2UgZmluZCB0aGUgc21hbGxlc3Qgbm9kZSB0aGF0IGZ1bGx5IGVuY2xvc2VzIGl0LlxuICogIFJldHVybiBub2RlcyBwYWlyZWQgd2l0aCB0aGUgcmFuZ2VzIHRoYXQgYXJlIG1vc3QgY2xvc2VseSBlbmNsb3NlZCBieSB0aGVtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jbG9zaW5nU3BhbnM8Tm9kZUlkPihcbiAgdHJlZTogU3BhblRyZWU8Tm9kZUlkPixcbiAgcmFuZ2VzOiBTb3VyY2VSYW5nZVtdLFxuICByZXN1bHRzT3V0PzogW05vZGVJZCwgU291cmNlUmFuZ2VbXV1bXSxcbikge1xuICBjb25zdCByZXN1bHRzID0gcmVzdWx0c091dCA/PyBbXVxuICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRyZWUuY2hpbGRyZW4oKSkge1xuICAgIGNvbnN0IGNoaWxkU3BhbiA9IGNoaWxkLnNwYW4oKVxuICAgIGNvbnN0IGNoaWxkUmFuZ2VzOiBTb3VyY2VSYW5nZVtdID0gW11cbiAgICByYW5nZXMgPSByYW5nZXMuZmlsdGVyKChyYW5nZSkgPT4ge1xuICAgICAgaWYgKHJhbmdlRW5jbG9zZXMoY2hpbGRTcGFuLCByYW5nZSkpIHtcbiAgICAgICAgY2hpbGRSYW5nZXMucHVzaChyYW5nZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0pXG4gICAgaWYgKGNoaWxkUmFuZ2VzLmxlbmd0aCkgZW5jbG9zaW5nU3BhbnMoY2hpbGQsIGNoaWxkUmFuZ2VzLCByZXN1bHRzKVxuICB9XG4gIGlmIChyYW5nZXMubGVuZ3RoKSByZXN1bHRzLnB1c2goW3RyZWUuaWQoKSwgcmFuZ2VzXSlcbiAgcmV0dXJuIHJlc3VsdHNcbn1cblxuLyoqIFJldHVybiB0aGUgZ2l2ZW4gcmFuZ2Ugd2l0aCBhbnkgdHJhaWxpbmcgc3BhY2VzIHN0cmlwcGVkLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyaW1FbmQocmFuZ2U6IFNvdXJjZVJhbmdlLCB0ZXh0OiBzdHJpbmcpOiBTb3VyY2VSYW5nZSB7XG4gIGNvbnN0IHRyaW1tZWRMZW5ndGggPSB0ZXh0LnNsaWNlKHJhbmdlWzBdLCByYW5nZVsxXSkuc2VhcmNoKC8gKyQvKVxuICByZXR1cm4gdHJpbW1lZExlbmd0aCA9PT0gLTEgPyByYW5nZSA6IFtyYW5nZVswXSwgcmFuZ2VbMF0gKyB0cmltbWVkTGVuZ3RoXVxufVxuIiwgImNvbnN0IF9fdml0ZV9pbmplY3RlZF9vcmlnaW5hbF9kaXJuYW1lID0gXCJDOlxcXFxQcm9qZWN0c1xcXFxlbnNvXFxcXGVuc29cXFxcYXBwXFxcXGd1aTJcXFxcc2hhcmVkXFxcXGFzdFwiO2NvbnN0IF9fdml0ZV9pbmplY3RlZF9vcmlnaW5hbF9maWxlbmFtZSA9IFwiQzpcXFxcUHJvamVjdHNcXFxcZW5zb1xcXFxlbnNvXFxcXGFwcFxcXFxndWkyXFxcXHNoYXJlZFxcXFxhc3RcXFxcZGVidWcudHNcIjtjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfaW1wb3J0X21ldGFfdXJsID0gXCJmaWxlOi8vL0M6L1Byb2plY3RzL2Vuc28vZW5zby9hcHAvZ3VpMi9zaGFyZWQvYXN0L2RlYnVnLnRzXCI7aW1wb3J0IHsgQXN0IH0gZnJvbSAnLi90cmVlJ1xuXG4vLy8gUmV0dXJucyBhIEdyYXBoVml6IGdyYXBoIGlsbHVzdHJhdGluZyBwYXJlbnQvY2hpbGQgcmVsYXRpb25zaGlwcyBpbiB0aGUgZ2l2ZW4gc3VidHJlZS5cbmV4cG9ydCBmdW5jdGlvbiBncmFwaFBhcmVudFBvaW50ZXJzKGFzdDogQXN0KSB7XG4gIGNvbnN0IHNhbml0aXplID0gKGlkOiBzdHJpbmcpID0+IGlkLnJlcGxhY2UoJ2FzdDonLCAnJykucmVwbGFjZSgvW15BLVphLXowLTldL2csICcnKVxuICBjb25zdCBwYXJlbnRUb0NoaWxkID0gbmV3IEFycmF5PHsgcGFyZW50OiBzdHJpbmc7IGNoaWxkOiBzdHJpbmcgfT4oKVxuICBjb25zdCBjaGlsZFRvUGFyZW50ID0gbmV3IEFycmF5PHsgY2hpbGQ6IHN0cmluZzsgcGFyZW50OiBzdHJpbmcgfT4oKVxuICBhc3QudmlzaXRSZWN1cnNpdmVBc3QoKGFzdCkgPT4ge1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgYXN0LmNoaWxkcmVuKCkpIHtcbiAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEFzdClcbiAgICAgICAgcGFyZW50VG9DaGlsZC5wdXNoKHsgY2hpbGQ6IHNhbml0aXplKGNoaWxkLmlkKSwgcGFyZW50OiBzYW5pdGl6ZShhc3QuaWQpIH0pXG4gICAgfVxuICAgIGNvbnN0IHBhcmVudCA9IGFzdC5wYXJlbnRJZFxuICAgIGlmIChwYXJlbnQpIGNoaWxkVG9QYXJlbnQucHVzaCh7IGNoaWxkOiBzYW5pdGl6ZShhc3QuaWQpLCBwYXJlbnQ6IHNhbml0aXplKHBhcmVudCkgfSlcbiAgfSlcbiAgbGV0IHJlc3VsdCA9ICdkaWdyYXBoIHBhcmVudFBvaW50ZXJzIHtcXG4nXG4gIGZvciAoY29uc3QgeyBwYXJlbnQsIGNoaWxkIH0gb2YgcGFyZW50VG9DaGlsZCkgcmVzdWx0ICs9IGAke3BhcmVudH0gLT4gJHtjaGlsZH07XFxuYFxuICBmb3IgKGNvbnN0IHsgY2hpbGQsIHBhcmVudCB9IG9mIGNoaWxkVG9QYXJlbnQpXG4gICAgcmVzdWx0ICs9IGAke2NoaWxkfSAtPiAke3BhcmVudH0gW3dlaWdodD0wOyBjb2xvcj1yZWQ7IHN0eWxlPWRvdHRlZF07XFxuYFxuICByZXN1bHQgKz0gJ31cXG4nXG4gIHJldHVybiByZXN1bHRcbn1cbiIsICJjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfZGlybmFtZSA9IFwiQzpcXFxcUHJvamVjdHNcXFxcZW5zb1xcXFxlbnNvXFxcXGFwcFxcXFxndWkyXFxcXHNoYXJlZFxcXFxhc3RcIjtjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfZmlsZW5hbWUgPSBcIkM6XFxcXFByb2plY3RzXFxcXGVuc29cXFxcZW5zb1xcXFxhcHBcXFxcZ3VpMlxcXFxzaGFyZWRcXFxcYXN0XFxcXG11dGFibGVNb2R1bGUudHNcIjtjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfaW1wb3J0X21ldGFfdXJsID0gXCJmaWxlOi8vL0M6L1Byb2plY3RzL2Vuc28vZW5zby9hcHAvZ3VpMi9zaGFyZWQvYXN0L211dGFibGVNb2R1bGUudHNcIjtpbXBvcnQgKiBhcyByYW5kb20gZnJvbSAnbGliMC9yYW5kb20nXG5pbXBvcnQgKiBhcyBZIGZyb20gJ3lqcydcbmltcG9ydCB0eXBlIHsgQXN0SWQsIE5vZGVDaGlsZCwgT3duZWQsIFJhd05vZGVDaGlsZCwgU3luY1Rva2VuSWQgfSBmcm9tICcuJ1xuaW1wb3J0IHsgVG9rZW4sIGFzT3duZWQsIGlzVG9rZW5JZCwgbmV3RXh0ZXJuYWxJZCwgc3VidHJlZVJvb3RzIH0gZnJvbSAnLidcbmltcG9ydCB7IGFzc2VydCwgYXNzZXJ0RGVmaW5lZCB9IGZyb20gJy4uL3V0aWwvYXNzZXJ0J1xuaW1wb3J0IHR5cGUgeyBTb3VyY2VSYW5nZUVkaXQgfSBmcm9tICcuLi91dGlsL2RhdGEvdGV4dCdcbmltcG9ydCB7IGRlZmF1bHRMb2NhbE9yaWdpbiwgdHJ5QXNPcmlnaW4sIHR5cGUgRXh0ZXJuYWxJZCwgdHlwZSBPcmlnaW4gfSBmcm9tICcuLi95anNNb2RlbCdcbmltcG9ydCB0eXBlIHsgQXN0RmllbGRzLCBGaXhlZE1hcCwgTXV0YWJsZSB9IGZyb20gJy4vdHJlZSdcbmltcG9ydCB7XG4gIEFzdCxcbiAgTXV0YWJsZUFzdCxcbiAgTXV0YWJsZUludmFsaWQsXG4gIFdpbGRjYXJkLFxuICBjb21wb3NlRmllbGREYXRhLFxuICBpbnZhbGlkRmllbGRzLFxuICBtYXRlcmlhbGl6ZU11dGFibGUsXG4gIHNldEFsbCxcbn0gZnJvbSAnLi90cmVlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIE1vZHVsZSB7XG4gIGVkaXQoKTogTXV0YWJsZU1vZHVsZVxuICByb290KCk6IEFzdCB8IHVuZGVmaW5lZFxuICB0cnlHZXQoaWQ6IEFzdElkIHwgdW5kZWZpbmVkKTogQXN0IHwgdW5kZWZpbmVkXG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgLyoqIFJldHVybiB0aGUgc3BlY2lmaWVkIEFTVC4gVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiBubyBBU1Qgd2l0aCB0aGUgcHJvdmlkZWQgSUQgd2FzIGZvdW5kLiAqL1xuICBnZXQoaWQ6IEFzdElkKTogQXN0XG4gIGdldChpZDogQXN0SWQgfCB1bmRlZmluZWQpOiBBc3QgfCB1bmRlZmluZWRcbiAgZ2V0VG9rZW4odG9rZW46IFN5bmNUb2tlbklkKTogVG9rZW5cbiAgZ2V0VG9rZW4odG9rZW46IFN5bmNUb2tlbklkIHwgdW5kZWZpbmVkKTogVG9rZW4gfCB1bmRlZmluZWRcbiAgZ2V0QW55KG5vZGU6IEFzdElkIHwgU3luY1Rva2VuSWQpOiBBc3QgfCBUb2tlblxuICBnZXRDb25jcmV0ZShjaGlsZDogUmF3Tm9kZUNoaWxkKTogTm9kZUNoaWxkPEFzdD4gfCBOb2RlQ2hpbGQ8VG9rZW4+XG4gIGhhcyhpZDogQXN0SWQpOiBib29sZWFuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTW9kdWxlVXBkYXRlIHtcbiAgbm9kZXNBZGRlZDogU2V0PEFzdElkPlxuICBub2Rlc0RlbGV0ZWQ6IFNldDxBc3RJZD5cbiAgbm9kZXNVcGRhdGVkOiBTZXQ8QXN0SWQ+XG4gIHVwZGF0ZVJvb3RzOiBTZXQ8QXN0SWQ+XG4gIG1ldGFkYXRhVXBkYXRlZDogeyBpZDogQXN0SWQ7IGNoYW5nZXM6IE1hcDxzdHJpbmcsIHVua25vd24+IH1bXVxuICBvcmlnaW46IE9yaWdpbiB8IHVuZGVmaW5lZFxufVxuXG50eXBlIFlOb2RlID0gRml4ZWRNYXA8QXN0RmllbGRzPlxudHlwZSBZTm9kZXMgPSBZLk1hcDxZTm9kZT5cblxuZXhwb3J0IGNsYXNzIE11dGFibGVNb2R1bGUgaW1wbGVtZW50cyBNb2R1bGUge1xuICBwcml2YXRlIHJlYWRvbmx5IG5vZGVzOiBZTm9kZXNcblxuICBwcml2YXRlIGdldCB5ZG9jKCkge1xuICAgIGNvbnN0IHlkb2MgPSB0aGlzLm5vZGVzLmRvY1xuICAgIGFzc2VydCh5ZG9jICE9IG51bGwpXG4gICAgcmV0dXJuIHlkb2NcbiAgfVxuXG4gIC8qKiBSZXR1cm4gdGhpcyBtb2R1bGUncyBjb3B5IG9mIGBhc3RgLCBpZiB0aGlzIG1vZHVsZSB3YXMgY3JlYXRlZCBieSBjbG9uaW5nIGBhc3RgJ3MgbW9kdWxlLiAqL1xuICBnZXRWZXJzaW9uPFQgZXh0ZW5kcyBBc3Q+KGFzdDogVCk6IE11dGFibGU8VD4ge1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXQoYXN0LmlkKVxuICAgIHJldHVybiBpbnN0YW5jZSBhcyBNdXRhYmxlPFQ+XG4gIH1cblxuICBlZGl0KCk6IE11dGFibGVNb2R1bGUge1xuICAgIGNvbnN0IGRvYyA9IG5ldyBZLkRvYygpXG4gICAgWS5hcHBseVVwZGF0ZVYyKGRvYywgWS5lbmNvZGVTdGF0ZUFzVXBkYXRlVjIodGhpcy55ZG9jKSlcbiAgICByZXR1cm4gbmV3IE11dGFibGVNb2R1bGUoZG9jKVxuICB9XG5cbiAgYXBwbHlFZGl0KGVkaXQ6IE11dGFibGVNb2R1bGUsIG9yaWdpbjogT3JpZ2luID0gZGVmYXVsdExvY2FsT3JpZ2luKSB7XG4gICAgWS5hcHBseVVwZGF0ZVYyKHRoaXMueWRvYywgWS5lbmNvZGVTdGF0ZUFzVXBkYXRlVjIoZWRpdC55ZG9jKSwgb3JpZ2luKVxuICB9XG5cbiAgdHJhbnNhY3Q8VD4oZjogKCkgPT4gVCwgb3JpZ2luOiBPcmlnaW4gPSBkZWZhdWx0TG9jYWxPcmlnaW4pOiBUIHtcbiAgICByZXR1cm4gdGhpcy55ZG9jLnRyYW5zYWN0KGYsIG9yaWdpbilcbiAgfVxuXG4gIHJvb3QoKTogTXV0YWJsZUFzdCB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMucm9vdFBvaW50ZXIoKT8uZXhwcmVzc2lvblxuICB9XG5cbiAgcmVwbGFjZVJvb3QobmV3Um9vdDogT3duZWQgfCB1bmRlZmluZWQpOiBPd25lZCB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKG5ld1Jvb3QpIHtcbiAgICAgIGNvbnN0IHJvb3RQb2ludGVyID0gdGhpcy5yb290UG9pbnRlcigpXG4gICAgICBpZiAocm9vdFBvaW50ZXIpIHtcbiAgICAgICAgcmV0dXJuIHJvb3RQb2ludGVyLmV4cHJlc3Npb24ucmVwbGFjZShuZXdSb290KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW52YWxpZEZpZWxkcyh0aGlzLCB0aGlzLmJhc2VPYmplY3QoJ0ludmFsaWQnLCB1bmRlZmluZWQsIFJPT1RfSUQpLCB7XG4gICAgICAgICAgd2hpdGVzcGFjZTogJycsXG4gICAgICAgICAgbm9kZTogbmV3Um9vdCxcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvbGRSb290ID0gdGhpcy5yb290KClcbiAgICAgIGlmICghb2xkUm9vdCkgcmV0dXJuXG4gICAgICB0aGlzLm5vZGVzLmRlbGV0ZShST09UX0lEKVxuICAgICAgb2xkUm9vdC5maWVsZHMuc2V0KCdwYXJlbnQnLCB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gYXNPd25lZChvbGRSb290KVxuICAgIH1cbiAgfVxuXG4gIHN5bmNSb290KHJvb3Q6IE93bmVkKSB7XG4gICAgdGhpcy5yZXBsYWNlUm9vdChyb290KVxuICAgIHRoaXMuZ2MoKVxuICB9XG5cbiAgc3luY1RvQ29kZShjb2RlOiBzdHJpbmcpIHtcbiAgICBjb25zdCByb290ID0gdGhpcy5yb290KClcbiAgICBpZiAocm9vdCkge1xuICAgICAgcm9vdC5zeW5jVG9Db2RlKGNvZGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVwbGFjZVJvb3QoQXN0LnBhcnNlKGNvZGUsIHRoaXMpKVxuICAgIH1cbiAgfVxuXG4gIC8qKiBVcGRhdGUgdGhlIG1vZHVsZSBhY2NvcmRpbmcgdG8gY2hhbmdlcyB0byBpdHMgY29ycmVzcG9uZGluZyBzb3VyY2UgY29kZS4gKi9cbiAgYXBwbHlUZXh0RWRpdHModGV4dEVkaXRzOiBTb3VyY2VSYW5nZUVkaXRbXSwgbWV0YWRhdGFTb3VyY2U/OiBNb2R1bGUpIHtcbiAgICBjb25zdCByb290ID0gdGhpcy5yb290KClcbiAgICBhc3NlcnREZWZpbmVkKHJvb3QpXG4gICAgcm9vdC5hcHBseVRleHRFZGl0cyh0ZXh0RWRpdHMsIG1ldGFkYXRhU291cmNlKVxuICB9XG5cbiAgcHJpdmF0ZSBnYygpIHtcbiAgICBjb25zdCBsaXZlID0gbmV3IFNldDxBc3RJZD4oKVxuICAgIGNvbnN0IGFjdGl2ZSA9IG5ldyBBcnJheTxBc3Q+KClcbiAgICBsZXQgbmV4dDogQXN0IHwgdW5kZWZpbmVkID0gdGhpcy5yb290KClcbiAgICB3aGlsZSAobmV4dCkge1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBuZXh0LmNoaWxkcmVuKCkpIHtcbiAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgQXN0KSBhY3RpdmUucHVzaChjaGlsZClcbiAgICAgIH1cbiAgICAgIGxpdmUuYWRkKG5leHQuaWQpXG4gICAgICBuZXh0ID0gYWN0aXZlLnBvcCgpXG4gICAgfVxuICAgIGNvbnN0IGFsbCA9IEFycmF5LmZyb20odGhpcy5ub2Rlcy5rZXlzKCkpXG4gICAgZm9yIChjb25zdCBpZCBvZiBhbGwpIHtcbiAgICAgIGlmIChpZCA9PT0gUk9PVF9JRCkgY29udGludWVcbiAgICAgIGFzc2VydChpc0FzdElkKGlkKSlcbiAgICAgIGlmICghbGl2ZS5oYXMoaWQpKSB0aGlzLm5vZGVzLmRlbGV0ZShpZClcbiAgICB9XG4gIH1cblxuICAvKiogQ29weSB0aGUgZ2l2ZW4gbm9kZSBpbnRvIHRoZSBtb2R1bGUuICovXG4gIGNvcHk8VCBleHRlbmRzIEFzdD4oYXN0OiBUKTogT3duZWQ8TXV0YWJsZTxUPj4ge1xuICAgIGNvbnN0IGlkID0gbmV3QXN0SWQoYXN0LnR5cGVOYW1lKCkpXG4gICAgY29uc3QgZmllbGRzID0gYXN0LmZpZWxkcy5jbG9uZSgpXG4gICAgdGhpcy5ub2Rlcy5zZXQoaWQsIGZpZWxkcyBhcyBhbnkpXG4gICAgZmllbGRzLnNldCgnaWQnLCBpZClcbiAgICBmaWVsZHMuc2V0KCdwYXJlbnQnLCB1bmRlZmluZWQpXG4gICAgY29uc3QgYXN0XyA9IG1hdGVyaWFsaXplTXV0YWJsZSh0aGlzLCBmaWVsZHMpXG4gICAgYXN0Xy5pbXBvcnRSZWZlcmVuY2VzKGFzdC5tb2R1bGUpXG4gICAgcmV0dXJuIGFzdF8gYXMgT3duZWQ8TXV0YWJsZTx0eXBlb2YgYXN0Pj5cbiAgfVxuXG4gIHN0YXRpYyBUcmFuc2llbnQoKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzKG5ldyBZLkRvYygpKVxuICB9XG5cbiAgb2JzZXJ2ZShvYnNlcnZlcjogKHVwZGF0ZTogTW9kdWxlVXBkYXRlKSA9PiB2b2lkKSB7XG4gICAgY29uc3QgaGFuZGxlID0gKGV2ZW50czogWS5ZRXZlbnQ8YW55PltdLCB0cmFuc2FjdGlvbjogWS5UcmFuc2FjdGlvbikgPT4ge1xuICAgICAgb2JzZXJ2ZXIodGhpcy5vYnNlcnZlRXZlbnRzKGV2ZW50cywgdHJ5QXNPcmlnaW4odHJhbnNhY3Rpb24ub3JpZ2luKSkpXG4gICAgfVxuICAgIC8vIEF0dGFjaCB0aGUgb2JzZXJ2ZXIgZmlyc3QsIHNvIHRoYXQgaWYgYW4gdXBkYXRlIGhvb2sgY2F1c2VzIGNoYW5nZXMgaW4gcmVhY3Rpb24gdG8gdGhlIGluaXRpYWwgc3RhdGUgdXBkYXRlLCB3ZVxuICAgIC8vIHdvbid0IG1pc3MgdGhlbS5cbiAgICB0aGlzLm5vZGVzLm9ic2VydmVEZWVwKGhhbmRsZSlcbiAgICBvYnNlcnZlcih0aGlzLmdldFN0YXRlQXNVcGRhdGUoKSlcbiAgICByZXR1cm4gaGFuZGxlXG4gIH1cblxuICB1bm9ic2VydmUoaGFuZGxlOiBSZXR1cm5UeXBlPHR5cGVvZiB0aGlzLm9ic2VydmU+KSB7XG4gICAgdGhpcy5ub2Rlcy51bm9ic2VydmVEZWVwKGhhbmRsZSlcbiAgfVxuXG4gIGdldFN0YXRlQXNVcGRhdGUoKTogTW9kdWxlVXBkYXRlIHtcbiAgICBjb25zdCB1cGRhdGVCdWlsZGVyID0gbmV3IFVwZGF0ZUJ1aWxkZXIodGhpcywgdGhpcy5ub2RlcywgdW5kZWZpbmVkKVxuICAgIGZvciAoY29uc3QgaWQgb2YgdGhpcy5ub2Rlcy5rZXlzKCkpIHVwZGF0ZUJ1aWxkZXIuYWRkTm9kZShpZCBhcyBBc3RJZClcbiAgICByZXR1cm4gdXBkYXRlQnVpbGRlci5maW5pc2goKVxuICB9XG5cbiAgYXBwbHlVcGRhdGUodXBkYXRlOiBVaW50OEFycmF5LCBvcmlnaW46IE9yaWdpbik6IE1vZHVsZVVwZGF0ZSB8IHVuZGVmaW5lZCB7XG4gICAgbGV0IHN1bW1hcnk6IE1vZHVsZVVwZGF0ZSB8IHVuZGVmaW5lZFxuICAgIGNvbnN0IG9ic2VydmVyID0gKGV2ZW50czogWS5ZRXZlbnQ8YW55PltdKSA9PiB7XG4gICAgICBzdW1tYXJ5ID0gdGhpcy5vYnNlcnZlRXZlbnRzKGV2ZW50cywgb3JpZ2luKVxuICAgIH1cbiAgICB0aGlzLm5vZGVzLm9ic2VydmVEZWVwKG9ic2VydmVyKVxuICAgIFkuYXBwbHlVcGRhdGUodGhpcy55ZG9jLCB1cGRhdGUsIG9yaWdpbilcbiAgICB0aGlzLm5vZGVzLnVub2JzZXJ2ZURlZXAob2JzZXJ2ZXIpXG4gICAgcmV0dXJuIHN1bW1hcnlcbiAgfVxuXG4gIHByaXZhdGUgb2JzZXJ2ZUV2ZW50cyhldmVudHM6IFkuWUV2ZW50PGFueT5bXSwgb3JpZ2luOiBPcmlnaW4gfCB1bmRlZmluZWQpOiBNb2R1bGVVcGRhdGUge1xuICAgIGNvbnN0IHVwZGF0ZUJ1aWxkZXIgPSBuZXcgVXBkYXRlQnVpbGRlcih0aGlzLCB0aGlzLm5vZGVzLCBvcmlnaW4pXG4gICAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMpIHtcbiAgICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMubm9kZXMpIHtcbiAgICAgICAgLy8gVXBkYXRlcyB0byB0aGUgbm9kZSBtYXAuXG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgY2hhbmdlXSBvZiBldmVudC5jaGFuZ2VzLmtleXMpIHtcbiAgICAgICAgICBjb25zdCBpZCA9IGtleSBhcyBBc3RJZFxuICAgICAgICAgIHN3aXRjaCAoY2hhbmdlLmFjdGlvbikge1xuICAgICAgICAgICAgY2FzZSAnYWRkJzpcbiAgICAgICAgICAgICAgdXBkYXRlQnVpbGRlci5hZGROb2RlKGlkKVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSAndXBkYXRlJzpcbiAgICAgICAgICAgICAgdXBkYXRlQnVpbGRlci51cGRhdGVBbGxGaWVsZHMoaWQpXG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlICdkZWxldGUnOlxuICAgICAgICAgICAgICB1cGRhdGVCdWlsZGVyLmRlbGV0ZU5vZGUoaWQpXG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LnRhcmdldC5wYXJlbnQgPT09IHRoaXMubm9kZXMpIHtcbiAgICAgICAgLy8gVXBkYXRlcyB0byBhIG5vZGUncyBmaWVsZHMuXG4gICAgICAgIGFzc2VydChldmVudC50YXJnZXQgaW5zdGFuY2VvZiBZLk1hcClcbiAgICAgICAgY29uc3QgaWQgPSBldmVudC50YXJnZXQuZ2V0KCdpZCcpIGFzIEFzdElkXG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLm5vZGVzLmdldChpZClcbiAgICAgICAgaWYgKCFub2RlKSBjb250aW51ZVxuICAgICAgICBjb25zdCBjaGFuZ2VzOiAocmVhZG9ubHkgW3N0cmluZywgdW5rbm93bl0pW10gPSBBcnJheS5mcm9tKGV2ZW50LmNoYW5nZXMua2V5cywgKFtrZXldKSA9PiBbXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIG5vZGUuZ2V0KGtleSBhcyBhbnkpLFxuICAgICAgICBdKVxuICAgICAgICB1cGRhdGVCdWlsZGVyLnVwZGF0ZUZpZWxkcyhpZCwgY2hhbmdlcylcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQudGFyZ2V0LnBhcmVudC5wYXJlbnQgPT09IHRoaXMubm9kZXMpIHtcbiAgICAgICAgLy8gVXBkYXRlcyB0byBmaWVsZHMgb2YgYSBtZXRhZGF0YSBvYmplY3Qgd2l0aGluIGEgbm9kZS5cbiAgICAgICAgY29uc3QgaWQgPSBldmVudC50YXJnZXQucGFyZW50LmdldCgnaWQnKSBhcyBBc3RJZFxuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5ub2Rlcy5nZXQoaWQpXG4gICAgICAgIGlmICghbm9kZSkgY29udGludWVcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBub2RlLmdldCgnbWV0YWRhdGEnKSBhcyB1bmtub3duIGFzIE1hcDxzdHJpbmcsIHVua25vd24+XG4gICAgICAgIGNvbnN0IGNoYW5nZXM6IChyZWFkb25seSBbc3RyaW5nLCB1bmtub3duXSlbXSA9IEFycmF5LmZyb20oZXZlbnQuY2hhbmdlcy5rZXlzLCAoW2tleV0pID0+IFtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgbWV0YWRhdGEuZ2V0KGtleSBhcyBhbnkpLFxuICAgICAgICBdKVxuICAgICAgICB1cGRhdGVCdWlsZGVyLnVwZGF0ZU1ldGFkYXRhKGlkLCBjaGFuZ2VzKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdXBkYXRlQnVpbGRlci5maW5pc2goKVxuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5ub2Rlcy5jbGVhcigpXG4gIH1cblxuICBnZXQoaWQ6IEFzdElkKTogTXV0YWJsZVxuICBnZXQoaWQ6IEFzdElkIHwgdW5kZWZpbmVkKTogTXV0YWJsZSB8IHVuZGVmaW5lZFxuICBnZXQoaWQ6IEFzdElkIHwgdW5kZWZpbmVkKTogTXV0YWJsZSB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKCFpZCkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIGNvbnN0IGFzdCA9IHRoaXMudHJ5R2V0KGlkKVxuICAgIGFzc2VydChhc3QgIT09IHVuZGVmaW5lZCwgJ2lkIGluIG1vZHVsZScpXG4gICAgcmV0dXJuIGFzdFxuICB9XG5cbiAgdHJ5R2V0KGlkOiBBc3RJZCB8IHVuZGVmaW5lZCk6IE11dGFibGUgfCB1bmRlZmluZWQge1xuICAgIGlmICghaWQpIHJldHVybiB1bmRlZmluZWRcbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMubm9kZXMuZ2V0KGlkKVxuICAgIGlmICghbm9kZURhdGEpIHJldHVybiB1bmRlZmluZWRcbiAgICBjb25zdCBmaWVsZHMgPSBub2RlRGF0YSBhcyBhbnlcbiAgICByZXR1cm4gbWF0ZXJpYWxpemVNdXRhYmxlKHRoaXMsIGZpZWxkcylcbiAgfVxuXG4gIHJlcGxhY2UoaWQ6IEFzdElkLCB2YWx1ZTogT3duZWQpOiBPd25lZCB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0KGlkKT8ucmVwbGFjZSh2YWx1ZSlcbiAgfVxuXG4gIHJlcGxhY2VWYWx1ZShpZDogQXN0SWQsIHZhbHVlOiBPd25lZCk6IE93bmVkIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXQoaWQpPy5yZXBsYWNlVmFsdWUodmFsdWUpXG4gIH1cblxuICB0YWtlKGlkOiBBc3RJZCk6IE93bmVkIHtcbiAgICByZXR1cm4gdGhpcy5yZXBsYWNlKGlkLCBXaWxkY2FyZC5uZXcodGhpcykpIHx8IGFzT3duZWQodGhpcy5nZXQoaWQpKVxuICB9XG5cbiAgdXBkYXRlVmFsdWU8VCBleHRlbmRzIE11dGFibGVBc3Q+KGlkOiBBc3RJZCwgZjogKHg6IE93bmVkKSA9PiBPd25lZDxUPik6IFQgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnRyeUdldChpZCk/LnVwZGF0ZVZhbHVlKGYpXG4gIH1cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICBjb25zdHJ1Y3Rvcihkb2M6IFkuRG9jKSB7XG4gICAgdGhpcy5ub2RlcyA9IGRvYy5nZXRNYXA8WU5vZGU+KCdub2RlcycpXG4gIH1cblxuICBwcml2YXRlIHJvb3RQb2ludGVyKCk6IE11dGFibGVSb290UG9pbnRlciB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3Qgcm9vdFBvaW50ZXIgPSB0aGlzLnRyeUdldChST09UX0lEKVxuICAgIGlmIChyb290UG9pbnRlcikgcmV0dXJuIHJvb3RQb2ludGVyIGFzIE11dGFibGVSb290UG9pbnRlclxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBiYXNlT2JqZWN0KHR5cGU6IHN0cmluZywgZXh0ZXJuYWxJZD86IEV4dGVybmFsSWQsIG92ZXJyaWRlSWQ/OiBBc3RJZCk6IEZpeGVkTWFwPEFzdEZpZWxkcz4ge1xuICAgIGNvbnN0IG1hcCA9IG5ldyBZLk1hcDx1bmtub3duPigpXG4gICAgY29uc3QgbWFwXyA9IG1hcCBhcyB1bmtub3duIGFzIEZpeGVkTWFwPHt9PlxuICAgIGNvbnN0IGlkID0gb3ZlcnJpZGVJZCA/PyBuZXdBc3RJZCh0eXBlKVxuICAgIGNvbnN0IG1ldGFkYXRhID0gbmV3IFkuTWFwPHVua25vd24+KCkgYXMgdW5rbm93biBhcyBGaXhlZE1hcDx7fT5cbiAgICBjb25zdCBtZXRhZGF0YUZpZWxkcyA9IHNldEFsbChtZXRhZGF0YSwge1xuICAgICAgZXh0ZXJuYWxJZDogZXh0ZXJuYWxJZCA/PyBuZXdFeHRlcm5hbElkKCksXG4gICAgfSlcbiAgICBjb25zdCBmaWVsZHMgPSBzZXRBbGwobWFwXywge1xuICAgICAgaWQsXG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgcGFyZW50OiB1bmRlZmluZWQsXG4gICAgICBtZXRhZGF0YTogbWV0YWRhdGFGaWVsZHMsXG4gICAgfSlcbiAgICBjb25zdCBmaWVsZE9iamVjdCA9IGNvbXBvc2VGaWVsZERhdGEoZmllbGRzLCB7fSlcbiAgICB0aGlzLm5vZGVzLnNldChpZCwgZmllbGRPYmplY3QpXG4gICAgcmV0dXJuIGZpZWxkT2JqZWN0XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIGdldFRva2VuKHRva2VuOiBTeW5jVG9rZW5JZCk6IFRva2VuXG4gIGdldFRva2VuKHRva2VuOiBTeW5jVG9rZW5JZCB8IHVuZGVmaW5lZCk6IFRva2VuIHwgdW5kZWZpbmVkXG4gIGdldFRva2VuKHRva2VuOiBTeW5jVG9rZW5JZCB8IHVuZGVmaW5lZCk6IFRva2VuIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAoIXRva2VuKSByZXR1cm4gdG9rZW5cbiAgICBpZiAodG9rZW4gaW5zdGFuY2VvZiBUb2tlbikgcmV0dXJuIHRva2VuXG4gICAgcmV0dXJuIFRva2VuLndpdGhJZCh0b2tlbi5jb2RlXywgdG9rZW4udG9rZW5UeXBlXywgdG9rZW4uaWQpXG4gIH1cblxuICBnZXRBbnkobm9kZTogQXN0SWQgfCBTeW5jVG9rZW5JZCk6IE11dGFibGVBc3QgfCBUb2tlbiB7XG4gICAgcmV0dXJuIGlzVG9rZW5JZChub2RlKSA/IHRoaXMuZ2V0VG9rZW4obm9kZSkgOiB0aGlzLmdldChub2RlKVxuICB9XG5cbiAgZ2V0Q29uY3JldGUoY2hpbGQ6IFJhd05vZGVDaGlsZCk6IE5vZGVDaGlsZDxBc3Q+IHwgTm9kZUNoaWxkPFRva2VuPiB7XG4gICAgaWYgKGlzVG9rZW5JZChjaGlsZC5ub2RlKSlcbiAgICAgIHJldHVybiB7IHdoaXRlc3BhY2U6IGNoaWxkLndoaXRlc3BhY2UsIG5vZGU6IHRoaXMuZ2V0VG9rZW4oY2hpbGQubm9kZSkgfVxuICAgIGVsc2UgcmV0dXJuIHsgd2hpdGVzcGFjZTogY2hpbGQud2hpdGVzcGFjZSwgbm9kZTogdGhpcy5nZXQoY2hpbGQubm9kZSkgfVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCBDb3B5IGEgbm9kZSBpbnRvIHRoZSBtb2R1bGUsIGlmIGl0IGlzIGJvdW5kIHRvIGEgZGlmZmVyZW50IG1vZHVsZS4gKi9cbiAgY29weUlmRm9yZWlnbjxUIGV4dGVuZHMgTXV0YWJsZUFzdD4oYXN0OiBPd25lZDxUPik6IE93bmVkPFQ+XG4gIGNvcHlJZkZvcmVpZ248VCBleHRlbmRzIE11dGFibGVBc3Q+KGFzdDogT3duZWQ8VD4gfCB1bmRlZmluZWQpOiBPd25lZDxUPiB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKCFhc3QpIHJldHVybiBhc3RcbiAgICBpZiAoYXN0Lm1vZHVsZSA9PT0gdGhpcykgcmV0dXJuIGFzdFxuICAgIHJldHVybiB0aGlzLmNvcHkoYXN0KSBhcyBhbnlcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZGVsZXRlKGlkOiBBc3RJZCkge1xuICAgIHRoaXMubm9kZXMuZGVsZXRlKGlkKVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBoYXMoaWQ6IEFzdElkKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMuaGFzKGlkKVxuICB9XG59XG5cbnR5cGUgTXV0YWJsZVJvb3RQb2ludGVyID0gTXV0YWJsZUludmFsaWQgJiB7IGdldCBleHByZXNzaW9uKCk6IE11dGFibGVBc3QgfCB1bmRlZmluZWQgfVxuXG5mdW5jdGlvbiBuZXdBc3RJZCh0eXBlOiBzdHJpbmcpOiBBc3RJZCB7XG4gIHJldHVybiBgYXN0OiR7dHlwZX0jJHtyYW5kb20udWludDUzKCl9YCBhcyBBc3RJZFxufVxuLyoqIENoZWNrcyB3aGV0aGVyIHRoZSBpbnB1dCBsb29rcyBsaWtlIGFuIEFzdElkLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXN0SWQodmFsdWU6IHN0cmluZyk6IHZhbHVlIGlzIEFzdElkIHtcbiAgcmV0dXJuIC9hc3Q6W0EtWmEtel0qI1swLTldKi8udGVzdCh2YWx1ZSlcbn1cbmV4cG9ydCBjb25zdCBST09UX0lEID0gYFJvb3RgIGFzIEFzdElkXG5cbmNsYXNzIFVwZGF0ZUJ1aWxkZXIge1xuICByZWFkb25seSBub2Rlc0FkZGVkID0gbmV3IFNldDxBc3RJZD4oKVxuICByZWFkb25seSBub2Rlc0RlbGV0ZWQgPSBuZXcgU2V0PEFzdElkPigpXG4gIHJlYWRvbmx5IG5vZGVzVXBkYXRlZCA9IG5ldyBTZXQ8QXN0SWQ+KClcbiAgcmVhZG9ubHkgbWV0YWRhdGFVcGRhdGVkOiB7IGlkOiBBc3RJZDsgY2hhbmdlczogTWFwPHN0cmluZywgdW5rbm93bj4gfVtdID0gW11cbiAgcmVhZG9ubHkgb3JpZ2luOiBPcmlnaW4gfCB1bmRlZmluZWRcblxuICBwcml2YXRlIHJlYWRvbmx5IG1vZHVsZTogTW9kdWxlXG4gIHByaXZhdGUgcmVhZG9ubHkgbm9kZXM6IFlOb2Rlc1xuXG4gIGNvbnN0cnVjdG9yKG1vZHVsZTogTW9kdWxlLCBub2RlczogWU5vZGVzLCBvcmlnaW46IE9yaWdpbiB8IHVuZGVmaW5lZCkge1xuICAgIHRoaXMubW9kdWxlID0gbW9kdWxlXG4gICAgdGhpcy5ub2RlcyA9IG5vZGVzXG4gICAgdGhpcy5vcmlnaW4gPSBvcmlnaW5cbiAgfVxuXG4gIGFkZE5vZGUoaWQ6IEFzdElkKSB7XG4gICAgdGhpcy5ub2Rlc0FkZGVkLmFkZChpZClcbiAgfVxuXG4gIHVwZGF0ZUFsbEZpZWxkcyhpZDogQXN0SWQpIHtcbiAgICB0aGlzLnVwZGF0ZUZpZWxkcyhpZCwgdGhpcy5ub2Rlcy5nZXQoaWQpIS5lbnRyaWVzKCkpXG4gIH1cblxuICB1cGRhdGVGaWVsZHMoaWQ6IEFzdElkLCBjaGFuZ2VzOiBJdGVyYWJsZTxyZWFkb25seSBbc3RyaW5nLCB1bmtub3duXT4pIHtcbiAgICBsZXQgZmllbGRzQ2hhbmdlZCA9IGZhbHNlXG4gICAgbGV0IG1ldGFkYXRhQ2hhbmdlcyA9IHVuZGVmaW5lZFxuICAgIGZvciAoY29uc3QgZW50cnkgb2YgY2hhbmdlcykge1xuICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gZW50cnlcbiAgICAgIGlmIChrZXkgPT09ICdtZXRhZGF0YScpIHtcbiAgICAgICAgYXNzZXJ0KHZhbHVlIGluc3RhbmNlb2YgWS5NYXApXG4gICAgICAgIG1ldGFkYXRhQ2hhbmdlcyA9IG5ldyBNYXA8c3RyaW5nLCB1bmtub3duPih2YWx1ZS5lbnRyaWVzKCkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhc3NlcnQoISh2YWx1ZSBpbnN0YW5jZW9mIFkuQWJzdHJhY3RUeXBlKSlcbiAgICAgICAgZmllbGRzQ2hhbmdlZCA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZpZWxkc0NoYW5nZWQpIHRoaXMubm9kZXNVcGRhdGVkLmFkZChpZClcbiAgICBpZiAobWV0YWRhdGFDaGFuZ2VzKSB0aGlzLm1ldGFkYXRhVXBkYXRlZC5wdXNoKHsgaWQsIGNoYW5nZXM6IG1ldGFkYXRhQ2hhbmdlcyB9KVxuICB9XG5cbiAgdXBkYXRlTWV0YWRhdGEoaWQ6IEFzdElkLCBjaGFuZ2VzOiBJdGVyYWJsZTxyZWFkb25seSBbc3RyaW5nLCB1bmtub3duXT4pIHtcbiAgICBjb25zdCBjaGFuZ2VNYXAgPSBuZXcgTWFwPHN0cmluZywgdW5rbm93bj4oKVxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGNoYW5nZXMpIGNoYW5nZU1hcC5zZXQoa2V5LCB2YWx1ZSlcbiAgICB0aGlzLm1ldGFkYXRhVXBkYXRlZC5wdXNoKHsgaWQsIGNoYW5nZXM6IGNoYW5nZU1hcCB9KVxuICB9XG5cbiAgZGVsZXRlTm9kZShpZDogQXN0SWQpIHtcbiAgICB0aGlzLm5vZGVzRGVsZXRlZC5hZGQoaWQpXG4gIH1cblxuICBmaW5pc2goKTogTW9kdWxlVXBkYXRlIHtcbiAgICBjb25zdCBkaXJ0eU5vZGVzID0gbmV3IFNldCh0aGlzLm5vZGVzVXBkYXRlZClcbiAgICB0aGlzLm5vZGVzQWRkZWQuZm9yRWFjaCgobm9kZSkgPT4gZGlydHlOb2Rlcy5hZGQobm9kZSkpXG4gICAgY29uc3QgdXBkYXRlUm9vdHMgPSBzdWJ0cmVlUm9vdHModGhpcy5tb2R1bGUsIGRpcnR5Tm9kZXMpXG4gICAgcmV0dXJuIHsgLi4udGhpcywgdXBkYXRlUm9vdHMgfVxuICB9XG59XG4iLCAiY29uc3QgX192aXRlX2luamVjdGVkX29yaWdpbmFsX2Rpcm5hbWUgPSBcIkM6XFxcXFByb2plY3RzXFxcXGVuc29cXFxcZW5zb1xcXFxhcHBcXFxcZ3VpMlxcXFxzaGFyZWRcXFxcYXN0XCI7Y29uc3QgX192aXRlX2luamVjdGVkX29yaWdpbmFsX2ZpbGVuYW1lID0gXCJDOlxcXFxQcm9qZWN0c1xcXFxlbnNvXFxcXGVuc29cXFxcYXBwXFxcXGd1aTJcXFxcc2hhcmVkXFxcXGFzdFxcXFx0cmVlLnRzXCI7Y29uc3QgX192aXRlX2luamVjdGVkX29yaWdpbmFsX2ltcG9ydF9tZXRhX3VybCA9IFwiZmlsZTovLy9DOi9Qcm9qZWN0cy9lbnNvL2Vuc28vYXBwL2d1aTIvc2hhcmVkL2FzdC90cmVlLnRzXCI7aW1wb3J0IHR5cGUgeyBEZWVwUmVhZG9ubHkgfSBmcm9tICd2dWUnXG5pbXBvcnQgdHlwZSB7XG4gIElkZW50aWZpZXIsXG4gIElkZW50aWZpZXJPck9wZXJhdG9ySWRlbnRpZmllcixcbiAgSWRlbnRpZmllck9yT3BlcmF0b3JJZGVudGlmaWVyVG9rZW4sXG4gIElkZW50aWZpZXJUb2tlbixcbiAgTW9kdWxlLFxuICBOb2RlQ2hpbGQsXG4gIE93bmVkLFxuICBSYXdOb2RlQ2hpbGQsXG4gIFNwYW5NYXAsXG4gIFN5bmNUb2tlbklkLFxufSBmcm9tICcuJ1xuaW1wb3J0IHtcbiAgTXV0YWJsZU1vZHVsZSxcbiAgUk9PVF9JRCxcbiAgVG9rZW4sXG4gIGFzT3duZWQsXG4gIGVzY2FwZVRleHRMaXRlcmFsLFxuICBpc0lkZW50aWZpZXIsXG4gIGlzVG9rZW4sXG4gIGlzVG9rZW5DaGlsZCxcbiAgaXNUb2tlbklkLFxuICBuZXdFeHRlcm5hbElkLFxuICBwYXJlbnRJZCxcbn0gZnJvbSAnLidcbmltcG9ydCB7IGFzc2VydCwgYXNzZXJ0RGVmaW5lZCwgYXNzZXJ0RXF1YWwsIGJhaWwgfSBmcm9tICcuLi91dGlsL2Fzc2VydCdcbmltcG9ydCB0eXBlIHsgUmVzdWx0IH0gZnJvbSAnLi4vdXRpbC9kYXRhL3Jlc3VsdCdcbmltcG9ydCB7IEVyciwgT2sgfSBmcm9tICcuLi91dGlsL2RhdGEvcmVzdWx0J1xuaW1wb3J0IHR5cGUgeyBTb3VyY2VSYW5nZUVkaXQgfSBmcm9tICcuLi91dGlsL2RhdGEvdGV4dCdcbmltcG9ydCB0eXBlIHsgRXh0ZXJuYWxJZCwgVmlzdWFsaXphdGlvbk1ldGFkYXRhIH0gZnJvbSAnLi4veWpzTW9kZWwnXG5pbXBvcnQgeyB2aXNNZXRhZGF0YUVxdWFscyB9IGZyb20gJy4uL3lqc01vZGVsJ1xuaW1wb3J0ICogYXMgUmF3QXN0IGZyb20gJy4vZ2VuZXJhdGVkL2FzdCdcbmltcG9ydCB7XG4gIGFwcGx5VGV4dEVkaXRzVG9Bc3QsXG4gIHBhcnNlLFxuICBwYXJzZUJsb2NrLFxuICBwcmludCxcbiAgcHJpbnRBc3QsXG4gIHByaW50QmxvY2ssXG4gIHByaW50RG9jdW1lbnRlZCxcbiAgc3luY1RvQ29kZSxcbn0gZnJvbSAnLi9wYXJzZSdcblxuZGVjbGFyZSBjb25zdCBicmFuZEFzdElkOiB1bmlxdWUgc3ltYm9sXG5leHBvcnQgdHlwZSBBc3RJZCA9IHN0cmluZyAmIHsgW2JyYW5kQXN0SWRdOiBuZXZlciB9XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWV0YWRhdGFGaWVsZHMge1xuICBleHRlcm5hbElkOiBFeHRlcm5hbElkXG59XG5leHBvcnQgaW50ZXJmYWNlIE5vZGVNZXRhZGF0YUZpZWxkcyB7XG4gIHBvc2l0aW9uPzogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9IHwgdW5kZWZpbmVkXG4gIHZpc3VhbGl6YXRpb24/OiBWaXN1YWxpemF0aW9uTWV0YWRhdGEgfCB1bmRlZmluZWRcbiAgY29sb3JPdmVycmlkZT86IHN0cmluZyB8IHVuZGVmaW5lZFxufVxuZXhwb3J0IHR5cGUgTm9kZU1ldGFkYXRhID0gRml4ZWRNYXBWaWV3PE5vZGVNZXRhZGF0YUZpZWxkcz5cbmV4cG9ydCB0eXBlIE11dGFibGVOb2RlTWV0YWRhdGEgPSBGaXhlZE1hcDxOb2RlTWV0YWRhdGFGaWVsZHM+XG5leHBvcnQgZnVuY3Rpb24gYXNOb2RlTWV0YWRhdGEobWFwOiBNYXA8c3RyaW5nLCB1bmtub3duPik6IE5vZGVNZXRhZGF0YSB7XG4gIHJldHVybiBtYXAgYXMgdW5rbm93biBhcyBOb2RlTWV0YWRhdGFcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmludGVyZmFjZSBSYXdBc3RGaWVsZHMge1xuICBpZDogQXN0SWRcbiAgdHlwZTogc3RyaW5nXG4gIHBhcmVudDogQXN0SWQgfCB1bmRlZmluZWRcbiAgbWV0YWRhdGE6IEZpeGVkTWFwPE1ldGFkYXRhRmllbGRzPlxufVxuZXhwb3J0IGludGVyZmFjZSBBc3RGaWVsZHMgZXh0ZW5kcyBSYXdBc3RGaWVsZHMsIExlZ2FsRmllbGRDb250ZW50IHt9XG5mdW5jdGlvbiBhbGxLZXlzPFQ+KGtleXM6IFJlY29yZDxrZXlvZiBULCBhbnk+KTogKGtleW9mIFQpW10ge1xuICByZXR1cm4gT2JqZWN0LmtleXMoa2V5cykgYXMgYW55XG59XG5jb25zdCBhc3RGaWVsZEtleXMgPSBhbGxLZXlzPFJhd0FzdEZpZWxkcz4oe1xuICBpZDogbnVsbCxcbiAgdHlwZTogbnVsbCxcbiAgcGFyZW50OiBudWxsLFxuICBtZXRhZGF0YTogbnVsbCxcbn0pXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQXN0IHtcbiAgcmVhZG9ubHkgbW9kdWxlOiBNb2R1bGVcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICByZWFkb25seSBmaWVsZHM6IEZpeGVkTWFwVmlldzxBc3RGaWVsZHM+XG5cbiAgZ2V0IGlkKCk6IEFzdElkIHtcbiAgICByZXR1cm4gdGhpcy5maWVsZHMuZ2V0KCdpZCcpXG4gIH1cblxuICBnZXQgZXh0ZXJuYWxJZCgpOiBFeHRlcm5hbElkIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuZmllbGRzLmdldCgnbWV0YWRhdGEnKS5nZXQoJ2V4dGVybmFsSWQnKVxuICAgIGFzc2VydChpZCAhPSBudWxsKVxuICAgIHJldHVybiBpZFxuICB9XG5cbiAgZ2V0IG5vZGVNZXRhZGF0YSgpOiBOb2RlTWV0YWRhdGEge1xuICAgIGNvbnN0IG1ldGFkYXRhID0gdGhpcy5maWVsZHMuZ2V0KCdtZXRhZGF0YScpXG4gICAgcmV0dXJuIG1ldGFkYXRhIGFzIEZpeGVkTWFwVmlldzxOb2RlTWV0YWRhdGFGaWVsZHM+XG4gIH1cblxuICB0eXBlTmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmZpZWxkcy5nZXQoJ3R5cGUnKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIGB0aGlzYCBhbmQgYG90aGVyYCBhcmUgdGhlIHNhbWUgb2JqZWN0LCBwb3NzaWJseSBpbiBkaWZmZXJlbnQgbW9kdWxlcy5cbiAgICovXG4gIGlzPFQgZXh0ZW5kcyBBc3Q+KG90aGVyOiBUKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaWQgPT09IG90aGVyLmlkXG4gIH1cblxuICBpbm5lckV4cHJlc3Npb24oKTogQXN0IHtcbiAgICAvLyBUT0RPOiBPdmVycmlkZSB0aGlzIGluIGBEb2N1bWVudGVkYCwgYEFubm90YXRlZGAsIGBBbm5vdGF0ZWRCdWlsdGluYFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBjb2RlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHByaW50KHRoaXMpLmNvZGVcbiAgfVxuXG4gIHZpc2l0UmVjdXJzaXZlKHZpc2l0OiAobm9kZTogQXN0IHwgVG9rZW4pID0+IHZvaWQpOiB2b2lkIHtcbiAgICB2aXNpdCh0aGlzKVxuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbigpKSB7XG4gICAgICBpZiAoaXNUb2tlbihjaGlsZCkpIHtcbiAgICAgICAgdmlzaXQoY2hpbGQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZC52aXNpdFJlY3Vyc2l2ZSh2aXNpdClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2aXNpdFJlY3Vyc2l2ZUFzdCh2aXNpdDogKGFzdDogQXN0KSA9PiB2b2lkIHwgYm9vbGVhbik6IHZvaWQge1xuICAgIGlmICh2aXNpdCh0aGlzKSA9PT0gZmFsc2UpIHJldHVyblxuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbigpKSB7XG4gICAgICBpZiAoIWlzVG9rZW4oY2hpbGQpKSBjaGlsZC52aXNpdFJlY3Vyc2l2ZUFzdCh2aXNpdClcbiAgICB9XG4gIH1cblxuICBwcmludFN1YnRyZWUoXG4gICAgaW5mbzogU3Bhbk1hcCxcbiAgICBvZmZzZXQ6IG51bWJlcixcbiAgICBwYXJlbnRJbmRlbnQ6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICB2ZXJiYXRpbT86IGJvb2xlYW4sXG4gICk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHByaW50QXN0KHRoaXMsIGluZm8sIG9mZnNldCwgcGFyZW50SW5kZW50LCB2ZXJiYXRpbSlcbiAgfVxuXG4gIC8qKiBSZXR1cm5zIGNoaWxkIHN1YnRyZWVzLCB3aXRob3V0IGluZm9ybWF0aW9uIGFib3V0IHRoZSB3aGl0ZXNwYWNlIGJldHdlZW4gdGhlbS4gKi9cbiAgKmNoaWxkcmVuKCk6IEl0ZXJhYmxlSXRlcmF0b3I8QXN0IHwgVG9rZW4+IHtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY29uY3JldGVDaGlsZHJlbigpKSB7XG4gICAgICBpZiAoaXNUb2tlbklkKGNoaWxkLm5vZGUpKSB7XG4gICAgICAgIHlpZWxkIHRoaXMubW9kdWxlLmdldFRva2VuKGNoaWxkLm5vZGUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5tb2R1bGUuZ2V0KGNoaWxkLm5vZGUpXG4gICAgICAgIGlmIChub2RlKSB5aWVsZCBub2RlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0IHBhcmVudElkKCk6IEFzdElkIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBwYXJlbnRJZCA9IHRoaXMuZmllbGRzLmdldCgncGFyZW50JylcbiAgICBpZiAocGFyZW50SWQgIT09IFJPT1RfSUQpIHJldHVybiBwYXJlbnRJZFxuICB9XG5cbiAgcGFyZW50KCk6IEFzdCB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMubW9kdWxlLmdldCh0aGlzLnBhcmVudElkKVxuICB9XG5cbiAgc3RhdGljIHBhcnNlQmxvY2soc291cmNlOiBzdHJpbmcsIGluTW9kdWxlPzogTXV0YWJsZU1vZHVsZSkge1xuICAgIHJldHVybiBwYXJzZUJsb2NrKHNvdXJjZSwgaW5Nb2R1bGUpXG4gIH1cblxuICBzdGF0aWMgcGFyc2Uoc291cmNlOiBzdHJpbmcsIG1vZHVsZT86IE11dGFibGVNb2R1bGUpIHtcbiAgICByZXR1cm4gcGFyc2Uoc291cmNlLCBtb2R1bGUpXG4gIH1cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIHByb3RlY3RlZCBjb25zdHJ1Y3Rvcihtb2R1bGU6IE1vZHVsZSwgZmllbGRzOiBGaXhlZE1hcFZpZXc8QXN0RmllbGRzPikge1xuICAgIHRoaXMubW9kdWxlID0gbW9kdWxlXG4gICAgdGhpcy5maWVsZHMgPSBmaWVsZHNcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWxcbiAgICogIFJldHVybnMgY2hpbGQgc3VidHJlZXMsIGluY2x1ZGluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgd2hpdGVzcGFjZSBiZXR3ZWVuIHRoZW0uXG4gICAqL1xuICBhYnN0cmFjdCBjb25jcmV0ZUNoaWxkcmVuKHZlcmJhdGltPzogYm9vbGVhbik6IEl0ZXJhYmxlSXRlcmF0b3I8UmF3Tm9kZUNoaWxkPlxufVxuZXhwb3J0IGludGVyZmFjZSBNdXRhYmxlQXN0IHt9XG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgTXV0YWJsZUFzdCBleHRlbmRzIEFzdCB7XG4gIGRlY2xhcmUgcmVhZG9ubHkgbW9kdWxlOiBNdXRhYmxlTW9kdWxlXG4gIGRlY2xhcmUgcmVhZG9ubHkgZmllbGRzOiBGaXhlZE1hcDxBc3RGaWVsZHM+XG5cbiAgc2V0RXh0ZXJuYWxJZChpZDogRXh0ZXJuYWxJZCkge1xuICAgIHRoaXMuZmllbGRzLmdldCgnbWV0YWRhdGEnKS5zZXQoJ2V4dGVybmFsSWQnLCBpZClcbiAgfVxuXG4gIG11dGFibGVOb2RlTWV0YWRhdGEoKTogTXV0YWJsZU5vZGVNZXRhZGF0YSB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSB0aGlzLmZpZWxkcy5nZXQoJ21ldGFkYXRhJylcbiAgICByZXR1cm4gbWV0YWRhdGEgYXMgRml4ZWRNYXA8Tm9kZU1ldGFkYXRhRmllbGRzPlxuICB9XG5cbiAgc2V0Tm9kZU1ldGFkYXRhKG5vZGVNZXRhOiBOb2RlTWV0YWRhdGFGaWVsZHMpIHtcbiAgICBjb25zdCBtZXRhZGF0YSA9IHRoaXMuZmllbGRzLmdldCgnbWV0YWRhdGEnKSBhcyB1bmtub3duIGFzIE1hcDxzdHJpbmcsIHVua25vd24+XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobm9kZU1ldGEpKVxuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIG1ldGFkYXRhLnNldChrZXksIHZhbHVlKVxuICB9XG5cbiAgLyoqIE1vZGlmeSB0aGUgcGFyZW50IG9mIHRoaXMgbm9kZSB0byByZWZlciB0byBhIG5ldyBvYmplY3QgaW5zdGVhZC4gUmV0dXJuIHRoZSBvYmplY3QsIHdoaWNoIG5vdyBoYXMgbm8gcGFyZW50LiAqL1xuICByZXBsYWNlPFQgZXh0ZW5kcyBNdXRhYmxlQXN0PihyZXBsYWNlbWVudDogT3duZWQ8VD4pOiBPd25lZDx0eXBlb2YgdGhpcz4ge1xuICAgIGNvbnN0IHBhcmVudElkID0gdGhpcy5maWVsZHMuZ2V0KCdwYXJlbnQnKVxuICAgIGlmIChwYXJlbnRJZCkge1xuICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5tb2R1bGUuZ2V0KHBhcmVudElkKVxuICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLmlkLCByZXBsYWNlbWVudClcbiAgICAgIHRoaXMuZmllbGRzLnNldCgncGFyZW50JywgdW5kZWZpbmVkKVxuICAgIH1cbiAgICByZXR1cm4gYXNPd25lZCh0aGlzKVxuICB9XG5cbiAgLyoqIENoYW5nZSB0aGUgdmFsdWUgb2YgdGhlIG9iamVjdCByZWZlcnJlZCB0byBieSB0aGUgYHRhcmdldGAgSUQuIChUaGUgaW5pdGlhbCBJRCBvZiBgcmVwbGFjZW1lbnRgIHdpbGwgYmUgaWdub3JlZC4pXG4gICAqICBSZXR1cm5zIHRoZSBvbGQgdmFsdWUsIHdpdGggYSBuZXcgKHVucmVmZXJlbmNlZCkgSUQuXG4gICAqL1xuICByZXBsYWNlVmFsdWU8VCBleHRlbmRzIE11dGFibGVBc3Q+KHJlcGxhY2VtZW50OiBPd25lZDxUPik6IE93bmVkPHR5cGVvZiB0aGlzPiB7XG4gICAgY29uc3QgcmVwbGFjZW1lbnRfID0gdGhpcy5tb2R1bGUuY29weUlmRm9yZWlnbihyZXBsYWNlbWVudClcbiAgICBjb25zdCBvbGQgPSB0aGlzLnJlcGxhY2UocmVwbGFjZW1lbnRfKVxuICAgIHJlcGxhY2VtZW50Xy5maWVsZHMuc2V0KCdtZXRhZGF0YScsIG9sZC5maWVsZHMuZ2V0KCdtZXRhZGF0YScpLmNsb25lKCkpXG4gICAgb2xkLnNldEV4dGVybmFsSWQobmV3RXh0ZXJuYWxJZCgpKVxuICAgIHJldHVybiBvbGRcbiAgfVxuXG4gIHJlcGxhY2VWYWx1ZUNoZWNrZWQ8VCBleHRlbmRzIE11dGFibGVBc3Q+KHJlcGxhY2VtZW50OiBPd25lZDxUPik6IE93bmVkPHR5cGVvZiB0aGlzPiB7XG4gICAgY29uc3QgcGFyZW50SWQgPSB0aGlzLmZpZWxkcy5nZXQoJ3BhcmVudCcpXG4gICAgYXNzZXJ0RGVmaW5lZChwYXJlbnRJZClcbiAgICByZXR1cm4gdGhpcy5yZXBsYWNlVmFsdWUocmVwbGFjZW1lbnQpXG4gIH1cblxuICAvKiogUmVwbGFjZSB0aGUgcGFyZW50IG9mIHRoaXMgb2JqZWN0IHdpdGggYSByZWZlcmVuY2UgdG8gYSBuZXcgcGxhY2Vob2xkZXIgb2JqZWN0LlxuICAgKiAgUmV0dXJucyB0aGUgb2JqZWN0LCBub3cgcGFyZW50bGVzcywgYW5kIHRoZSBwbGFjZWhvbGRlci4gKi9cbiAgdGFrZVRvUmVwbGFjZSgpOiBSZW1vdmVkPHRoaXM+IHtcbiAgICBpZiAocGFyZW50SWQodGhpcykpIHtcbiAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gV2lsZGNhcmQubmV3KHRoaXMubW9kdWxlKVxuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMucmVwbGFjZShwbGFjZWhvbGRlcilcbiAgICAgIHJldHVybiB7IG5vZGUsIHBsYWNlaG9sZGVyIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHsgbm9kZTogYXNPd25lZCh0aGlzKSwgcGxhY2Vob2xkZXI6IHVuZGVmaW5lZCB9XG4gICAgfVxuICB9XG5cbiAgLyoqIFJlcGxhY2UgdGhlIHBhcmVudCBvZiB0aGlzIG9iamVjdCB3aXRoIGEgcmVmZXJlbmNlIHRvIGEgbmV3IHBsYWNlaG9sZGVyIG9iamVjdC5cbiAgICogIFJldHVybnMgdGhlIG9iamVjdCwgbm93IHBhcmVudGxlc3MuICovXG4gIHRha2UoKTogT3duZWQ8dGhpcz4ge1xuICAgIHJldHVybiB0aGlzLnJlcGxhY2UoV2lsZGNhcmQubmV3KHRoaXMubW9kdWxlKSlcbiAgfVxuXG4gIHRha2VJZlBhcmVudGVkKCk6IE93bmVkPHR5cGVvZiB0aGlzPiB7XG4gICAgY29uc3QgcGFyZW50ID0gcGFyZW50SWQodGhpcylcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBjb25zdCBwYXJlbnRBc3QgPSB0aGlzLm1vZHVsZS5nZXQocGFyZW50KVxuICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSBXaWxkY2FyZC5uZXcodGhpcy5tb2R1bGUpXG4gICAgICBwYXJlbnRBc3QucmVwbGFjZUNoaWxkKHRoaXMuaWQsIHBsYWNlaG9sZGVyKVxuICAgICAgdGhpcy5maWVsZHMuc2V0KCdwYXJlbnQnLCB1bmRlZmluZWQpXG4gICAgfVxuICAgIHJldHVybiBhc093bmVkKHRoaXMpXG4gIH1cblxuICAvKiogUmVwbGFjZSB0aGUgdmFsdWUgYXNzaWduZWQgdG8gdGhlIGdpdmVuIElEIHdpdGggYSBwbGFjZWhvbGRlci5cbiAgICogIFJldHVybnMgdGhlIHJlbW92ZWQgdmFsdWUsIHdpdGggYSBuZXcgdW5yZWZlcmVuY2VkIElELlxuICAgKiovXG4gIHRha2VWYWx1ZSgpOiBSZW1vdmVkPHR5cGVvZiB0aGlzPiB7XG4gICAgY29uc3QgcGxhY2Vob2xkZXIgPSBXaWxkY2FyZC5uZXcodGhpcy5tb2R1bGUpXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMucmVwbGFjZVZhbHVlKHBsYWNlaG9sZGVyKVxuICAgIHJldHVybiB7IG5vZGUsIHBsYWNlaG9sZGVyIH1cbiAgfVxuXG4gIC8qKiBUYWtlIHRoaXMgbm9kZSBmcm9tIHRoZSB0cmVlLCBhbmQgcmVwbGFjZSBpdCB3aXRoIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIGdpdmVuIGZ1bmN0aW9uIHRvIGl0LlxuICAgKlxuICAgKiAgTm90ZSB0aGF0IHRoaXMgaXMgYSBtb2RpZmljYXRpb24gb2YgdGhlICpwYXJlbnQqIG5vZGUuIEFueSBgQXN0YCBvYmplY3RzIG9yIGBBc3RJZGBzIHRoYXQgcG9pbnRlZCB0byB0aGUgb2xkIHZhbHVlXG4gICAqICB3aWxsIHN0aWxsIHBvaW50IHRvIHRoZSBvbGQgdmFsdWUuXG4gICAqL1xuICB1cGRhdGU8VCBleHRlbmRzIE11dGFibGVBc3Q+KGY6ICh4OiBPd25lZDx0eXBlb2YgdGhpcz4pID0+IE93bmVkPFQ+KTogVCB7XG4gICAgY29uc3QgdGFrZW4gPSB0aGlzLnRha2VUb1JlcGxhY2UoKVxuICAgIGFzc2VydERlZmluZWQodGFrZW4ucGxhY2Vob2xkZXIsICdUbyByZXBsYWNlIGFuIGBBc3RgLCBpdCBtdXN0IGhhdmUgYSBwYXJlbnQuJylcbiAgICBjb25zdCByZXBsYWNlbWVudCA9IGYodGFrZW4ubm9kZSlcbiAgICB0YWtlbi5wbGFjZWhvbGRlci5yZXBsYWNlKHJlcGxhY2VtZW50KVxuICAgIHJldHVybiByZXBsYWNlbWVudFxuICB9XG5cbiAgLyoqIFRha2UgdGhpcyBub2RlIGZyb20gdGhlIHRyZWUsIGFuZCByZXBsYWNlIGl0IHdpdGggdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGUgZ2l2ZW4gZnVuY3Rpb24gdG8gaXQ7IHRyYW5zZmVyIHRoZVxuICAgKiAgbWV0YWRhdGEgZnJvbSB0aGlzIG5vZGUgdG8gdGhlIHJlcGxhY2VtZW50LlxuICAgKlxuICAgKiAgTm90ZSB0aGF0IHRoaXMgaXMgYSBtb2RpZmljYXRpb24gb2YgdGhlICpwYXJlbnQqIG5vZGUuIEFueSBgQXN0YCBvYmplY3RzIG9yIGBBc3RJZGBzIHRoYXQgcG9pbnRlZCB0byB0aGUgb2xkIHZhbHVlXG4gICAqICB3aWxsIHN0aWxsIHBvaW50IHRvIHRoZSBvbGQgdmFsdWUuXG4gICAqL1xuICB1cGRhdGVWYWx1ZTxUIGV4dGVuZHMgTXV0YWJsZUFzdD4oZjogKHg6IE93bmVkPHR5cGVvZiB0aGlzPikgPT4gT3duZWQ8VD4pOiBUIHtcbiAgICBjb25zdCB0YWtlbiA9IHRoaXMudGFrZVZhbHVlKClcbiAgICBhc3NlcnREZWZpbmVkKHRha2VuLnBsYWNlaG9sZGVyLCAnVG8gcmVwbGFjZSBhbiBgQXN0YCwgaXQgbXVzdCBoYXZlIGEgcGFyZW50LicpXG4gICAgY29uc3QgcmVwbGFjZW1lbnQgPSBmKHRha2VuLm5vZGUpXG4gICAgdGFrZW4ucGxhY2Vob2xkZXIucmVwbGFjZVZhbHVlKHJlcGxhY2VtZW50KVxuICAgIHJldHVybiByZXBsYWNlbWVudFxuICB9XG5cbiAgbXV0YWJsZVBhcmVudCgpOiBNdXRhYmxlQXN0IHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBwYXJlbnRJZCA9IHRoaXMuZmllbGRzLmdldCgncGFyZW50JylcbiAgICBpZiAocGFyZW50SWQgPT09ICdST09UX0lEJykgcmV0dXJuXG4gICAgcmV0dXJuIHRoaXMubW9kdWxlLmdldChwYXJlbnRJZClcbiAgfVxuXG4gIC8qKiBNb2RpZnkgdGhpcyB0cmVlIHRvIHJlcHJlc2VudCB0aGUgZ2l2ZW4gY29kZSwgd2hpbGUgbWluaW1pemluZyBjaGFuZ2VzIGZyb20gdGhlIGN1cnJlbnQgc2V0IG9mIGBBc3Rgcy4gKi9cbiAgc3luY1RvQ29kZShjb2RlOiBzdHJpbmcsIG1ldGFkYXRhU291cmNlPzogTW9kdWxlKSB7XG4gICAgc3luY1RvQ29kZSh0aGlzLCBjb2RlLCBtZXRhZGF0YVNvdXJjZSlcbiAgfVxuXG4gIC8qKiBVcGRhdGUgdGhlIEFTVCBhY2NvcmRpbmcgdG8gY2hhbmdlcyB0byBpdHMgY29ycmVzcG9uZGluZyBzb3VyY2UgY29kZS4gKi9cbiAgYXBwbHlUZXh0RWRpdHModGV4dEVkaXRzOiBTb3VyY2VSYW5nZUVkaXRbXSwgbWV0YWRhdGFTb3VyY2U/OiBNb2R1bGUpIHtcbiAgICBhcHBseVRleHRFZGl0c1RvQXN0KHRoaXMsIHRleHRFZGl0cywgbWV0YWRhdGFTb3VyY2UgPz8gdGhpcy5tb2R1bGUpXG4gIH1cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBpbXBvcnRSZWZlcmVuY2VzKG1vZHVsZTogTW9kdWxlKSB7XG4gICAgaWYgKG1vZHVsZSA9PT0gdGhpcy5tb2R1bGUpIHJldHVyblxuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jb25jcmV0ZUNoaWxkcmVuKCkpIHtcbiAgICAgIGlmICghaXNUb2tlbklkKGNoaWxkLm5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkSW5Gb3JlaWduTW9kdWxlID0gbW9kdWxlLmdldChjaGlsZC5ub2RlKVxuICAgICAgICBhc3NlcnQoY2hpbGRJbkZvcmVpZ25Nb2R1bGUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgY29uc3QgaW1wb3J0ZWRDaGlsZCA9IHRoaXMubW9kdWxlLmNvcHkoY2hpbGRJbkZvcmVpZ25Nb2R1bGUpXG4gICAgICAgIGltcG9ydGVkQ2hpbGQuZmllbGRzLnNldCgncGFyZW50JywgdW5kZWZpbmVkKVxuICAgICAgICB0aGlzLnJlcGxhY2VDaGlsZChjaGlsZC5ub2RlLCBhc093bmVkKGltcG9ydGVkQ2hpbGQpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcmVwbGFjZUNoaWxkPFQgZXh0ZW5kcyBNdXRhYmxlQXN0Pih0YXJnZXQ6IEFzdElkLCByZXBsYWNlbWVudDogT3duZWQ8VD4pIHtcbiAgICBjb25zdCByZXBsYWNlbWVudElkID0gdGhpcy5jbGFpbUNoaWxkKHJlcGxhY2VtZW50KVxuICAgIGNvbnN0IGNoYW5nZXMgPSByZXdyaXRlUmVmcyh0aGlzLCAoaWQpID0+IChpZCA9PT0gdGFyZ2V0ID8gcmVwbGFjZW1lbnRJZCA6IHVuZGVmaW5lZCkpXG4gICAgYXNzZXJ0RXF1YWwoY2hhbmdlcywgMSlcbiAgfVxuXG4gIHByb3RlY3RlZCBjbGFpbUNoaWxkPFQgZXh0ZW5kcyBNdXRhYmxlQXN0PihjaGlsZDogT3duZWQ8VD4pOiBBc3RJZFxuICBwcm90ZWN0ZWQgY2xhaW1DaGlsZDxUIGV4dGVuZHMgTXV0YWJsZUFzdD4oY2hpbGQ6IE93bmVkPFQ+IHwgdW5kZWZpbmVkKTogQXN0SWQgfCB1bmRlZmluZWRcbiAgcHJvdGVjdGVkIGNsYWltQ2hpbGQ8VCBleHRlbmRzIE11dGFibGVBc3Q+KGNoaWxkOiBPd25lZDxUPiB8IHVuZGVmaW5lZCk6IEFzdElkIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gY2hpbGQgPyBjbGFpbUNoaWxkKHRoaXMubW9kdWxlLCBjaGlsZCwgdGhpcy5pZCkgOiB1bmRlZmluZWRcbiAgfVxufVxuXG4vKiogVmFsdWVzIHRoYXQgbWF5IGJlIGZvdW5kIGluIGZpZWxkcyBvZiBgQXN0YCBzdWJ0eXBlcy4gKi9cbnR5cGUgRmllbGREYXRhPFQgZXh0ZW5kcyBUcmVlUmVmcyA9IFJhd1JlZnM+ID1cbiAgfCBOb25BcnJheUZpZWxkRGF0YTxUPlxuICB8IE5vbkFycmF5RmllbGREYXRhPFQ+W11cbiAgfCAoVFsnYXN0J10gfCBUWyd0b2tlbiddKVtdXG5cbi8vIExvZ2ljYWxseSBgRmllbGREYXRhPFQ+W11gIGNvdWxkIGJlIGEgdHlwZSBvZiBgRmllbGREYXRhYCwgYnV0IHRoZSB0eXBlIG5lZWRzIHRvIGJlIG5vbi1yZWN1cnNpdmUgc28gdGhhdCBpdCBjYW4gYmVcbi8vIHVzZWQgd2l0aCBgRGVlcFJlYWRvbmx5YC5cbnR5cGUgTm9uQXJyYXlGaWVsZERhdGE8VCBleHRlbmRzIFRyZWVSZWZzPiA9IFRbJ2FzdCddIHwgVFsndG9rZW4nXSB8IHVuZGVmaW5lZCB8IFN0cnVjdHVyYWxGaWVsZDxUPlxuXG4vKiogT2JqZWN0cyB0aGF0IGRvIG5vdCBkaXJlY3RseSBjb250YWluIGBBc3RJZGBzIG9yIGBTeW5jVG9rZW5JZGBzLCBidXQgbWF5IGhhdmUgYE5vZGVDaGlsZGAgZmllbGRzLiAqL1xudHlwZSBTdHJ1Y3R1cmFsRmllbGQ8VCBleHRlbmRzIFRyZWVSZWZzID0gUmF3UmVmcz4gPVxuICB8IE11bHRpU2VnbWVudEFwcFNlZ21lbnQ8VD5cbiAgfCBMaW5lPFQ+XG4gIHwgT3BlbkNsb3NlVG9rZW5zPFQ+XG4gIHwgTmFtZVNwZWNpZmljYXRpb248VD5cbiAgfCBUZXh0RWxlbWVudDxUPlxuICB8IEFyZ3VtZW50RGVmaW5pdGlvbjxUPlxuICB8IFZlY3RvckVsZW1lbnQ8VD5cblxuLyoqIFR5cGUgd2hvc2UgZmllbGRzIGFyZSBhbGwgc3VpdGFibGUgZm9yIHN0b3JhZ2UgYXMgYEFzdGAgZmllbGRzLiAqL1xuaW50ZXJmYWNlIEZpZWxkT2JqZWN0PFQgZXh0ZW5kcyBUcmVlUmVmcz4ge1xuICBbZmllbGQ6IHN0cmluZ106IEZpZWxkRGF0YTxUPlxufVxuXG4vKiogUmV0dXJucyB0aGUgZmllbGRzIG9mIGFuIGBBc3RgIHN1YnR5cGUgdGhhdCBhcmUgbm90IHBhcnQgb2YgYEFzdEZpZWxkc2AuICovXG5mdW5jdGlvbiogZmllbGREYXRhRW50cmllczxGaWVsZHM+KG1hcDogRml4ZWRNYXBWaWV3PEZpZWxkcz4pIHtcbiAgZm9yIChjb25zdCBlbnRyeSBvZiBtYXAuZW50cmllcygpKSB7XG4gICAgLy8gQWxsIGZpZWxkcyB0aGF0IGFyZSBub3QgZnJvbSBgQXN0RmllbGRzYCBhcmUgYEZpZWxkRGF0YWAuXG4gICAgaWYgKCFhc3RGaWVsZEtleXMuaW5jbHVkZXMoZW50cnlbMF0gYXMgYW55KSkgeWllbGQgZW50cnkgYXMgW3N0cmluZywgRGVlcFJlYWRvbmx5PEZpZWxkRGF0YT5dXG4gIH1cbn1cblxuZnVuY3Rpb24gaWRSZXdyaXRlcihcbiAgZjogKGlkOiBBc3RJZCkgPT4gQXN0SWQgfCB1bmRlZmluZWQsXG4pOiAoZmllbGQ6IERlZXBSZWFkb25seTxGaWVsZERhdGE+KSA9PiBGaWVsZERhdGEgfCB1bmRlZmluZWQge1xuICByZXR1cm4gKGZpZWxkOiBEZWVwUmVhZG9ubHk8RmllbGREYXRhPikgPT4ge1xuICAgIGlmICh0eXBlb2YgZmllbGQgIT09ICdvYmplY3QnKSByZXR1cm5cbiAgICBpZiAoISgnbm9kZScgaW4gZmllbGQpKSByZXR1cm5cbiAgICBpZiAoaXNUb2tlbklkKGZpZWxkLm5vZGUpKSByZXR1cm5cbiAgICBjb25zdCBuZXdJZCA9IGYoZmllbGQubm9kZSlcbiAgICBpZiAoIW5ld0lkKSByZXR1cm5cbiAgICByZXR1cm4geyB3aGl0ZXNwYWNlOiBmaWVsZC53aGl0ZXNwYWNlLCBub2RlOiBuZXdJZCB9XG4gIH1cbn1cblxuLyoqIEFwcGx5IHRoZSBnaXZlbiBmdW5jdGlvbiB0byBlYWNoIGBBc3RJZGAgaW4gdGhlIGZpZWxkcyBvZiBgYXN0YC4gRm9yIGVhY2ggdmFsdWUgdGhhdCBpdCByZXR1cm5zIGFuIG91dHB1dCwgdGhhdFxuICogIG91dHB1dCB3aWxsIGJlIHN1YnN0aXR1dGVkIGZvciB0aGUgaW5wdXQgSUQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXdyaXRlUmVmcyhhc3Q6IE11dGFibGVBc3QsIGY6IChpZDogQXN0SWQpID0+IEFzdElkIHwgdW5kZWZpbmVkKSB7XG4gIGxldCBmaWVsZHNDaGFuZ2VkID0gMFxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBmaWVsZERhdGFFbnRyaWVzKGFzdC5maWVsZHMpKSB7XG4gICAgY29uc3QgbmV3VmFsdWUgPSByZXdyaXRlRmllbGRSZWZzKHZhbHVlLCBpZFJld3JpdGVyKGYpKVxuICAgIGlmIChuZXdWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhc3QuZmllbGRzLnNldChrZXkgYXMgYW55LCBuZXdWYWx1ZSlcbiAgICAgIGZpZWxkc0NoYW5nZWQgKz0gMVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmllbGRzQ2hhbmdlZFxufVxuXG4vKiogQ29weSBhbGwgZmllbGRzIGV4Y2VwdCB0aGUgYEFzdGAgYmFzZSBmaWVsZHMgZnJvbSBgYXN0MmAgdG8gYGFzdDFgLiBBIHJlZmVyZW5jZS1yZXdyaXRpbmcgZnVuY3Rpb24gd2lsbCBiZSBhcHBsaWVkXG4gKiAgdG8gYEFzdElkYHMgaW4gY29waWVkIGZpZWxkczsgc2VlIHtAbGluayByZXdyaXRlUmVmc30uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzeW5jRmllbGRzKGFzdDE6IE11dGFibGVBc3QsIGFzdDI6IEFzdCwgZjogKGlkOiBBc3RJZCkgPT4gQXN0SWQgfCB1bmRlZmluZWQpIHtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZmllbGREYXRhRW50cmllcyhhc3QyLmZpZWxkcykpIHtcbiAgICBjb25zdCBuZXdWYWx1ZSA9IG1hcFJlZnModmFsdWUsIGlkUmV3cml0ZXIoZikpXG4gICAgaWYgKCFmaWVsZEVxdWFsKGFzdDEuZmllbGRzLmdldChrZXkgYXMgYW55KSwgbmV3VmFsdWUpKSBhc3QxLmZpZWxkcy5zZXQoa2V5IGFzIGFueSwgbmV3VmFsdWUpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN5bmNOb2RlTWV0YWRhdGEodGFyZ2V0OiBNdXRhYmxlTm9kZU1ldGFkYXRhLCBzb3VyY2U6IE5vZGVNZXRhZGF0YSkge1xuICBjb25zdCBvbGRQb3MgPSB0YXJnZXQuZ2V0KCdwb3NpdGlvbicpXG4gIGNvbnN0IG5ld1BvcyA9IHNvdXJjZS5nZXQoJ3Bvc2l0aW9uJylcbiAgaWYgKG9sZFBvcz8ueCAhPT0gbmV3UG9zPy54IHx8IG9sZFBvcz8ueSAhPT0gbmV3UG9zPy55KSB0YXJnZXQuc2V0KCdwb3NpdGlvbicsIG5ld1BvcylcbiAgY29uc3QgbmV3VmlzID0gc291cmNlLmdldCgndmlzdWFsaXphdGlvbicpXG4gIGlmICghdmlzTWV0YWRhdGFFcXVhbHModGFyZ2V0LmdldCgndmlzdWFsaXphdGlvbicpLCBuZXdWaXMpKSB0YXJnZXQuc2V0KCd2aXN1YWxpemF0aW9uJywgbmV3VmlzKVxufVxuXG5mdW5jdGlvbiByZXdyaXRlRmllbGRSZWZzPFQgZXh0ZW5kcyBUcmVlUmVmcywgVSBleHRlbmRzIFRyZWVSZWZzPihcbiAgZmllbGQ6IERlZXBSZWFkb25seTxGaWVsZERhdGE8VD4+LFxuICBmOiAodDogRGVlcFJlYWRvbmx5PEZpZWxkRGF0YTxUPj4pID0+IEZpZWxkRGF0YTxVPiB8IHVuZGVmaW5lZCxcbik6IEZpZWxkRGF0YTxVPiB7XG4gIGNvbnN0IG5ld1ZhbHVlID0gZihmaWVsZClcbiAgaWYgKG5ld1ZhbHVlKSByZXR1cm4gbmV3VmFsdWVcbiAgaWYgKHR5cGVvZiBmaWVsZCAhPT0gJ29iamVjdCcpIHJldHVyblxuICAvLyBgQXJyYXkuaXNBcnJheWAgZG9lc24ndCB3b3JrIHdpdGggYERlZXBSZWFkb25seWAsIGJ1dCB3ZSBqdXN0IG5lZWQgYSBuYXJyb3dpbmcgdGhhdCBkaXN0aW5ndWlzaGVzIGl0IGZyb20gYWxsXG4gIC8vIGBTdHJ1Y3R1cmFsRmllbGRgIHR5cGVzLlxuICBpZiAoJ2ZvckVhY2gnIGluIGZpZWxkKSB7XG4gICAgY29uc3QgbmV3VmFsdWVzID0gbmV3IE1hcDxudW1iZXIsIEZpZWxkRGF0YTxVPj4oKVxuICAgIGZpZWxkLmZvckVhY2goKHN1YmZpZWxkLCBpKSA9PiB7XG4gICAgICBjb25zdCBuZXdWYWx1ZSA9IHJld3JpdGVGaWVsZFJlZnMoc3ViZmllbGQsIGYpXG4gICAgICBpZiAobmV3VmFsdWUgIT09IHVuZGVmaW5lZCkgbmV3VmFsdWVzLnNldChpLCBuZXdWYWx1ZSlcbiAgICB9KVxuICAgIGlmIChuZXdWYWx1ZXMuc2l6ZSkgcmV0dXJuIEFycmF5LmZyb20oZmllbGQsIChvbGRWYWx1ZSwgaSkgPT4gbmV3VmFsdWVzLmdldChpKSA/PyBvbGRWYWx1ZSlcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBmaWVsZE9iamVjdCA9IGZpZWxkIHNhdGlzZmllcyBEZWVwUmVhZG9ubHk8U3RydWN0dXJhbEZpZWxkPlxuICAgIGNvbnN0IG5ld1ZhbHVlcyA9IG5ldyBNYXA8c3RyaW5nLCBGaWVsZERhdGE8VT4+KClcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhmaWVsZE9iamVjdCkpIHtcbiAgICAgIGNvbnN0IG5ld1ZhbHVlID0gcmV3cml0ZUZpZWxkUmVmcyh2YWx1ZSwgZilcbiAgICAgIGlmIChuZXdWYWx1ZSAhPT0gdW5kZWZpbmVkKSBuZXdWYWx1ZXMuc2V0KGtleSwgbmV3VmFsdWUpXG4gICAgfVxuICAgIGlmIChuZXdWYWx1ZXMuc2l6ZSlcbiAgICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGZpZWxkT2JqZWN0KS5tYXAoKFtrZXksIG9sZFZhbHVlXSkgPT4gW2tleSwgbmV3VmFsdWVzLmdldChrZXkpID8/IG9sZFZhbHVlXSksXG4gICAgICApXG4gIH1cbn1cblxudHlwZSBNYXBSZWY8VCBleHRlbmRzIFRyZWVSZWZzLCBVIGV4dGVuZHMgVHJlZVJlZnM+ID0gKHQ6IEZpZWxkRGF0YTxUPikgPT4gRmllbGREYXRhPFU+IHwgdW5kZWZpbmVkXG5cbi8vIFRoaXMgb3BlcmF0aW9uIGNhbiB0cmFuc2Zvcm0gYW55IGBGaWVsZERhdGFgIHR5cGUgcGFyYW1ldGVyaXplZCBieSBzb21lIGBUcmVlUmVmc2AgaW50byB0aGUgc2FtZSB0eXBlIHBhcmFtZXRlcml6ZWRcbi8vIGJ5IGFub3RoZXIgYFRyZWVSZWZzYCwgYnV0IGl0IGlzIG5vdCBwb3NzaWJsZSB0byBleHByZXNzIHRoYXQgZ2VuZXJhbGl6YXRpb24gdG8gVHlwZVNjcmlwdCBhcyBzdWNoLlxuZnVuY3Rpb24gbWFwUmVmczxUIGV4dGVuZHMgVHJlZVJlZnMsIFUgZXh0ZW5kcyBUcmVlUmVmcz4oXG4gIGZpZWxkOiBJbXBvcnRGaWVsZHM8VD4sXG4gIGY6IE1hcFJlZjxULCBVPixcbik6IEltcG9ydEZpZWxkczxVPlxuZnVuY3Rpb24gbWFwUmVmczxUIGV4dGVuZHMgVHJlZVJlZnMsIFUgZXh0ZW5kcyBUcmVlUmVmcz4oXG4gIGZpZWxkOiBUZXh0VG9rZW48VD4sXG4gIGY6IE1hcFJlZjxULCBVPixcbik6IFRleHRUb2tlbjxVPlxuZnVuY3Rpb24gbWFwUmVmczxUIGV4dGVuZHMgVHJlZVJlZnMsIFUgZXh0ZW5kcyBUcmVlUmVmcz4oXG4gIGZpZWxkOiBUZXh0RWxlbWVudDxUPixcbiAgZjogTWFwUmVmPFQsIFU+LFxuKTogVGV4dEVsZW1lbnQ8VT5cbmZ1bmN0aW9uIG1hcFJlZnM8VCBleHRlbmRzIFRyZWVSZWZzLCBVIGV4dGVuZHMgVHJlZVJlZnM+KFxuICBmaWVsZDogQXJndW1lbnREZWZpbml0aW9uPFQ+LFxuICBmOiBNYXBSZWY8VCwgVT4sXG4pOiBBcmd1bWVudERlZmluaXRpb248VT5cbmZ1bmN0aW9uIG1hcFJlZnM8VCBleHRlbmRzIFRyZWVSZWZzLCBVIGV4dGVuZHMgVHJlZVJlZnM+KFxuICBmaWVsZDogVmVjdG9yRWxlbWVudDxUPixcbiAgZjogTWFwUmVmPFQsIFU+LFxuKTogVmVjdG9yRWxlbWVudDxVPlxuZnVuY3Rpb24gbWFwUmVmczxUIGV4dGVuZHMgVHJlZVJlZnMsIFUgZXh0ZW5kcyBUcmVlUmVmcz4oXG4gIGZpZWxkOiBGaWVsZERhdGE8VD4sXG4gIGY6IE1hcFJlZjxULCBVPixcbik6IEZpZWxkRGF0YTxVPlxuZnVuY3Rpb24gbWFwUmVmczxUIGV4dGVuZHMgVHJlZVJlZnMsIFUgZXh0ZW5kcyBUcmVlUmVmcz4oXG4gIGZpZWxkOiBGaWVsZERhdGE8VD4sXG4gIGY6IE1hcFJlZjxULCBVPixcbik6IEZpZWxkRGF0YTxVPiB7XG4gIHJldHVybiByZXdyaXRlRmllbGRSZWZzKGZpZWxkLCBmKSA/PyBmaWVsZFxufVxuXG5mdW5jdGlvbiBmaWVsZEVxdWFsKGZpZWxkMTogRmllbGREYXRhLCBmaWVsZDI6IEZpZWxkRGF0YSk6IGJvb2xlYW4ge1xuICBpZiAodHlwZW9mIGZpZWxkMSAhPT0gJ29iamVjdCcpIHJldHVybiBmaWVsZDEgPT09IGZpZWxkMlxuICBpZiAodHlwZW9mIGZpZWxkMiAhPT0gJ29iamVjdCcpIHJldHVybiBmYWxzZVxuICBpZiAoJ25vZGUnIGluIGZpZWxkMSAmJiAnbm9kZScgaW4gZmllbGQyKSB7XG4gICAgaWYgKGZpZWxkMVsnd2hpdGVzcGFjZSddICE9PSBmaWVsZDJbJ3doaXRlc3BhY2UnXSkgcmV0dXJuIGZhbHNlXG4gICAgaWYgKGlzVG9rZW5JZChmaWVsZDEubm9kZSkgJiYgaXNUb2tlbklkKGZpZWxkMi5ub2RlKSlcbiAgICAgIHJldHVybiBUb2tlbi5lcXVhbChmaWVsZDEubm9kZSwgZmllbGQyLm5vZGUpXG4gICAgZWxzZSByZXR1cm4gZmllbGQxLm5vZGUgPT09IGZpZWxkMi5ub2RlXG4gIH0gZWxzZSBpZiAoJ25vZGUnIGluIGZpZWxkMSB8fCAnbm9kZScgaW4gZmllbGQyKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShmaWVsZDEpICYmIEFycmF5LmlzQXJyYXkoZmllbGQyKSkge1xuICAgIHJldHVybiAoXG4gICAgICBmaWVsZDEubGVuZ3RoID09PSBmaWVsZDIubGVuZ3RoICYmIGZpZWxkMS5ldmVyeSgodmFsdWUxLCBpKSA9PiBmaWVsZEVxdWFsKHZhbHVlMSwgZmllbGQyW2ldKSlcbiAgICApXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShmaWVsZDEpIHx8IEFycmF5LmlzQXJyYXkoZmllbGQyKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGZpZWxkT2JqZWN0MSA9IGZpZWxkMSBzYXRpc2ZpZXMgU3RydWN0dXJhbEZpZWxkXG4gICAgY29uc3QgZmllbGRPYmplY3QyID0gZmllbGQyIHNhdGlzZmllcyBTdHJ1Y3R1cmFsRmllbGRcbiAgICBjb25zdCBrZXlzID0gbmV3IFNldDxzdHJpbmc+KClcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhmaWVsZE9iamVjdDEpKSBrZXlzLmFkZChrZXkpXG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoZmllbGRPYmplY3QyKSkga2V5cy5hZGQoa2V5KVxuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpXG4gICAgICBpZiAoIWZpZWxkRXF1YWwoKGZpZWxkT2JqZWN0MSBhcyBhbnkpW2tleV0sIChmaWVsZE9iamVjdDIgYXMgYW55KVtrZXldKSkgcmV0dXJuIGZhbHNlXG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseU1peGlucyhkZXJpdmVkQ3RvcjogYW55LCBjb25zdHJ1Y3RvcnM6IGFueVtdKSB7XG4gIGNvbnN0cnVjdG9ycy5mb3JFYWNoKChiYXNlQ3RvcikgPT4ge1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGJhc2VDdG9yLnByb3RvdHlwZSkuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICBkZXJpdmVkQ3Rvci5wcm90b3R5cGUsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZUN0b3IucHJvdG90eXBlLCBuYW1lKSB8fCBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgKVxuICAgIH0pXG4gIH0pXG59XG5cbmludGVyZmFjZSBBcHBGaWVsZHMge1xuICBmdW5jdGlvbjogTm9kZUNoaWxkPEFzdElkPlxuICBwYXJlbnM6IE9wZW5DbG9zZVRva2VucyB8IHVuZGVmaW5lZFxuICBuYW1lU3BlY2lmaWNhdGlvbjogTmFtZVNwZWNpZmljYXRpb24gfCB1bmRlZmluZWRcbiAgYXJndW1lbnQ6IE5vZGVDaGlsZDxBc3RJZD5cbn1cbmludGVyZmFjZSBPcGVuQ2xvc2VUb2tlbnM8VCBleHRlbmRzIFRyZWVSZWZzID0gUmF3UmVmcz4ge1xuICBvcGVuOiBUWyd0b2tlbiddXG4gIGNsb3NlOiBUWyd0b2tlbiddXG59XG5pbnRlcmZhY2UgTmFtZVNwZWNpZmljYXRpb248VCBleHRlbmRzIFRyZWVSZWZzID0gUmF3UmVmcz4ge1xuICBuYW1lOiBUWyd0b2tlbiddXG4gIGVxdWFsczogVFsndG9rZW4nXVxufVxuZXhwb3J0IGNsYXNzIEFwcCBleHRlbmRzIEFzdCB7XG4gIGRlY2xhcmUgZmllbGRzOiBGaXhlZE1hcDxBc3RGaWVsZHMgJiBBcHBGaWVsZHM+XG4gIGNvbnN0cnVjdG9yKG1vZHVsZTogTW9kdWxlLCBmaWVsZHM6IEZpeGVkTWFwVmlldzxBc3RGaWVsZHMgJiBBcHBGaWVsZHM+KSB7XG4gICAgc3VwZXIobW9kdWxlLCBmaWVsZHMpXG4gIH1cblxuICBzdGF0aWMgdHJ5UGFyc2Uoc291cmNlOiBzdHJpbmcsIG1vZHVsZT86IE11dGFibGVNb2R1bGUpOiBPd25lZDxNdXRhYmxlQXBwPiB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2Uoc291cmNlLCBtb2R1bGUpXG4gICAgaWYgKHBhcnNlZCBpbnN0YW5jZW9mIE11dGFibGVBcHApIHJldHVybiBwYXJzZWRcbiAgfVxuXG4gIHN0YXRpYyBjb25jcmV0ZShcbiAgICBtb2R1bGU6IE11dGFibGVNb2R1bGUsXG4gICAgZnVuYzogTm9kZUNoaWxkPE93bmVkPixcbiAgICBwYXJlbnM6IE9wZW5DbG9zZVRva2VucyB8IHVuZGVmaW5lZCxcbiAgICBuYW1lU3BlY2lmaWNhdGlvbjogTmFtZVNwZWNpZmljYXRpb24gfCB1bmRlZmluZWQsXG4gICAgYXJndW1lbnQ6IE5vZGVDaGlsZDxPd25lZD4sXG4gICkge1xuICAgIGNvbnN0IGJhc2UgPSBtb2R1bGUuYmFzZU9iamVjdCgnQXBwJylcbiAgICBjb25zdCBpZF8gPSBiYXNlLmdldCgnaWQnKVxuICAgIGNvbnN0IGZpZWxkcyA9IGNvbXBvc2VGaWVsZERhdGEoYmFzZSwge1xuICAgICAgZnVuY3Rpb246IGNvbmNyZXRlQ2hpbGQobW9kdWxlLCBmdW5jLCBpZF8pLFxuICAgICAgcGFyZW5zLFxuICAgICAgbmFtZVNwZWNpZmljYXRpb24sXG4gICAgICBhcmd1bWVudDogY29uY3JldGVDaGlsZChtb2R1bGUsIGFyZ3VtZW50LCBpZF8pLFxuICAgIH0pXG4gICAgcmV0dXJuIGFzT3duZWQobmV3IE11dGFibGVBcHAobW9kdWxlLCBmaWVsZHMpKVxuICB9XG5cbiAgc3RhdGljIG5ldyhcbiAgICBtb2R1bGU6IE11dGFibGVNb2R1bGUsXG4gICAgZnVuYzogT3duZWQsXG4gICAgYXJndW1lbnROYW1lOiBTdHJpY3RJZGVudExpa2UgfCB1bmRlZmluZWQsXG4gICAgYXJndW1lbnQ6IE93bmVkLFxuICApIHtcbiAgICByZXR1cm4gQXBwLmNvbmNyZXRlKFxuICAgICAgbW9kdWxlLFxuICAgICAgYXV0b3NwYWNlZChmdW5jKSxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIG5hbWVTcGVjaWZpY2F0aW9uKGFyZ3VtZW50TmFtZSksXG4gICAgICBhdXRvc3BhY2VkKGFyZ3VtZW50KSxcbiAgICApXG4gIH1cblxuICBzdGF0aWMgcG9zaXRpb25hbChmdW5jOiBPd25lZCwgYXJndW1lbnQ6IE93bmVkLCBtb2R1bGU/OiBNdXRhYmxlTW9kdWxlKTogT3duZWQ8TXV0YWJsZUFwcD4ge1xuICAgIHJldHVybiBBcHAubmV3KG1vZHVsZSA/PyBNdXRhYmxlTW9kdWxlLlRyYW5zaWVudCgpLCBmdW5jLCB1bmRlZmluZWQsIGFyZ3VtZW50KVxuICB9XG5cbiAgc3RhdGljIFBvc2l0aW9uYWxTZXF1ZW5jZShmdW5jOiBPd25lZCwgYXJnczogT3duZWRbXSk6IE93bmVkIHtcbiAgICByZXR1cm4gYXJncy5yZWR1Y2UoXG4gICAgICAoZXhwcmVzc2lvbiwgYXJndW1lbnQpID0+IEFwcC5uZXcoZnVuYy5tb2R1bGUsIGV4cHJlc3Npb24sIHVuZGVmaW5lZCwgYXJndW1lbnQpLFxuICAgICAgZnVuYyxcbiAgICApXG4gIH1cblxuICBnZXQgZnVuY3Rpb24oKTogQXN0IHtcbiAgICByZXR1cm4gdGhpcy5tb2R1bGUuZ2V0KHRoaXMuZmllbGRzLmdldCgnZnVuY3Rpb24nKS5ub2RlKVxuICB9XG4gIGdldCBhcmd1bWVudE5hbWUoKTogVG9rZW4gfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLm1vZHVsZS5nZXRUb2tlbih0aGlzLmZpZWxkcy5nZXQoJ25hbWVTcGVjaWZpY2F0aW9uJyk/Lm5hbWUubm9kZSlcbiAgfVxuICBnZXQgYXJndW1lbnQoKTogQXN0IHtcbiAgICByZXR1cm4gdGhpcy5tb2R1bGUuZ2V0KHRoaXMuZmllbGRzLmdldCgnYXJndW1lbnQnKS5ub2RlKVxuICB9XG5cbiAgKmNvbmNyZXRlQ2hpbGRyZW4odmVyYmF0aW0/OiBib29sZWFuKTogSXRlcmFibGVJdGVyYXRvcjxSYXdOb2RlQ2hpbGQ+IHtcbiAgICBjb25zdCB7IGZ1bmN0aW9uOiBmdW5jdGlvbl8sIHBhcmVucywgbmFtZVNwZWNpZmljYXRpb24sIGFyZ3VtZW50IH0gPSBnZXRBbGwodGhpcy5maWVsZHMpXG4gICAgeWllbGQgZW5zdXJlVW5zcGFjZWQoZnVuY3Rpb25fLCB2ZXJiYXRpbSlcbiAgICBjb25zdCB1c2VQYXJlbnMgPSAhIShwYXJlbnMgJiYgKG5hbWVTcGVjaWZpY2F0aW9uIHx8IHZlcmJhdGltKSlcbiAgICBjb25zdCBzcGFjZWRFcXVhbHMgPSB1c2VQYXJlbnMgJiYgISFuYW1lU3BlY2lmaWNhdGlvbj8uZXF1YWxzLndoaXRlc3BhY2VcbiAgICBpZiAodXNlUGFyZW5zKSB5aWVsZCBlbnN1cmVTcGFjZWQocGFyZW5zLm9wZW4sIHZlcmJhdGltKVxuICAgIGlmIChuYW1lU3BlY2lmaWNhdGlvbikge1xuICAgICAgeWllbGQgdXNlUGFyZW5zID9cbiAgICAgICAgcHJlZmVyVW5zcGFjZWQobmFtZVNwZWNpZmljYXRpb24ubmFtZSlcbiAgICAgIDogZW5zdXJlU3BhY2VkKG5hbWVTcGVjaWZpY2F0aW9uLm5hbWUsIHZlcmJhdGltKVxuICAgICAgeWllbGQgZW5zdXJlU3BhY2VkT25seUlmKG5hbWVTcGVjaWZpY2F0aW9uLmVxdWFscywgc3BhY2VkRXF1YWxzLCB2ZXJiYXRpbSlcbiAgICB9XG4gICAgeWllbGQgZW5zdXJlU3BhY2VkT25seUlmKGFyZ3VtZW50LCAhbmFtZVNwZWNpZmljYXRpb24gfHwgc3BhY2VkRXF1YWxzLCB2ZXJiYXRpbSlcbiAgICBpZiAodXNlUGFyZW5zKSB5aWVsZCBwcmVmZXJVbnNwYWNlZChwYXJlbnMuY2xvc2UpXG4gIH1cblxuICBwcmludFN1YnRyZWUoXG4gICAgaW5mbzogU3Bhbk1hcCxcbiAgICBvZmZzZXQ6IG51bWJlcixcbiAgICBwYXJlbnRJbmRlbnQ6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICB2ZXJiYXRpbT86IGJvb2xlYW4sXG4gICk6IHN0cmluZyB7XG4gICAgY29uc3QgdmVyYmF0aW1fID1cbiAgICAgIHZlcmJhdGltID8/ICh0aGlzLmZ1bmN0aW9uIGluc3RhbmNlb2YgSW52YWxpZCB8fCB0aGlzLmFyZ3VtZW50IGluc3RhbmNlb2YgSW52YWxpZClcbiAgICByZXR1cm4gc3VwZXIucHJpbnRTdWJ0cmVlKGluZm8sIG9mZnNldCwgcGFyZW50SW5kZW50LCB2ZXJiYXRpbV8pXG4gIH1cbn1cbmZ1bmN0aW9uIGVuc3VyZVNwYWNlZE9ubHlJZjxUPihcbiAgY2hpbGQ6IE5vZGVDaGlsZDxUPixcbiAgY29uZGl0aW9uOiBib29sZWFuLFxuICB2ZXJiYXRpbTogYm9vbGVhbiB8IHVuZGVmaW5lZCxcbik6IENvbmNyZXRlQ2hpbGQ8VD4ge1xuICByZXR1cm4gY29uZGl0aW9uID8gZW5zdXJlU3BhY2VkKGNoaWxkLCB2ZXJiYXRpbSkgOiBlbnN1cmVVbnNwYWNlZChjaGlsZCwgdmVyYmF0aW0pXG59XG5cbnR5cGUgQ29uY3JldGVDaGlsZDxUPiA9IHsgd2hpdGVzcGFjZTogc3RyaW5nOyBub2RlOiBUIH1cbmZ1bmN0aW9uIGlzQ29uY3JldGU8VD4oY2hpbGQ6IE5vZGVDaGlsZDxUPik6IGNoaWxkIGlzIENvbmNyZXRlQ2hpbGQ8VD4ge1xuICByZXR1cm4gY2hpbGQud2hpdGVzcGFjZSAhPT0gdW5kZWZpbmVkXG59XG5mdW5jdGlvbiB0cnlBc0NvbmNyZXRlPFQ+KGNoaWxkOiBOb2RlQ2hpbGQ8VD4pOiBDb25jcmV0ZUNoaWxkPFQ+IHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIGlzQ29uY3JldGUoY2hpbGQpID8gY2hpbGQgOiB1bmRlZmluZWRcbn1cbmZ1bmN0aW9uIGVuc3VyZVNwYWNlZDxUPihjaGlsZDogTm9kZUNoaWxkPFQ+LCB2ZXJiYXRpbTogYm9vbGVhbiB8IHVuZGVmaW5lZCk6IENvbmNyZXRlQ2hpbGQ8VD4ge1xuICBjb25zdCBjb25jcmV0ZUlucHV0ID0gdHJ5QXNDb25jcmV0ZShjaGlsZClcbiAgaWYgKHZlcmJhdGltICYmIGNvbmNyZXRlSW5wdXQpIHJldHVybiBjb25jcmV0ZUlucHV0XG4gIHJldHVybiBjb25jcmV0ZUlucHV0Py53aGl0ZXNwYWNlID8gY29uY3JldGVJbnB1dCA6IHsgLi4uY2hpbGQsIHdoaXRlc3BhY2U6ICcgJyB9XG59XG5mdW5jdGlvbiBlbnN1cmVVbnNwYWNlZDxUPihjaGlsZDogTm9kZUNoaWxkPFQ+LCB2ZXJiYXRpbTogYm9vbGVhbiB8IHVuZGVmaW5lZCk6IENvbmNyZXRlQ2hpbGQ8VD4ge1xuICBjb25zdCBjb25jcmV0ZUlucHV0ID0gdHJ5QXNDb25jcmV0ZShjaGlsZClcbiAgaWYgKHZlcmJhdGltICYmIGNvbmNyZXRlSW5wdXQpIHJldHVybiBjb25jcmV0ZUlucHV0XG4gIHJldHVybiBjb25jcmV0ZUlucHV0Py53aGl0ZXNwYWNlID09PSAnJyA/IGNvbmNyZXRlSW5wdXQgOiB7IC4uLmNoaWxkLCB3aGl0ZXNwYWNlOiAnJyB9XG59XG5mdW5jdGlvbiBwcmVmZXJTcGFjZWRJZjxUPihjaGlsZDogTm9kZUNoaWxkPFQ+LCBjb25kaXRpb246IGJvb2xlYW4pOiBDb25jcmV0ZUNoaWxkPFQ+IHtcbiAgcmV0dXJuIGNvbmRpdGlvbiA/IHByZWZlclNwYWNlZChjaGlsZCkgOiBwcmVmZXJVbnNwYWNlZChjaGlsZClcbn1cbmZ1bmN0aW9uIHByZWZlclVuc3BhY2VkPFQ+KGNoaWxkOiBOb2RlQ2hpbGQ8VD4pOiBDb25jcmV0ZUNoaWxkPFQ+IHtcbiAgcmV0dXJuIHRyeUFzQ29uY3JldGUoY2hpbGQpID8/IHsgLi4uY2hpbGQsIHdoaXRlc3BhY2U6ICcnIH1cbn1cbmZ1bmN0aW9uIHByZWZlclNwYWNlZDxUPihjaGlsZDogTm9kZUNoaWxkPFQ+KTogQ29uY3JldGVDaGlsZDxUPiB7XG4gIHJldHVybiB0cnlBc0NvbmNyZXRlKGNoaWxkKSA/PyB7IC4uLmNoaWxkLCB3aGl0ZXNwYWNlOiAnICcgfVxufVxuZXhwb3J0IGNsYXNzIE11dGFibGVBcHAgZXh0ZW5kcyBBcHAgaW1wbGVtZW50cyBNdXRhYmxlQXN0IHtcbiAgZGVjbGFyZSByZWFkb25seSBtb2R1bGU6IE11dGFibGVNb2R1bGVcbiAgZGVjbGFyZSByZWFkb25seSBmaWVsZHM6IEZpeGVkTWFwPEFzdEZpZWxkcyAmIEFwcEZpZWxkcz5cblxuICBzZXRGdW5jdGlvbjxUIGV4dGVuZHMgTXV0YWJsZUFzdD4odmFsdWU6IE93bmVkPFQ+KSB7XG4gICAgc2V0Tm9kZSh0aGlzLmZpZWxkcywgJ2Z1bmN0aW9uJywgdGhpcy5jbGFpbUNoaWxkKHZhbHVlKSlcbiAgfVxuICBzZXRBcmd1bWVudE5hbWUobmFtZTogU3RyaWN0SWRlbnRMaWtlIHwgdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5maWVsZHMuc2V0KCduYW1lU3BlY2lmaWNhdGlvbicsIG5hbWVTcGVjaWZpY2F0aW9uKG5hbWUpKVxuICB9XG4gIHNldEFyZ3VtZW50PFQgZXh0ZW5kcyBNdXRhYmxlQXN0Pih2YWx1ZTogT3duZWQ8VD4pIHtcbiAgICBzZXROb2RlKHRoaXMuZmllbGRzLCAnYXJndW1lbnQnLCB0aGlzLmNsYWltQ2hpbGQodmFsdWUpKVxuICB9XG59XG5leHBvcnQgaW50ZXJmYWNlIE11dGFibGVBcHAgZXh0ZW5kcyBBcHAsIE11dGFibGVBc3Qge1xuICBnZXQgZnVuY3Rpb24oKTogTXV0YWJsZUFzdFxuICBnZXQgYXJndW1lbnQoKTogTXV0YWJsZUFzdFxufVxuYXBwbHlNaXhpbnMoTXV0YWJsZUFwcCwgW011dGFibGVBc3RdKVxuXG5pbnRlcmZhY2UgVW5hcnlPcHJBcHBGaWVsZHMge1xuICBvcGVyYXRvcjogTm9kZUNoaWxkPFN5bmNUb2tlbklkPlxuICBhcmd1bWVudDogTm9kZUNoaWxkPEFzdElkPiB8IHVuZGVmaW5lZFxufVxuZXhwb3J0IGNsYXNzIFVuYXJ5T3ByQXBwIGV4dGVuZHMgQXN0IHtcbiAgZGVjbGFyZSBmaWVsZHM6IEZpeGVkTWFwVmlldzxBc3RGaWVsZHMgJiBVbmFyeU9wckFwcEZpZWxkcz5cbiAgY29uc3RydWN0b3IobW9kdWxlOiBNb2R1bGUsIGZpZWxkczogRml4ZWRNYXBWaWV3PEFzdEZpZWxkcyAmIFVuYXJ5T3ByQXBwRmllbGRzPikge1xuICAgIHN1cGVyKG1vZHVsZSwgZmllbGRzKVxuICB9XG5cbiAgc3RhdGljIHRyeVBhcnNlKHNvdXJjZTogc3RyaW5nLCBtb2R1bGU/OiBNdXRhYmxlTW9kdWxlKTogT3duZWQ8TXV0YWJsZVVuYXJ5T3ByQXBwPiB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2Uoc291cmNlLCBtb2R1bGUpXG4gICAgaWYgKHBhcnNlZCBpbnN0YW5jZW9mIE11dGFibGVVbmFyeU9wckFwcCkgcmV0dXJuIHBhcnNlZFxuICB9XG5cbiAgc3RhdGljIGNvbmNyZXRlKFxuICAgIG1vZHVsZTogTXV0YWJsZU1vZHVsZSxcbiAgICBvcGVyYXRvcjogTm9kZUNoaWxkPFRva2VuPixcbiAgICBhcmd1bWVudDogTm9kZUNoaWxkPE93bmVkPiB8IHVuZGVmaW5lZCxcbiAgKSB7XG4gICAgY29uc3QgYmFzZSA9IG1vZHVsZS5iYXNlT2JqZWN0KCdVbmFyeU9wckFwcCcpXG4gICAgY29uc3QgaWRfID0gYmFzZS5nZXQoJ2lkJylcbiAgICBjb25zdCBmaWVsZHMgPSBjb21wb3NlRmllbGREYXRhKGJhc2UsIHtcbiAgICAgIG9wZXJhdG9yLFxuICAgICAgYXJndW1lbnQ6IGNvbmNyZXRlQ2hpbGQobW9kdWxlLCBhcmd1bWVudCwgaWRfKSxcbiAgICB9KVxuICAgIHJldHVybiBhc093bmVkKG5ldyBNdXRhYmxlVW5hcnlPcHJBcHAobW9kdWxlLCBmaWVsZHMpKVxuICB9XG5cbiAgc3RhdGljIG5ldyhtb2R1bGU6IE11dGFibGVNb2R1bGUsIG9wZXJhdG9yOiBUb2tlbiwgYXJndW1lbnQ6IE93bmVkIHwgdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uY3JldGUobW9kdWxlLCB1bnNwYWNlZChvcGVyYXRvciksIGFyZ3VtZW50ID8gYXV0b3NwYWNlZChhcmd1bWVudCkgOiB1bmRlZmluZWQpXG4gIH1cblxuICBnZXQgb3BlcmF0b3IoKTogVG9rZW4ge1xuICAgIHJldHVybiB0aGlzLm1vZHVsZS5nZXRUb2tlbih0aGlzLmZpZWxkcy5nZXQoJ29wZXJhdG9yJykubm9kZSlcbiAgfVxuICBnZXQgYXJndW1lbnQoKTogQXN0IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5tb2R1bGUuZ2V0KHRoaXMuZmllbGRzLmdldCgnYXJndW1lbnQnKT8ubm9kZSlcbiAgfVxuXG4gICpjb25jcmV0ZUNoaWxkcmVuKF92ZXJiYXRpbT86IGJvb2xlYW4pOiBJdGVyYWJsZUl0ZXJhdG9yPFJhd05vZGVDaGlsZD4ge1xuICAgIGNvbnN0IHsgb3BlcmF0b3IsIGFyZ3VtZW50IH0gPSBnZXRBbGwodGhpcy5maWVsZHMpXG4gICAgeWllbGQgb3BlcmF0b3JcbiAgICBpZiAoYXJndW1lbnQpIHlpZWxkIGFyZ3VtZW50XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBNdXRhYmxlVW5hcnlPcHJBcHAgZXh0ZW5kcyBVbmFyeU9wckFwcCBpbXBsZW1lbnRzIE11dGFibGVBc3Qge1xuICBkZWNsYXJlIHJlYWRvbmx5IG1vZHVsZTogTXV0YWJsZU1vZHVsZVxuICBkZWNsYXJlIHJlYWRvbmx5IGZpZWxkczogRml4ZWRNYXA8QXN0RmllbGRzICYgVW5hcnlPcHJBcHBGaWVsZHM+XG5cbiAgc2V0T3BlcmF0b3IodmFsdWU6IFRva2VuKSB7XG4gICAgdGhpcy5maWVsZHMuc2V0KCdvcGVyYXRvcicsIHVuc3BhY2VkKHZhbHVlKSlcbiAgfVxuICBzZXRBcmd1bWVudDxUIGV4dGVuZHMgTXV0YWJsZUFzdD4oYXJndW1lbnQ6IE93bmVkPFQ+IHwgdW5kZWZpbmVkKSB7XG4gICAgc2V0Tm9kZSh0aGlzLmZpZWxkcywgJ2FyZ3VtZW50JywgdGhpcy5jbGFpbUNoaWxkKGFyZ3VtZW50KSlcbiAgfVxufVxuZXhwb3J0IGludGVyZmFjZSBNdXRhYmxlVW5hcnlPcHJBcHAgZXh0ZW5kcyBVbmFyeU9wckFwcCwgTXV0YWJsZUFzdCB7XG4gIGdldCBhcmd1bWVudCgpOiBNdXRhYmxlQXN0IHwgdW5kZWZpbmVkXG59XG5hcHBseU1peGlucyhNdXRhYmxlVW5hcnlPcHJBcHAsIFtNdXRhYmxlQXN0XSlcblxuaW50ZXJmYWNlIE5lZ2F0aW9uQXBwRmllbGRzIHtcbiAgb3BlcmF0b3I6IE5vZGVDaGlsZDxTeW5jVG9rZW5JZD5cbiAgYXJndW1lbnQ6IE5vZGVDaGlsZDxBc3RJZD5cbn1cbmV4cG9ydCBjbGFzcyBOZWdhdGlvbkFwcCBleHRlbmRzIEFzdCB7XG4gIGRlY2xhcmUgZmllbGRzOiBGaXhlZE1hcFZpZXc8QXN0RmllbGRzICYgTmVnYXRpb25BcHBGaWVsZHM+XG4gIGNvbnN0cnVjdG9yKG1vZHVsZTogTW9kdWxlLCBmaWVsZHM6IEZpeGVkTWFwVmlldzxBc3RGaWVsZHMgJiBOZWdhdGlvbkFwcEZpZWxkcz4pIHtcbiAgICBzdXBlcihtb2R1bGUsIGZpZWxkcylcbiAgfVxuXG4gIHN0YXRpYyB0cnlQYXJzZShzb3VyY2U6IHN0cmluZywgbW9kdWxlPzogTXV0YWJsZU1vZHVsZSk6IE93bmVkPE11dGFibGVOZWdhdGlvbkFwcD4gfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlKHNvdXJjZSwgbW9kdWxlKVxuICAgIGlmIChwYXJzZWQgaW5zdGFuY2VvZiBNdXRhYmxlTmVnYXRpb25BcHApIHJldHVybiBwYXJzZWRcbiAgfVxuXG4gIHN0YXRpYyBjb25jcmV0ZShtb2R1bGU6IE11dGFibGVNb2R1bGUsIG9wZXJhdG9yOiBOb2RlQ2hpbGQ8VG9rZW4+LCBhcmd1bWVudDogTm9kZUNoaWxkPE93bmVkPikge1xuICAgIGNvbnN0IGJhc2UgPSBtb2R1bGUuYmFzZU9iamVjdCgnTmVnYXRpb25BcHAnKVxuICAgIGNvbnN0IGlkXyA9IGJhc2UuZ2V0KCdpZCcpXG4gICAgY29uc3QgZmllbGRzID0gY29tcG9zZUZpZWxkRGF0YShiYXNlLCB7XG4gICAgICBvcGVyYXRvcixcbiAgICAgIGFyZ3VtZW50OiBjb25jcmV0ZUNoaWxkKG1vZHVsZSwgYXJndW1lbnQsIGlkXyksXG4gICAgfSlcbiAgICByZXR1cm4gYXNPd25lZChuZXcgTXV0YWJsZU5lZ2F0aW9uQXBwKG1vZHVsZSwgZmllbGRzKSlcbiAgfVxuXG4gIHN0YXRpYyBuZXcobW9kdWxlOiBNdXRhYmxlTW9kdWxlLCBvcGVyYXRvcjogVG9rZW4sIGFyZ3VtZW50OiBPd25lZCkge1xuICAgIHJldHVybiB0aGlzLmNvbmNyZXRlKG1vZHVsZSwgdW5zcGFjZWQob3BlcmF0b3IpLCBhdXRvc3BhY2VkKGFyZ3VtZW50KSlcbiAgfVxuXG4gIGdldCBvcGVyYXRvcigpOiBUb2tlbiB7XG4gICAgcmV0dXJuIHRoaXMubW9kdWxlLmdldFRva2VuKHRoaXMuZmllbGRzLmdldCgnb3BlcmF0b3InKS5ub2RlKVxuICB9XG4gIGdldCBhcmd1bWVudCgpOiBBc3Qge1xuICAgIHJldHVybiB0aGlzLm1vZHVsZS5nZXQodGhpcy5maWVsZHMuZ2V0KCdhcmd1bWVudCcpLm5vZGUpXG4gIH1cblxuICAqY29uY3JldGVDaGlsZHJlbihfdmVyYmF0aW0/OiBib29sZWFuKTogSXRlcmFibGVJdGVyYXRvcjxSYXdOb2RlQ2hpbGQ+IHtcbiAgICBjb25zdCB7IG9wZXJhdG9yLCBhcmd1bWVudCB9ID0gZ2V0QWxsKHRoaXMuZmllbGRzKVxuICAgIHlpZWxkIG9wZXJhdG9yXG4gICAgaWYgKGFyZ3VtZW50KSB5aWVsZCBhcmd1bWVudFxuICB9XG59XG5leHBvcnQgY2xhc3MgTXV0YWJsZU5lZ2F0aW9uQXBwIGV4dGVuZHMgTmVnYXRpb25BcHAgaW1wbGVtZW50cyBNdXRhYmxlQXN0IHtcbiAgZGVjbGFyZSByZWFkb25seSBtb2R1bGU6IE11dGFibGVNb2R1bGVcbiAgZGVjbGFyZSByZWFkb25seSBmaWVsZHM6IEZpeGVkTWFwPEFzdEZpZWxkcyAmIE5lZ2F0aW9uQXBwRmllbGRzPlxuXG4gIHNldEFyZ3VtZW50PFQgZXh0ZW5kcyBNdXRhYmxlQXN0Pih2YWx1ZTogT3duZWQ8VD4pIHtcbiAgICBzZXROb2RlKHRoaXMuZmllbGRzLCAnYXJndW1lbnQnLCB0aGlzLmNsYWltQ2hpbGQodmFsdWUpKVxuICB9XG59XG5leHBvcnQgaW50ZXJmYWNlIE11dGFibGVOZWdhdGlvbkFwcCBleHRlbmRzIE5lZ2F0aW9uQXBwLCBNdXRhYmxlQXN0IHtcbiAgZ2V0IGFyZ3VtZW50KCk6IE11dGFibGVBc3Rcbn1cbmFwcGx5TWl4aW5zKE11dGFibGVOZWdhdGlvbkFwcCwgW011dGFibGVBc3RdKVxuXG5pbnRlcmZhY2UgT3ByQXBwRmllbGRzIHtcbiAgbGhzOiBOb2RlQ2hpbGQ8QXN0SWQ+IHwgdW5kZWZpbmVkXG4gIG9wZXJhdG9yczogTm9kZUNoaWxkPFN5bmNUb2tlbklkPltdXG4gIHJoczogTm9kZUNoaWxkPEFzdElkPiB8IHVuZGVmaW5lZFxufVxuZXhwb3J0IGNsYXNzIE9wckFwcCBleHRlbmRzIEFzdCB7XG4gIGRlY2xhcmUgZmllbGRzOiBGaXhlZE1hcFZpZXc8QXN0RmllbGRzICYgT3ByQXBwRmllbGRzPlxuICBjb25zdHJ1Y3Rvcihtb2R1bGU6IE1vZHVsZSwgZmllbGRzOiBGaXhlZE1hcFZpZXc8QXN0RmllbGRzICYgT3ByQXBwRmllbGRzPikge1xuICAgIHN1cGVyKG1vZHVsZSwgZmllbGRzKVxuICB9XG5cbiAgc3RhdGljIHRyeVBhcnNlKHNvdXJjZTogc3RyaW5nLCBtb2R1bGU/OiBNdXRhYmxlTW9kdWxlKTogT3duZWQ8TXV0YWJsZU9wckFwcD4gfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlKHNvdXJjZSwgbW9kdWxlKVxuICAgIGlmIChwYXJzZWQgaW5zdGFuY2VvZiBNdXRhYmxlT3ByQXBwKSByZXR1cm4gcGFyc2VkXG4gIH1cblxuICBzdGF0aWMgY29uY3JldGUoXG4gICAgbW9kdWxlOiBNdXRhYmxlTW9kdWxlLFxuICAgIGxoczogTm9kZUNoaWxkPE93bmVkPiB8IHVuZGVmaW5lZCxcbiAgICBvcGVyYXRvcnM6IE5vZGVDaGlsZDxUb2tlbj5bXSxcbiAgICByaHM6IE5vZGVDaGlsZDxPd25lZD4gfCB1bmRlZmluZWQsXG4gICkge1xuICAgIGNvbnN0IGJhc2UgPSBtb2R1bGUuYmFzZU9iamVjdCgnT3ByQXBwJylcbiAgICBjb25zdCBpZF8gPSBiYXNlLmdldCgnaWQnKVxuICAgIGNvbnN0IGZpZWxkcyA9IGNvbXBvc2VGaWVsZERhdGEoYmFzZSwge1xuICAgICAgbGhzOiBjb25jcmV0ZUNoaWxkKG1vZHVsZSwgbGhzLCBpZF8pLFxuICAgICAgb3BlcmF0b3JzLFxuICAgICAgcmhzOiBjb25jcmV0ZUNoaWxkKG1vZHVsZSwgcmhzLCBpZF8pLFxuICAgIH0pXG4gICAgcmV0dXJuIGFzT3duZWQobmV3IE11dGFibGVPcHJBcHAobW9kdWxlLCBmaWVsZHMpKVxuICB9XG5cbiAgc3RhdGljIG5ldyhcbiAgICBtb2R1bGU6IE11dGFibGVNb2R1bGUsXG4gICAgbGhzOiBPd25lZCB8IHVuZGVmaW5lZCxcbiAgICBvcGVyYXRvcjogVG9rZW4gfCBzdHJpbmcsXG4gICAgcmhzOiBPd25lZCB8IHVuZGVmaW5lZCxcbiAgKSB7XG4gICAgY29uc3Qgb3BlcmF0b3JUb2tlbiA9XG4gICAgICBvcGVyYXRvciBpbnN0YW5jZW9mIFRva2VuID8gb3BlcmF0b3IgOiBUb2tlbi5uZXcob3BlcmF0b3IsIFJhd0FzdC5Ub2tlbi5UeXBlLk9wZXJhdG9yKVxuICAgIHJldHVybiBPcHJBcHAuY29uY3JldGUobW9kdWxlLCB1bnNwYWNlZChsaHMpLCBbYXV0b3NwYWNlZChvcGVyYXRvclRva2VuKV0sIGF1dG9zcGFjZWQocmhzKSlcbiAgfVxuXG4gIGdldCBsaHMoKTogQXN0IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5tb2R1bGUuZ2V0KHRoaXMuZmllbGRzLmdldCgnbGhzJyk/Lm5vZGUpXG4gIH1cbiAgZ2V0IG9wZXJhdG9yKCk6IFJlc3VsdDxUb2tlbiwgTm9kZUNoaWxkPFRva2VuPltdPiB7XG4gICAgY29uc3Qgb3BlcmF0b3JzID0gdGhpcy5maWVsZHMuZ2V0KCdvcGVyYXRvcnMnKVxuICAgIGNvbnN0IG9wZXJhdG9yc18gPSBvcGVyYXRvcnMubWFwKChjaGlsZCkgPT4gKHtcbiAgICAgIC4uLmNoaWxkLFxuICAgICAgbm9kZTogdGhpcy5tb2R1bGUuZ2V0VG9rZW4oY2hpbGQubm9kZSksXG4gICAgfSkpXG4gICAgY29uc3QgW29wcl0gPSBvcGVyYXRvcnNfXG4gICAgcmV0dXJuIG9wciA/IE9rKG9wci5ub2RlKSA6IEVycihvcGVyYXRvcnNfKVxuICB9XG4gIGdldCByaHMoKTogQXN0IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5tb2R1bGUuZ2V0KHRoaXMuZmllbGRzLmdldCgncmhzJyk/Lm5vZGUpXG4gIH1cblxuICAqY29uY3JldGVDaGlsZHJlbihfdmVyYmF0aW0/OiBib29sZWFuKTogSXRlcmFibGVJdGVyYXRvcjxSYXdOb2RlQ2hpbGQ+IHtcbiAgICBjb25zdCB7IGxocywgb3BlcmF0b3JzLCByaHMgfSA9IGdldEFsbCh0aGlzLmZpZWxkcylcbiAgICBpZiAobGhzKSB5aWVsZCBsaHNcbiAgICB5aWVsZCogb3BlcmF0b3JzXG4gICAgaWYgKHJocykgeWllbGQgcmhzXG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBNdXRhYmxlT3ByQXBwIGV4dGVuZHMgT3ByQXBwIGltcGxlbWVudHMgTXV0YWJsZUFzdCB7XG4gIGRlY2xhcmUgcmVhZG9ubHkgbW9kdWxlOiBNdXRhYmxlTW9kdWxlXG4gIGRlY2xhcmUgcmVhZG9ubHkgZmllbGRzOiBGaXhlZE1hcDxBc3RGaWVsZHMgJiBPcHJBcHBGaWVsZHM+XG5cbiAgc2V0TGhzPFQgZXh0ZW5kcyBNdXRhYmxlQXN0Pih2YWx1ZTogT3duZWQ8VD4pIHtcbiAgICBzZXROb2RlKHRoaXMuZmllbGRzLCAnbGhzJywgdGhpcy5jbGFpbUNoaWxkKHZhbHVlKSlcbiAgfVxuICBzZXRPcGVyYXRvcih2YWx1ZTogVG9rZW4pIHtcbiAgICB0aGlzLmZpZWxkcy5zZXQoJ29wZXJhdG9ycycsIFt1bnNwYWNlZCh2YWx1ZSldKVxuICB9XG4gIHNldFJoczxUIGV4dGVuZHMgTXV0YWJsZUFzdD4odmFsdWU6IE93bmVkPFQ+KSB7XG4gICAgc2V0Tm9kZSh0aGlzLmZpZWxkcywgJ3JocycsIHRoaXMuY2xhaW1DaGlsZCh2YWx1ZSkpXG4gIH1cbn1cbmV4cG9ydCBpbnRlcmZhY2UgTXV0YWJsZU9wckFwcCBleHRlbmRzIE9wckFwcCwgTXV0YWJsZUFzdCB7XG4gIGdldCBsaHMoKTogTXV0YWJsZUFzdCB8IHVuZGVmaW5lZFxuICBnZXQgcmhzKCk6IE11dGFibGVBc3QgfCB1bmRlZmluZWRcbn1cbmFwcGx5TWl4aW5zKE11dGFibGVPcHJBcHAsIFtNdXRhYmxlQXN0XSlcblxuaW50ZXJmYWNlIFByb3BlcnR5QWNjZXNzRmllbGRzIHtcbiAgbGhzOiBOb2RlQ2hpbGQ8QXN0SWQ+IHwgdW5kZWZpbmVkXG4gIG9wZXJhdG9yOiBOb2RlQ2hpbGQ8U3luY1Rva2VuSWQ+XG4gIHJoczogTm9kZUNoaWxkPEFzdElkPlxufVxuZXhwb3J0IGNsYXNzIFByb3BlcnR5QWNjZXNzIGV4dGVuZHMgQXN0IHtcbiAgZGVjbGFyZSBmaWVsZHM6IEZpeGVkTWFwVmlldzxBc3RGaWVsZHMgJiBQcm9wZXJ0eUFjY2Vzc0ZpZWxkcz5cbiAgY29uc3RydWN0b3IobW9kdWxlOiBNb2R1bGUsIGZpZWxkczogRml4ZWRNYXBWaWV3PEFzdEZpZWxkcyAmIFByb3BlcnR5QWNjZXNzRmllbGRzPikge1xuICAgIHN1cGVyKG1vZHVsZSwgZmllbGRzKVxuICB9XG5cbiAgc3RhdGljIHRyeVBhcnNlKFxuICAgIHNvdXJjZTogc3RyaW5nLFxuICAgIG1vZHVsZT86IE11dGFibGVNb2R1bGUsXG4gICk6IE93bmVkPE11dGFibGVQcm9wZXJ0eUFjY2Vzcz4gfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlKHNvdXJjZSwgbW9kdWxlKVxuICAgIGlmIChwYXJzZWQgaW5zdGFuY2VvZiBNdXRhYmxlUHJvcGVydHlBY2Nlc3MpIHJldHVybiBwYXJzZWRcbiAgfVxuXG4gIHN0YXRpYyBuZXcobW9kdWxlOiBNdXRhYmxlTW9kdWxlLCBsaHM6IE93bmVkLCByaHM6IElkZW50TGlrZSwgc3R5bGU/OiB7IHNwYWNlZD86IGJvb2xlYW4gfSkge1xuICAgIGNvbnN0IGRvdCA9IFRva2VuLm5ldygnLicsIFJhd0FzdC5Ub2tlbi5UeXBlLk9wZXJhdG9yKVxuICAgIGNvbnN0IHdoaXRlc3BhY2UgPSBzdHlsZT8uc3BhY2VkID8gJyAnIDogJydcbiAgICByZXR1cm4gdGhpcy5jb25jcmV0ZShcbiAgICAgIG1vZHVsZSxcbiAgICAgIHVuc3BhY2VkKGxocyksXG4gICAgICB7IHdoaXRlc3BhY2UsIG5vZGU6IGRvdCB9LFxuICAgICAgeyB3aGl0ZXNwYWNlLCBub2RlOiBJZGVudC5uZXdBbGxvd2luZ09wZXJhdG9ycyhtb2R1bGUsIHRvSWRlbnQocmhzKSkgfSxcbiAgICApXG4gIH1cblxuICBzdGF0aWMgU2VxdWVuY2UoXG4gICAgc2VnbWVudHM6IFtTdHJpY3RJZGVudExpa2UsIC4uLlN0cmljdElkZW50TGlrZVtdXSxcbiAgICBtb2R1bGU6IE11dGFibGVNb2R1bGUsXG4gICk6IE93bmVkPE11dGFibGVQcm9wZXJ0eUFjY2Vzcz4gfCBPd25lZDxNdXRhYmxlSWRlbnQ+XG4gIHN0YXRpYyBTZXF1ZW5jZShcbiAgICBzZWdtZW50czogW1N0cmljdElkZW50TGlrZSwgLi4uU3RyaWN0SWRlbnRMaWtlW10sIElkZW50TGlrZV0sXG4gICAgbW9kdWxlOiBNdXRhYmxlTW9kdWxlLFxuICApOiBPd25lZDxNdXRhYmxlUHJvcGVydHlBY2Nlc3M+IHwgT3duZWQ8TXV0YWJsZUlkZW50PlxuICBzdGF0aWMgU2VxdWVuY2UoXG4gICAgc2VnbWVudHM6IElkZW50TGlrZVtdLFxuICAgIG1vZHVsZTogTXV0YWJsZU1vZHVsZSxcbiAgKTogT3duZWQ8TXV0YWJsZVByb3BlcnR5QWNjZXNzPiB8IE93bmVkPE11dGFibGVJZGVudD4gfCB1bmRlZmluZWRcbiAgc3RhdGljIFNlcXVlbmNlKFxuICAgIHNlZ21lbnRzOiBJZGVudExpa2VbXSxcbiAgICBtb2R1bGU6IE11dGFibGVNb2R1bGUsXG4gICk6IE93bmVkPE11dGFibGVQcm9wZXJ0eUFjY2Vzcz4gfCBPd25lZDxNdXRhYmxlSWRlbnQ+IHwgdW5kZWZpbmVkIHtcbiAgICBsZXQgcGF0aDogT3duZWQ8TXV0YWJsZVByb3BlcnR5QWNjZXNzPiB8IE93bmVkPE11dGFibGVJZGVudD4gfCB1bmRlZmluZWRcbiAgICBsZXQgb3BlcmF0b3JJbk5vbkZpbmFsU2VnbWVudCA9IGZhbHNlXG4gICAgc2VnbWVudHMuZm9yRWFjaCgocywgaSkgPT4ge1xuICAgICAgY29uc3QgdCA9IHRvSWRlbnQocylcbiAgICAgIGlmIChpICE9PSBzZWdtZW50cy5sZW5ndGggLSAxICYmICFpc0lkZW50aWZpZXIodC5jb2RlKCkpKSBvcGVyYXRvckluTm9uRmluYWxTZWdtZW50ID0gdHJ1ZVxuICAgICAgcGF0aCA9IHBhdGggPyB0aGlzLm5ldyhtb2R1bGUsIHBhdGgsIHQpIDogSWRlbnQubmV3QWxsb3dpbmdPcGVyYXRvcnMobW9kdWxlLCB0KVxuICAgIH0pXG4gICAgaWYgKCFvcGVyYXRvckluTm9uRmluYWxTZWdtZW50KSByZXR1cm4gcGF0aFxuICB9XG5cbiAgc3RhdGljIGNvbmNyZXRlKFxuICAgIG1vZHVsZTogTXV0YWJsZU1vZHVsZSxcbiAgICBsaHM6IE5vZGVDaGlsZDxPd25lZD4gfCB1bmRlZmluZWQsXG4gICAgb3BlcmF0b3I6IE5vZGVDaGlsZDxUb2tlbj4sXG4gICAgcmhzOiBOb2RlQ2hpbGQ8T3duZWQ8TXV0YWJsZUlkZW50Pj4sXG4gICkge1xuICAgIGNvbnN0IGJhc2UgPSBtb2R1bGUuYmFzZU9iamVjdCgnUHJvcGVydHlBY2Nlc3MnKVxuICAgIGNvbnN0IGlkXyA9IGJhc2UuZ2V0KCdpZCcpXG4gICAgY29uc3QgZmllbGRzID0gY29tcG9zZUZpZWxkRGF0YShiYXNlLCB7XG4gICAgICBsaHM6IGNvbmNyZXRlQ2hpbGQobW9kdWxlLCBsaHMsIGlkXyksXG4gICAgICBvcGVyYXRvcixcbiAgICAgIHJoczogY29uY3JldGVDaGlsZChtb2R1bGUsIHJocywgaWRfKSxcbiAgICB9KVxuICAgIHJldHVybiBhc093bmVkKG5ldyBNdXRhYmxlUHJvcGVydHlBY2Nlc3MobW9kdWxlLCBmaWVsZHMpKVxuICB9XG5cbiAgZ2V0IGxocygpOiBBc3QgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLm1vZHVsZS5nZXQodGhpcy5maWVsZHMuZ2V0KCdsaHMnKT8ubm9kZSlcbiAgfVxuICBnZXQgb3BlcmF0b3IoKTogVG9rZW4ge1xuICAgIHJldHVybiB0aGlzLm1vZHVsZS5nZXRUb2tlbih0aGlzLmZpZWxkcy5nZXQoJ29wZXJhdG9yJykubm9kZSlcbiAgfVxuICBnZXQgcmhzKCk6IElkZW50aWZpZXJPck9wZXJhdG9ySWRlbnRpZmllclRva2VuIHtcbiAgICBjb25zdCBhc3QgPSB0aGlzLm1vZHVsZS5nZXQodGhpcy5maWVsZHMuZ2V0KCdyaHMnKS5ub2RlKVxuICAgIGFzc2VydChhc3QgaW5zdGFuY2VvZiBJZGVudClcbiAgICByZXR1cm4gYXN0LnRva2VuIGFzIElkZW50aWZpZXJPck9wZXJhdG9ySWRlbnRpZmllclRva2VuXG4gIH1cblxuICAqY29uY3JldGVDaGlsZHJlbihfdmVyYmF0aW0/OiBib29sZWFuKTogSXRlcmFibGVJdGVyYXRvcjxSYXdOb2RlQ2hpbGQ+IHtcbiAgICBjb25zdCB7IGxocywgb3BlcmF0b3IsIHJocyB9ID0gZ2V0QWxsKHRoaXMuZmllbGRzKVxuICAgIGlmIChsaHMpIHlpZWxkIGxoc1xuICAgIHlpZWxkIG9wZXJhdG9yXG4gICAgeWllbGQgcmhzXG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBNdXRhYmxlUHJvcGVydHlBY2Nlc3MgZXh0ZW5kcyBQcm9wZXJ0eUFjY2VzcyBpbXBsZW1lbnRzIE11dGFibGVBc3Qge1xuICBkZWNsYXJlIHJlYWRvbmx5IG1vZHVsZTogTXV0YWJsZU1vZHVsZVxuICBkZWNsYXJlIHJlYWRvbmx5IGZpZWxkczogRml4ZWRNYXA8QXN0RmllbGRzICYgUHJvcGVydHlBY2Nlc3NGaWVsZHM+XG5cbiAgc2V0TGhzPFQgZXh0ZW5kcyBNdXRhYmxlQXN0Pih2YWx1ZTogT3duZWQ8VD4gfCB1bmRlZmluZWQpIHtcbiAgICBzZXROb2RlKHRoaXMuZmllbGRzLCAnbGhzJywgdGhpcy5jbGFpbUNoaWxkKHZhbHVlKSlcbiAgfVxuICBzZXRSaHMoaWRlbnQ6IElkZW50TGlrZSkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLmNsYWltQ2hpbGQoSWRlbnQubmV3QWxsb3dpbmdPcGVyYXRvcnModGhpcy5tb2R1bGUsIGlkZW50KSlcbiAgICBjb25zdCBvbGQgPSB0aGlzLmZpZWxkcy5nZXQoJ3JocycpXG4gICAgdGhpcy5maWVsZHMuc2V0KCdyaHMnLCBvbGQgPyB7IC4uLm9sZCwgbm9kZSB9IDogdW5zcGFjZWQobm9kZSkpXG4gIH1cbn1cbmV4cG9ydCBpbnRlcmZhY2UgTXV0YWJsZVByb3BlcnR5QWNjZXNzIGV4dGVuZHMgUHJvcGVydHlBY2Nlc3MsIE11dGFibGVBc3Qge1xuICBnZXQgbGhzKCk6IE11dGFibGVBc3QgfCB1bmRlZmluZWRcbn1cbmFwcGx5TWl4aW5zKE11dGFibGVQcm9wZXJ0eUFjY2VzcywgW011dGFibGVBc3RdKVxuXG4vKiogVW5yb2xsIHRoZSBwcm92aWRlZCBjaGFpbiBvZiBgUHJvcGVydHlBY2Nlc3NgIG5vZGVzLCByZXR1cm5pbmcgdGhlIGZpcnN0IG5vbi1hY2Nlc3MgYXMgYHN1YmplY3RgIGFuZCB0aGUgYWNjZXNzZXNcbiAqICBmcm9tIGxlZnQtdG8tcmlnaHQuICovXG5leHBvcnQgZnVuY3Rpb24gYWNjZXNzQ2hhaW4oYXN0OiBBc3QpOiB7IHN1YmplY3Q6IEFzdDsgYWNjZXNzQ2hhaW46IFByb3BlcnR5QWNjZXNzW10gfSB7XG4gIGNvbnN0IGFjY2Vzc0NoYWluID0gbmV3IEFycmF5PFByb3BlcnR5QWNjZXNzPigpXG4gIHdoaWxlIChhc3QgaW5zdGFuY2VvZiBQcm9wZXJ0eUFjY2VzcyAmJiBhc3QubGhzKSB7XG4gICAgYWNjZXNzQ2hhaW4ucHVzaChhc3QpXG4gICAgYXN0ID0gYXN0Lmxoc1xuICB9XG4gIGFjY2Vzc0NoYWluLnJldmVyc2UoKVxuICByZXR1cm4geyBzdWJqZWN0OiBhc3QsIGFjY2Vzc0NoYWluIH1cbn1cblxuaW50ZXJmYWNlIEdlbmVyaWNGaWVsZHMge1xuICBjaGlsZHJlbjogUmF3Tm9kZUNoaWxkW11cbn1cbmV4cG9ydCBjbGFzcyBHZW5lcmljIGV4dGVuZHMgQXN0IHtcbiAgZGVjbGFyZSBmaWVsZHM6IEZpeGVkTWFwVmlldzxBc3RGaWVsZHMgJiBHZW5lcmljRmllbGRzPlxuICBjb25zdHJ1Y3Rvcihtb2R1bGU6IE1vZHVsZSwgZmllbGRzOiBGaXhlZE1hcFZpZXc8QXN0RmllbGRzICYgR2VuZXJpY0ZpZWxkcz4pIHtcbiAgICBzdXBlcihtb2R1bGUsIGZpZWxkcylcbiAgfVxuXG4gIHN0YXRpYyBjb25jcmV0ZShtb2R1bGU6IE11dGFibGVNb2R1bGUsIGNoaWxkcmVuOiAoTm9kZUNoaWxkPE93bmVkPiB8IE5vZGVDaGlsZDxUb2tlbj4pW10pIHtcbiAgICBjb25zdCBiYXNlID0gbW9kdWxlLmJhc2VPYmplY3QoJ0dlbmVyaWMnKVxuICAgIGNvbnN0IGlkXyA9IGJhc2UuZ2V0KCdpZCcpXG4gICAgY29uc3QgZmllbGRzID0gY29tcG9zZUZpZWxkRGF0YShiYXNlLCB7XG4gICAgICBjaGlsZHJlbjogY2hpbGRyZW4ubWFwKChjaGlsZCkgPT4gY29uY3JldGVDaGlsZChtb2R1bGUsIGNoaWxkLCBpZF8pKSxcbiAgICB9KVxuICAgIHJldHVybiBhc093bmVkKG5ldyBNdXRhYmxlR2VuZXJpYyhtb2R1bGUsIGZpZWxkcykpXG4gIH1cblxuICBjb25jcmV0ZUNoaWxkcmVuKF92ZXJiYXRpbT86IGJvb2xlYW4pOiBJdGVyYWJsZUl0ZXJhdG9yPFJhd05vZGVDaGlsZD4ge1xuICAgIHJldHVybiB0aGlzLmZpZWxkcy5nZXQoJ2NoaWxkcmVuJylbU3ltYm9sLml0ZXJhdG9yXSgpXG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBNdXRhYmxlR2VuZXJpYyBleHRlbmRzIEdlbmVyaWMgaW1wbGVtZW50cyBNdXRhYmxlQXN0IHtcbiAgZGVjbGFyZSByZWFkb25seSBtb2R1bGU6IE11dGFibGVNb2R1bGVcbiAgZGVjbGFyZSByZWFkb25seSBmaWVsZHM6IEZpeGVkTWFwPEFzdEZpZWxkcyAmIEdlbmVyaWNGaWVsZHM+XG59XG5leHBvcnQgaW50ZXJmYWNlIE11dGFibGVHZW5lcmljIGV4dGVuZHMgR2VuZXJpYywgTXV0YWJsZUFzdCB7fVxuYXBwbHlNaXhpbnMoTXV0YWJsZUdlbmVyaWMsIFtNdXRhYmxlQXN0XSlcblxuaW50ZXJmYWNlIE11bHRpU2VnbWVudEFwcFNlZ21lbnQ8VCBleHRlbmRzIFRyZWVSZWZzID0gUmF3UmVmcz4ge1xuICBoZWFkZXI6IFRbJ3Rva2VuJ11cbiAgYm9keTogVFsnYXN0J10gfCB1bmRlZmluZWRcbn1cbmZ1bmN0aW9uIG11bHRpU2VnbWVudEFwcFNlZ21lbnQ8VCBleHRlbmRzIE11dGFibGVBc3Q+KFxuICBoZWFkZXI6IHN0cmluZyxcbiAgYm9keTogT3duZWQ8VD4sXG4pOiBNdWx0aVNlZ21lbnRBcHBTZWdtZW50PE93bmVkUmVmcz5cbmZ1bmN0aW9uIG11bHRpU2VnbWVudEFwcFNlZ21lbnQ8VCBleHRlbmRzIE11dGFibGVBc3Q+KFxuICBoZWFkZXI6IHN0cmluZyxcbiAgYm9keTogT3duZWQ8VD4gfCB1bmRlZmluZWQsXG4pOiBNdWx0aVNlZ21lbnRBcHBTZWdtZW50PE93bmVkUmVmcz4gfCB1bmRlZmluZWRcbmZ1bmN0aW9uIG11bHRpU2VnbWVudEFwcFNlZ21lbnQ8VCBleHRlbmRzIE11dGFibGVBc3Q+KFxuICBoZWFkZXI6IHN0cmluZyxcbiAgYm9keTogT3duZWQ8VD4gfCB1bmRlZmluZWQsXG4pOiBNdWx0aVNlZ21lbnRBcHBTZWdtZW50PE93bmVkUmVmcz4gfCB1bmRlZmluZWQge1xuICByZXR1cm4ge1xuICAgIGhlYWRlcjogYXV0b3NwYWNlZChUb2tlbi5uZXcoaGVhZGVyLCBSYXdBc3QuVG9rZW4uVHlwZS5JZGVudCkpLFxuICAgIGJvZHk6IHNwYWNlZChib2R5ID8gKGJvZHkgYXMgYW55KSA6IHVuZGVmaW5lZCksXG4gIH1cbn1cblxuZnVuY3Rpb24gbXVsdGlTZWdtZW50QXBwU2VnbWVudFRvUmF3KFxuICBtb2R1bGU6IE11dGFibGVNb2R1bGUsXG4gIG1zYXM6IE11bHRpU2VnbWVudEFwcFNlZ21lbnQ8T3duZWRSZWZzPiB8IHVuZGVmaW5lZCxcbiAgcGFyZW50OiBBc3RJZCxcbik6IE11bHRpU2VnbWVudEFwcFNlZ21lbnQgfCB1bmRlZmluZWQge1xuICBpZiAoIW1zYXMpIHJldHVybiB1bmRlZmluZWRcbiAgcmV0dXJuIHtcbiAgICAuLi5tc2FzLFxuICAgIGJvZHk6IGNvbmNyZXRlQ2hpbGQobW9kdWxlLCBtc2FzLmJvZHksIHBhcmVudCksXG4gIH1cbn1cbmludGVyZmFjZSBJbXBvcnRGaWVsZHM8VCBleHRlbmRzIFRyZWVSZWZzID0gUmF3UmVmcz4gZXh0ZW5kcyBGaWVsZE9iamVjdDxUPiB7XG4gIHBvbHlnbG90OiBNdWx0aVNlZ21lbnRBcHBTZWdtZW50PFQ+IHwgdW5kZWZpbmVkXG4gIGZyb206IE11bHRpU2VnbWVudEFwcFNlZ21lbnQ8VD4gfCB1bmRlZmluZWRcbiAgaW1wb3J0OiBNdWx0aVNlZ21lbnRBcHBTZWdtZW50PFQ+XG4gIGFsbDogVFsndG9rZW4nXSB8IHVuZGVmaW5lZFxuICBhczogTXVsdGlTZWdtZW50QXBwU2VnbWVudDxUPiB8IHVuZGVmaW5lZFxuICBoaWRpbmc6IE11bHRpU2VnbWVudEFwcFNlZ21lbnQ8VD4gfCB1bmRlZmluZWRcbn1cblxuZXhwb3J0IGNsYXNzIEltcG9ydCBleHRlbmRzIEFzdCB7XG4gIGRlY2xhcmUgZmllbGRzOiBGaXhlZE1hcFZpZXc8QXN0RmllbGRzICYgSW1wb3J0RmllbGRzPlxuICBjb25zdHJ1Y3Rvcihtb2R1bGU6IE1vZHVsZSwgZmllbGRzOiBGaXhlZE1hcFZpZXc8QXN0RmllbGRzICYgSW1wb3J0RmllbGRzPikge1xuICAgIHN1cGVyKG1vZHVsZSwgZmllbGRzKVxuICB9XG5cbiAgc3RhdGljIHRyeVBhcnNlKHNvdXJjZTogc3RyaW5nLCBtb2R1bGU/OiBNdXRhYmxlTW9kdWxlKTogT3duZWQ8TXV0YWJsZUltcG9ydD4gfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlKHNvdXJjZSwgbW9kdWxlKVxuICAgIGlmIChwYXJzZWQgaW5zdGFuY2VvZiBNdXRhYmxlSW1wb3J0KSByZXR1cm4gcGFyc2VkXG4gIH1cblxuICBnZXQgcG9seWdsb3QoKTogQXN0IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5tb2R1bGUuZ2V0KHRoaXMuZmllbGRzLmdldCgncG9seWdsb3QnKT8uYm9keT8ubm9kZSlcbiAgfVxuICBnZXQgZnJvbSgpOiBBc3QgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLm1vZHVsZS5nZXQodGhpcy5maWVsZHMuZ2V0KCdmcm9tJyk/LmJvZHk/Lm5vZGUpXG4gIH1cbiAgZ2V0IGltcG9ydF8oKTogQXN0IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5tb2R1bGUuZ2V0KHRoaXMuZmllbGRzLmdldCgnaW1wb3J0JykuYm9keT8ubm9kZSlcbiAgfVxuICBnZXQgYWxsKCk6IFRva2VuIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5tb2R1bGUuZ2V0VG9rZW4odGhpcy5maWVsZHMuZ2V0KCdhbGwnKT8ubm9kZSlcbiAgfVxuICBnZXQgYXMoKTogQXN0IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5tb2R1bGUuZ2V0KHRoaXMuZmllbGRzLmdldCgnYXMnKT8uYm9keT8ubm9kZSlcbiAgfVxuICBnZXQgaGlkaW5nKCk6IEFzdCB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMubW9kdWxlLmdldCh0aGlzLmZpZWxkcy5nZXQoJ2hpZGluZycpPy5ib2R5Py5ub2RlKVxuICB9XG5cbiAgc3RhdGljIGNvbmNyZXRlKFxuICAgIG1vZHVsZTogTXV0YWJsZU1vZHVsZSxcbiAgICBwb2x5Z2xvdDogTXVsdGlTZWdtZW50QXBwU2VnbWVudDxPd25lZFJlZnM+IHwgdW5kZWZpbmVkLFxuICAgIGZyb206IE11bHRpU2VnbWVudEFwcFNlZ21lbnQ8T3duZWRSZWZzPiB8IHVuZGVmaW5lZCxcbiAgICBpbXBvcnRfOiBNdWx0aVNlZ21lbnRBcHBTZWdtZW50PE93bmVkUmVmcz4sXG4gICAgYWxsOiBOb2RlQ2hpbGQ8VG9rZW4+IHwgdW5kZWZpbmVkLFxuICAgIGFzOiBNdWx0aVNlZ21lbnRBcHBTZWdtZW50PE93bmVkUmVmcz4gfCB1bmRlZmluZWQsXG4gICAgaGlkaW5nOiBNdWx0aVNlZ21lbnRBcHBTZWdtZW50PE93bmVkUmVmcz4gfCB1bmRlZmluZWQsXG4gICkge1xuICAgIGNvbnN0IGJhc2UgPSBtb2R1bGUuYmFzZU9iamVjdCgnSW1wb3J0JylcbiAgICBjb25zdCBpZF8gPSBiYXNlLmdldCgnaWQnKVxuICAgIGNvbnN0IG93bmVkRmllbGRzOiBJbXBvcnRGaWVsZHM8T3duZWRSZWZzPiA9IHtcbiAgICAgIHBvbHlnbG90LFxuICAgICAgZnJvbSxcbiAgICAgIGltcG9ydDogaW1wb3J0XyxcbiAgICAgIGFsbCxcbiAgICAgIGFzLFxuICAgICAgaGlkaW5nLFxuICAgIH1cbiAgICBjb25zdCByYXdGaWVsZHMgPSBtYXBSZWZzKG93bmVkRmllbGRzLCBvd25lZFRvUmF3KG1vZHVsZSwgaWRfKSlcbiAgICBjb25zdCBmaWVsZHMgPSBjb21wb3NlRmllbGREYXRhKGJhc2UsIHJhd0ZpZWxkcylcbiAgICByZXR1cm4gYXNPd25lZChuZXcgTXV0YWJsZUltcG9ydChtb2R1bGUsIGZpZWxkcykpXG4gIH1cblxuICBzdGF0aWMgUXVhbGlmaWVkKHBhdGg6IElkZW50TGlrZVtdLCBtb2R1bGU6IE11dGFibGVNb2R1bGUpOiBPd25lZDxNdXRhYmxlSW1wb3J0PiB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgcGF0aF8gPSBQcm9wZXJ0eUFjY2Vzcy5TZXF1ZW5jZShwYXRoLCBtb2R1bGUpXG4gICAgaWYgKCFwYXRoXykgcmV0dXJuXG4gICAgcmV0dXJuIE11dGFibGVJbXBvcnQuY29uY3JldGUoXG4gICAgICBtb2R1bGUsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICBtdWx0aVNlZ21lbnRBcHBTZWdtZW50KCdpbXBvcnQnLCBwYXRoXyksXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB1bmRlZmluZWQsXG4gICAgKVxuICB9XG5cbiAgc3RhdGljIFVucXVhbGlmaWVkKFxuICAgIHBhdGg6IElkZW50TGlrZVtdLFxuICAgIG5hbWU6IElkZW50TGlrZSxcbiAgICBtb2R1bGU6IE11dGFibGVNb2R1bGUsXG4gICk6IE93bmVkPE11dGFibGVJbXBvcnQ+IHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBwYXRoXyA9IFByb3BlcnR5QWNjZXNzLlNlcXVlbmNlKHBhdGgsIG1vZHVsZSlcbiAgICBpZiAoIXBhdGhfKSByZXR1cm5cbiAgICBjb25zdCBuYW1lXyA9IElkZW50Lm5ld0FsbG93aW5nT3BlcmF0b3JzKG1vZHVsZSwgbmFtZSlcbiAgICByZXR1cm4gTXV0YWJsZUltcG9ydC5jb25jcmV0ZShcbiAgICAgIG1vZHVsZSxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIG11bHRpU2VnbWVudEFwcFNlZ21lbnQoJ2Zyb20nLCBwYXRoXyksXG4gICAgICBtdWx0aVNlZ21lbnRBcHBTZWdtZW50KCdpbXBvcnQnLCBuYW1lXyksXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB1bmRlZmluZWQsXG4gICAgKVxuICB9XG5cbiAgKmNvbmNyZXRlQ2hpbGRyZW4oX3ZlcmJhdGltPzogYm9vbGVhbik6IEl0ZXJhYmxlSXRlcmF0b3I8UmF3Tm9kZUNoaWxkPiB7XG4gICAgY29uc3Qgc2VnbWVudCA9IChzZWdtZW50OiBNdWx0aVNlZ21lbnRBcHBTZWdtZW50IHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgICBjb25zdCBwYXJ0cyA9IFtdXG4gICAgICBpZiAoc2VnbWVudCkgcGFydHMucHVzaChzZWdtZW50LmhlYWRlcilcbiAgICAgIGlmIChzZWdtZW50Py5ib2R5KSBwYXJ0cy5wdXNoKHNlZ21lbnQuYm9keSlcbiAgICAgIHJldHVybiBwYXJ0c1xuICAgIH1cbiAgICBjb25zdCB7IHBvbHlnbG90LCBmcm9tLCBpbXBvcnQ6IGltcG9ydF8sIGFsbCwgYXMsIGhpZGluZyB9ID0gZ2V0QWxsKHRoaXMuZmllbGRzKVxuICAgIHlpZWxkKiBzZWdtZW50KHBvbHlnbG90KVxuICAgIHlpZWxkKiBzZWdtZW50KGZyb20pXG4gICAgeWllbGQqIHNlZ21lbnQoaW1wb3J0XylcbiAgICBpZiAoYWxsKSB5aWVsZCBhbGxcbiAgICB5aWVsZCogc2VnbWVudChhcylcbiAgICB5aWVsZCogc2VnbWVudChoaWRpbmcpXG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBNdXRhYmxlSW1wb3J0IGV4dGVuZHMgSW1wb3J0IGltcGxlbWVudHMgTXV0YWJsZUFzdCB7XG4gIGRlY2xhcmUgcmVhZG9ubHkgbW9kdWxlOiBNdXRhYmxlTW9kdWxlXG4gIGRlY2xhcmUgcmVhZG9ubHkgZmllbGRzOiBGaXhlZE1hcDxBc3RGaWVsZHMgJiBJbXBvcnRGaWVsZHM+XG5cbiAgcHJpdmF0ZSB0b1Jhdyhtc2FzOiBNdWx0aVNlZ21lbnRBcHBTZWdtZW50PE93bmVkUmVmcz4pOiBNdWx0aVNlZ21lbnRBcHBTZWdtZW50XG4gIHByaXZhdGUgdG9SYXcoXG4gICAgbXNhczogTXVsdGlTZWdtZW50QXBwU2VnbWVudDxPd25lZFJlZnM+IHwgdW5kZWZpbmVkLFxuICApOiBNdWx0aVNlZ21lbnRBcHBTZWdtZW50IHwgdW5kZWZpbmVkXG4gIHByaXZhdGUgdG9SYXcoXG4gICAgbXNhczogTXVsdGlTZWdtZW50QXBwU2VnbWVudDxPd25lZFJlZnM+IHwgdW5kZWZpbmVkLFxuICApOiBNdWx0aVNlZ21lbnRBcHBTZWdtZW50IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gbXVsdGlTZWdtZW50QXBwU2VnbWVudFRvUmF3KHRoaXMubW9kdWxlLCBtc2FzLCB0aGlzLmlkKVxuICB9XG5cbiAgc2V0UG9seWdsb3Q8VCBleHRlbmRzIE11dGFibGVBc3Q+KHZhbHVlOiBPd25lZDxUPiB8IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuZmllbGRzLnNldChcbiAgICAgICdwb2x5Z2xvdCcsXG4gICAgICB2YWx1ZSA/IHRoaXMudG9SYXcobXVsdGlTZWdtZW50QXBwU2VnbWVudCgncG9seWdsb3QnLCB2YWx1ZSkpIDogdW5kZWZpbmVkLFxuICAgIClcbiAgfVxuICBzZXRGcm9tPFQgZXh0ZW5kcyBNdXRhYmxlQXN0Pih2YWx1ZTogT3duZWQ8VD4gfCB1bmRlZmluZWQpIHtcbiAgICB0aGlzLmZpZWxkcy5zZXQoJ2Zyb20nLCB2YWx1ZSA/IHRoaXMudG9SYXcobXVsdGlTZWdtZW50QXBwU2VnbWVudCgnZnJvbScsIHZhbHVlKSkgOiB2YWx1ZSlcbiAgfVxuICBzZXRJbXBvcnQ8VCBleHRlbmRzIE11dGFibGVBc3Q+KHZhbHVlOiBPd25lZDxUPikge1xuICAgIHRoaXMuZmllbGRzLnNldCgnaW1wb3J0JywgdGhpcy50b1JhdyhtdWx0aVNlZ21lbnRBcHBTZWdtZW50KCdpbXBvcnQnLCB2YWx1ZSkpKVxuICB9XG4gIHNldEFsbCh2YWx1ZTogVG9rZW4gfCB1bmRlZmluZWQpIHtcbiAgICB0aGlzLmZpZWxkcy5zZXQoJ2FsbCcsIHNwYWNlZCh2YWx1ZSkpXG4gIH1cbiAgc2V0QXM8VCBleHRlbmRzIE11dGFibGVBc3Q+KHZhbHVlOiBPd25lZDxUPiB8IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuZmllbGRzLnNldCgnYXMnLCB0aGlzLnRvUmF3KG11bHRpU2VnbWVudEFwcFNlZ21lbnQoJ2FzJywgdmFsdWUpKSlcbiAgfVxuICBzZXRIaWRpbmc8VCBleHRlbmRzIE11dGFibGVBc3Q+KHZhbHVlOiBPd25lZDxUPiB8IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuZmllbGRzLnNldCgnaGlkaW5nJywgdGhpcy50b1JhdyhtdWx0aVNlZ21lbnRBcHBTZWdtZW50KCdoaWRpbmcnLCB2YWx1ZSkpKVxuICB9XG59XG5leHBvcnQgaW50ZXJmYWNlIE11dGFibGVJbXBvcnQgZXh0ZW5kcyBJbXBvcnQsIE11dGFibGVBc3Qge1xuICBnZXQgcG9seWdsb3QoKTogTXV0YWJsZUFzdCB8IHVuZGVmaW5lZFxuICBnZXQgZnJvbSgpOiBNdXRhYmxlQXN0IHwgdW5kZWZpbmVkXG4gIGdldCBpbXBvcnRfKCk6IE11dGFibGVBc3QgfCB1bmRlZmluZWRcbiAgZ2V0IGFzKCk6IE11dGFibGVBc3QgfCB1bmRlZmluZWRcbiAgZ2V0IGhpZGluZygpOiBNdXRhYmxlQXN0IHwgdW5kZWZpbmVkXG59XG5hcHBseU1peGlucyhNdXRhYmxlSW1wb3J0LCBbTXV0YWJsZUFzdF0pXG5cbmludGVyZmFjZSBUcmVlUmVmcyB7XG4gIHRva2VuOiBhbnlcbiAgYXN0OiBhbnlcbn1cbnR5cGUgUmVmTWFwPFQgZXh0ZW5kcyBUcmVlUmVmcywgVSBleHRlbmRzIFRyZWVSZWZzPiA9IChcbiAgZmllbGQ6IEZpZWxkRGF0YTxUPixcbikgPT4gRmllbGREYXRhPFU+IHwgdW5kZWZpbmVkXG50eXBlIFJhd1JlZnMgPSB7XG4gIHRva2VuOiBOb2RlQ2hpbGQ8U3luY1Rva2VuSWQ+XG4gIGFzdDogTm9kZUNoaWxkPEFzdElkPlxufVxuZXhwb3J0IHR5cGUgT3duZWRSZWZzID0ge1xuICB0b2tlbjogTm9kZUNoaWxkPFRva2VuPlxuICBhc3Q6IE5vZGVDaGlsZDxPd25lZD5cbn1cbnR5cGUgQ29uY3JldGVSZWZzID0ge1xuICB0b2tlbjogTm9kZUNoaWxkPFRva2VuPlxuICBhc3Q6IE5vZGVDaGlsZDxBc3Q+XG59XG5mdW5jdGlvbiBvd25lZFRvUmF3KG1vZHVsZTogTXV0YWJsZU1vZHVsZSwgcGFyZW50SWQ6IEFzdElkKTogUmVmTWFwPE93bmVkUmVmcywgUmF3UmVmcz4ge1xuICByZXR1cm4gKGNoaWxkOiBGaWVsZERhdGE8T3duZWRSZWZzPikgPT4ge1xuICAgIGlmICh0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnKSByZXR1cm5cbiAgICBpZiAoISgnbm9kZScgaW4gY2hpbGQpKSByZXR1cm5cbiAgICBpZiAoaXNUb2tlbihjaGlsZC5ub2RlKSkgcmV0dXJuXG4gICAgcmV0dXJuIHsgLi4uY2hpbGQsIG5vZGU6IGNsYWltQ2hpbGQobW9kdWxlLCBjaGlsZC5ub2RlLCBwYXJlbnRJZCkgfVxuICB9XG59XG5mdW5jdGlvbiByYXdUb0NvbmNyZXRlKG1vZHVsZTogTW9kdWxlKTogUmVmTWFwPFJhd1JlZnMsIENvbmNyZXRlUmVmcz4ge1xuICByZXR1cm4gKGNoaWxkOiBGaWVsZERhdGEpID0+IHtcbiAgICBpZiAodHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0JykgcmV0dXJuXG4gICAgaWYgKCEoJ25vZGUnIGluIGNoaWxkKSkgcmV0dXJuXG4gICAgaWYgKGlzVG9rZW5JZChjaGlsZC5ub2RlKSkgcmV0dXJuIHsgLi4uY2hpbGQsIG5vZGU6IG1vZHVsZS5nZXRUb2tlbihjaGlsZC5ub2RlKSB9XG4gICAgZWxzZSByZXR1cm4geyAuLi5jaGlsZCwgbm9kZTogbW9kdWxlLmdldChjaGlsZC5ub2RlKSB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29uY3JldGVUb093bmVkKG1vZHVsZTogTXV0YWJsZU1vZHVsZSk6IFJlZk1hcDxDb25jcmV0ZVJlZnMsIE93bmVkUmVmcz4ge1xuICByZXR1cm4gKGNoaWxkOiBGaWVsZERhdGE8Q29uY3JldGVSZWZzPikgPT4ge1xuICAgIGlmICh0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnKSByZXR1cm5cbiAgICBpZiAoISgnbm9kZScgaW4gY2hpbGQpKSByZXR1cm5cbiAgICBpZiAoaXNUb2tlbkNoaWxkKGNoaWxkKSkgcmV0dXJuIGNoaWxkXG4gICAgZWxzZSByZXR1cm4geyAuLi5jaGlsZCwgbm9kZTogbW9kdWxlLmNvcHkoY2hpbGQubm9kZSkgfVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dFRva2VuPFQgZXh0ZW5kcyBUcmVlUmVmcyA9IFJhd1JlZnM+IHtcbiAgdHlwZTogJ3Rva2VuJ1xuICByZWFkb25seSB0b2tlbjogVFsndG9rZW4nXVxuICByZWFkb25seSBpbnRlcnByZXRlZD86IHN0cmluZyB8IHVuZGVmaW5lZFxufVxuZXhwb3J0IGludGVyZmFjZSBUZXh0U3BsaWNlPFQgZXh0ZW5kcyBUcmVlUmVmcyA9IFJhd1JlZnM+IHtcbiAgdHlwZTogJ3NwbGljZSdcbiAgcmVhZG9ubHkgb3BlbjogVFsndG9rZW4nXVxuICByZWFkb25seSBleHByZXNzaW9uOiBUWydhc3QnXSB8IHVuZGVmaW5lZFxuICByZWFkb25seSBjbG9zZTogVFsndG9rZW4nXVxufVxuXG5leHBvcnQgdHlwZSBUZXh0RWxlbWVudDxUIGV4dGVuZHMgVHJlZVJlZnMgPSBSYXdSZWZzPiA9IFRleHRUb2tlbjxUPiB8IFRleHRTcGxpY2U8VD5cblxuZnVuY3Rpb24gdGV4dEVsZW1lbnRWYWx1ZShlbGVtZW50OiBUZXh0RWxlbWVudDxDb25jcmV0ZVJlZnM+KTogc3RyaW5nIHtcbiAgc3dpdGNoIChlbGVtZW50LnR5cGUpIHtcbiAgICBjYXNlICd0b2tlbic6IHtcbiAgICAgIGlmIChlbGVtZW50LmludGVycHJldGVkICE9IG51bGwpIHJldHVybiBlbGVtZW50LmludGVycHJldGVkXG4gICAgICAvLyBUaGUgbG9naWNhbCBuZXdsaW5lIGlzIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBhcyB0aGUgY29uY3JldGUgdG9rZW4sIGUuZy4gdGhlIHRva2VuIGNvdWxkIGJlIGEgQ1JMRi5cbiAgICAgIGlmIChlbGVtZW50LnRva2VuLm5vZGUudG9rZW5UeXBlXyA9PT0gUmF3QXN0LlRva2VuLlR5cGUuVGV4dE5ld2xpbmUpIHJldHVybiAnXFxuJ1xuICAgICAgLy8gVGhlIHRva2VuIGlzIGFuIGludmFsaWQgZXNjYXBlLXNlcXVlbmNlIG9yIGEgdGV4dC1zZWN0aW9uOyByZXR1cm4gaXQgdmVyYmF0aW0uXG4gICAgICByZXR1cm4gZWxlbWVudC50b2tlbi5ub2RlLmNvZGUoKVxuICAgIH1cbiAgICBjYXNlICdzcGxpY2UnOiB7XG4gICAgICBsZXQgcyA9ICcnXG4gICAgICBzICs9IGVsZW1lbnQub3Blbi5ub2RlLmNvZGUoKVxuICAgICAgaWYgKGVsZW1lbnQuZXhwcmVzc2lvbikge1xuICAgICAgICBzICs9IGVsZW1lbnQuZXhwcmVzc2lvbi53aGl0ZXNwYWNlID8/ICcnXG4gICAgICAgIHMgKz0gZWxlbWVudC5leHByZXNzaW9uLm5vZGUuY29kZSgpXG4gICAgICB9XG4gICAgICBzICs9IGVsZW1lbnQuY2xvc2Uud2hpdGVzcGFjZSA/PyAnJ1xuICAgICAgcyArPSBlbGVtZW50LmNsb3NlLm5vZGUuY29kZSgpXG4gICAgICByZXR1cm4gc1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByYXdUZXh0RWxlbWVudFZhbHVlKHJhdzogVGV4dEVsZW1lbnQsIG1vZHVsZTogTW9kdWxlKTogc3RyaW5nIHtcbiAgcmV0dXJuIHRleHRFbGVtZW50VmFsdWUobWFwUmVmcyhyYXcsIHJhd1RvQ29uY3JldGUobW9kdWxlKSkpXG59XG5cbmZ1bmN0aW9uIHVuaW50ZXJwb2xhdGVkVGV4dChlbGVtZW50czogRGVlcFJlYWRvbmx5PFRleHRFbGVtZW50W10+LCBtb2R1bGU6IE1vZHVsZSk6IHN0cmluZyB7XG4gIHJldHVybiBlbGVtZW50cy5yZWR1Y2UoKHMsIGUpID0+IHMgKyByYXdUZXh0RWxlbWVudFZhbHVlKGUsIG1vZHVsZSksICcnKVxufVxuXG5mdW5jdGlvbiBmaWVsZENvbmNyZXRlQ2hpbGRyZW4oZmllbGQ6IEZpZWxkRGF0YSkge1xuICBjb25zdCBjaGlsZHJlbiA9IG5ldyBBcnJheTxSYXdOb2RlQ2hpbGQ+KClcbiAgcmV3cml0ZUZpZWxkUmVmcyhmaWVsZCwgKHN1YmZpZWxkOiBGaWVsZERhdGEpID0+IHtcbiAgICBpZiAodHlwZW9mIHN1YmZpZWxkID09PSAnb2JqZWN0JyAmJiAnbm9kZScgaW4gc3ViZmllbGQpIGNoaWxkcmVuLnB1c2goc3ViZmllbGQpXG4gIH0pXG4gIHJldHVybiBjaGlsZHJlblxufVxuXG5pbnRlcmZhY2UgVGV4dExpdGVyYWxGaWVsZHMge1xuICBvcGVuOiBOb2RlQ2hpbGQ8U3luY1Rva2VuSWQ+IHwgdW5kZWZpbmVkXG4gIG5ld2xpbmU6IE5vZGVDaGlsZDxTeW5jVG9rZW5JZD4gfCB1bmRlZmluZWRcbiAgZWxlbWVudHM6IFRleHRFbGVtZW50W11cbiAgY2xvc2U6IE5vZGVDaGlsZDxTeW5jVG9rZW5JZD4gfCB1bmRlZmluZWRcbn1cbmV4cG9ydCBjbGFzcyBUZXh0TGl0ZXJhbCBleHRlbmRzIEFzdCB7XG4gIGRlY2xhcmUgZmllbGRzOiBGaXhlZE1hcFZpZXc8QXN0RmllbGRzICYgVGV4dExpdGVyYWxGaWVsZHM+XG4gIGNvbnN0cnVjdG9yKG1vZHVsZTogTW9kdWxlLCBmaWVsZHM6IEZpeGVkTWFwVmlldzxBc3RGaWVsZHMgJiBUZXh0TGl0ZXJhbEZpZWxkcz4pIHtcbiAgICBzdXBlcihtb2R1bGUsIGZpZWxkcylcbiAgfVxuXG4gIHN0YXRpYyB0cnlQYXJzZShzb3VyY2U6IHN0cmluZywgbW9kdWxlPzogTXV0YWJsZU1vZHVsZSk6IE93bmVkPE11dGFibGVUZXh0TGl0ZXJhbD4gfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlKHNvdXJjZSwgbW9kdWxlKVxuICAgIGlmIChwYXJzZWQgaW5zdGFuY2VvZiBNdXRhYmxlVGV4dExpdGVyYWwpIHJldHVybiBwYXJzZWRcbiAgfVxuXG4gIHN0YXRpYyBjb25jcmV0ZShcbiAgICBtb2R1bGU6IE11dGFibGVNb2R1bGUsXG4gICAgb3BlbjogTm9kZUNoaWxkPFRva2VuPiB8IHVuZGVmaW5lZCxcbiAgICBuZXdsaW5lOiBOb2RlQ2hpbGQ8VG9rZW4+IHwgdW5kZWZpbmVkLFxuICAgIGVsZW1lbnRzOiBUZXh0RWxlbWVudDxPd25lZFJlZnM+W10sXG4gICAgY2xvc2U6IE5vZGVDaGlsZDxUb2tlbj4gfCB1bmRlZmluZWQsXG4gICkge1xuICAgIGNvbnN0IGJhc2UgPSBtb2R1bGUuYmFzZU9iamVjdCgnVGV4dExpdGVyYWwnKVxuICAgIGNvbnN0IGlkXyA9IGJhc2UuZ2V0KCdpZCcpXG4gICAgY29uc3QgZmllbGRzID0gY29tcG9zZUZpZWxkRGF0YShiYXNlLCB7XG4gICAgICBvcGVuLFxuICAgICAgbmV3bGluZSxcbiAgICAgIGVsZW1lbnRzOiBlbGVtZW50cy5tYXAoKGUpID0+IG1hcFJlZnMoZSwgb3duZWRUb1Jhdyhtb2R1bGUsIGlkXykpKSxcbiAgICAgIGNsb3NlLFxuICAgIH0pXG4gICAgcmV0dXJuIGFzT3duZWQobmV3IE11dGFibGVUZXh0TGl0ZXJhbChtb2R1bGUsIGZpZWxkcykpXG4gIH1cblxuICBzdGF0aWMgbmV3KHJhd1RleHQ6IHN0cmluZywgbW9kdWxlPzogTXV0YWJsZU1vZHVsZSk6IE93bmVkPE11dGFibGVUZXh0TGl0ZXJhbD4ge1xuICAgIGNvbnN0IGVzY2FwZWQgPSBlc2NhcGVUZXh0TGl0ZXJhbChyYXdUZXh0KVxuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlKGAnJHtlc2NhcGVkfSdgLCBtb2R1bGUpXG4gICAgaWYgKCEocGFyc2VkIGluc3RhbmNlb2YgTXV0YWJsZVRleHRMaXRlcmFsKSkge1xuICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGVzY2FwZSBzdHJpbmcgZm9yIGludGVycG9sYXRlZCB0ZXh0YCwgcmF3VGV4dCwgZXNjYXBlZCwgcGFyc2VkKVxuICAgICAgY29uc3Qgc2FmZVRleHQgPSByYXdUZXh0LnJlcGxhY2VBbGwoL1teLStBLVphLXowLTlfLiBdL2csICcnKVxuICAgICAgcmV0dXJuIFRleHRMaXRlcmFsLm5ldyhzYWZlVGV4dCwgbW9kdWxlKVxuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBsaXRlcmFsIHZhbHVlIG9mIHRoZSBzdHJpbmcgd2l0aCBhbGwgZXNjYXBlIHNlcXVlbmNlcyBhcHBsaWVkLCBidXQgd2l0aG91dFxuICAgKiBldmFsdWF0aW5nIGFueSBpbnRlcnBvbGF0ZWQgZXhwcmVzc2lvbnMuXG4gICAqL1xuICBnZXQgcmF3VGV4dENvbnRlbnQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdW5pbnRlcnBvbGF0ZWRUZXh0KHRoaXMuZmllbGRzLmdldCgnZWxlbWVudHMnKSwgdGhpcy5tb2R1bGUpXG4gIH1cblxuICAqY29uY3JldGVDaGlsZHJlbihfdmVyYmF0aW0/OiBib29sZWFuKTogSXRlcmFibGVJdGVyYXRvcjxSYXdOb2RlQ2hpbGQ+IHtcbiAgICBjb25zdCB7IG9wZW4sIG5ld2xpbmUsIGVsZW1lbnRzLCBjbG9zZSB9ID0gZ2V0QWxsKHRoaXMuZmllbGRzKVxuICAgIGlmIChvcGVuKSB5aWVsZCBvcGVuXG4gICAgaWYgKG5ld2xpbmUpIHlpZWxkIG5ld2xpbmVcbiAgICBmb3IgKGNvbnN0IGUgb2YgZWxlbWVudHMpIHlpZWxkKiBmaWVsZENvbmNyZXRlQ2hpbGRyZW4oZSlcbiAgICBpZiAoY2xvc2UpIHlpZWxkIGNsb3NlXG4gIH1cblxuICBib3VuZGFyeVRva2VuQ29kZSgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiAodGhpcy5vcGVuIHx8IHRoaXMuY2xvc2UpPy5jb2RlKClcbiAgfVxuXG4gIGlzSW50ZXJwb2xhdGVkKCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHRva2VuID0gdGhpcy5ib3VuZGFyeVRva2VuQ29kZSgpXG4gICAgcmV0dXJuIHRva2VuID09PSBcIidcIiB8fCB0b2tlbiA9PT0gXCInJydcIlxuICB9XG5cbiAgZ2V0IG9wZW4oKTogVG9rZW4gfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLm1vZHVsZS5nZXRUb2tlbih0aGlzLmZpZWxkcy5nZXQoJ29wZW4nKT8ubm9kZSlcbiAgfVxuXG4gIGdldCBjbG9zZSgpOiBUb2tlbiB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMubW9kdWxlLmdldFRva2VuKHRoaXMuZmllbGRzLmdldCgnY2xvc2UnKT8ubm9kZSlcbiAgfVxuXG4gIGdldCBlbGVtZW50cygpOiBUZXh0RWxlbWVudDxDb25jcmV0ZVJlZnM+W10ge1xuICAgIHJldHVybiB0aGlzLmZpZWxkcy5nZXQoJ2VsZW1lbnRzJykubWFwKChlKSA9PiBtYXBSZWZzKGUsIHJhd1RvQ29uY3JldGUodGhpcy5tb2R1bGUpKSlcbiAgfVxufVxuZXhwb3J0IGNsYXNzIE11dGFibGVUZXh0TGl0ZXJhbCBleHRlbmRzIFRleHRMaXRlcmFsIGltcGxlbWVudHMgTXV0YWJsZUFzdCB7XG4gIGRlY2xhcmUgcmVhZG9ubHkgbW9kdWxlOiBNdXRhYmxlTW9kdWxlXG4gIGRlY2xhcmUgcmVhZG9ubHkgZmllbGRzOiBGaXhlZE1hcDxBc3RGaWVsZHMgJiBUZXh0TGl0ZXJhbEZpZWxkcz5cblxuICBzZXRCb3VuZGFyaWVzKGNvZGU6IHN0cmluZykge1xuICAgIHRoaXMuZmllbGRzLnNldCgnb3BlbicsIHVuc3BhY2VkKFRva2VuLm5ldyhjb2RlKSkpXG4gICAgdGhpcy5maWVsZHMuc2V0KCdjbG9zZScsIHVuc3BhY2VkKFRva2VuLm5ldyhjb2RlKSkpXG4gIH1cblxuICBzZXRFbGVtZW50cyhlbGVtZW50czogVGV4dEVsZW1lbnQ8T3duZWRSZWZzPltdKSB7XG4gICAgdGhpcy5maWVsZHMuc2V0KFxuICAgICAgJ2VsZW1lbnRzJyxcbiAgICAgIGVsZW1lbnRzLm1hcCgoZSkgPT4gbWFwUmVmcyhlLCBvd25lZFRvUmF3KHRoaXMubW9kdWxlLCB0aGlzLmlkKSkpLFxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgbGl0ZXJhbCB2YWx1ZSBvZiB0aGUgc3RyaW5nLiBUaGUgY29kZSByZXByZXNlbnRhdGlvbiBvZiBhc3NpZ25lZCB0ZXh0IHdpbGwgYmUgYXV0b21hdGljYWxseVxuICAgKiB0cmFuc2Zvcm1lZCB0byB1c2UgZXNjYXBlIHNlcXVlbmNlcyB3aGVuIG5lY2Vzc2FyeS5cbiAgICovXG4gIHNldFJhd1RleHRDb250ZW50KHJhd1RleHQ6IHN0cmluZykge1xuICAgIGxldCBib3VuZGFyeSA9IHRoaXMuYm91bmRhcnlUb2tlbkNvZGUoKVxuICAgIGNvbnN0IGlzSW50ZXJwb2xhdGVkID0gdGhpcy5pc0ludGVycG9sYXRlZCgpXG4gICAgY29uc3QgbXVzdEJlY29tZUludGVycG9sYXRlZCA9ICFpc0ludGVycG9sYXRlZCAmJiAoIWJvdW5kYXJ5IHx8IHJhd1RleHQubWF0Y2goL1tcIlxcblxccl0vKSlcbiAgICBpZiAobXVzdEJlY29tZUludGVycG9sYXRlZCkge1xuICAgICAgYm91bmRhcnkgPSBcIidcIlxuICAgICAgdGhpcy5zZXRCb3VuZGFyaWVzKGJvdW5kYXJ5KVxuICAgIH1cbiAgICBjb25zdCBsaXRlcmFsQ29udGVudHMgPVxuICAgICAgaXNJbnRlcnBvbGF0ZWQgfHwgbXVzdEJlY29tZUludGVycG9sYXRlZCA/IGVzY2FwZVRleHRMaXRlcmFsKHJhd1RleHQpIDogcmF3VGV4dFxuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlKGAke2JvdW5kYXJ5fSR7bGl0ZXJhbENvbnRlbnRzfSR7Ym91bmRhcnl9YClcbiAgICBhc3NlcnQocGFyc2VkIGluc3RhbmNlb2YgVGV4dExpdGVyYWwpXG4gICAgY29uc3QgZWxlbWVudHMgPSBwYXJzZWQuZWxlbWVudHMubWFwKChlKSA9PiBtYXBSZWZzKGUsIGNvbmNyZXRlVG9Pd25lZCh0aGlzLm1vZHVsZSkpKVxuICAgIHRoaXMuc2V0RWxlbWVudHMoZWxlbWVudHMpXG4gIH1cbn1cbmV4cG9ydCBpbnRlcmZhY2UgTXV0YWJsZVRleHRMaXRlcmFsIGV4dGVuZHMgVGV4dExpdGVyYWwsIE11dGFibGVBc3Qge31cbmFwcGx5TWl4aW5zKE11dGFibGVUZXh0TGl0ZXJhbCwgW011dGFibGVBc3RdKVxuXG5pbnRlcmZhY2UgRG9jdW1lbnRlZEZpZWxkcyB7XG4gIG9wZW46IE5vZGVDaGlsZDxTeW5jVG9rZW5JZD5cbiAgZWxlbWVudHM6IFRleHRUb2tlbltdXG4gIG5ld2xpbmVzOiBOb2RlQ2hpbGQ8U3luY1Rva2VuSWQ+W11cbiAgZXhwcmVzc2lvbjogTm9kZUNoaWxkPEFzdElkPiB8IHVuZGVmaW5lZFxufVxuZXhwb3J0IGNsYXNzIERvY3VtZW50ZWQgZXh0ZW5kcyBBc3Qge1xuICBkZWNsYXJlIGZpZWxkczogRml4ZWRNYXBWaWV3PEFzdEZpZWxkcyAmIERvY3VtZW50ZWRGaWVsZHM+XG4gIGNvbnN0cnVjdG9yKG1vZHVsZTogTW9kdWxlLCBmaWVsZHM6IEZpeGVkTWFwVmlldzxBc3RGaWVsZHMgJiBEb2N1bWVudGVkRmllbGRzPikge1xuICAgIHN1cGVyKG1vZHVsZSwgZmllbGRzKVxuICB9XG5cbiAgc3RhdGljIHRyeVBhcnNlKHNvdXJjZTogc3RyaW5nLCBtb2R1bGU/OiBNdXRhYmxlTW9kdWxlKTogT3duZWQ8TXV0YWJsZURvY3VtZW50ZWQ+IHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZShzb3VyY2UsIG1vZHVsZSlcbiAgICBpZiAocGFyc2VkIGluc3RhbmNlb2YgTXV0YWJsZURvY3VtZW50ZWQpIHJldHVybiBwYXJzZWRcbiAgfVxuXG4gIHN0YXRpYyBuZXcodGV4dDogc3RyaW5nLCBleHByZXNzaW9uOiBPd25lZCkge1xuICAgIHJldHVybiB0aGlzLmNvbmNyZXRlKFxuICAgICAgZXhwcmVzc2lvbi5tb2R1bGUsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB0ZXh0VG9VbmludGVycG9sYXRlZEVsZW1lbnRzKHRleHQpLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgYXV0b3NwYWNlZChleHByZXNzaW9uKSxcbiAgICApXG4gIH1cblxuICBzdGF0aWMgY29uY3JldGUoXG4gICAgbW9kdWxlOiBNdXRhYmxlTW9kdWxlLFxuICAgIG9wZW46IE5vZGVDaGlsZDxUb2tlbj4gfCB1bmRlZmluZWQsXG4gICAgZWxlbWVudHM6IFRleHRUb2tlbjxPd25lZFJlZnM+W10sXG4gICAgbmV3bGluZXM6IE5vZGVDaGlsZDxUb2tlbj5bXSB8IHVuZGVmaW5lZCxcbiAgICBleHByZXNzaW9uOiBOb2RlQ2hpbGQ8T3duZWQ+IHwgdW5kZWZpbmVkLFxuICApIHtcbiAgICBjb25zdCBiYXNlID0gbW9kdWxlLmJhc2VPYmplY3QoJ0RvY3VtZW50ZWQnKVxuICAgIGNvbnN0IGlkXyA9IGJhc2UuZ2V0KCdpZCcpXG4gICAgY29uc3QgZmllbGRzID0gY29tcG9zZUZpZWxkRGF0YShiYXNlLCB7XG4gICAgICBvcGVuOiBvcGVuID8/IHVuc3BhY2VkKFRva2VuLm5ldygnIyMnLCBSYXdBc3QuVG9rZW4uVHlwZS5PcGVyYXRvcikpLFxuICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLm1hcCgoZSkgPT4gbWFwUmVmcyhlLCBvd25lZFRvUmF3KG1vZHVsZSwgaWRfKSkpLFxuICAgICAgbmV3bGluZXM6IG5ld2xpbmVzID8/IFt1bnNwYWNlZChUb2tlbi5uZXcoJ1xcbicsIFJhd0FzdC5Ub2tlbi5UeXBlLk5ld2xpbmUpKV0sXG4gICAgICBleHByZXNzaW9uOiBjb25jcmV0ZUNoaWxkKG1vZHVsZSwgZXhwcmVzc2lvbiwgaWRfKSxcbiAgICB9KVxuICAgIHJldHVybiBhc093bmVkKG5ldyBNdXRhYmxlRG9jdW1lbnRlZChtb2R1bGUsIGZpZWxkcykpXG4gIH1cblxuICBnZXQgZXhwcmVzc2lvbigpOiBBc3QgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLm1vZHVsZS5nZXQodGhpcy5maWVsZHMuZ2V0KCdleHByZXNzaW9uJyk/Lm5vZGUpXG4gIH1cblxuICAvKiogUmV0dXJuIHRoZSBzdHJpbmcgdmFsdWUgb2YgdGhlIGRvY3VtZW50YXRpb24uICovXG4gIGRvY3VtZW50YXRpb24oKTogc3RyaW5nIHtcbiAgICBjb25zdCByYXcgPSB1bmludGVycG9sYXRlZFRleHQodGhpcy5maWVsZHMuZ2V0KCdlbGVtZW50cycpLCB0aGlzLm1vZHVsZSlcbiAgICByZXR1cm4gcmF3LnN0YXJ0c1dpdGgoJyAnKSA/IHJhdy5zbGljZSgxKSA6IHJhd1xuICB9XG5cbiAgKmNvbmNyZXRlQ2hpbGRyZW4oX3ZlcmJhdGltPzogYm9vbGVhbik6IEl0ZXJhYmxlSXRlcmF0b3I8UmF3Tm9kZUNoaWxkPiB7XG4gICAgY29uc3QgeyBvcGVuLCBlbGVtZW50cywgbmV3bGluZXMsIGV4cHJlc3Npb24gfSA9IGdldEFsbCh0aGlzLmZpZWxkcylcbiAgICB5aWVsZCBvcGVuXG4gICAgZm9yIChjb25zdCB7IHRva2VuIH0gb2YgZWxlbWVudHMpIHlpZWxkIHRva2VuXG4gICAgeWllbGQqIG5ld2xpbmVzXG4gICAgaWYgKGV4cHJlc3Npb24pIHlpZWxkIGV4cHJlc3Npb25cbiAgfVxuXG4gIHByaW50U3VidHJlZShcbiAgICBpbmZvOiBTcGFuTWFwLFxuICAgIG9mZnNldDogbnVtYmVyLFxuICAgIHBhcmVudEluZGVudDogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIHZlcmJhdGltPzogYm9vbGVhbixcbiAgKTogc3RyaW5nIHtcbiAgICByZXR1cm4gcHJpbnREb2N1bWVudGVkKHRoaXMsIGluZm8sIG9mZnNldCwgcGFyZW50SW5kZW50LCB2ZXJiYXRpbSlcbiAgfVxufVxuZXhwb3J0IGNsYXNzIE11dGFibGVEb2N1bWVudGVkIGV4dGVuZHMgRG9jdW1lbnRlZCBpbXBsZW1lbnRzIE11dGFibGVBc3Qge1xuICBkZWNsYXJlIHJlYWRvbmx5IG1vZHVsZTogTXV0YWJsZU1vZHVsZVxuICBkZWNsYXJlIHJlYWRvbmx5IGZpZWxkczogRml4ZWRNYXA8QXN0RmllbGRzICYgRG9jdW1lbnRlZEZpZWxkcz5cblxuICBzZXREb2N1bWVudGF0aW9uVGV4dCh0ZXh0OiBzdHJpbmcpIHtcbiAgICB0aGlzLmZpZWxkcy5zZXQoXG4gICAgICAnZWxlbWVudHMnLFxuICAgICAgdGV4dFRvVW5pbnRlcnBvbGF0ZWRFbGVtZW50cyh0ZXh0KS5tYXAoKG93bmVkKSA9PlxuICAgICAgICBtYXBSZWZzKG93bmVkLCBvd25lZFRvUmF3KHRoaXMubW9kdWxlLCB0aGlzLmlkKSksXG4gICAgICApLFxuICAgIClcbiAgfVxuXG4gIHNldEV4cHJlc3Npb248VCBleHRlbmRzIE11dGFibGVBc3Q+KHZhbHVlOiBPd25lZDxUPiB8IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuZmllbGRzLnNldCgnZXhwcmVzc2lvbicsIHVuc3BhY2VkKHRoaXMuY2xhaW1DaGlsZCh2YWx1ZSkpKVxuICB9XG59XG5leHBvcnQgaW50ZXJmYWNlIE11dGFibGVEb2N1bWVudGVkIGV4dGVuZHMgRG9jdW1lbnRlZCwgTXV0YWJsZUFzdCB7XG4gIGdldCBleHByZXNzaW9uKCk6IE11dGFibGVBc3QgfCB1bmRlZmluZWRcbn1cbmFwcGx5TWl4aW5zKE11dGFibGVEb2N1bWVudGVkLCBbTXV0YWJsZUFzdF0pXG5cbmZ1bmN0aW9uIHRleHRUb1VuaW50ZXJwb2xhdGVkRWxlbWVudHModGV4dDogc3RyaW5nKTogVGV4dFRva2VuPE93bmVkUmVmcz5bXSB7XG4gIGNvbnN0IGVsZW1lbnRzID0gbmV3IEFycmF5PFRleHRUb2tlbjxPd25lZFJlZnM+PigpXG4gIHRleHQuc3BsaXQoJ1xcbicpLmZvckVhY2goKGxpbmUsIGkpID0+IHtcbiAgICBpZiAoaSlcbiAgICAgIGVsZW1lbnRzLnB1c2goe1xuICAgICAgICB0eXBlOiAndG9rZW4nLFxuICAgICAgICB0b2tlbjogdW5zcGFjZWQoVG9rZW4ubmV3KCdcXG4nLCBSYXdBc3QuVG9rZW4uVHlwZS5UZXh0TmV3bGluZSkpLFxuICAgICAgfSlcbiAgICBlbGVtZW50cy5wdXNoKHtcbiAgICAgIHR5cGU6ICd0b2tlbicsXG4gICAgICB0b2tlbjogYXV0b3NwYWNlZChUb2tlbi5uZXcobGluZSwgUmF3QXN0LlRva2VuLlR5cGUuVGV4dFNlY3Rpb24pKSxcbiAgICB9KVxuICB9KVxuICByZXR1cm4gZWxlbWVudHNcbn1cblxuaW50ZXJmYWNlIEludmFsaWRGaWVsZHMge1xuICBleHByZXNzaW9uOiBOb2RlQ2hpbGQ8QXN0SWQ+XG59XG5leHBvcnQgY2xhc3MgSW52YWxpZCBleHRlbmRzIEFzdCB7XG4gIGRlY2xhcmUgZmllbGRzOiBGaXhlZE1hcFZpZXc8QXN0RmllbGRzICYgSW52YWxpZEZpZWxkcz5cbiAgY29uc3RydWN0b3IobW9kdWxlOiBNb2R1bGUsIGZpZWxkczogRml4ZWRNYXBWaWV3PEFzdEZpZWxkcyAmIEludmFsaWRGaWVsZHM+KSB7XG4gICAgc3VwZXIobW9kdWxlLCBmaWVsZHMpXG4gIH1cblxuICBzdGF0aWMgY29uY3JldGUobW9kdWxlOiBNdXRhYmxlTW9kdWxlLCBleHByZXNzaW9uOiBOb2RlQ2hpbGQ8T3duZWQ+KSB7XG4gICAgY29uc3QgYmFzZSA9IG1vZHVsZS5iYXNlT2JqZWN0KCdJbnZhbGlkJylcbiAgICByZXR1cm4gYXNPd25lZChuZXcgTXV0YWJsZUludmFsaWQobW9kdWxlLCBpbnZhbGlkRmllbGRzKG1vZHVsZSwgYmFzZSwgZXhwcmVzc2lvbikpKVxuICB9XG5cbiAgZ2V0IGV4cHJlc3Npb24oKTogQXN0IHtcbiAgICByZXR1cm4gdGhpcy5tb2R1bGUuZ2V0KHRoaXMuZmllbGRzLmdldCgnZXhwcmVzc2lvbicpLm5vZGUpXG4gIH1cblxuICAqY29uY3JldGVDaGlsZHJlbihfdmVyYmF0aW0/OiBib29sZWFuKTogSXRlcmFibGVJdGVyYXRvcjxSYXdOb2RlQ2hpbGQ+IHtcbiAgICB5aWVsZCB0aGlzLmZpZWxkcy5nZXQoJ2V4cHJlc3Npb24nKVxuICB9XG5cbiAgcHJpbnRTdWJ0cmVlKFxuICAgIGluZm86IFNwYW5NYXAsXG4gICAgb2Zmc2V0OiBudW1iZXIsXG4gICAgcGFyZW50SW5kZW50OiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgX3ZlcmJhdGltPzogYm9vbGVhbixcbiAgKTogc3RyaW5nIHtcbiAgICByZXR1cm4gc3VwZXIucHJpbnRTdWJ0cmVlKGluZm8sIG9mZnNldCwgcGFyZW50SW5kZW50LCB0cnVlKVxuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaW52YWxpZEZpZWxkcyhcbiAgbW9kdWxlOiBNdXRhYmxlTW9kdWxlLFxuICBiYXNlOiBGaXhlZE1hcDxBc3RGaWVsZHM+LFxuICBleHByZXNzaW9uOiBOb2RlQ2hpbGQ8T3duZWQ+LFxuKTogRml4ZWRNYXA8QXN0RmllbGRzICYgSW52YWxpZEZpZWxkcz4ge1xuICBjb25zdCBpZF8gPSBiYXNlLmdldCgnaWQnKVxuICByZXR1cm4gY29tcG9zZUZpZWxkRGF0YShiYXNlLCB7IGV4cHJlc3Npb246IGNvbmNyZXRlQ2hpbGQobW9kdWxlLCBleHByZXNzaW9uLCBpZF8pIH0pXG59XG5leHBvcnQgY2xhc3MgTXV0YWJsZUludmFsaWQgZXh0ZW5kcyBJbnZhbGlkIGltcGxlbWVudHMgTXV0YWJsZUFzdCB7XG4gIGRlY2xhcmUgcmVhZG9ubHkgbW9kdWxlOiBNdXRhYmxlTW9kdWxlXG4gIGRlY2xhcmUgcmVhZG9ubHkgZmllbGRzOiBGaXhlZE1hcDxBc3RGaWVsZHMgJiBJbnZhbGlkRmllbGRzPlxufVxuZXhwb3J0IGludGVyZmFjZSBNdXRhYmxlSW52YWxpZCBleHRlbmRzIEludmFsaWQsIE11dGFibGVBc3Qge1xuICAvKiogVGhlIGBleHByZXNzaW9uYCBnZXR0ZXIgaXMgaW50ZW50aW9uYWxseSBub3QgbmFycm93ZWQgdG8gcHJvdmlkZSBtdXRhYmxlIGFjY2VzczpcbiAgICogIEl0IG1ha2VzIG1vcmUgc2Vuc2UgdG8gYC5yZXBsYWNlYCB0aGUgYEludmFsaWRgIG5vZGUuICovXG59XG5hcHBseU1peGlucyhNdXRhYmxlSW52YWxpZCwgW011dGFibGVBc3RdKVxuXG5pbnRlcmZhY2UgR3JvdXBGaWVsZHMge1xuICBvcGVuOiBOb2RlQ2hpbGQ8U3luY1Rva2VuSWQ+IHwgdW5kZWZpbmVkXG4gIGV4cHJlc3Npb246IE5vZGVDaGlsZDxBc3RJZD4gfCB1bmRlZmluZWRcbiAgY2xvc2U6IE5vZGVDaGlsZDxTeW5jVG9rZW5JZD4gfCB1bmRlZmluZWRcbn1cbmV4cG9ydCBjbGFzcyBHcm91cCBleHRlbmRzIEFzdCB7XG4gIGRlY2xhcmUgZmllbGRzOiBGaXhlZE1hcFZpZXc8QXN0RmllbGRzICYgR3JvdXBGaWVsZHM+XG4gIGNvbnN0cnVjdG9yKG1vZHVsZTogTW9kdWxlLCBmaWVsZHM6IEZpeGVkTWFwVmlldzxBc3RGaWVsZHMgJiBHcm91cEZpZWxkcz4pIHtcbiAgICBzdXBlcihtb2R1bGUsIGZpZWxkcylcbiAgfVxuXG4gIHN0YXRpYyB0cnlQYXJzZShzb3VyY2U6IHN0cmluZywgbW9kdWxlPzogTXV0YWJsZU1vZHVsZSk6IE93bmVkPE11dGFibGVHcm91cD4gfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlKHNvdXJjZSwgbW9kdWxlKVxuICAgIGlmIChwYXJzZWQgaW5zdGFuY2VvZiBNdXRhYmxlR3JvdXApIHJldHVybiBwYXJzZWRcbiAgfVxuXG4gIHN0YXRpYyBjb25jcmV0ZShcbiAgICBtb2R1bGU6IE11dGFibGVNb2R1bGUsXG4gICAgb3BlbjogTm9kZUNoaWxkPFRva2VuPiB8IHVuZGVmaW5lZCxcbiAgICBleHByZXNzaW9uOiBOb2RlQ2hpbGQ8T3duZWQ+IHwgdW5kZWZpbmVkLFxuICAgIGNsb3NlOiBOb2RlQ2hpbGQ8VG9rZW4+IHwgdW5kZWZpbmVkLFxuICApIHtcbiAgICBjb25zdCBiYXNlID0gbW9kdWxlLmJhc2VPYmplY3QoJ0dyb3VwJylcbiAgICBjb25zdCBpZF8gPSBiYXNlLmdldCgnaWQnKVxuICAgIGNvbnN0IGZpZWxkcyA9IGNvbXBvc2VGaWVsZERhdGEoYmFzZSwge1xuICAgICAgb3BlbixcbiAgICAgIGV4cHJlc3Npb246IGNvbmNyZXRlQ2hpbGQobW9kdWxlLCBleHByZXNzaW9uLCBpZF8pLFxuICAgICAgY2xvc2UsXG4gICAgfSlcbiAgICByZXR1cm4gYXNPd25lZChuZXcgTXV0YWJsZUdyb3VwKG1vZHVsZSwgZmllbGRzKSlcbiAgfVxuXG4gIHN0YXRpYyBuZXcobW9kdWxlOiBNdXRhYmxlTW9kdWxlLCBleHByZXNzaW9uOiBPd25lZCkge1xuICAgIGNvbnN0IG9wZW4gPSB1bnNwYWNlZChUb2tlbi5uZXcoJygnLCBSYXdBc3QuVG9rZW4uVHlwZS5PcGVuU3ltYm9sKSlcbiAgICBjb25zdCBjbG9zZSA9IHVuc3BhY2VkKFRva2VuLm5ldygnKScsIFJhd0FzdC5Ub2tlbi5UeXBlLkNsb3NlU3ltYm9sKSlcbiAgICByZXR1cm4gdGhpcy5jb25jcmV0ZShtb2R1bGUsIG9wZW4sIHVuc3BhY2VkKGV4cHJlc3Npb24pLCBjbG9zZSlcbiAgfVxuXG4gIGdldCBleHByZXNzaW9uKCk6IEFzdCB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMubW9kdWxlLmdldCh0aGlzLmZpZWxkcy5nZXQoJ2V4cHJlc3Npb24nKT8ubm9kZSlcbiAgfVxuXG4gICpjb25jcmV0ZUNoaWxkcmVuKF92ZXJiYXRpbT86IGJvb2xlYW4pOiBJdGVyYWJsZUl0ZXJhdG9yPFJhd05vZGVDaGlsZD4ge1xuICAgIGNvbnN0IHsgb3BlbiwgZXhwcmVzc2lvbiwgY2xvc2UgfSA9IGdldEFsbCh0aGlzLmZpZWxkcylcbiAgICBpZiAob3BlbikgeWllbGQgb3BlblxuICAgIGlmIChleHByZXNzaW9uKSB5aWVsZCBleHByZXNzaW9uXG4gICAgaWYgKGNsb3NlKSB5aWVsZCBjbG9zZVxuICB9XG59XG5leHBvcnQgY2xhc3MgTXV0YWJsZUdyb3VwIGV4dGVuZHMgR3JvdXAgaW1wbGVtZW50cyBNdXRhYmxlQXN0IHtcbiAgZGVjbGFyZSByZWFkb25seSBtb2R1bGU6IE11dGFibGVNb2R1bGVcbiAgZGVjbGFyZSByZWFkb25seSBmaWVsZHM6IEZpeGVkTWFwPEFzdEZpZWxkcyAmIEdyb3VwRmllbGRzPlxuXG4gIHNldEV4cHJlc3Npb248VCBleHRlbmRzIE11dGFibGVBc3Q+KHZhbHVlOiBPd25lZDxUPiB8IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuZmllbGRzLnNldCgnZXhwcmVzc2lvbicsIHVuc3BhY2VkKHRoaXMuY2xhaW1DaGlsZCh2YWx1ZSkpKVxuICB9XG59XG5leHBvcnQgaW50ZXJmYWNlIE11dGFibGVHcm91cCBleHRlbmRzIEdyb3VwLCBNdXRhYmxlQXN0IHtcbiAgZ2V0IGV4cHJlc3Npb24oKTogTXV0YWJsZUFzdCB8IHVuZGVmaW5lZFxufVxuYXBwbHlNaXhpbnMoTXV0YWJsZUdyb3VwLCBbTXV0YWJsZUFzdF0pXG5cbmludGVyZmFjZSBOdW1lcmljTGl0ZXJhbEZpZWxkcyB7XG4gIHRva2VuczogTm9kZUNoaWxkPFN5bmNUb2tlbklkPltdXG59XG5leHBvcnQgY2xhc3MgTnVtZXJpY0xpdGVyYWwgZXh0ZW5kcyBBc3Qge1xuICBkZWNsYXJlIGZpZWxkczogRml4ZWRNYXBWaWV3PEFzdEZpZWxkcyAmIE51bWVyaWNMaXRlcmFsRmllbGRzPlxuICBjb25zdHJ1Y3Rvcihtb2R1bGU6IE1vZHVsZSwgZmllbGRzOiBGaXhlZE1hcFZpZXc8QXN0RmllbGRzICYgTnVtZXJpY0xpdGVyYWxGaWVsZHM+KSB7XG4gICAgc3VwZXIobW9kdWxlLCBmaWVsZHMpXG4gIH1cblxuICBzdGF0aWMgdHJ5UGFyc2UoXG4gICAgc291cmNlOiBzdHJpbmcsXG4gICAgbW9kdWxlPzogTXV0YWJsZU1vZHVsZSxcbiAgKTogT3duZWQ8TXV0YWJsZU51bWVyaWNMaXRlcmFsPiB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2Uoc291cmNlLCBtb2R1bGUpXG4gICAgaWYgKHBhcnNlZCBpbnN0YW5jZW9mIE11dGFibGVOdW1lcmljTGl0ZXJhbCkgcmV0dXJuIHBhcnNlZFxuICB9XG5cbiAgc3RhdGljIGNvbmNyZXRlKG1vZHVsZTogTXV0YWJsZU1vZHVsZSwgdG9rZW5zOiBOb2RlQ2hpbGQ8VG9rZW4+W10pIHtcbiAgICBjb25zdCBiYXNlID0gbW9kdWxlLmJhc2VPYmplY3QoJ051bWVyaWNMaXRlcmFsJylcbiAgICBjb25zdCBmaWVsZHMgPSBjb21wb3NlRmllbGREYXRhKGJhc2UsIHsgdG9rZW5zIH0pXG4gICAgcmV0dXJuIGFzT3duZWQobmV3IE11dGFibGVOdW1lcmljTGl0ZXJhbChtb2R1bGUsIGZpZWxkcykpXG4gIH1cblxuICBjb25jcmV0ZUNoaWxkcmVuKF92ZXJiYXRpbT86IGJvb2xlYW4pOiBJdGVyYWJsZUl0ZXJhdG9yPFJhd05vZGVDaGlsZD4ge1xuICAgIHJldHVybiB0aGlzLmZpZWxkcy5nZXQoJ3Rva2VucycpW1N5bWJvbC5pdGVyYXRvcl0oKVxuICB9XG59XG5leHBvcnQgY2xhc3MgTXV0YWJsZU51bWVyaWNMaXRlcmFsIGV4dGVuZHMgTnVtZXJpY0xpdGVyYWwgaW1wbGVtZW50cyBNdXRhYmxlQXN0IHtcbiAgZGVjbGFyZSByZWFkb25seSBtb2R1bGU6IE11dGFibGVNb2R1bGVcbiAgZGVjbGFyZSByZWFkb25seSBmaWVsZHM6IEZpeGVkTWFwPEFzdEZpZWxkcyAmIE51bWVyaWNMaXRlcmFsRmllbGRzPlxufVxuZXhwb3J0IGludGVyZmFjZSBNdXRhYmxlTnVtZXJpY0xpdGVyYWwgZXh0ZW5kcyBOdW1lcmljTGl0ZXJhbCwgTXV0YWJsZUFzdCB7fVxuYXBwbHlNaXhpbnMoTXV0YWJsZU51bWVyaWNMaXRlcmFsLCBbTXV0YWJsZUFzdF0pXG5cbi8qKiBUaGUgYWN0dWFsIGNvbnRlbnRzIG9mIGFuIGBBcmd1bWVudERlZmluaXRpb25gIGFyZSBjb21wbGV4LCBidXQgcHJvYmFibHkgb2YgbW9yZSBpbnRlcmVzdCB0byB0aGUgY29tcGlsZXIgdGhhbiB0aGVcbiAqICBHVUkuIFdlIGp1c3QgbmVlZCB0byByZXByZXNlbnQgdGhlbSBmYWl0aGZ1bGx5IGFuZCBjcmVhdGUgdGhlIHNpbXBsZSBjYXNlcy4gKi9cbnR5cGUgQXJndW1lbnREZWZpbml0aW9uPFQgZXh0ZW5kcyBUcmVlUmVmcyA9IFJhd1JlZnM+ID0gKFRbJ2FzdCddIHwgVFsndG9rZW4nXSlbXVxuXG5pbnRlcmZhY2UgRnVuY3Rpb25GaWVsZHMge1xuICBuYW1lOiBOb2RlQ2hpbGQ8QXN0SWQ+XG4gIGFyZ3VtZW50RGVmaW5pdGlvbnM6IEFyZ3VtZW50RGVmaW5pdGlvbltdXG4gIGVxdWFsczogTm9kZUNoaWxkPFN5bmNUb2tlbklkPlxuICBib2R5OiBOb2RlQ2hpbGQ8QXN0SWQ+IHwgdW5kZWZpbmVkXG59XG5leHBvcnQgY2xhc3MgRnVuY3Rpb24gZXh0ZW5kcyBBc3Qge1xuICBkZWNsYXJlIGZpZWxkczogRml4ZWRNYXBWaWV3PEFzdEZpZWxkcyAmIEZ1bmN0aW9uRmllbGRzPlxuICBjb25zdHJ1Y3Rvcihtb2R1bGU6IE1vZHVsZSwgZmllbGRzOiBGaXhlZE1hcFZpZXc8QXN0RmllbGRzICYgRnVuY3Rpb25GaWVsZHM+KSB7XG4gICAgc3VwZXIobW9kdWxlLCBmaWVsZHMpXG4gIH1cblxuICBzdGF0aWMgdHJ5UGFyc2Uoc291cmNlOiBzdHJpbmcsIG1vZHVsZT86IE11dGFibGVNb2R1bGUpOiBPd25lZDxNdXRhYmxlRnVuY3Rpb24+IHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZShzb3VyY2UsIG1vZHVsZSlcbiAgICBpZiAocGFyc2VkIGluc3RhbmNlb2YgTXV0YWJsZUZ1bmN0aW9uKSByZXR1cm4gcGFyc2VkXG4gIH1cblxuICBnZXQgbmFtZSgpOiBBc3Qge1xuICAgIHJldHVybiB0aGlzLm1vZHVsZS5nZXQodGhpcy5maWVsZHMuZ2V0KCduYW1lJykubm9kZSlcbiAgfVxuICBnZXQgYm9keSgpOiBBc3QgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLm1vZHVsZS5nZXQodGhpcy5maWVsZHMuZ2V0KCdib2R5Jyk/Lm5vZGUpXG4gIH1cbiAgZ2V0IGFyZ3VtZW50RGVmaW5pdGlvbnMoKTogQXJndW1lbnREZWZpbml0aW9uPENvbmNyZXRlUmVmcz5bXSB7XG4gICAgcmV0dXJuIHRoaXMuZmllbGRzXG4gICAgICAuZ2V0KCdhcmd1bWVudERlZmluaXRpb25zJylcbiAgICAgIC5tYXAoKHJhdykgPT4gcmF3Lm1hcCgocGFydCkgPT4gdGhpcy5tb2R1bGUuZ2V0Q29uY3JldGUocGFydCkpKVxuICB9XG5cbiAgc3RhdGljIGNvbmNyZXRlKFxuICAgIG1vZHVsZTogTXV0YWJsZU1vZHVsZSxcbiAgICBuYW1lOiBOb2RlQ2hpbGQ8T3duZWQ+LFxuICAgIGFyZ3VtZW50RGVmaW5pdGlvbnM6IEFyZ3VtZW50RGVmaW5pdGlvbjxPd25lZFJlZnM+W10sXG4gICAgZXF1YWxzOiBOb2RlQ2hpbGQ8VG9rZW4+LFxuICAgIGJvZHk6IE5vZGVDaGlsZDxPd25lZD4gfCB1bmRlZmluZWQsXG4gICkge1xuICAgIGNvbnN0IGJhc2UgPSBtb2R1bGUuYmFzZU9iamVjdCgnRnVuY3Rpb24nKVxuICAgIGNvbnN0IGlkXyA9IGJhc2UuZ2V0KCdpZCcpXG4gICAgY29uc3QgZmllbGRzID0gY29tcG9zZUZpZWxkRGF0YShiYXNlLCB7XG4gICAgICBuYW1lOiBjb25jcmV0ZUNoaWxkKG1vZHVsZSwgbmFtZSwgaWRfKSxcbiAgICAgIGFyZ3VtZW50RGVmaW5pdGlvbnM6IGFyZ3VtZW50RGVmaW5pdGlvbnMubWFwKChkZWYpID0+IG1hcFJlZnMoZGVmLCBvd25lZFRvUmF3KG1vZHVsZSwgaWRfKSkpLFxuICAgICAgZXF1YWxzLFxuICAgICAgYm9keTogY29uY3JldGVDaGlsZChtb2R1bGUsIGJvZHksIGlkXyksXG4gICAgfSlcbiAgICByZXR1cm4gYXNPd25lZChuZXcgTXV0YWJsZUZ1bmN0aW9uKG1vZHVsZSwgZmllbGRzKSlcbiAgfVxuXG4gIHN0YXRpYyBuZXcoXG4gICAgbW9kdWxlOiBNdXRhYmxlTW9kdWxlLFxuICAgIG5hbWU6IElkZW50TGlrZSxcbiAgICBhcmd1bWVudERlZmluaXRpb25zOiBBcmd1bWVudERlZmluaXRpb248T3duZWRSZWZzPltdLFxuICAgIGJvZHk6IE93bmVkLFxuICApOiBPd25lZDxNdXRhYmxlRnVuY3Rpb24+IHtcbiAgICAvLyBOb3RlIHRoYXQgYSBmdW5jdGlvbiBuYW1lIG1heSBub3QgYmUgYW4gb3BlcmF0b3IgaWYgdGhlIGZ1bmN0aW9uIGlzIG5vdCBpbiB0aGUgYm9keSBvZiBhIHR5cGUgZGVmaW5pdGlvbiwgYnV0IHdlXG4gICAgLy8gY2FuJ3QgZWFzaWx5IGVuZm9yY2UgdGhhdCBiZWNhdXNlIHdlIGRvbid0IGN1cnJlbnRseSBtYWtlIGEgc3ludGFjdGljIGRpc3RpbmN0aW9uIGJldHdlZW4gdG9wLWxldmVsIGZ1bmN0aW9ucyBhbmRcbiAgICAvLyB0eXBlIG1ldGhvZHMuXG4gICAgcmV0dXJuIE11dGFibGVGdW5jdGlvbi5jb25jcmV0ZShcbiAgICAgIG1vZHVsZSxcbiAgICAgIHVuc3BhY2VkKElkZW50Lm5ld0FsbG93aW5nT3BlcmF0b3JzKG1vZHVsZSwgbmFtZSkpLFxuICAgICAgYXJndW1lbnREZWZpbml0aW9ucyxcbiAgICAgIHNwYWNlZChtYWtlRXF1YWxzKCkpLFxuICAgICAgYXV0b3NwYWNlZChib2R5KSxcbiAgICApXG4gIH1cblxuICAvKiogQ29uc3RydWN0IGEgZnVuY3Rpb24gd2l0aCBzaW1wbGUgKG5hbWUtb25seSkgYXJndW1lbnRzIGFuZCBhIGJvZHkgYmxvY2suICovXG4gIHN0YXRpYyBmcm9tU3RhdGVtZW50cyhcbiAgICBtb2R1bGU6IE11dGFibGVNb2R1bGUsXG4gICAgbmFtZTogSWRlbnRMaWtlLFxuICAgIGFyZ3VtZW50TmFtZXM6IFN0cmljdElkZW50TGlrZVtdLFxuICAgIHN0YXRlbWVudHM6IE93bmVkW10sXG4gICk6IE93bmVkPE11dGFibGVGdW5jdGlvbj4ge1xuICAgIGNvbnN0IHN0YXRlbWVudHNfOiBPd25lZEJsb2NrTGluZVtdID0gc3RhdGVtZW50cy5tYXAoKHN0YXRlbWVudCkgPT4gKHtcbiAgICAgIGV4cHJlc3Npb246IHVuc3BhY2VkKHN0YXRlbWVudCksXG4gICAgfSkpXG4gICAgY29uc3QgYXJndW1lbnREZWZpbml0aW9ucyA9IGFyZ3VtZW50TmFtZXMubWFwKChuYW1lKSA9PiBbc3BhY2VkKElkZW50Lm5ldyhtb2R1bGUsIG5hbWUpKV0pXG4gICAgY29uc3QgYm9keSA9IEJvZHlCbG9jay5uZXcoc3RhdGVtZW50c18sIG1vZHVsZSlcbiAgICByZXR1cm4gTXV0YWJsZUZ1bmN0aW9uLm5ldyhtb2R1bGUsIG5hbWUsIGFyZ3VtZW50RGVmaW5pdGlvbnMsIGJvZHkpXG4gIH1cblxuICAqYm9keUV4cHJlc3Npb25zKCk6IEl0ZXJhYmxlSXRlcmF0b3I8QXN0PiB7XG4gICAgY29uc3QgYm9keSA9IHRoaXMuYm9keVxuICAgIGlmIChib2R5IGluc3RhbmNlb2YgQm9keUJsb2NrKSB7XG4gICAgICB5aWVsZCogYm9keS5zdGF0ZW1lbnRzKClcbiAgICB9IGVsc2UgaWYgKGJvZHkpIHtcbiAgICAgIHlpZWxkIGJvZHlcbiAgICB9XG4gIH1cblxuICAqY29uY3JldGVDaGlsZHJlbihfdmVyYmF0aW0/OiBib29sZWFuKTogSXRlcmFibGVJdGVyYXRvcjxSYXdOb2RlQ2hpbGQ+IHtcbiAgICBjb25zdCB7IG5hbWUsIGFyZ3VtZW50RGVmaW5pdGlvbnMsIGVxdWFscywgYm9keSB9ID0gZ2V0QWxsKHRoaXMuZmllbGRzKVxuICAgIHlpZWxkIG5hbWVcbiAgICBmb3IgKGNvbnN0IGRlZiBvZiBhcmd1bWVudERlZmluaXRpb25zKSB5aWVsZCogZGVmXG4gICAgeWllbGQgeyB3aGl0ZXNwYWNlOiBlcXVhbHMud2hpdGVzcGFjZSA/PyAnICcsIG5vZGU6IHRoaXMubW9kdWxlLmdldFRva2VuKGVxdWFscy5ub2RlKSB9XG4gICAgaWYgKGJvZHkpIHlpZWxkIHByZWZlclNwYWNlZElmKGJvZHksIHRoaXMubW9kdWxlLnRyeUdldChib2R5Lm5vZGUpIGluc3RhbmNlb2YgQm9keUJsb2NrKVxuICB9XG59XG5leHBvcnQgY2xhc3MgTXV0YWJsZUZ1bmN0aW9uIGV4dGVuZHMgRnVuY3Rpb24gaW1wbGVtZW50cyBNdXRhYmxlQXN0IHtcbiAgZGVjbGFyZSByZWFkb25seSBtb2R1bGU6IE11dGFibGVNb2R1bGVcbiAgZGVjbGFyZSByZWFkb25seSBmaWVsZHM6IEZpeGVkTWFwPEFzdEZpZWxkcyAmIEZ1bmN0aW9uRmllbGRzPlxuXG4gIHNldE5hbWU8VCBleHRlbmRzIE11dGFibGVBc3Q+KHZhbHVlOiBPd25lZDxUPikge1xuICAgIHRoaXMuZmllbGRzLnNldCgnbmFtZScsIHVuc3BhY2VkKHRoaXMuY2xhaW1DaGlsZCh2YWx1ZSkpKVxuICB9XG4gIHNldEJvZHk8VCBleHRlbmRzIE11dGFibGVBc3Q+KHZhbHVlOiBPd25lZDxUPiB8IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuZmllbGRzLnNldCgnYm9keScsIHVuc3BhY2VkKHRoaXMuY2xhaW1DaGlsZCh2YWx1ZSkpKVxuICB9XG4gIHNldEFyZ3VtZW50RGVmaW5pdGlvbnMoZGVmczogQXJndW1lbnREZWZpbml0aW9uPE93bmVkUmVmcz5bXSkge1xuICAgIHRoaXMuZmllbGRzLnNldChcbiAgICAgICdhcmd1bWVudERlZmluaXRpb25zJyxcbiAgICAgIGRlZnMubWFwKChkZWYpID0+IG1hcFJlZnMoZGVmLCBvd25lZFRvUmF3KHRoaXMubW9kdWxlLCB0aGlzLmlkKSkpLFxuICAgIClcbiAgfVxuXG4gIC8qKiBSZXR1cm5zIHRoZSBib2R5LCBhZnRlciBjb252ZXJ0aW5nIGl0IHRvIGEgYmxvY2sgaWYgaXQgd2FzIGVtcHR5IG9yIGFuIGlubGluZSBleHByZXNzaW9uLiAqL1xuICBib2R5QXNCbG9jaygpOiBNdXRhYmxlQm9keUJsb2NrIHtcbiAgICBjb25zdCBvbGRCb2R5ID0gdGhpcy5ib2R5XG4gICAgaWYgKG9sZEJvZHkgaW5zdGFuY2VvZiBNdXRhYmxlQm9keUJsb2NrKSByZXR1cm4gb2xkQm9keVxuICAgIGNvbnN0IG5ld0JvZHkgPSBCb2R5QmxvY2submV3KFtdLCB0aGlzLm1vZHVsZSlcbiAgICBpZiAob2xkQm9keSkgbmV3Qm9keS5wdXNoKG9sZEJvZHkudGFrZSgpKVxuICAgIHJldHVybiBuZXdCb2R5XG4gIH1cbn1cbmV4cG9ydCBpbnRlcmZhY2UgTXV0YWJsZUZ1bmN0aW9uIGV4dGVuZHMgRnVuY3Rpb24sIE11dGFibGVBc3Qge1xuICBnZXQgbmFtZSgpOiBNdXRhYmxlQXN0XG4gIGdldCBib2R5KCk6IE11dGFibGVBc3QgfCB1bmRlZmluZWRcbn1cbmFwcGx5TWl4aW5zKE11dGFibGVGdW5jdGlvbiwgW011dGFibGVBc3RdKVxuXG5pbnRlcmZhY2UgQXNzaWdubWVudEZpZWxkcyB7XG4gIHBhdHRlcm46IE5vZGVDaGlsZDxBc3RJZD5cbiAgZXF1YWxzOiBOb2RlQ2hpbGQ8U3luY1Rva2VuSWQ+XG4gIGV4cHJlc3Npb246IE5vZGVDaGlsZDxBc3RJZD5cbn1cbmV4cG9ydCBjbGFzcyBBc3NpZ25tZW50IGV4dGVuZHMgQXN0IHtcbiAgZGVjbGFyZSBmaWVsZHM6IEZpeGVkTWFwVmlldzxBc3RGaWVsZHMgJiBBc3NpZ25tZW50RmllbGRzPlxuICBjb25zdHJ1Y3Rvcihtb2R1bGU6IE1vZHVsZSwgZmllbGRzOiBGaXhlZE1hcFZpZXc8QXN0RmllbGRzICYgQXNzaWdubWVudEZpZWxkcz4pIHtcbiAgICBzdXBlcihtb2R1bGUsIGZpZWxkcylcbiAgfVxuXG4gIHN0YXRpYyB0cnlQYXJzZShzb3VyY2U6IHN0cmluZywgbW9kdWxlPzogTXV0YWJsZU1vZHVsZSk6IE93bmVkPE11dGFibGVBc3NpZ25tZW50PiB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2Uoc291cmNlLCBtb2R1bGUpXG4gICAgaWYgKHBhcnNlZCBpbnN0YW5jZW9mIE11dGFibGVBc3NpZ25tZW50KSByZXR1cm4gcGFyc2VkXG4gIH1cblxuICBzdGF0aWMgY29uY3JldGUoXG4gICAgbW9kdWxlOiBNdXRhYmxlTW9kdWxlLFxuICAgIHBhdHRlcm46IE5vZGVDaGlsZDxPd25lZD4sXG4gICAgZXF1YWxzOiBOb2RlQ2hpbGQ8VG9rZW4+LFxuICAgIGV4cHJlc3Npb246IE5vZGVDaGlsZDxPd25lZD4sXG4gICkge1xuICAgIGNvbnN0IGJhc2UgPSBtb2R1bGUuYmFzZU9iamVjdCgnQXNzaWdubWVudCcpXG4gICAgY29uc3QgaWRfID0gYmFzZS5nZXQoJ2lkJylcbiAgICBjb25zdCBmaWVsZHMgPSBjb21wb3NlRmllbGREYXRhKGJhc2UsIHtcbiAgICAgIHBhdHRlcm46IGNvbmNyZXRlQ2hpbGQobW9kdWxlLCBwYXR0ZXJuLCBpZF8pLFxuICAgICAgZXF1YWxzLFxuICAgICAgZXhwcmVzc2lvbjogY29uY3JldGVDaGlsZChtb2R1bGUsIGV4cHJlc3Npb24sIGlkXyksXG4gICAgfSlcbiAgICByZXR1cm4gYXNPd25lZChuZXcgTXV0YWJsZUFzc2lnbm1lbnQobW9kdWxlLCBmaWVsZHMpKVxuICB9XG5cbiAgc3RhdGljIG5ldyhtb2R1bGU6IE11dGFibGVNb2R1bGUsIGlkZW50OiBTdHJpY3RJZGVudExpa2UsIGV4cHJlc3Npb246IE93bmVkKSB7XG4gICAgcmV0dXJuIEFzc2lnbm1lbnQuY29uY3JldGUoXG4gICAgICBtb2R1bGUsXG4gICAgICB1bnNwYWNlZChJZGVudC5uZXcobW9kdWxlLCBpZGVudCkpLFxuICAgICAgc3BhY2VkKG1ha2VFcXVhbHMoKSksXG4gICAgICBzcGFjZWQoZXhwcmVzc2lvbiksXG4gICAgKVxuICB9XG5cbiAgZ2V0IHBhdHRlcm4oKTogQXN0IHtcbiAgICByZXR1cm4gdGhpcy5tb2R1bGUuZ2V0KHRoaXMuZmllbGRzLmdldCgncGF0dGVybicpLm5vZGUpXG4gIH1cbiAgZ2V0IGV4cHJlc3Npb24oKTogQXN0IHtcbiAgICByZXR1cm4gdGhpcy5tb2R1bGUuZ2V0KHRoaXMuZmllbGRzLmdldCgnZXhwcmVzc2lvbicpLm5vZGUpXG4gIH1cblxuICAqY29uY3JldGVDaGlsZHJlbih2ZXJiYXRpbT86IGJvb2xlYW4pOiBJdGVyYWJsZUl0ZXJhdG9yPFJhd05vZGVDaGlsZD4ge1xuICAgIGNvbnN0IHsgcGF0dGVybiwgZXF1YWxzLCBleHByZXNzaW9uIH0gPSBnZXRBbGwodGhpcy5maWVsZHMpXG4gICAgeWllbGQgZW5zdXJlVW5zcGFjZWQocGF0dGVybiwgdmVyYmF0aW0pXG4gICAgeWllbGQgZW5zdXJlU3BhY2VkT25seUlmKGVxdWFscywgZXhwcmVzc2lvbi53aGl0ZXNwYWNlICE9PSAnJywgdmVyYmF0aW0pXG4gICAgeWllbGQgcHJlZmVyU3BhY2VkKGV4cHJlc3Npb24pXG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBNdXRhYmxlQXNzaWdubWVudCBleHRlbmRzIEFzc2lnbm1lbnQgaW1wbGVtZW50cyBNdXRhYmxlQXN0IHtcbiAgZGVjbGFyZSByZWFkb25seSBtb2R1bGU6IE11dGFibGVNb2R1bGVcbiAgZGVjbGFyZSByZWFkb25seSBmaWVsZHM6IEZpeGVkTWFwPEFzdEZpZWxkcyAmIEFzc2lnbm1lbnRGaWVsZHM+XG5cbiAgc2V0UGF0dGVybjxUIGV4dGVuZHMgTXV0YWJsZUFzdD4odmFsdWU6IE93bmVkPFQ+KSB7XG4gICAgdGhpcy5maWVsZHMuc2V0KCdwYXR0ZXJuJywgdW5zcGFjZWQodGhpcy5jbGFpbUNoaWxkKHZhbHVlKSkpXG4gIH1cbiAgc2V0RXhwcmVzc2lvbjxUIGV4dGVuZHMgTXV0YWJsZUFzdD4odmFsdWU6IE93bmVkPFQ+KSB7XG4gICAgc2V0Tm9kZSh0aGlzLmZpZWxkcywgJ2V4cHJlc3Npb24nLCB0aGlzLmNsYWltQ2hpbGQodmFsdWUpKVxuICB9XG59XG5leHBvcnQgaW50ZXJmYWNlIE11dGFibGVBc3NpZ25tZW50IGV4dGVuZHMgQXNzaWdubWVudCwgTXV0YWJsZUFzdCB7XG4gIGdldCBwYXR0ZXJuKCk6IE11dGFibGVBc3RcbiAgZ2V0IGV4cHJlc3Npb24oKTogTXV0YWJsZUFzdFxufVxuYXBwbHlNaXhpbnMoTXV0YWJsZUFzc2lnbm1lbnQsIFtNdXRhYmxlQXN0XSlcblxuaW50ZXJmYWNlIEJvZHlCbG9ja0ZpZWxkcyB7XG4gIGxpbmVzOiBSYXdCbG9ja0xpbmVbXVxufVxuZXhwb3J0IGNsYXNzIEJvZHlCbG9jayBleHRlbmRzIEFzdCB7XG4gIGRlY2xhcmUgZmllbGRzOiBGaXhlZE1hcFZpZXc8QXN0RmllbGRzICYgQm9keUJsb2NrRmllbGRzPlxuICBjb25zdHJ1Y3Rvcihtb2R1bGU6IE1vZHVsZSwgZmllbGRzOiBGaXhlZE1hcFZpZXc8QXN0RmllbGRzICYgQm9keUJsb2NrRmllbGRzPikge1xuICAgIHN1cGVyKG1vZHVsZSwgZmllbGRzKVxuICB9XG5cbiAgc3RhdGljIHRyeVBhcnNlKHNvdXJjZTogc3RyaW5nLCBtb2R1bGU/OiBNdXRhYmxlTW9kdWxlKTogT3duZWQ8TXV0YWJsZUJvZHlCbG9jaz4gfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlKHNvdXJjZSwgbW9kdWxlKVxuICAgIGlmIChwYXJzZWQgaW5zdGFuY2VvZiBNdXRhYmxlQm9keUJsb2NrKSByZXR1cm4gcGFyc2VkXG4gIH1cblxuICBzdGF0aWMgY29uY3JldGUobW9kdWxlOiBNdXRhYmxlTW9kdWxlLCBsaW5lczogT3duZWRCbG9ja0xpbmVbXSkge1xuICAgIGNvbnN0IGJhc2UgPSBtb2R1bGUuYmFzZU9iamVjdCgnQm9keUJsb2NrJylcbiAgICBjb25zdCBpZF8gPSBiYXNlLmdldCgnaWQnKVxuICAgIGNvbnN0IGZpZWxkcyA9IGNvbXBvc2VGaWVsZERhdGEoYmFzZSwge1xuICAgICAgbGluZXM6IGxpbmVzLm1hcCgobGluZSkgPT4gbGluZVRvUmF3KGxpbmUsIG1vZHVsZSwgaWRfKSksXG4gICAgfSlcbiAgICByZXR1cm4gYXNPd25lZChuZXcgTXV0YWJsZUJvZHlCbG9jayhtb2R1bGUsIGZpZWxkcykpXG4gIH1cblxuICBzdGF0aWMgbmV3KGxpbmVzOiBPd25lZEJsb2NrTGluZVtdLCBtb2R1bGU6IE11dGFibGVNb2R1bGUpIHtcbiAgICByZXR1cm4gQm9keUJsb2NrLmNvbmNyZXRlKG1vZHVsZSwgbGluZXMpXG4gIH1cblxuICBnZXQgbGluZXMoKTogQmxvY2tMaW5lW10ge1xuICAgIHJldHVybiB0aGlzLmZpZWxkcy5nZXQoJ2xpbmVzJykubWFwKChsaW5lKSA9PiBsaW5lRnJvbVJhdyhsaW5lLCB0aGlzLm1vZHVsZSkpXG4gIH1cblxuICAqc3RhdGVtZW50cygpOiBJdGVyYWJsZUl0ZXJhdG9yPEFzdD4ge1xuICAgIGZvciAoY29uc3QgbGluZSBvZiB0aGlzLmxpbmVzKSB7XG4gICAgICBpZiAobGluZS5leHByZXNzaW9uKSB5aWVsZCBsaW5lLmV4cHJlc3Npb24ubm9kZVxuICAgIH1cbiAgfVxuXG4gICpjb25jcmV0ZUNoaWxkcmVuKF92ZXJiYXRpbT86IGJvb2xlYW4pOiBJdGVyYWJsZUl0ZXJhdG9yPFJhd05vZGVDaGlsZD4ge1xuICAgIGZvciAoY29uc3QgbGluZSBvZiB0aGlzLmZpZWxkcy5nZXQoJ2xpbmVzJykpIHtcbiAgICAgIHlpZWxkIHByZWZlclVuc3BhY2VkKGxpbmUubmV3bGluZSlcbiAgICAgIGlmIChsaW5lLmV4cHJlc3Npb24pIHlpZWxkIGxpbmUuZXhwcmVzc2lvblxuICAgIH1cbiAgfVxuXG4gIHByaW50U3VidHJlZShcbiAgICBpbmZvOiBTcGFuTWFwLFxuICAgIG9mZnNldDogbnVtYmVyLFxuICAgIHBhcmVudEluZGVudDogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIHZlcmJhdGltPzogYm9vbGVhbixcbiAgKTogc3RyaW5nIHtcbiAgICByZXR1cm4gcHJpbnRCbG9jayh0aGlzLCBpbmZvLCBvZmZzZXQsIHBhcmVudEluZGVudCwgdmVyYmF0aW0pXG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBNdXRhYmxlQm9keUJsb2NrIGV4dGVuZHMgQm9keUJsb2NrIGltcGxlbWVudHMgTXV0YWJsZUFzdCB7XG4gIGRlY2xhcmUgcmVhZG9ubHkgbW9kdWxlOiBNdXRhYmxlTW9kdWxlXG4gIGRlY2xhcmUgcmVhZG9ubHkgZmllbGRzOiBGaXhlZE1hcDxBc3RGaWVsZHMgJiBCb2R5QmxvY2tGaWVsZHM+XG5cbiAgdXBkYXRlTGluZXMobWFwOiAobGluZXM6IE93bmVkQmxvY2tMaW5lW10pID0+IE93bmVkQmxvY2tMaW5lW10pIHtcbiAgICByZXR1cm4gdGhpcy5zZXRMaW5lcyhtYXAodGhpcy50YWtlTGluZXMoKSkpXG4gIH1cbiAgdGFrZUxpbmVzKCk6IE93bmVkQmxvY2tMaW5lW10ge1xuICAgIHJldHVybiB0aGlzLmZpZWxkcy5nZXQoJ2xpbmVzJykubWFwKChsaW5lKSA9PiBvd25lZExpbmVGcm9tUmF3KGxpbmUsIHRoaXMubW9kdWxlKSlcbiAgfVxuICBzZXRMaW5lcyhsaW5lczogT3duZWRCbG9ja0xpbmVbXSkge1xuICAgIHRoaXMuZmllbGRzLnNldChcbiAgICAgICdsaW5lcycsXG4gICAgICBsaW5lcy5tYXAoKGxpbmUpID0+IGxpbmVUb1JhdyhsaW5lLCB0aGlzLm1vZHVsZSwgdGhpcy5pZCkpLFxuICAgIClcbiAgfVxuXG4gIC8qKiBJbnNlcnQgdGhlIGdpdmVuIHN0YXRlbWVudChzKSBzdGFydGluZyBhdCB0aGUgc3BlY2lmaWVkIGxpbmUgaW5kZXguICovXG4gIGluc2VydChpbmRleDogbnVtYmVyLCAuLi5zdGF0ZW1lbnRzOiAoT3duZWQgfCB1bmRlZmluZWQpW10pIHtcbiAgICBjb25zdCBiZWZvcmUgPSB0aGlzLmZpZWxkcy5nZXQoJ2xpbmVzJykuc2xpY2UoMCwgaW5kZXgpXG4gICAgY29uc3QgaW5zZXJ0aW9ucyA9IHN0YXRlbWVudHMubWFwKChzdGF0ZW1lbnQpID0+ICh7XG4gICAgICBuZXdsaW5lOiB1bnNwYWNlZChUb2tlbi5uZXcoJ1xcbicsIFJhd0FzdC5Ub2tlbi5UeXBlLk5ld2xpbmUpKSxcbiAgICAgIGV4cHJlc3Npb246IHN0YXRlbWVudCAmJiB1bnNwYWNlZCh0aGlzLmNsYWltQ2hpbGQoc3RhdGVtZW50KSksXG4gICAgfSkpXG4gICAgY29uc3QgYWZ0ZXIgPSB0aGlzLmZpZWxkcy5nZXQoJ2xpbmVzJykuc2xpY2UoaW5kZXgpXG4gICAgdGhpcy5maWVsZHMuc2V0KCdsaW5lcycsIFsuLi5iZWZvcmUsIC4uLmluc2VydGlvbnMsIC4uLmFmdGVyXSlcbiAgfVxuXG4gIHB1c2goc3RhdGVtZW50OiBPd25lZCkge1xuICAgIGNvbnN0IG9sZExpbmVzID0gdGhpcy5maWVsZHMuZ2V0KCdsaW5lcycpXG4gICAgY29uc3QgbmV3TGluZSA9IHtcbiAgICAgIG5ld2xpbmU6IHVuc3BhY2VkKFRva2VuLm5ldygnXFxuJywgUmF3QXN0LlRva2VuLlR5cGUuTmV3bGluZSkpLFxuICAgICAgZXhwcmVzc2lvbjogdW5zcGFjZWQodGhpcy5jbGFpbUNoaWxkKHN0YXRlbWVudCkpLFxuICAgIH1cbiAgICB0aGlzLmZpZWxkcy5zZXQoJ2xpbmVzJywgWy4uLm9sZExpbmVzLCBuZXdMaW5lXSlcbiAgfVxuXG4gIGZpbHRlcihrZWVwOiAoYXN0OiBNdXRhYmxlQXN0KSA9PiBib29sZWFuKSB7XG4gICAgY29uc3Qgb2xkTGluZXMgPSB0aGlzLmZpZWxkcy5nZXQoJ2xpbmVzJylcbiAgICBjb25zdCBmaWx0ZXJlZExpbmVzID0gb2xkTGluZXMuZmlsdGVyKChsaW5lKSA9PiB7XG4gICAgICBpZiAoIWxpbmUuZXhwcmVzc2lvbikgcmV0dXJuIHRydWVcbiAgICAgIHJldHVybiBrZWVwKHRoaXMubW9kdWxlLmdldChsaW5lLmV4cHJlc3Npb24ubm9kZSkpXG4gICAgfSlcbiAgICB0aGlzLmZpZWxkcy5zZXQoJ2xpbmVzJywgZmlsdGVyZWRMaW5lcylcbiAgfVxufVxuZXhwb3J0IGludGVyZmFjZSBNdXRhYmxlQm9keUJsb2NrIGV4dGVuZHMgQm9keUJsb2NrLCBNdXRhYmxlQXN0IHtcbiAgc3RhdGVtZW50cygpOiBJdGVyYWJsZUl0ZXJhdG9yPE11dGFibGVBc3Q+XG59XG5hcHBseU1peGlucyhNdXRhYmxlQm9keUJsb2NrLCBbTXV0YWJsZUFzdF0pXG5cbmludGVyZmFjZSBSYXdMaW5lPFQgZXh0ZW5kcyBUcmVlUmVmcz4ge1xuICBuZXdsaW5lOiBUWyd0b2tlbiddXG4gIGV4cHJlc3Npb246IFRbJ2FzdCddIHwgdW5kZWZpbmVkXG59XG5cbmludGVyZmFjZSBMaW5lPFQgZXh0ZW5kcyBUcmVlUmVmcz4ge1xuICBuZXdsaW5lPzogVFsndG9rZW4nXSB8IHVuZGVmaW5lZFxuICBleHByZXNzaW9uOiBUWydhc3QnXSB8IHVuZGVmaW5lZFxufVxuXG50eXBlIFJhd0Jsb2NrTGluZSA9IFJhd0xpbmU8UmF3UmVmcz5cbmV4cG9ydCB0eXBlIEJsb2NrTGluZSA9IExpbmU8Q29uY3JldGVSZWZzPlxuZXhwb3J0IHR5cGUgT3duZWRCbG9ja0xpbmUgPSBMaW5lPE93bmVkUmVmcz5cblxuZnVuY3Rpb24gbGluZUZyb21SYXcocmF3OiBSYXdCbG9ja0xpbmUsIG1vZHVsZTogTW9kdWxlKTogQmxvY2tMaW5lIHtcbiAgY29uc3QgZXhwcmVzc2lvbiA9IHJhdy5leHByZXNzaW9uID8gbW9kdWxlLmdldChyYXcuZXhwcmVzc2lvbi5ub2RlKSA6IHVuZGVmaW5lZFxuICByZXR1cm4ge1xuICAgIG5ld2xpbmU6IHsgLi4ucmF3Lm5ld2xpbmUsIG5vZGU6IG1vZHVsZS5nZXRUb2tlbihyYXcubmV3bGluZS5ub2RlKSB9LFxuICAgIGV4cHJlc3Npb246XG4gICAgICBleHByZXNzaW9uID9cbiAgICAgICAge1xuICAgICAgICAgIHdoaXRlc3BhY2U6IHJhdy5leHByZXNzaW9uPy53aGl0ZXNwYWNlLFxuICAgICAgICAgIG5vZGU6IGV4cHJlc3Npb24sXG4gICAgICAgIH1cbiAgICAgIDogdW5kZWZpbmVkLFxuICB9XG59XG5cbmZ1bmN0aW9uIG93bmVkTGluZUZyb21SYXcocmF3OiBSYXdCbG9ja0xpbmUsIG1vZHVsZTogTXV0YWJsZU1vZHVsZSk6IE93bmVkQmxvY2tMaW5lIHtcbiAgY29uc3QgZXhwcmVzc2lvbiA9IHJhdy5leHByZXNzaW9uID8gbW9kdWxlLmdldChyYXcuZXhwcmVzc2lvbi5ub2RlKS50YWtlSWZQYXJlbnRlZCgpIDogdW5kZWZpbmVkXG4gIHJldHVybiB7XG4gICAgbmV3bGluZTogeyAuLi5yYXcubmV3bGluZSwgbm9kZTogbW9kdWxlLmdldFRva2VuKHJhdy5uZXdsaW5lLm5vZGUpIH0sXG4gICAgZXhwcmVzc2lvbjpcbiAgICAgIGV4cHJlc3Npb24gP1xuICAgICAgICB7XG4gICAgICAgICAgd2hpdGVzcGFjZTogcmF3LmV4cHJlc3Npb24/LndoaXRlc3BhY2UsXG4gICAgICAgICAgbm9kZTogZXhwcmVzc2lvbixcbiAgICAgICAgfVxuICAgICAgOiB1bmRlZmluZWQsXG4gIH1cbn1cblxuZnVuY3Rpb24gbGluZVRvUmF3KGxpbmU6IE93bmVkQmxvY2tMaW5lLCBtb2R1bGU6IE11dGFibGVNb2R1bGUsIGJsb2NrOiBBc3RJZCk6IFJhd0Jsb2NrTGluZSB7XG4gIHJldHVybiB7XG4gICAgbmV3bGluZTogbGluZS5uZXdsaW5lID8/IHVuc3BhY2VkKFRva2VuLm5ldygnXFxuJywgUmF3QXN0LlRva2VuLlR5cGUuTmV3bGluZSkpLFxuICAgIGV4cHJlc3Npb246XG4gICAgICBsaW5lLmV4cHJlc3Npb24gP1xuICAgICAgICB7XG4gICAgICAgICAgd2hpdGVzcGFjZTogbGluZS5leHByZXNzaW9uPy53aGl0ZXNwYWNlLFxuICAgICAgICAgIG5vZGU6IGNsYWltQ2hpbGQobW9kdWxlLCBsaW5lLmV4cHJlc3Npb24ubm9kZSwgYmxvY2spLFxuICAgICAgICB9XG4gICAgICA6IHVuZGVmaW5lZCxcbiAgfVxufVxuXG5pbnRlcmZhY2UgSWRlbnRGaWVsZHMge1xuICB0b2tlbjogTm9kZUNoaWxkPFN5bmNUb2tlbklkPlxufVxuZXhwb3J0IGNsYXNzIElkZW50IGV4dGVuZHMgQXN0IHtcbiAgZGVjbGFyZSBmaWVsZHM6IEZpeGVkTWFwVmlldzxBc3RGaWVsZHMgJiBJZGVudEZpZWxkcz5cbiAgY29uc3RydWN0b3IobW9kdWxlOiBNb2R1bGUsIGZpZWxkczogRml4ZWRNYXBWaWV3PEFzdEZpZWxkcyAmIElkZW50RmllbGRzPikge1xuICAgIHN1cGVyKG1vZHVsZSwgZmllbGRzKVxuICB9XG5cbiAgc3RhdGljIHRyeVBhcnNlKHNvdXJjZTogc3RyaW5nLCBtb2R1bGU/OiBNdXRhYmxlTW9kdWxlKTogT3duZWQ8TXV0YWJsZUlkZW50PiB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2Uoc291cmNlLCBtb2R1bGUpXG4gICAgaWYgKHBhcnNlZCBpbnN0YW5jZW9mIE11dGFibGVJZGVudCkgcmV0dXJuIHBhcnNlZFxuICB9XG5cbiAgZ2V0IHRva2VuKCk6IElkZW50aWZpZXJUb2tlbiB7XG4gICAgcmV0dXJuIHRoaXMubW9kdWxlLmdldFRva2VuKHRoaXMuZmllbGRzLmdldCgndG9rZW4nKS5ub2RlKSBhcyBJZGVudGlmaWVyVG9rZW5cbiAgfVxuXG4gIHN0YXRpYyBjb25jcmV0ZShtb2R1bGU6IE11dGFibGVNb2R1bGUsIHRva2VuOiBOb2RlQ2hpbGQ8VG9rZW4+KSB7XG4gICAgY29uc3QgYmFzZSA9IG1vZHVsZS5iYXNlT2JqZWN0KCdJZGVudCcpXG4gICAgY29uc3QgZmllbGRzID0gY29tcG9zZUZpZWxkRGF0YShiYXNlLCB7IHRva2VuIH0pXG4gICAgcmV0dXJuIGFzT3duZWQobmV3IE11dGFibGVJZGVudChtb2R1bGUsIGZpZWxkcykpXG4gIH1cblxuICBzdGF0aWMgbmV3KG1vZHVsZTogTXV0YWJsZU1vZHVsZSwgaWRlbnQ6IFN0cmljdElkZW50TGlrZSkge1xuICAgIHJldHVybiBJZGVudC5jb25jcmV0ZShtb2R1bGUsIHVuc3BhY2VkKHRvSWRlbnRTdHJpY3QoaWRlbnQpKSlcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIG5ld0FsbG93aW5nT3BlcmF0b3JzKG1vZHVsZTogTXV0YWJsZU1vZHVsZSwgaWRlbnQ6IElkZW50TGlrZSkge1xuICAgIHJldHVybiBJZGVudC5jb25jcmV0ZShtb2R1bGUsIHVuc3BhY2VkKHRvSWRlbnQoaWRlbnQpKSlcbiAgfVxuXG4gICpjb25jcmV0ZUNoaWxkcmVuKF92ZXJiYXRpbT86IGJvb2xlYW4pOiBJdGVyYWJsZUl0ZXJhdG9yPFJhd05vZGVDaGlsZD4ge1xuICAgIHlpZWxkIHRoaXMuZmllbGRzLmdldCgndG9rZW4nKVxuICB9XG5cbiAgY29kZSgpOiBJZGVudGlmaWVyIHtcbiAgICByZXR1cm4gdGhpcy50b2tlbi5jb2RlKCkgYXMgSWRlbnRpZmllclxuICB9XG59XG5leHBvcnQgY2xhc3MgTXV0YWJsZUlkZW50IGV4dGVuZHMgSWRlbnQgaW1wbGVtZW50cyBNdXRhYmxlQXN0IHtcbiAgZGVjbGFyZSByZWFkb25seSBtb2R1bGU6IE11dGFibGVNb2R1bGVcbiAgZGVjbGFyZSByZWFkb25seSBmaWVsZHM6IEZpeGVkTWFwPEFzdEZpZWxkcyAmIElkZW50RmllbGRzPlxuXG4gIHNldFRva2VuKGlkZW50OiBJZGVudExpa2UpIHtcbiAgICB0aGlzLmZpZWxkcy5zZXQoJ3Rva2VuJywgdW5zcGFjZWQodG9JZGVudChpZGVudCkpKVxuICB9XG5cbiAgY29kZSgpOiBJZGVudGlmaWVyIHtcbiAgICByZXR1cm4gdGhpcy50b2tlbi5jb2RlKClcbiAgfVxufVxuZXhwb3J0IGludGVyZmFjZSBNdXRhYmxlSWRlbnQgZXh0ZW5kcyBJZGVudCwgTXV0YWJsZUFzdCB7fVxuYXBwbHlNaXhpbnMoTXV0YWJsZUlkZW50LCBbTXV0YWJsZUFzdF0pXG5cbmludGVyZmFjZSBXaWxkY2FyZEZpZWxkcyB7XG4gIHRva2VuOiBOb2RlQ2hpbGQ8U3luY1Rva2VuSWQ+XG59XG5leHBvcnQgY2xhc3MgV2lsZGNhcmQgZXh0ZW5kcyBBc3Qge1xuICBkZWNsYXJlIGZpZWxkczogRml4ZWRNYXBWaWV3PEFzdEZpZWxkcyAmIFdpbGRjYXJkRmllbGRzPlxuICBjb25zdHJ1Y3Rvcihtb2R1bGU6IE1vZHVsZSwgZmllbGRzOiBGaXhlZE1hcFZpZXc8QXN0RmllbGRzICYgV2lsZGNhcmRGaWVsZHM+KSB7XG4gICAgc3VwZXIobW9kdWxlLCBmaWVsZHMpXG4gIH1cblxuICBzdGF0aWMgdHJ5UGFyc2Uoc291cmNlOiBzdHJpbmcsIG1vZHVsZT86IE11dGFibGVNb2R1bGUpOiBPd25lZDxNdXRhYmxlV2lsZGNhcmQ+IHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZShzb3VyY2UsIG1vZHVsZSlcbiAgICBpZiAocGFyc2VkIGluc3RhbmNlb2YgTXV0YWJsZVdpbGRjYXJkKSByZXR1cm4gcGFyc2VkXG4gIH1cblxuICBnZXQgdG9rZW4oKTogVG9rZW4ge1xuICAgIHJldHVybiB0aGlzLm1vZHVsZS5nZXRUb2tlbih0aGlzLmZpZWxkcy5nZXQoJ3Rva2VuJykubm9kZSlcbiAgfVxuXG4gIHN0YXRpYyBjb25jcmV0ZShtb2R1bGU6IE11dGFibGVNb2R1bGUsIHRva2VuOiBOb2RlQ2hpbGQ8VG9rZW4+KSB7XG4gICAgY29uc3QgYmFzZSA9IG1vZHVsZS5iYXNlT2JqZWN0KCdXaWxkY2FyZCcpXG4gICAgY29uc3QgZmllbGRzID0gY29tcG9zZUZpZWxkRGF0YShiYXNlLCB7IHRva2VuIH0pXG4gICAgcmV0dXJuIGFzT3duZWQobmV3IE11dGFibGVXaWxkY2FyZChtb2R1bGUsIGZpZWxkcykpXG4gIH1cblxuICBzdGF0aWMgbmV3KG1vZHVsZT86IE11dGFibGVNb2R1bGUpIHtcbiAgICBjb25zdCB0b2tlbiA9IFRva2VuLm5ldygnXycsIFJhd0FzdC5Ub2tlbi5UeXBlLldpbGRjYXJkKVxuICAgIHJldHVybiB0aGlzLmNvbmNyZXRlKG1vZHVsZSA/PyBNdXRhYmxlTW9kdWxlLlRyYW5zaWVudCgpLCB1bnNwYWNlZCh0b2tlbikpXG4gIH1cblxuICAqY29uY3JldGVDaGlsZHJlbihfdmVyYmF0aW0/OiBib29sZWFuKTogSXRlcmFibGVJdGVyYXRvcjxSYXdOb2RlQ2hpbGQ+IHtcbiAgICB5aWVsZCB0aGlzLmZpZWxkcy5nZXQoJ3Rva2VuJylcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTXV0YWJsZVdpbGRjYXJkIGV4dGVuZHMgV2lsZGNhcmQgaW1wbGVtZW50cyBNdXRhYmxlQXN0IHtcbiAgZGVjbGFyZSByZWFkb25seSBtb2R1bGU6IE11dGFibGVNb2R1bGVcbiAgZGVjbGFyZSByZWFkb25seSBmaWVsZHM6IEZpeGVkTWFwPEFzdEZpZWxkcyAmIFdpbGRjYXJkRmllbGRzPlxufVxuZXhwb3J0IGludGVyZmFjZSBNdXRhYmxlV2lsZGNhcmQgZXh0ZW5kcyBXaWxkY2FyZCwgTXV0YWJsZUFzdCB7fVxuYXBwbHlNaXhpbnMoTXV0YWJsZVdpbGRjYXJkLCBbTXV0YWJsZUFzdF0pXG5cbnR5cGUgQWJzdHJhY3RWZWN0b3JFbGVtZW50PFQgZXh0ZW5kcyBUcmVlUmVmcz4gPSB7XG4gIGRlbGltaXRlcj86IFRbJ3Rva2VuJ11cbiAgdmFsdWU6IFRbJ2FzdCddIHwgdW5kZWZpbmVkXG59XG5mdW5jdGlvbiBkZWxpbWl0VmVjdG9yRWxlbWVudChlbGVtZW50OiBBYnN0cmFjdFZlY3RvckVsZW1lbnQ8T3duZWRSZWZzPik6IFZlY3RvckVsZW1lbnQ8T3duZWRSZWZzPiB7XG4gIHJldHVybiB7XG4gICAgLi4uZWxlbWVudCxcbiAgICBkZWxpbWl0ZXI6IGVsZW1lbnQuZGVsaW1pdGVyID8/IHVuc3BhY2VkKFRva2VuLm5ldygnLCcsIFJhd0FzdC5Ub2tlbi5UeXBlLk9wZXJhdG9yKSksXG4gIH1cbn1cbnR5cGUgVmVjdG9yRWxlbWVudDxUIGV4dGVuZHMgVHJlZVJlZnM+ID0geyBkZWxpbWl0ZXI6IFRbJ3Rva2VuJ107IHZhbHVlOiBUWydhc3QnXSB8IHVuZGVmaW5lZCB9XG5pbnRlcmZhY2UgVmVjdG9yRmllbGRzIHtcbiAgb3BlbjogTm9kZUNoaWxkPFRva2VuPlxuICBlbGVtZW50czogVmVjdG9yRWxlbWVudDxSYXdSZWZzPltdXG4gIGNsb3NlOiBOb2RlQ2hpbGQ8VG9rZW4+XG59XG5leHBvcnQgY2xhc3MgVmVjdG9yIGV4dGVuZHMgQXN0IHtcbiAgZGVjbGFyZSBmaWVsZHM6IEZpeGVkTWFwVmlldzxBc3RGaWVsZHMgJiBWZWN0b3JGaWVsZHM+XG4gIGNvbnN0cnVjdG9yKG1vZHVsZTogTW9kdWxlLCBmaWVsZHM6IEZpeGVkTWFwVmlldzxBc3RGaWVsZHMgJiBWZWN0b3JGaWVsZHM+KSB7XG4gICAgc3VwZXIobW9kdWxlLCBmaWVsZHMpXG4gIH1cblxuICBzdGF0aWMgdHJ5UGFyc2Uoc291cmNlOiBzdHJpbmcsIG1vZHVsZT86IE11dGFibGVNb2R1bGUpOiBPd25lZDxNdXRhYmxlVmVjdG9yPiB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2Uoc291cmNlLCBtb2R1bGUpXG4gICAgaWYgKHBhcnNlZCBpbnN0YW5jZW9mIE11dGFibGVWZWN0b3IpIHJldHVybiBwYXJzZWRcbiAgfVxuXG4gIHN0YXRpYyBjb25jcmV0ZShcbiAgICBtb2R1bGU6IE11dGFibGVNb2R1bGUsXG4gICAgb3BlbjogTm9kZUNoaWxkPFRva2VuPiB8IHVuZGVmaW5lZCxcbiAgICBlbGVtZW50czogQWJzdHJhY3RWZWN0b3JFbGVtZW50PE93bmVkUmVmcz5bXSxcbiAgICBjbG9zZTogTm9kZUNoaWxkPFRva2VuPiB8IHVuZGVmaW5lZCxcbiAgKSB7XG4gICAgY29uc3QgYmFzZSA9IG1vZHVsZS5iYXNlT2JqZWN0KCdWZWN0b3InKVxuICAgIGNvbnN0IGlkXyA9IGJhc2UuZ2V0KCdpZCcpXG4gICAgY29uc3QgZmllbGRzID0gY29tcG9zZUZpZWxkRGF0YShiYXNlLCB7XG4gICAgICBvcGVuOiBvcGVuID8/IHVuc3BhY2VkKFRva2VuLm5ldygnWycsIFJhd0FzdC5Ub2tlbi5UeXBlLk9wZW5TeW1ib2wpKSxcbiAgICAgIGVsZW1lbnRzOiBlbGVtZW50cy5tYXAoZGVsaW1pdFZlY3RvckVsZW1lbnQpLm1hcCgoZSkgPT4gbWFwUmVmcyhlLCBvd25lZFRvUmF3KG1vZHVsZSwgaWRfKSkpLFxuICAgICAgY2xvc2U6IGNsb3NlID8/IHVuc3BhY2VkKFRva2VuLm5ldygnXScsIFJhd0FzdC5Ub2tlbi5UeXBlLkNsb3NlU3ltYm9sKSksXG4gICAgfSlcbiAgICByZXR1cm4gYXNPd25lZChuZXcgTXV0YWJsZVZlY3Rvcihtb2R1bGUsIGZpZWxkcykpXG4gIH1cblxuICBzdGF0aWMgbmV3KG1vZHVsZTogTXV0YWJsZU1vZHVsZSwgZWxlbWVudHM6IE93bmVkW10pIHtcbiAgICByZXR1cm4gdGhpcy5jb25jcmV0ZShcbiAgICAgIG1vZHVsZSxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIGVsZW1lbnRzLm1hcCgodmFsdWUpID0+ICh7IHZhbHVlOiBhdXRvc3BhY2VkKHZhbHVlKSB9KSksXG4gICAgICB1bmRlZmluZWQsXG4gICAgKVxuICB9XG5cbiAgc3RhdGljIHRyeUJ1aWxkPFQ+KFxuICAgIGlucHV0czogSXRlcmFibGU8VD4sXG4gICAgZWxlbWVudEJ1aWxkZXI6IChpbnB1dDogVCwgbW9kdWxlOiBNdXRhYmxlTW9kdWxlKSA9PiBPd25lZCxcbiAgICBlZGl0PzogTXV0YWJsZU1vZHVsZSxcbiAgKTogT3duZWQ8TXV0YWJsZVZlY3Rvcj5cbiAgc3RhdGljIHRyeUJ1aWxkPFQ+KFxuICAgIGlucHV0czogSXRlcmFibGU8VD4sXG4gICAgZWxlbWVudEJ1aWxkZXI6IChpbnB1dDogVCwgbW9kdWxlOiBNdXRhYmxlTW9kdWxlKSA9PiBPd25lZCB8IHVuZGVmaW5lZCxcbiAgICBlZGl0PzogTXV0YWJsZU1vZHVsZSxcbiAgKTogT3duZWQ8TXV0YWJsZVZlY3Rvcj4gfCB1bmRlZmluZWRcbiAgc3RhdGljIHRyeUJ1aWxkPFQ+KFxuICAgIGlucHV0czogSXRlcmFibGU8VD4sXG4gICAgdmFsdWVCdWlsZGVyOiAoaW5wdXQ6IFQsIG1vZHVsZTogTXV0YWJsZU1vZHVsZSkgPT4gT3duZWQgfCB1bmRlZmluZWQsXG4gICAgZWRpdD86IE11dGFibGVNb2R1bGUsXG4gICk6IE93bmVkPE11dGFibGVWZWN0b3I+IHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBtb2R1bGUgPSBlZGl0ID8/IE11dGFibGVNb2R1bGUuVHJhbnNpZW50KClcbiAgICBjb25zdCBlbGVtZW50cyA9IG5ldyBBcnJheTxBYnN0cmFjdFZlY3RvckVsZW1lbnQ8T3duZWRSZWZzPj4oKVxuICAgIGZvciAoY29uc3QgaW5wdXQgb2YgaW5wdXRzKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlQnVpbGRlcihpbnB1dCwgbW9kdWxlKVxuICAgICAgaWYgKCF2YWx1ZSkgcmV0dXJuXG4gICAgICBlbGVtZW50cy5wdXNoKHsgdmFsdWU6IGF1dG9zcGFjZWQodmFsdWUpIH0pXG4gICAgfVxuICAgIHJldHVybiBWZWN0b3IuY29uY3JldGUobW9kdWxlLCB1bmRlZmluZWQsIGVsZW1lbnRzLCB1bmRlZmluZWQpXG4gIH1cblxuICBzdGF0aWMgYnVpbGQ8VD4oXG4gICAgaW5wdXRzOiBJdGVyYWJsZTxUPixcbiAgICBlbGVtZW50QnVpbGRlcjogKGlucHV0OiBULCBtb2R1bGU6IE11dGFibGVNb2R1bGUpID0+IE93bmVkLFxuICAgIGVkaXQ/OiBNdXRhYmxlTW9kdWxlLFxuICApOiBPd25lZDxNdXRhYmxlVmVjdG9yPiB7XG4gICAgcmV0dXJuIFZlY3Rvci50cnlCdWlsZChpbnB1dHMsIGVsZW1lbnRCdWlsZGVyLCBlZGl0KVxuICB9XG5cbiAgKmNvbmNyZXRlQ2hpbGRyZW4odmVyYmF0aW0/OiBib29sZWFuKTogSXRlcmFibGVJdGVyYXRvcjxSYXdOb2RlQ2hpbGQ+IHtcbiAgICBjb25zdCB7IG9wZW4sIGVsZW1lbnRzLCBjbG9zZSB9ID0gZ2V0QWxsKHRoaXMuZmllbGRzKVxuICAgIHlpZWxkIGVuc3VyZVVuc3BhY2VkKG9wZW4sIHZlcmJhdGltKVxuICAgIGxldCBpc0ZpcnN0ID0gdHJ1ZVxuICAgIGZvciAoY29uc3QgeyBkZWxpbWl0ZXIsIHZhbHVlIH0gb2YgZWxlbWVudHMpIHtcbiAgICAgIGlmIChpc0ZpcnN0ICYmIHZhbHVlKSB7XG4gICAgICAgIHlpZWxkIHByZWZlclVuc3BhY2VkKHZhbHVlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeWllbGQgcHJlZmVyVW5zcGFjZWQoZGVsaW1pdGVyKVxuICAgICAgICBpZiAodmFsdWUpIHlpZWxkIHByZWZlclNwYWNlZCh2YWx1ZSlcbiAgICAgIH1cbiAgICAgIGlzRmlyc3QgPSBmYWxzZVxuICAgIH1cbiAgICB5aWVsZCBwcmVmZXJVbnNwYWNlZChjbG9zZSlcbiAgfVxuXG4gICp2YWx1ZXMoKTogSXRlcmFibGVJdGVyYXRvcjxBc3Q+IHtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy5maWVsZHMuZ2V0KCdlbGVtZW50cycpKVxuICAgICAgaWYgKGVsZW1lbnQudmFsdWUpIHlpZWxkIHRoaXMubW9kdWxlLmdldChlbGVtZW50LnZhbHVlLm5vZGUpXG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBNdXRhYmxlVmVjdG9yIGV4dGVuZHMgVmVjdG9yIGltcGxlbWVudHMgTXV0YWJsZUFzdCB7XG4gIGRlY2xhcmUgcmVhZG9ubHkgbW9kdWxlOiBNdXRhYmxlTW9kdWxlXG4gIGRlY2xhcmUgcmVhZG9ubHkgZmllbGRzOiBGaXhlZE1hcDxBc3RGaWVsZHMgJiBWZWN0b3JGaWVsZHM+XG5cbiAgcHVzaCh2YWx1ZTogT3duZWQpIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuZmllbGRzLmdldCgnZWxlbWVudHMnKVxuICAgIGNvbnN0IGVsZW1lbnQgPSBtYXBSZWZzKFxuICAgICAgZGVsaW1pdFZlY3RvckVsZW1lbnQoeyB2YWx1ZTogYXV0b3NwYWNlZCh2YWx1ZSkgfSksXG4gICAgICBvd25lZFRvUmF3KHRoaXMubW9kdWxlLCB0aGlzLmlkKSxcbiAgICApXG4gICAgdGhpcy5maWVsZHMuc2V0KCdlbGVtZW50cycsIFsuLi5lbGVtZW50cywgZWxlbWVudF0pXG4gIH1cblxuICBrZWVwKHByZWRpY2F0ZTogKGFzdDogQXN0KSA9PiBib29sZWFuKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLmZpZWxkcy5nZXQoJ2VsZW1lbnRzJylcbiAgICBjb25zdCBmaWx0ZXJlZCA9IGVsZW1lbnRzLmZpbHRlcihcbiAgICAgIChlbGVtZW50KSA9PiBlbGVtZW50LnZhbHVlICYmIHByZWRpY2F0ZSh0aGlzLm1vZHVsZS5nZXQoZWxlbWVudC52YWx1ZS5ub2RlKSksXG4gICAgKVxuICAgIHRoaXMuZmllbGRzLnNldCgnZWxlbWVudHMnLCBmaWx0ZXJlZClcbiAgfVxufVxuZXhwb3J0IGludGVyZmFjZSBNdXRhYmxlVmVjdG9yIGV4dGVuZHMgVmVjdG9yLCBNdXRhYmxlQXN0IHtcbiAgdmFsdWVzKCk6IEl0ZXJhYmxlSXRlcmF0b3I8TXV0YWJsZUFzdD5cbn1cbmFwcGx5TWl4aW5zKE11dGFibGVWZWN0b3IsIFtNdXRhYmxlQXN0XSlcblxuZXhwb3J0IHR5cGUgTXV0YWJsZTxUIGV4dGVuZHMgQXN0ID0gQXN0PiA9XG4gIFQgZXh0ZW5kcyBBcHAgPyBNdXRhYmxlQXBwXG4gIDogVCBleHRlbmRzIEFzc2lnbm1lbnQgPyBNdXRhYmxlQXNzaWdubWVudFxuICA6IFQgZXh0ZW5kcyBCb2R5QmxvY2sgPyBNdXRhYmxlQm9keUJsb2NrXG4gIDogVCBleHRlbmRzIERvY3VtZW50ZWQgPyBNdXRhYmxlRG9jdW1lbnRlZFxuICA6IFQgZXh0ZW5kcyBGdW5jdGlvbiA/IE11dGFibGVGdW5jdGlvblxuICA6IFQgZXh0ZW5kcyBHZW5lcmljID8gTXV0YWJsZUdlbmVyaWNcbiAgOiBUIGV4dGVuZHMgR3JvdXAgPyBNdXRhYmxlR3JvdXBcbiAgOiBUIGV4dGVuZHMgSWRlbnQgPyBNdXRhYmxlSWRlbnRcbiAgOiBUIGV4dGVuZHMgSW1wb3J0ID8gTXV0YWJsZUltcG9ydFxuICA6IFQgZXh0ZW5kcyBJbnZhbGlkID8gTXV0YWJsZUludmFsaWRcbiAgOiBUIGV4dGVuZHMgTmVnYXRpb25BcHAgPyBNdXRhYmxlTmVnYXRpb25BcHBcbiAgOiBUIGV4dGVuZHMgTnVtZXJpY0xpdGVyYWwgPyBNdXRhYmxlTnVtZXJpY0xpdGVyYWxcbiAgOiBUIGV4dGVuZHMgT3ByQXBwID8gTXV0YWJsZU9wckFwcFxuICA6IFQgZXh0ZW5kcyBQcm9wZXJ0eUFjY2VzcyA/IE11dGFibGVQcm9wZXJ0eUFjY2Vzc1xuICA6IFQgZXh0ZW5kcyBUZXh0TGl0ZXJhbCA/IE11dGFibGVUZXh0TGl0ZXJhbFxuICA6IFQgZXh0ZW5kcyBVbmFyeU9wckFwcCA/IE11dGFibGVVbmFyeU9wckFwcFxuICA6IFQgZXh0ZW5kcyBWZWN0b3IgPyBNdXRhYmxlVmVjdG9yXG4gIDogVCBleHRlbmRzIFdpbGRjYXJkID8gTXV0YWJsZVdpbGRjYXJkXG4gIDogTXV0YWJsZUFzdFxuXG5leHBvcnQgZnVuY3Rpb24gbWF0ZXJpYWxpemVNdXRhYmxlKG1vZHVsZTogTXV0YWJsZU1vZHVsZSwgZmllbGRzOiBGaXhlZE1hcDxBc3RGaWVsZHM+KTogTXV0YWJsZUFzdCB7XG4gIGNvbnN0IHR5cGUgPSBmaWVsZHMuZ2V0KCd0eXBlJylcbiAgY29uc3QgZmllbGRzRm9yVHlwZSA9IGZpZWxkcyBhcyBGaXhlZE1hcDxhbnk+XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ0FwcCc6XG4gICAgICByZXR1cm4gbmV3IE11dGFibGVBcHAobW9kdWxlLCBmaWVsZHNGb3JUeXBlKVxuICAgIGNhc2UgJ0Fzc2lnbm1lbnQnOlxuICAgICAgcmV0dXJuIG5ldyBNdXRhYmxlQXNzaWdubWVudChtb2R1bGUsIGZpZWxkc0ZvclR5cGUpXG4gICAgY2FzZSAnQm9keUJsb2NrJzpcbiAgICAgIHJldHVybiBuZXcgTXV0YWJsZUJvZHlCbG9jayhtb2R1bGUsIGZpZWxkc0ZvclR5cGUpXG4gICAgY2FzZSAnRG9jdW1lbnRlZCc6XG4gICAgICByZXR1cm4gbmV3IE11dGFibGVEb2N1bWVudGVkKG1vZHVsZSwgZmllbGRzRm9yVHlwZSlcbiAgICBjYXNlICdGdW5jdGlvbic6XG4gICAgICByZXR1cm4gbmV3IE11dGFibGVGdW5jdGlvbihtb2R1bGUsIGZpZWxkc0ZvclR5cGUpXG4gICAgY2FzZSAnR2VuZXJpYyc6XG4gICAgICByZXR1cm4gbmV3IE11dGFibGVHZW5lcmljKG1vZHVsZSwgZmllbGRzRm9yVHlwZSlcbiAgICBjYXNlICdHcm91cCc6XG4gICAgICByZXR1cm4gbmV3IE11dGFibGVHcm91cChtb2R1bGUsIGZpZWxkc0ZvclR5cGUpXG4gICAgY2FzZSAnSWRlbnQnOlxuICAgICAgcmV0dXJuIG5ldyBNdXRhYmxlSWRlbnQobW9kdWxlLCBmaWVsZHNGb3JUeXBlKVxuICAgIGNhc2UgJ0ltcG9ydCc6XG4gICAgICByZXR1cm4gbmV3IE11dGFibGVJbXBvcnQobW9kdWxlLCBmaWVsZHNGb3JUeXBlKVxuICAgIGNhc2UgJ0ludmFsaWQnOlxuICAgICAgcmV0dXJuIG5ldyBNdXRhYmxlSW52YWxpZChtb2R1bGUsIGZpZWxkc0ZvclR5cGUpXG4gICAgY2FzZSAnTmVnYXRpb25BcHAnOlxuICAgICAgcmV0dXJuIG5ldyBNdXRhYmxlTmVnYXRpb25BcHAobW9kdWxlLCBmaWVsZHNGb3JUeXBlKVxuICAgIGNhc2UgJ051bWVyaWNMaXRlcmFsJzpcbiAgICAgIHJldHVybiBuZXcgTXV0YWJsZU51bWVyaWNMaXRlcmFsKG1vZHVsZSwgZmllbGRzRm9yVHlwZSlcbiAgICBjYXNlICdPcHJBcHAnOlxuICAgICAgcmV0dXJuIG5ldyBNdXRhYmxlT3ByQXBwKG1vZHVsZSwgZmllbGRzRm9yVHlwZSlcbiAgICBjYXNlICdQcm9wZXJ0eUFjY2Vzcyc6XG4gICAgICByZXR1cm4gbmV3IE11dGFibGVQcm9wZXJ0eUFjY2Vzcyhtb2R1bGUsIGZpZWxkc0ZvclR5cGUpXG4gICAgY2FzZSAnVGV4dExpdGVyYWwnOlxuICAgICAgcmV0dXJuIG5ldyBNdXRhYmxlVGV4dExpdGVyYWwobW9kdWxlLCBmaWVsZHNGb3JUeXBlKVxuICAgIGNhc2UgJ1VuYXJ5T3ByQXBwJzpcbiAgICAgIHJldHVybiBuZXcgTXV0YWJsZVVuYXJ5T3ByQXBwKG1vZHVsZSwgZmllbGRzRm9yVHlwZSlcbiAgICBjYXNlICdWZWN0b3InOlxuICAgICAgcmV0dXJuIG5ldyBNdXRhYmxlVmVjdG9yKG1vZHVsZSwgZmllbGRzRm9yVHlwZSlcbiAgICBjYXNlICdXaWxkY2FyZCc6XG4gICAgICByZXR1cm4gbmV3IE11dGFibGVXaWxkY2FyZChtb2R1bGUsIGZpZWxkc0ZvclR5cGUpXG4gIH1cbiAgYmFpbChgSW52YWxpZCB0eXBlOiAke3R5cGV9YClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hdGVyaWFsaXplKG1vZHVsZTogTW9kdWxlLCBmaWVsZHM6IEZpeGVkTWFwVmlldzxBc3RGaWVsZHM+KTogQXN0IHtcbiAgY29uc3QgdHlwZSA9IGZpZWxkcy5nZXQoJ3R5cGUnKVxuICBjb25zdCBmaWVsZHNfID0gZmllbGRzIGFzIEZpeGVkTWFwVmlldzxhbnk+XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ0FwcCc6XG4gICAgICByZXR1cm4gbmV3IEFwcChtb2R1bGUsIGZpZWxkc18pXG4gICAgY2FzZSAnQXNzaWdubWVudCc6XG4gICAgICByZXR1cm4gbmV3IEFzc2lnbm1lbnQobW9kdWxlLCBmaWVsZHNfKVxuICAgIGNhc2UgJ0JvZHlCbG9jayc6XG4gICAgICByZXR1cm4gbmV3IEJvZHlCbG9jayhtb2R1bGUsIGZpZWxkc18pXG4gICAgY2FzZSAnRG9jdW1lbnRlZCc6XG4gICAgICByZXR1cm4gbmV3IERvY3VtZW50ZWQobW9kdWxlLCBmaWVsZHNfKVxuICAgIGNhc2UgJ0Z1bmN0aW9uJzpcbiAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24obW9kdWxlLCBmaWVsZHNfKVxuICAgIGNhc2UgJ0dlbmVyaWMnOlxuICAgICAgcmV0dXJuIG5ldyBHZW5lcmljKG1vZHVsZSwgZmllbGRzXylcbiAgICBjYXNlICdHcm91cCc6XG4gICAgICByZXR1cm4gbmV3IEdyb3VwKG1vZHVsZSwgZmllbGRzXylcbiAgICBjYXNlICdJZGVudCc6XG4gICAgICByZXR1cm4gbmV3IElkZW50KG1vZHVsZSwgZmllbGRzXylcbiAgICBjYXNlICdJbXBvcnQnOlxuICAgICAgcmV0dXJuIG5ldyBJbXBvcnQobW9kdWxlLCBmaWVsZHNfKVxuICAgIGNhc2UgJ0ludmFsaWQnOlxuICAgICAgcmV0dXJuIG5ldyBJbnZhbGlkKG1vZHVsZSwgZmllbGRzXylcbiAgICBjYXNlICdOZWdhdGlvbkFwcCc6XG4gICAgICByZXR1cm4gbmV3IE5lZ2F0aW9uQXBwKG1vZHVsZSwgZmllbGRzXylcbiAgICBjYXNlICdOdW1lcmljTGl0ZXJhbCc6XG4gICAgICByZXR1cm4gbmV3IE51bWVyaWNMaXRlcmFsKG1vZHVsZSwgZmllbGRzXylcbiAgICBjYXNlICdPcHJBcHAnOlxuICAgICAgcmV0dXJuIG5ldyBPcHJBcHAobW9kdWxlLCBmaWVsZHNfKVxuICAgIGNhc2UgJ1Byb3BlcnR5QWNjZXNzJzpcbiAgICAgIHJldHVybiBuZXcgUHJvcGVydHlBY2Nlc3MobW9kdWxlLCBmaWVsZHNfKVxuICAgIGNhc2UgJ1RleHRMaXRlcmFsJzpcbiAgICAgIHJldHVybiBuZXcgVGV4dExpdGVyYWwobW9kdWxlLCBmaWVsZHNfKVxuICAgIGNhc2UgJ1VuYXJ5T3ByQXBwJzpcbiAgICAgIHJldHVybiBuZXcgVW5hcnlPcHJBcHAobW9kdWxlLCBmaWVsZHNfKVxuICAgIGNhc2UgJ1ZlY3Rvcic6XG4gICAgICByZXR1cm4gbmV3IFZlY3Rvcihtb2R1bGUsIGZpZWxkc18pXG4gICAgY2FzZSAnV2lsZGNhcmQnOlxuICAgICAgcmV0dXJuIG5ldyBXaWxkY2FyZChtb2R1bGUsIGZpZWxkc18pXG4gIH1cbiAgYmFpbChgSW52YWxpZCB0eXBlOiAke3R5cGV9YClcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGaXhlZE1hcFZpZXc8RmllbGRzPiB7XG4gIGdldDxLZXkgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBGaWVsZHM+KGtleTogS2V5KTogRGVlcFJlYWRvbmx5PEZpZWxkc1tLZXldPlxuICAvKiogQGludGVybmFsIFVuc2FmZS4gVGhlIGNhbGxlciBtdXN0IGVuc3VyZSB0aGUgeWllbGRlZCB2YWx1ZXMgYXJlIG5vdCBtb2RpZmllZC4gKi9cbiAgZW50cmllcygpOiBJdGVyYWJsZUl0ZXJhdG9yPHJlYWRvbmx5IFtzdHJpbmcsIHVua25vd25dPlxuICBjbG9uZSgpOiBGaXhlZE1hcDxGaWVsZHM+XG4gIGhhcyhrZXk6IHN0cmluZyk6IGJvb2xlYW5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBGaXhlZE1hcDxGaWVsZHM+IGV4dGVuZHMgRml4ZWRNYXBWaWV3PEZpZWxkcz4ge1xuICBzZXQ8S2V5IGV4dGVuZHMgc3RyaW5nICYga2V5b2YgRmllbGRzPihrZXk6IEtleSwgdmFsdWU6IEZpZWxkc1tLZXldKTogdm9pZFxufVxuXG50eXBlIERlZXBSZWFkb25seUZpZWxkczxUPiA9IHtcbiAgW0sgaW4ga2V5b2YgVF06IERlZXBSZWFkb25seTxUW0tdPlxufVxuXG5mdW5jdGlvbiBnZXRBbGw8RmllbGRzIGV4dGVuZHMgb2JqZWN0PihtYXA6IEZpeGVkTWFwVmlldzxGaWVsZHM+KTogRGVlcFJlYWRvbmx5RmllbGRzPEZpZWxkcz4ge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKG1hcC5lbnRyaWVzKCkpIGFzIERlZXBSZWFkb25seUZpZWxkczxGaWVsZHM+XG59XG5cbmRlY2xhcmUgY29uc3QgYnJhbmRMZWdhbEZpZWxkQ29udGVudDogdW5pcXVlIHN5bWJvbFxuLyoqIFVzZWQgdG8gYWRkIGEgY29uc3RyYWludCB0byBhbGwgYEFzdEZpZWxkc2BzIHN1YnR5cGVzIGVuc3VyaW5nIHRoYXQgdGhleSB3ZXJlIHByb2R1Y2VkIGJ5IGBjb21wb3NlRmllbGREYXRhYCwgd2hpY2hcbiAqICBlbmZvcmNlcyBhIHJlcXVpcmVtZW50IHRoYXQgdGhlIHByb3ZpZGVkIGZpZWxkcyBleHRlbmQgYEZpZWxkT2JqZWN0YC5cbiAqL1xuaW50ZXJmYWNlIExlZ2FsRmllbGRDb250ZW50IHtcbiAgW2JyYW5kTGVnYWxGaWVsZENvbnRlbnRdOiBuZXZlclxufVxuXG4vKiogTW9kaWZpZXMgdGhlIGlucHV0IGBtYXBgLiBSZXR1cm5zIHRoZSBzYW1lIG9iamVjdCB3aXRoIGFuIGV4dGVuZGVkIHR5cGUuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0QWxsPEZpZWxkczEsIEZpZWxkczIgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+PihcbiAgbWFwOiBGaXhlZE1hcDxGaWVsZHMxPixcbiAgZmllbGRzOiBGaWVsZHMyLFxuKTogRml4ZWRNYXA8RmllbGRzMSAmIEZpZWxkczI+IHtcbiAgY29uc3QgbWFwXyA9IG1hcCBhcyBGaXhlZE1hcDxGaWVsZHMxICYgRmllbGRzMj5cbiAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMoZmllbGRzKSkge1xuICAgIGNvbnN0IGtfID0gayBhcyBzdHJpbmcgJiAoa2V5b2YgRmllbGRzMSB8IGtleW9mIEZpZWxkczIpXG4gICAgbWFwXy5zZXQoa18sIHYgYXMgYW55KVxuICB9XG4gIHJldHVybiBtYXBfXG59XG5cbi8qKiBNb2RpZmllcyB0aGUgaW5wdXQgYG1hcGAuIFJldHVybnMgdGhlIHNhbWUgb2JqZWN0IHdpdGggYW4gZXh0ZW5kZWQgdHlwZS4gVGhlIGFkZGVkIGZpZWxkcyBhcmUgcmVxdWlyZWQgdG8gaGF2ZSBvbmx5XG4gKiAgdHlwZXMgZXh0ZW5kaW5nIGBGaWVsZERhdGFgOyB0aGUgcmV0dXJuZWQgb2JqZWN0IGlzIGJyYW5kZWQgYXMgYExlZ2FsRmllbGRDb250ZW50YC4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wb3NlRmllbGREYXRhPEZpZWxkczEsIEZpZWxkczIgZXh0ZW5kcyBGaWVsZE9iamVjdDxSYXdSZWZzPj4oXG4gIG1hcDogRml4ZWRNYXA8RmllbGRzMT4sXG4gIGZpZWxkczogRmllbGRzMixcbik6IEZpeGVkTWFwPEZpZWxkczEgJiBGaWVsZHMyICYgTGVnYWxGaWVsZENvbnRlbnQ+IHtcbiAgcmV0dXJuIHNldEFsbChtYXAsIGZpZWxkcykgYXMgRml4ZWRNYXA8RmllbGRzMSAmIEZpZWxkczIgJiBMZWdhbEZpZWxkQ29udGVudD5cbn1cblxuZnVuY3Rpb24gY2xhaW1DaGlsZDxUIGV4dGVuZHMgTXV0YWJsZUFzdD4oXG4gIG1vZHVsZTogTXV0YWJsZU1vZHVsZSxcbiAgY2hpbGQ6IE93bmVkPFQ+LFxuICBwYXJlbnQ6IEFzdElkLFxuKTogQXN0SWQge1xuICBpZiAoY2hpbGQubW9kdWxlID09PSBtb2R1bGUpIGFzc2VydEVxdWFsKGNoaWxkLmZpZWxkcy5nZXQoJ3BhcmVudCcpLCB1bmRlZmluZWQpXG4gIGNvbnN0IGNoaWxkXyA9IG1vZHVsZS5jb3B5SWZGb3JlaWduKGNoaWxkKVxuICBjaGlsZF8uZmllbGRzLnNldCgncGFyZW50JywgcGFyZW50KVxuICByZXR1cm4gY2hpbGRfLmlkXG59XG5cbmZ1bmN0aW9uIGNvbmNyZXRlQ2hpbGQoXG4gIG1vZHVsZTogTXV0YWJsZU1vZHVsZSxcbiAgY2hpbGQ6IE5vZGVDaGlsZDxPd25lZD4sXG4gIHBhcmVudDogQXN0SWQsXG4pOiBOb2RlQ2hpbGQ8QXN0SWQ+XG5mdW5jdGlvbiBjb25jcmV0ZUNoaWxkKFxuICBtb2R1bGU6IE11dGFibGVNb2R1bGUsXG4gIGNoaWxkOiBOb2RlQ2hpbGQ8T3duZWQ+IHwgdW5kZWZpbmVkLFxuICBwYXJlbnQ6IEFzdElkLFxuKTogTm9kZUNoaWxkPEFzdElkPiB8IHVuZGVmaW5lZFxuZnVuY3Rpb24gY29uY3JldGVDaGlsZChcbiAgbW9kdWxlOiBNdXRhYmxlTW9kdWxlLFxuICBjaGlsZDogTm9kZUNoaWxkPE93bmVkIHwgVG9rZW4+LFxuICBwYXJlbnQ6IEFzdElkLFxuKTogTm9kZUNoaWxkPEFzdElkPiB8IE5vZGVDaGlsZDxUb2tlbj5cbmZ1bmN0aW9uIGNvbmNyZXRlQ2hpbGQoXG4gIG1vZHVsZTogTXV0YWJsZU1vZHVsZSxcbiAgY2hpbGQ6IE5vZGVDaGlsZDxPd25lZCB8IFRva2VuPiB8IHVuZGVmaW5lZCxcbiAgcGFyZW50OiBBc3RJZCxcbik6IE5vZGVDaGlsZDxBc3RJZD4gfCBOb2RlQ2hpbGQ8VG9rZW4+IHwgdW5kZWZpbmVkXG5mdW5jdGlvbiBjb25jcmV0ZUNoaWxkKFxuICBtb2R1bGU6IE11dGFibGVNb2R1bGUsXG4gIGNoaWxkOiBOb2RlQ2hpbGQ8T3duZWQgfCBUb2tlbj4gfCB1bmRlZmluZWQsXG4gIHBhcmVudDogQXN0SWQsXG4pOiBOb2RlQ2hpbGQ8QXN0SWQ+IHwgTm9kZUNoaWxkPFRva2VuPiB8IHVuZGVmaW5lZCB7XG4gIGlmICghY2hpbGQpIHJldHVybiB1bmRlZmluZWRcbiAgaWYgKGlzVG9rZW5JZChjaGlsZC5ub2RlKSkgcmV0dXJuIGNoaWxkIGFzIE5vZGVDaGlsZDxUb2tlbj5cbiAgcmV0dXJuIHsgLi4uY2hpbGQsIG5vZGU6IGNsYWltQ2hpbGQobW9kdWxlLCBjaGlsZC5ub2RlLCBwYXJlbnQpIH1cbn1cblxudHlwZSBTdHJpY3RJZGVudExpa2UgPSBJZGVudGlmaWVyIHwgSWRlbnRpZmllclRva2VuXG5mdW5jdGlvbiB0b0lkZW50U3RyaWN0KGlkZW50OiBTdHJpY3RJZGVudExpa2UpOiBJZGVudGlmaWVyVG9rZW5cbmZ1bmN0aW9uIHRvSWRlbnRTdHJpY3QoaWRlbnQ6IFN0cmljdElkZW50TGlrZSB8IHVuZGVmaW5lZCk6IElkZW50aWZpZXJUb2tlbiB8IHVuZGVmaW5lZFxuZnVuY3Rpb24gdG9JZGVudFN0cmljdChpZGVudDogU3RyaWN0SWRlbnRMaWtlIHwgdW5kZWZpbmVkKTogSWRlbnRpZmllclRva2VuIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIChcbiAgICBpZGVudCA/XG4gICAgICBpc1Rva2VuKGlkZW50KSA/IGlkZW50XG4gICAgICA6IChUb2tlbi5uZXcoaWRlbnQsIFJhd0FzdC5Ub2tlbi5UeXBlLklkZW50KSBhcyBJZGVudGlmaWVyVG9rZW4pXG4gICAgOiB1bmRlZmluZWRcbiAgKVxufVxuXG50eXBlIElkZW50TGlrZSA9IElkZW50aWZpZXJPck9wZXJhdG9ySWRlbnRpZmllciB8IElkZW50aWZpZXJPck9wZXJhdG9ySWRlbnRpZmllclRva2VuXG5mdW5jdGlvbiB0b0lkZW50KGlkZW50OiBJZGVudExpa2UpOiBJZGVudGlmaWVyT3JPcGVyYXRvcklkZW50aWZpZXJUb2tlblxuZnVuY3Rpb24gdG9JZGVudChpZGVudDogSWRlbnRMaWtlIHwgdW5kZWZpbmVkKTogSWRlbnRpZmllck9yT3BlcmF0b3JJZGVudGlmaWVyVG9rZW4gfCB1bmRlZmluZWRcbmZ1bmN0aW9uIHRvSWRlbnQoaWRlbnQ6IElkZW50TGlrZSB8IHVuZGVmaW5lZCk6IElkZW50aWZpZXJPck9wZXJhdG9ySWRlbnRpZmllclRva2VuIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIChcbiAgICBpZGVudCA/XG4gICAgICBpc1Rva2VuKGlkZW50KSA/IGlkZW50XG4gICAgICA6IChUb2tlbi5uZXcoaWRlbnQsIFJhd0FzdC5Ub2tlbi5UeXBlLklkZW50KSBhcyBJZGVudGlmaWVyT3JPcGVyYXRvcklkZW50aWZpZXJUb2tlbilcbiAgICA6IHVuZGVmaW5lZFxuICApXG59XG5cbmZ1bmN0aW9uIG1ha2VFcXVhbHMoKTogVG9rZW4ge1xuICByZXR1cm4gVG9rZW4ubmV3KCc9JywgUmF3QXN0LlRva2VuLlR5cGUuT3BlcmF0b3IpXG59XG5cbmZ1bmN0aW9uIG5hbWVTcGVjaWZpY2F0aW9uKFxuICBuYW1lOiBTdHJpY3RJZGVudExpa2UgfCB1bmRlZmluZWQsXG4pOiB7IG5hbWU6IE5vZGVDaGlsZDxUb2tlbj47IGVxdWFsczogTm9kZUNoaWxkPFRva2VuPiB9IHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIG5hbWUgJiYgeyBuYW1lOiBhdXRvc3BhY2VkKHRvSWRlbnRTdHJpY3QobmFtZSkpLCBlcXVhbHM6IHVuc3BhY2VkKG1ha2VFcXVhbHMoKSkgfVxufVxuXG50eXBlIEtleXNPZkZpZWxkVHlwZTxGaWVsZHMsIFQ+ID0ge1xuICBbSyBpbiBrZXlvZiBGaWVsZHNdOiBGaWVsZHNbS10gZXh0ZW5kcyBUID8gSyA6IG5ldmVyXG59W2tleW9mIEZpZWxkc11cbmZ1bmN0aW9uIHNldE5vZGU8RmllbGRzLCBLZXkgZXh0ZW5kcyBzdHJpbmcgJiBLZXlzT2ZGaWVsZFR5cGU8RmllbGRzLCBOb2RlQ2hpbGQ8QXN0SWQ+Pj4oXG4gIG1hcDogRml4ZWRNYXA8RmllbGRzPixcbiAga2V5OiBLZXksXG4gIG5vZGU6IEFzdElkLFxuKTogdm9pZFxuZnVuY3Rpb24gc2V0Tm9kZTxcbiAgRmllbGRzLFxuICBLZXkgZXh0ZW5kcyBzdHJpbmcgJiBLZXlzT2ZGaWVsZFR5cGU8RmllbGRzLCBOb2RlQ2hpbGQ8QXN0SWQ+IHwgdW5kZWZpbmVkPixcbj4obWFwOiBGaXhlZE1hcDxGaWVsZHM+LCBrZXk6IEtleSwgbm9kZTogQXN0SWQgfCB1bmRlZmluZWQpOiB2b2lkXG5mdW5jdGlvbiBzZXROb2RlPFxuICBGaWVsZHMsXG4gIEtleSBleHRlbmRzIHN0cmluZyAmIEtleXNPZkZpZWxkVHlwZTxGaWVsZHMsIE5vZGVDaGlsZDxBc3RJZD4gfCB1bmRlZmluZWQ+LFxuPihtYXA6IEZpeGVkTWFwPEZpZWxkcz4sIGtleTogS2V5LCBub2RlOiBBc3RJZCB8IHVuZGVmaW5lZCk6IHZvaWQge1xuICAvLyBUaGUgc2lnbmF0dXJlIGNvcnJlY3RseSBvbmx5IGFsbG93cyB0aGlzIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBpZiBgRmllbGRzW0tleV0gaW5zdGFuY2VvZiBOb2RlQ2hpbGQ8U3luY0lkPmAsXG4gIC8vIGJ1dCBpdCBkb2Vzbid0IHByb3ZlIHRoYXQgcHJvcGVydHkgdG8gVFNDLCBzbyB3ZSBoYXZlIHRvIGNhc3QgaGVyZS5cbiAgY29uc3Qgb2xkID0gbWFwLmdldChrZXkgYXMgc3RyaW5nICYga2V5b2YgRmllbGRzKSBhcyBEZWVwUmVhZG9ubHk8Tm9kZUNoaWxkPEFzdElkPj5cbiAgY29uc3QgdXBkYXRlZCA9IG9sZCA/IHsgLi4ub2xkLCBub2RlIH0gOiBhdXRvc3BhY2VkKG5vZGUpXG4gIG1hcC5zZXQoa2V5LCB1cGRhdGVkIGFzIEZpZWxkc1tLZXldKVxufVxuXG5mdW5jdGlvbiBzcGFjZWQ8VCBleHRlbmRzIG9iamVjdCB8IHN0cmluZz4obm9kZTogVCk6IE5vZGVDaGlsZDxUPlxuZnVuY3Rpb24gc3BhY2VkPFQgZXh0ZW5kcyBvYmplY3QgfCBzdHJpbmc+KG5vZGU6IFQgfCB1bmRlZmluZWQpOiBOb2RlQ2hpbGQ8VD4gfCB1bmRlZmluZWRcbmZ1bmN0aW9uIHNwYWNlZDxUIGV4dGVuZHMgb2JqZWN0IHwgc3RyaW5nPihub2RlOiBUIHwgdW5kZWZpbmVkKTogTm9kZUNoaWxkPFQ+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIG5vZGVcbiAgcmV0dXJuIHsgd2hpdGVzcGFjZTogJyAnLCBub2RlIH1cbn1cblxuZnVuY3Rpb24gdW5zcGFjZWQ8VCBleHRlbmRzIG9iamVjdCB8IHN0cmluZz4obm9kZTogVCk6IE5vZGVDaGlsZDxUPlxuZnVuY3Rpb24gdW5zcGFjZWQ8VCBleHRlbmRzIG9iamVjdCB8IHN0cmluZz4obm9kZTogVCB8IHVuZGVmaW5lZCk6IE5vZGVDaGlsZDxUPiB8IHVuZGVmaW5lZFxuZnVuY3Rpb24gdW5zcGFjZWQ8VCBleHRlbmRzIG9iamVjdCB8IHN0cmluZz4obm9kZTogVCB8IHVuZGVmaW5lZCk6IE5vZGVDaGlsZDxUPiB8IHVuZGVmaW5lZCB7XG4gIGlmIChub2RlID09PSB1bmRlZmluZWQpIHJldHVybiBub2RlXG4gIHJldHVybiB7IHdoaXRlc3BhY2U6ICcnLCBub2RlIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGF1dG9zcGFjZWQ8VCBleHRlbmRzIG9iamVjdCB8IHN0cmluZz4obm9kZTogVCk6IE5vZGVDaGlsZDxUPlxuZXhwb3J0IGZ1bmN0aW9uIGF1dG9zcGFjZWQ8VCBleHRlbmRzIG9iamVjdCB8IHN0cmluZz4obm9kZTogVCB8IHVuZGVmaW5lZCk6IE5vZGVDaGlsZDxUPiB8IHVuZGVmaW5lZFxuZXhwb3J0IGZ1bmN0aW9uIGF1dG9zcGFjZWQ8VCBleHRlbmRzIG9iamVjdCB8IHN0cmluZz4oXG4gIG5vZGU6IFQgfCB1bmRlZmluZWQsXG4pOiBOb2RlQ2hpbGQ8VD4gfCB1bmRlZmluZWQge1xuICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gbm9kZVxuICByZXR1cm4geyB3aGl0ZXNwYWNlOiB1bmRlZmluZWQsIG5vZGUgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlbW92ZWQ8VCBleHRlbmRzIE11dGFibGVBc3Q+IHtcbiAgbm9kZTogT3duZWQ8VD5cbiAgcGxhY2Vob2xkZXI6IE11dGFibGVXaWxkY2FyZCB8IHVuZGVmaW5lZFxufVxuIiwgImNvbnN0IF9fdml0ZV9pbmplY3RlZF9vcmlnaW5hbF9kaXJuYW1lID0gXCJDOlxcXFxQcm9qZWN0c1xcXFxlbnNvXFxcXGVuc29cXFxcYXBwXFxcXGd1aTJcXFxcc2hhcmVkXFxcXGFzdFwiO2NvbnN0IF9fdml0ZV9pbmplY3RlZF9vcmlnaW5hbF9maWxlbmFtZSA9IFwiQzpcXFxcUHJvamVjdHNcXFxcZW5zb1xcXFxlbnNvXFxcXGFwcFxcXFxndWkyXFxcXHNoYXJlZFxcXFxhc3RcXFxcdGV4dC50c1wiO2NvbnN0IF9fdml0ZV9pbmplY3RlZF9vcmlnaW5hbF9pbXBvcnRfbWV0YV91cmwgPSBcImZpbGU6Ly8vQzovUHJvamVjdHMvZW5zby9lbnNvL2FwcC9ndWkyL3NoYXJlZC9hc3QvdGV4dC50c1wiOy8qKipcbiAqIFN0cmluZyBlc2NhcGluZyBhbmQgaW50ZXJwb2xhdGlvbiBoYW5kbGluZy4gQ29kZSBpbiB0aGlzIG1vZHVsZSBtdXN0IGJlIGtlcHQgYWxpZ25lZCB3aXRoIGxleGVyJ3NcbiAqIHVuZGVyc3RhbmRpbmcgIG9mIHN0cmluZyBsaXRlcmFscy4gVGhlIHJlbGV2YW50IGxleGVyIGNvZGUgY2FuIGJlIGZvdW5kIGluXG4gKiBgbGliL3J1c3QvcGFyc2VyL3NyYy9sZXhlci5yc2AsIHNlYXJjaCBmb3IgYGZuIHRleHRfZXNjYXBlYC5cbiAqL1xuXG5pbXBvcnQgeyBhc3NlcnRVbnJlYWNoYWJsZSB9IGZyb20gJy4uL3V0aWwvYXNzZXJ0J1xuXG5jb25zdCBlc2NhcGVTZXF1ZW5jZXMgPSBbXG4gIFsnMCcsICdcXDAnXSxcbiAgWydhJywgJ1xceDA3J10sXG4gIFsnYicsICdcXHgwOCddLFxuICBbJ2YnLCAnXFx4MEMnXSxcbiAgWyduJywgJ1xceDBBJ10sXG4gIFsncicsICdcXHgwRCddLFxuICBbJ3QnLCAnXFx4MDknXSxcbiAgWyd2JywgJ1xceDBCJ10sXG4gIFsnZScsICdcXHgxQiddLFxuICBbJ1xcXFwnLCAnXFxcXCddLFxuICBbJ1wiJywgJ1wiJ10sXG4gIFtcIidcIiwgXCInXCJdLFxuICBbJ2AnLCAnYCddLFxuXSBhcyBjb25zdFxuXG5mdW5jdGlvbiBlc2NhcGVBc0NoYXJDb2RlcyhzdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gIGxldCBvdXQgPSAnJ1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gMSkgb3V0ICs9IGBcXFxcdXske3N0cj8uY2hhckNvZGVBdChpKS50b1N0cmluZygxNil9fWBcbiAgcmV0dXJuIG91dFxufVxuXG5jb25zdCBlc2NhcGVSZWdleCA9IG5ldyBSZWdFeHAoXG4gIGAke2VzY2FwZVNlcXVlbmNlcy5tYXAoKFtfLCByYXddKSA9PiBlc2NhcGVBc0NoYXJDb2RlcyhyYXcpKS5qb2luKCd8Jyl9YCxcbiAgJ2d1JyxcbilcblxuY29uc3QgdW5lc2NhcGVSZWdleCA9IG5ldyBSZWdFeHAoXG4gICdcXFxcXFxcXCg/OicgK1xuICAgIGAke2VzY2FwZVNlcXVlbmNlcy5tYXAoKFtlc2NhcGVdKSA9PiBlc2NhcGVBc0NoYXJDb2Rlcyhlc2NhcGUpKS5qb2luKCd8Jyl9YCArXG4gICAgJ3x4WzAtOWEtZkEtRl17MCwyfScgK1xuICAgICd8dVxcXFx7WzAtOWEtZkEtRl17MCw0fVxcXFx9PycgKyAvLyBMZXhlciBhbGxvd3MgdHJhaWxpbmcgfSB0byBiZSBtaXNzaW5nLlxuICAgICd8dVswLTlhLWZBLUZdezAsNH0nICtcbiAgICAnfFVbMC05YS1mQS1GXXswLDh9JyArXG4gICAgJyknLFxuICAnZ3UnLFxuKVxuXG5jb25zdCBlc2NhcGVNYXBwaW5nID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICBlc2NhcGVTZXF1ZW5jZXMubWFwKChbZXNjYXBlLCByYXddKSA9PiBbcmF3LCBgXFxcXCR7ZXNjYXBlfWBdKSxcbilcbmNvbnN0IHVuZXNjYXBlTWFwcGluZyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgZXNjYXBlU2VxdWVuY2VzLm1hcCgoW2VzY2FwZSwgcmF3XSkgPT4gW2BcXFxcJHtlc2NhcGV9YCwgcmF3XSksXG4pXG5cbi8qKlxuICogRXNjYXBlIGEgc3RyaW5nIHNvIGl0IGNhbiBiZSBzYWZlbHkgc3BsaWNlZCBpbnRvIGFuIGludGVycG9sYXRlZCAoYCcnYCkgRW5zbyBzdHJpbmcuXG4gKiBOb3RlOiBFc2NhcGUgc2VxdWVuY2VzIGFyZSBOT1QgaW50ZXJwcmV0ZWQgaW4gcmF3IChgXCJcImApIHN0cmluZyBsaXRlcmFscy5cbiAqICovXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlVGV4dExpdGVyYWwocmF3U3RyaW5nOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHJhd1N0cmluZy5yZXBsYWNlKGVzY2FwZVJlZ2V4LCAobWF0Y2gpID0+IGVzY2FwZU1hcHBpbmdbbWF0Y2hdID8/IGFzc2VydFVucmVhY2hhYmxlKCkpXG59XG5cbi8qKlxuICogSW50ZXJwcmV0IGFsbCBlc2NhcGVkIGNoYXJhY3RlcnMgZnJvbSBhbiBpbnRlcnBvbGF0ZWQgKGAnJ2ApIEVuc28gc3RyaW5nLlxuICogTm90ZTogRXNjYXBlIHNlcXVlbmNlcyBhcmUgTk9UIGludGVycHJldGVkIGluIHJhdyAoYFwiXCJgKSBzdHJpbmcgbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bmVzY2FwZVRleHRMaXRlcmFsKGVzY2FwZWRTdHJpbmc6IHN0cmluZykge1xuICByZXR1cm4gZXNjYXBlZFN0cmluZy5yZXBsYWNlKHVuZXNjYXBlUmVnZXgsIChtYXRjaCkgPT4ge1xuICAgIGxldCBjdXQgPSAyXG4gICAgc3dpdGNoIChtYXRjaFsxXSkge1xuICAgICAgY2FzZSAndSc6XG4gICAgICAgIGlmIChtYXRjaFsyXSA9PT0gJ3snKSBjdXQgPSAzIC8vIGZhbGx0aHJvdWdoXG4gICAgICBjYXNlICdVJzpcbiAgICAgIGNhc2UgJ3gnOlxuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChtYXRjaC5zdWJzdHJpbmcoY3V0KSwgMTYpKVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHVuZXNjYXBlTWFwcGluZ1ttYXRjaF0gPz8gYXNzZXJ0VW5yZWFjaGFibGUoKVxuICAgIH1cbiAgfSlcbn1cbiIsICJjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfZGlybmFtZSA9IFwiQzpcXFxcUHJvamVjdHNcXFxcZW5zb1xcXFxlbnNvXFxcXGFwcFxcXFxndWkyXFxcXHNoYXJlZFxcXFxhc3RcIjtjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfZmlsZW5hbWUgPSBcIkM6XFxcXFByb2plY3RzXFxcXGVuc29cXFxcZW5zb1xcXFxhcHBcXFxcZ3VpMlxcXFxzaGFyZWRcXFxcYXN0XFxcXHRva2VuLnRzXCI7Y29uc3QgX192aXRlX2luamVjdGVkX29yaWdpbmFsX2ltcG9ydF9tZXRhX3VybCA9IFwiZmlsZTovLy9DOi9Qcm9qZWN0cy9lbnNvL2Vuc28vYXBwL2d1aTIvc2hhcmVkL2FzdC90b2tlbi50c1wiO2ltcG9ydCB0eXBlIHsgRGVlcFJlYWRvbmx5IH0gZnJvbSAndnVlJ1xuaW1wb3J0IHR5cGUgeyBBc3RJZCwgTm9kZUNoaWxkLCBPd25lZCB9IGZyb20gJy4nXG5pbXBvcnQgeyBBc3QsIG5ld0V4dGVybmFsSWQgfSBmcm9tICcuJ1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnLi4vdXRpbC9hc3NlcnQnXG5pbXBvcnQgdHlwZSB7IEV4dGVybmFsSWQgfSBmcm9tICcuLi95anNNb2RlbCdcbmltcG9ydCB7IGlzVXVpZCB9IGZyb20gJy4uL3lqc01vZGVsJ1xuaW1wb3J0IHsgaXNfaWRlbnRfb3Jfb3BlcmF0b3IgfSBmcm9tICcuL2ZmaSdcbmltcG9ydCAqIGFzIFJhd0FzdCBmcm9tICcuL2dlbmVyYXRlZC9hc3QnXG5cbmV4cG9ydCBmdW5jdGlvbiBpc1Rva2VuKHQ6IHVua25vd24pOiB0IGlzIFRva2VuIHtcbiAgcmV0dXJuIHQgaW5zdGFuY2VvZiBUb2tlblxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNUb2tlbkNoaWxkKGNoaWxkOiBOb2RlQ2hpbGQ8dW5rbm93bj4pOiBjaGlsZCBpcyBOb2RlQ2hpbGQ8VG9rZW4+IHtcbiAgcmV0dXJuIGlzVG9rZW4oY2hpbGQubm9kZSlcbn1cblxuZGVjbGFyZSBjb25zdCBicmFuZFRva2VuSWQ6IHVuaXF1ZSBzeW1ib2xcbmV4cG9ydCB0eXBlIFRva2VuSWQgPSBFeHRlcm5hbElkICYgeyBbYnJhbmRUb2tlbklkXTogbmV2ZXIgfVxuXG5mdW5jdGlvbiBuZXdUb2tlbklkKCk6IFRva2VuSWQge1xuICByZXR1cm4gbmV3RXh0ZXJuYWxJZCgpIGFzIFRva2VuSWRcbn1cblxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGludGVyZmFjZSBTeW5jVG9rZW5JZCB7XG4gIHJlYWRvbmx5IGlkOiBUb2tlbklkXG4gIHJlYWRvbmx5IGNvZGVfOiBzdHJpbmdcbiAgcmVhZG9ubHkgdG9rZW5UeXBlXzogUmF3QXN0LlRva2VuLlR5cGUgfCB1bmRlZmluZWRcbn1cblxuZXhwb3J0IGNsYXNzIFRva2VuIGltcGxlbWVudHMgU3luY1Rva2VuSWQge1xuICByZWFkb25seSBpZDogVG9rZW5JZFxuICBjb2RlXzogc3RyaW5nXG4gIHRva2VuVHlwZV86IFJhd0FzdC5Ub2tlbi5UeXBlIHwgdW5kZWZpbmVkXG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcihjb2RlOiBzdHJpbmcsIHR5cGU6IFJhd0FzdC5Ub2tlbi5UeXBlIHwgdW5kZWZpbmVkLCBpZDogVG9rZW5JZCkge1xuICAgIHRoaXMuaWQgPSBpZFxuICAgIHRoaXMuY29kZV8gPSBjb2RlXG4gICAgdGhpcy50b2tlblR5cGVfID0gdHlwZVxuICB9XG5cbiAgZ2V0IGV4dGVybmFsSWQoKTogVG9rZW5JZCB7XG4gICAgcmV0dXJuIHRoaXMuaWRcbiAgfVxuXG4gIHN0YXRpYyBuZXcoY29kZTogc3RyaW5nLCB0eXBlPzogUmF3QXN0LlRva2VuLlR5cGUpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMoY29kZSwgdHlwZSwgbmV3VG9rZW5JZCgpKVxuICB9XG5cbiAgc3RhdGljIHdpdGhJZChjb2RlOiBzdHJpbmcsIHR5cGU6IFJhd0FzdC5Ub2tlbi5UeXBlIHwgdW5kZWZpbmVkLCBpZDogVG9rZW5JZCkge1xuICAgIGFzc2VydChpc1V1aWQoaWQpKVxuICAgIHJldHVybiBuZXcgdGhpcyhjb2RlLCB0eXBlLCBpZClcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbChhOiBTeW5jVG9rZW5JZCwgYjogU3luY1Rva2VuSWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gYS50b2tlblR5cGVfID09PSBiLnRva2VuVHlwZV8gJiYgYS5jb2RlXyA9PT0gYi5jb2RlX1xuICB9XG5cbiAgY29kZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmNvZGVfXG4gIH1cblxuICB0eXBlTmFtZSgpOiBzdHJpbmcge1xuICAgIGlmICh0aGlzLnRva2VuVHlwZV8pIHJldHVybiBSYXdBc3QuVG9rZW4udHlwZU5hbWVzW3RoaXMudG9rZW5UeXBlX10hXG4gICAgZWxzZSByZXR1cm4gJ1JhdydcbiAgfVxufVxuLy8gV2UgaGF2ZW4ndCBoYWQgbXVjaCBuZWVkIHRvIGRpc3Rpbmd1aXNoIHRva2VuIHR5cGVzLCBidXQgaXQncyB1c2VmdWwgdG8ga25vdyB0aGF0IGFuIGlkZW50aWZpZXIgdG9rZW4ncyBjb2RlIGlzIGFcbi8vIHZhbGlkIHN0cmluZyBmb3IgYW4gaWRlbnRpZmllci5cbmV4cG9ydCBpbnRlcmZhY2UgSWRlbnRpZmllck9yT3BlcmF0b3JJZGVudGlmaWVyVG9rZW4gZXh0ZW5kcyBUb2tlbiB7XG4gIGNvZGUoKTogSWRlbnRpZmllck9yT3BlcmF0b3JJZGVudGlmaWVyXG59XG5leHBvcnQgaW50ZXJmYWNlIElkZW50aWZpZXJUb2tlbiBleHRlbmRzIFRva2VuIHtcbiAgY29kZSgpOiBJZGVudGlmaWVyXG59XG5cbmRlY2xhcmUgY29uc3QgcXVhbGlmaWVkTmFtZUJyYW5kOiB1bmlxdWUgc3ltYm9sXG5kZWNsYXJlIGNvbnN0IGlkZW50aWZpZXJCcmFuZDogdW5pcXVlIHN5bWJvbFxuZGVjbGFyZSBjb25zdCBvcGVyYXRvckJyYW5kOiB1bmlxdWUgc3ltYm9sXG5cbi8qKiBBIHN0cmluZyByZXByZXNlbnRpbmcgYSB2YWxpZCBxdWFsaWZpZWQgbmFtZSBvZiBvdXIgbGFuZ3VhZ2UuXG4gKlxuICogSW4gb3VyIGxhbmd1YWdlLCB0aGUgc2VnbWVudHMgYXJlIHNlcGFyYXRlZCBieSBgLmAuIEFsbCB0aGUgc2VnbWVudHMgZXhjZXB0IHRoZSBsYXN0IG11c3QgYmUgbGV4aWNhbCBpZGVudGlmaWVycy4gVGhlXG4gKiBsYXN0IG1heSBiZSBhbiBpZGVudGlmaWVyIG9yIGEgbGV4aWNhbCBvcGVyYXRvci4gQSBzaW5nbGUgaWRlbnRpZmllciBpcyBhbHNvIGEgdmFsaWQgcXVhbGlmaWVkIG5hbWUuXG4gKi9cbmV4cG9ydCB0eXBlIFF1YWxpZmllZE5hbWUgPSBzdHJpbmcgJiB7IFtxdWFsaWZpZWROYW1lQnJhbmRdOiBuZXZlciB9XG5cbi8qKiBBIHN0cmluZyByZXByZXNlbnRpbmcgYSBsZXhpY2FsIGlkZW50aWZpZXIuICovXG5leHBvcnQgdHlwZSBJZGVudGlmaWVyID0gc3RyaW5nICYgeyBbaWRlbnRpZmllckJyYW5kXTogbmV2ZXI7IFtxdWFsaWZpZWROYW1lQnJhbmRdOiBuZXZlciB9XG5cbi8qKiBBIHN0cmluZyByZXByZXNlbnRpbmcgYSBsZXhpY2FsIG9wZXJhdG9yLiAqL1xuZXhwb3J0IHR5cGUgT3BlcmF0b3IgPSBzdHJpbmcgJiB7IFtvcGVyYXRvckJyYW5kXTogbmV2ZXI7IFtxdWFsaWZpZWROYW1lQnJhbmRdOiBuZXZlciB9XG5cbi8qKiBBIHN0cmluZyB0aGF0IGNhbiBiZSBwYXJzZWQgYXMgYW4gaWRlbnRpZmllciBpbiBzb21lIGNvbnRleHRzLlxuICpcbiAqICBJZiBpdCBpcyBsZXhpY2FsbHkgYW4gaWRlbnRpZmllciAoc2VlIGBTdHJpY3RJZGVudGlmaWVyYCksIGl0IGNhbiBiZSB1c2VkIGFzIGlkZW50aWZpZXIgYW55d2hlcmUuXG4gKlxuICogIElmIGl0IGlzIGxleGljYWxseSBhbiBvcGVyYXRvciAoc2VlIGBPcGVyYXRvcmApLCBpdCB0YWtlcyB0aGUgc3ludGFjdGljIHJvbGUgb2YgYW4gaWRlbnRpZmllciBpZiBpdCBpcyB0aGUgUkhTIG9mXG4gKiAgYSBgUHJvcGVydHlBY2Nlc3NgLCBvciBpdCBpcyB0aGUgbmFtZSBvZiBhIGBGdW5jdGlvbmAgYmVpbmcgZGVmaW5lZCB3aXRoaW4gYSB0eXBlLiBJbiBhbGwgb3RoZXIgY2FzZXMsIGl0IGlzIG5vdFxuICogIHZhbGlkIHRvIHVzZSBhIGxleGljYWwgb3BlcmF0b3IgYXMgYW4gaWRlbnRpZmllciAocmF0aGVyLCBpdCB3aWxsIHVzdWFsbHkgcGFyc2UgYXMgYW4gYE9wckFwcGAgb3IgYFVuYXJ5T3ByQXBwYCkuXG4gKi9cbmV4cG9ydCB0eXBlIElkZW50aWZpZXJPck9wZXJhdG9ySWRlbnRpZmllciA9IElkZW50aWZpZXIgfCBPcGVyYXRvclxuXG4vKiogUmV0dXJucyB0cnVlIGlmIGBjb2RlYCBjYW4gYmUgdXNlZCBhcyBhbiBpZGVudGlmaWVyIGluIHNvbWUgY29udGV4dHMuXG4gKlxuICogIElmIGl0IGlzIGxleGljYWxseSBhbiBpZGVudGlmaWVyIChzZWUgYGlzSWRlbnRpZmllcmApLCBpdCBjYW4gYmUgdXNlZCBhcyBpZGVudGlmaWVyIGFueXdoZXJlLlxuICpcbiAqICBJZiBpdCBpcyBsZXhpY2FsbHkgYW4gb3BlcmF0b3IgKHNlZSBgaXNPcGVyYXRvcmApLCBpdCB0YWtlcyB0aGUgc3ludGFjdGljIHJvbGUgb2YgYW4gaWRlbnRpZmllciBpZiBpdCBpcyB0aGUgUkhTIG9mXG4gKiAgYSBgUHJvcGVydHlBY2Nlc3NgLCBvciBpdCBpcyB0aGUgbmFtZSBvZiBhIGBGdW5jdGlvbmAgYmVpbmcgZGVmaW5lZCB3aXRoaW4gYSB0eXBlLiBJbiBhbGwgb3RoZXIgY2FzZXMsIGl0IGlzIG5vdFxuICogIHZhbGlkIHRvIHVzZSBhIGxleGljYWwgb3BlcmF0b3IgYXMgYW4gaWRlbnRpZmllciAocmF0aGVyLCBpdCB3aWxsIHVzdWFsbHkgcGFyc2UgYXMgYW4gYE9wckFwcGAgb3IgYFVuYXJ5T3ByQXBwYCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0lkZW50aWZpZXJPck9wZXJhdG9ySWRlbnRpZmllcihcbiAgY29kZTogc3RyaW5nLFxuKTogY29kZSBpcyBJZGVudGlmaWVyT3JPcGVyYXRvcklkZW50aWZpZXIge1xuICByZXR1cm4gaXNfaWRlbnRfb3Jfb3BlcmF0b3IoY29kZSkgIT09IDBcbn1cblxuLyoqIFJldHVybnMgdHJ1ZSBpZiBgY29kZWAgaXMgbGV4aWNhbGx5IGFuIGlkZW50aWZpZXIuICovXG5leHBvcnQgZnVuY3Rpb24gaXNJZGVudGlmaWVyKGNvZGU6IHN0cmluZyk6IGNvZGUgaXMgSWRlbnRpZmllciB7XG4gIHJldHVybiBpc19pZGVudF9vcl9vcGVyYXRvcihjb2RlKSA9PT0gMVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpZmllcihjb2RlOiBzdHJpbmcpOiBJZGVudGlmaWVyIHwgdW5kZWZpbmVkIHtcbiAgaWYgKGlzSWRlbnRpZmllcihjb2RlKSkgcmV0dXJuIGNvZGVcbn1cblxuLyoqIFJldHVybnMgdHJ1ZSBpZiBgY29kZWAgaXMgbGV4aWNhbGx5IGFuIG9wZXJhdG9yLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT3BlcmF0b3IoY29kZTogc3RyaW5nKTogY29kZSBpcyBPcGVyYXRvciB7XG4gIHJldHVybiBpc19pZGVudF9vcl9vcGVyYXRvcihjb2RlKSA9PT0gMlxufVxuXG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gaXNUb2tlbklkKFxuICB0OiBEZWVwUmVhZG9ubHk8U3luY1Rva2VuSWQgfCBBc3RJZCB8IEFzdCB8IE93bmVkPEFzdD4gfCBPd25lZD4sXG4pOiB0IGlzIERlZXBSZWFkb25seTxTeW5jVG9rZW5JZD4ge1xuICByZXR1cm4gdHlwZW9mIHQgPT09ICdvYmplY3QnICYmICEodCBpbnN0YW5jZW9mIEFzdClcbn1cbiIsICJjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfZGlybmFtZSA9IFwiQzpcXFxcUHJvamVjdHNcXFxcZW5zb1xcXFxlbnNvXFxcXGFwcFxcXFxndWkyXFxcXHNoYXJlZFwiO2NvbnN0IF9fdml0ZV9pbmplY3RlZF9vcmlnaW5hbF9maWxlbmFtZSA9IFwiQzpcXFxcUHJvamVjdHNcXFxcZW5zb1xcXFxlbnNvXFxcXGFwcFxcXFxndWkyXFxcXHNoYXJlZFxcXFxlbnNvRmlsZS50c1wiO2NvbnN0IF9fdml0ZV9pbmplY3RlZF9vcmlnaW5hbF9pbXBvcnRfbWV0YV91cmwgPSBcImZpbGU6Ly8vQzovUHJvamVjdHMvZW5zby9lbnNvL2FwcC9ndWkyL3NoYXJlZC9lbnNvRmlsZS50c1wiO2NvbnN0IE1FVEFfVEFHID0gJ1xcblxcblxcbiMjIyMgTUVUQURBVEEgIyMjIydcblxuZXhwb3J0IGludGVyZmFjZSBFbnNvRmlsZVBhcnRzIHtcbiAgY29kZTogc3RyaW5nXG4gIGlkTWFwSnNvbjogc3RyaW5nIHwgbnVsbFxuICBtZXRhZGF0YUpzb246IHN0cmluZyB8IG51bGxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0RmlsZUNvbnRlbnRzKGNvbnRlbnQ6IHN0cmluZyk6IEVuc29GaWxlUGFydHMge1xuICBjb25zdCBzcGxpdFBvaW50ID0gY29udGVudC5sYXN0SW5kZXhPZihNRVRBX1RBRylcbiAgaWYgKHNwbGl0UG9pbnQgPCAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvZGU6IGNvbnRlbnQsXG4gICAgICBpZE1hcEpzb246IG51bGwsXG4gICAgICBtZXRhZGF0YUpzb246IG51bGwsXG4gICAgfVxuICB9XG4gIGNvbnN0IGNvZGUgPSBjb250ZW50LnNsaWNlKDAsIHNwbGl0UG9pbnQpXG4gIGNvbnN0IG1ldGFkYXRhU3RyaW5nID0gY29udGVudC5zbGljZShzcGxpdFBvaW50ICsgTUVUQV9UQUcubGVuZ3RoKVxuICBjb25zdCBtZXRhTGluZXMgPSBtZXRhZGF0YVN0cmluZy50cmltKCkuc3BsaXQoJ1xcbicpXG4gIGNvbnN0IGlkTWFwSnNvbiA9IG1ldGFMaW5lc1swXSA/PyBudWxsXG4gIGNvbnN0IG1ldGFkYXRhSnNvbiA9IG1ldGFMaW5lc1sxXSA/PyBudWxsXG4gIHJldHVybiB7IGNvZGUsIGlkTWFwSnNvbiwgbWV0YWRhdGFKc29uIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVGaWxlUGFydHMocGFydHM6IEVuc29GaWxlUGFydHMpOiBzdHJpbmcge1xuICBjb25zdCBoYXNNZXRhID0gcGFydHMuaWRNYXBKc29uICE9IG51bGwgfHwgcGFydHMubWV0YWRhdGFKc29uICE9IG51bGxcbiAgaWYgKGhhc01ldGEpIHtcbiAgICByZXR1cm4gYCR7cGFydHMuY29kZX0ke01FVEFfVEFHfVxcbiR7cGFydHMuaWRNYXBKc29uID8/ICcnfVxcbiR7cGFydHMubWV0YWRhdGFKc29uID8/ICcnfWBcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBjb2RlIHNlZ21lbnQgY29udGFpbnMgbWV0YSB0YWcsIGFkZCBhbm90aGVyIG9uZSB0byBtYWtlIHN1cmUgaXQgaXMgbm90IG1pc2ludGVycHJldGVkLlxuICAgIGlmIChwYXJ0cy5jb2RlLmluY2x1ZGVzKE1FVEFfVEFHKSkge1xuICAgICAgcmV0dXJuIGAke3BhcnRzLmNvZGV9JHtNRVRBX1RBR31gXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwYXJ0cy5jb2RlXG4gICAgfVxuICB9XG59XG4iLCAiY29uc3QgX192aXRlX2luamVjdGVkX29yaWdpbmFsX2Rpcm5hbWUgPSBcIkM6XFxcXFByb2plY3RzXFxcXGVuc29cXFxcZW5zb1xcXFxhcHBcXFxcZ3VpMlxcXFxzaGFyZWRcIjtjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfZmlsZW5hbWUgPSBcIkM6XFxcXFByb2plY3RzXFxcXGVuc29cXFxcZW5zb1xcXFxhcHBcXFxcZ3VpMlxcXFxzaGFyZWRcXFxcbGFuZ3VhZ2VTZXJ2ZXIudHNcIjtjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfaW1wb3J0X21ldGFfdXJsID0gXCJmaWxlOi8vL0M6L1Byb2plY3RzL2Vuc28vZW5zby9hcHAvZ3VpMi9zaGFyZWQvbGFuZ3VhZ2VTZXJ2ZXIudHNcIjtpbXBvcnQgeyBzaGEzXzIyNCBhcyBTSEEzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEzJ1xuaW1wb3J0IHsgYnl0ZXNUb0hleCB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnXG5pbXBvcnQgeyBDbGllbnQgfSBmcm9tICdAb3Blbi1ycGMvY2xpZW50LWpzJ1xuaW1wb3J0IHsgT2JzZXJ2YWJsZVYyIH0gZnJvbSAnbGliMC9vYnNlcnZhYmxlJ1xuaW1wb3J0IHsgdXVpZHY0IH0gZnJvbSAnbGliMC9yYW5kb20nXG5pbXBvcnQgeyB6IH0gZnJvbSAnem9kJ1xuaW1wb3J0IHsgd2Fsa0ZzIH0gZnJvbSAnLi9sYW5ndWFnZVNlcnZlci9maWxlcydcbmltcG9ydCB0eXBlIHtcbiAgQ2hlY2tzdW0sXG4gIENvbnRleHRJZCxcbiAgRXZlbnQsXG4gIEV4ZWN1dGlvbkVudmlyb25tZW50LFxuICBFeHByZXNzaW9uSWQsXG4gIEZpbGVFZGl0LFxuICBGaWxlU3lzdGVtT2JqZWN0LFxuICBOb3RpZmljYXRpb25zLFxuICBQYXRoLFxuICBSZWdpc3Rlck9wdGlvbnMsXG4gIFN0YWNrSXRlbSxcbiAgVGV4dEZpbGVDb250ZW50cyxcbiAgVmlzdWFsaXphdGlvbkNvbmZpZ3VyYXRpb24sXG4gIHJlc3BvbnNlLFxufSBmcm9tICcuL2xhbmd1YWdlU2VydmVyVHlwZXMnXG5pbXBvcnQgdHlwZSB7IFV1aWQgfSBmcm9tICcuL3lqc01vZGVsJ1xuXG5jb25zdCBERUJVR19MT0dfUlBDID0gZmFsc2VcbmNvbnN0IFJQQ19USU1FT1VUX01TID0gMTUwMDBcblxuZXhwb3J0IGVudW0gRXJyb3JDb2RlIHtcbiAgQUNDRVNTX0RFTklFRCA9IDEwMCxcbiAgRklMRV9TWVNURU1fRVJST1IgPSAxMDAwLFxuICBDT05URU5UX1JPT1RfTk9UX0ZPVU5EID0gMTAwMSxcbiAgRklMRV9OT1RfRk9VTkQgPSAxMDAzLFxuICBGSUxFX0VYSVNUUyA9IDEwMDQsXG4gIE9QRVJBVElPTl9USU1FT1VUID0gMTAwNSxcbiAgTk9UX0RJUkVDVE9SWSA9IDEwMDYsXG4gIE5PVF9GSUxFID0gMTAwNyxcbiAgQ0FOTk9UX09WRVJXUklURSA9IDEwMDgsXG4gIFJFQURfT1VUX09GX0JPVU5EUyA9IDEwMDksXG4gIENBTk5PVF9ERUNPREUgPSAxMDEwLFxuICBTVEFDS19JVEVNX05PVF9GT1VORCA9IDIwMDEsXG4gIENPTlRFWFRfTk9UX0ZPVU5EID0gMjAwMixcbiAgRU1QVFlfU1RBQ0sgPSAyMDAzLFxuICBJTlZBTElEX1NUQUNLX0lURU0gPSAyMDA0LFxuICBNT0RVTEVfTk9UX0ZPVU5EID0gMjAwNSxcbiAgVklTVUFMSVpBVElPTl9OT1RfRk9VTkQgPSAyMDA2LFxuICBWSVNVQUxJWkFUSU9OX0VYUFJFU1NJT05fRVJST1IgPSAyMDA3LFxuICBGSUxFX05PVF9PUEVORUQgPSAzMDAxLFxuICBURVhUX0VESVRfVkFMSURBVElPTl9FUlJPUiA9IDMwMDIsXG4gIElOVkFMSURfVkVSU0lPTiA9IDMwMDMsXG4gIFdSSVRFX0RFTklFRCA9IDMwMDQsXG4gIENBUEFCSUxJVFlfTk9UX0FDUVVJUkVEID0gNTAwMSxcbiAgU0VTU0lPTl9OT1RfSU5JVElBTElaRUQgPSA2MDAxLFxuICBTRVNTSU9OX0FMUkVBRFlfSU5JVElBTElaRUQgPSA2MDAyLFxuICBSRVNPVVJDRVNfSU5JVElBTElaQVRJT05fRVJST1IgPSA2MDAzLFxuICBTVUdHRVNUSU9OX0RBVEFCQVNFX0VSUk9SID0gNzAwMSxcbiAgUFJPSkVDVF9OT1RfRk9VTkQgPSA3MDAyLFxuICBNT0RVTEVfTkFNRV9OT1RfUkVTT0xWRUQgPSA3MDAzLFxuICBTVUdHRVNUSU9OX05PVF9GT1VORCA9IDcwMDQsXG4gIEVESVRJT05fTk9UX0ZPVU5EID0gODAwMSxcbiAgTElCUkFSWV9BTFJFQURZX0VYSVNUUyA9IDgwMDIsXG4gIExJQlJBUllfUkVQT1NJVE9SWV9BVVRIRU5USUNBVElPTl9FUlJPUiA9IDgwMDMsXG4gIExJQlJBUllfUFVCTElTSF9FUlJPUiA9IDgwMDQsXG4gIExJQlJBUllfVVBMT0FEX0VSUk9SID0gODAwNSxcbiAgTElCUkFSWV9ET1dOTE9BRF9FUlJPUiA9IDgwMDYsXG4gIExPQ0FMX0xJQlJBUllfTk9UX0ZPVU5EID0gODAwNyxcbiAgTElCUkFSWV9OT1RfUkVTT0xWRUQgPSA4MDA4LFxuICBJTlZBTElEX0xJQlJBUllfTkFNRSA9IDgwMDksXG4gIERFUEVOREVOQ1lfRElTQ09WRVJZX0VSUk9SID0gODAxMCxcbiAgSU5WQUxJRF9TRU1WRVJfVkVSU0lPTiA9IDgwMTEsXG4gIEVYUFJFU1NJT05fTk9UX0ZPVU5EID0gOTAwMSxcbiAgRkFJTEVEX1RPX0FQUExZX0VESVRTID0gOTAwMixcbiAgUkVGQUNUT1JJTkdfTk9UX1NVUFBPUlRFRCA9IDkwMDMsXG59XG5cbmNvbnN0IFJlbW90ZVJwY0Vycm9yU2NoZW1hID0gei5vYmplY3Qoe1xuICBjb2RlOiB6Lm5hdGl2ZUVudW0oRXJyb3JDb2RlKSxcbiAgbWVzc2FnZTogei5zdHJpbmcoKSxcbiAgZGF0YTogei5vcHRpb25hbCh6LmFueSgpKSxcbn0pXG50eXBlIFJlbW90ZVJwY0Vycm9yUGFyc2VkID0gei5pbmZlcjx0eXBlb2YgUmVtb3RlUnBjRXJyb3JTY2hlbWE+XG5cbmV4cG9ydCBjbGFzcyBSZW1vdGVScGNFcnJvciB7XG4gIGNvZGU6IEVycm9yQ29kZVxuICBtZXNzYWdlOiBzdHJpbmdcbiAgZGF0YT86IGFueVxuICBjb25zdHJ1Y3RvcihlcnJvcjogUmVtb3RlUnBjRXJyb3JQYXJzZWQpIHtcbiAgICB0aGlzLmNvZGUgPSBlcnJvci5jb2RlXG4gICAgdGhpcy5tZXNzYWdlID0gZXJyb3IubWVzc2FnZVxuICAgIHRoaXMuZGF0YSA9IGVycm9yLmRhdGFcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTHNScGNFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY2F1c2U6IFJlbW90ZVJwY0Vycm9yIHwgRXJyb3JcbiAgcmVxdWVzdDogc3RyaW5nXG4gIHBhcmFtczogb2JqZWN0XG4gIGNvbnN0cnVjdG9yKGNhdXNlOiBSZW1vdGVScGNFcnJvciB8IEVycm9yLCByZXF1ZXN0OiBzdHJpbmcsIHBhcmFtczogb2JqZWN0KSB7XG4gICAgc3VwZXIoYExhbmd1YWdlIHNlcnZlciByZXF1ZXN0ICcke3JlcXVlc3R9JyBmYWlsZWQuYClcbiAgICB0aGlzLmNhdXNlID0gY2F1c2VcbiAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXNcbiAgfVxufVxuXG4vKiogW0RvY3VtZW50YXRpb25dKGh0dHBzOi8vZ2l0aHViLmNvbS9lbnNvLW9yZy9lbnNvL2Jsb2IvZGV2ZWxvcC9kb2NzL2xhbmd1YWdlLXNlcnZlci9wcm90b2NvbC1sYW5ndWFnZS1zZXJ2ZXIubWQpICovXG5leHBvcnQgY2xhc3MgTGFuZ3VhZ2VTZXJ2ZXIgZXh0ZW5kcyBPYnNlcnZhYmxlVjI8Tm90aWZpY2F0aW9ucz4ge1xuICBjbGllbnQ6IENsaWVudFxuICBoYW5kbGVyczogTWFwPHN0cmluZywgU2V0PCguLi5wYXJhbXM6IGFueVtdKSA9PiB2b2lkPj5cbiAgcmV0YWluQ291bnQgPSAxXG5cbiAgY29uc3RydWN0b3IoY2xpZW50OiBDbGllbnQpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnRcbiAgICB0aGlzLmhhbmRsZXJzID0gbmV3IE1hcCgpXG5cbiAgICBjbGllbnQub25Ob3RpZmljYXRpb24oKG5vdGlmaWNhdGlvbikgPT4ge1xuICAgICAgdGhpcy5lbWl0KG5vdGlmaWNhdGlvbi5tZXRob2QgYXMga2V5b2YgTm90aWZpY2F0aW9ucywgW25vdGlmaWNhdGlvbi5wYXJhbXNdKVxuICAgIH0pXG4gICAgY2xpZW50Lm9uRXJyb3IoKGVycm9yKSA9PiB7XG4gICAgICBjb25zb2xlLmVycm9yKGBVbmV4cGVjdGVkIExTIGNvbm5lY3Rpb24gZXJyb3I6YCwgZXJyb3IpXG4gICAgfSlcbiAgfVxuXG4gIC8vIFRoZSBcIm1hZ2ljIGJhZyBvZiBob2xkaW5nXCIgZ2VuZXJpYyB0aGF0IGlzIG9ubHkgcHJlc2VudCBpbiB0aGUgcmV0dXJuIHR5cGUgaXMgVU5TT1VORC5cbiAgLy8gSG93ZXZlciwgaXQgaXMgU0FGRSwgYXMgdGhlIHJldHVybiB0eXBlIG9mIHRoZSBBUEkgaXMgc3RhdGljYWxseSBrbm93bi5cbiAgcHJpdmF0ZSBhc3luYyByZXF1ZXN0PFQ+KG1ldGhvZDogc3RyaW5nLCBwYXJhbXM6IG9iamVjdCk6IFByb21pc2U8VD4ge1xuICAgIGlmICh0aGlzLnJldGFpbkNvdW50ID09PSAwKSByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdMYW5ndWFnZVNlcnZlciBkaXNwb3NlZCcpKVxuICAgIGNvbnN0IHV1aWQgPSB1dWlkdjQoKVxuICAgIGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgdHJ5IHtcbiAgICAgIGlmIChERUJVR19MT0dfUlBDKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBMUyBbJHt1dWlkfV0gJHttZXRob2R9OmApXG4gICAgICAgIGNvbnNvbGUuZGlyKHBhcmFtcylcbiAgICAgIH1cbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KHsgbWV0aG9kLCBwYXJhbXMgfSwgUlBDX1RJTUVPVVRfTVMpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IHJlbW90ZUVycm9yID0gUmVtb3RlUnBjRXJyb3JTY2hlbWEuc2FmZVBhcnNlKGVycm9yKVxuICAgICAgaWYgKHJlbW90ZUVycm9yLnN1Y2Nlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IExzUnBjRXJyb3IobmV3IFJlbW90ZVJwY0Vycm9yKHJlbW90ZUVycm9yLmRhdGEpLCBtZXRob2QsIHBhcmFtcylcbiAgICAgIH0gZWxzZSBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgTHNScGNFcnJvcihlcnJvciwgbWV0aG9kLCBwYXJhbXMpXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoREVCVUdfTE9HX1JQQykge1xuICAgICAgICBjb25zb2xlLmxvZyhgTFMgWyR7dXVpZH1dICR7bWV0aG9kfSB0b29rICR7cGVyZm9ybWFuY2Uubm93KCkgLSBub3d9bXNgKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKiBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL2Vuc28tb3JnL2Vuc28vYmxvYi9kZXZlbG9wL2RvY3MvbGFuZ3VhZ2Utc2VydmVyL3Byb3RvY29sLWxhbmd1YWdlLXNlcnZlci5tZCNjYXBhYmlsaXR5YWNxdWlyZSkgKi9cbiAgYWNxdWlyZUNhcGFiaWxpdHkobWV0aG9kOiBzdHJpbmcsIHJlZ2lzdGVyT3B0aW9uczogUmVnaXN0ZXJPcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCgnY2FwYWJpbGl0eS9hY3F1aXJlJywgeyBtZXRob2QsIHJlZ2lzdGVyT3B0aW9ucyB9KVxuICB9XG5cbiAgLyoqIFtEb2N1bWVudGF0aW9uXShodHRwczovL2dpdGh1Yi5jb20vZW5zby1vcmcvZW5zby9ibG9iL2RldmVsb3AvZG9jcy9sYW5ndWFnZS1zZXJ2ZXIvcHJvdG9jb2wtbGFuZ3VhZ2Utc2VydmVyLm1kI2ZpbGVyZWNlaXZlc3RyZWV1cGRhdGVzKSAqL1xuICBhY3F1aXJlUmVjZWl2ZXNUcmVlVXBkYXRlcyhwYXRoOiBQYXRoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuYWNxdWlyZUNhcGFiaWxpdHkoJ2ZpbGUvcmVjZWl2ZXNUcmVlVXBkYXRlcycsIHsgcGF0aCB9KVxuICB9XG5cbiAgYWNxdWlyZUV4ZWN1dGlvbkNvbnRleHRDYW5Nb2RpZnkoY29udGV4dElkOiBDb250ZXh0SWQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5hY3F1aXJlQ2FwYWJpbGl0eSgnZXhlY3V0aW9uQ29udGV4dC9jYW5Nb2RpZnknLCB7IGNvbnRleHRJZCB9KVxuICB9XG5cbiAgLyoqIFtEb2N1bWVudGF0aW9uXShodHRwczovL2dpdGh1Yi5jb20vZW5zby1vcmcvZW5zby9ibG9iL2RldmVsb3AvZG9jcy9sYW5ndWFnZS1zZXJ2ZXIvcHJvdG9jb2wtbGFuZ3VhZ2Utc2VydmVyLm1kI3Nlc3Npb25pbml0cHJvdG9jb2xjb25uZWN0aW9uKSAqL1xuICBpbml0UHJvdG9jb2xDb25uZWN0aW9uKGNsaWVudElkOiBVdWlkKTogUHJvbWlzZTxyZXNwb25zZS5Jbml0UHJvdG9jb2xDb25uZWN0aW9uPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCgnc2Vzc2lvbi9pbml0UHJvdG9jb2xDb25uZWN0aW9uJywgeyBjbGllbnRJZCB9KVxuICB9XG5cbiAgLyoqIFtEb2N1bWVudGF0aW9uXShodHRwczovL2dpdGh1Yi5jb20vZW5zby1vcmcvZW5zby9ibG9iL2RldmVsb3AvZG9jcy9sYW5ndWFnZS1zZXJ2ZXIvcHJvdG9jb2wtbGFuZ3VhZ2Utc2VydmVyLm1kI3RleHRvcGVuZmlsZSkgKi9cbiAgb3BlblRleHRGaWxlKHBhdGg6IFBhdGgpOiBQcm9taXNlPHJlc3BvbnNlLk9wZW5UZXh0RmlsZT4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3Q8cmVzcG9uc2UuT3BlblRleHRGaWxlPigndGV4dC9vcGVuRmlsZScsIHsgcGF0aCB9KVxuICB9XG5cbiAgLyoqIFtEb2N1bWVudGF0aW9uXShodHRwczovL2dpdGh1Yi5jb20vZW5zby1vcmcvZW5zby9ibG9iL2RldmVsb3AvZG9jcy9sYW5ndWFnZS1zZXJ2ZXIvcHJvdG9jb2wtbGFuZ3VhZ2Utc2VydmVyLm1kI3RleHRjbG9zZWZpbGUpICovXG4gIGNsb3NlVGV4dEZpbGUocGF0aDogUGF0aCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoJ3RleHQvY2xvc2VGaWxlJywgeyBwYXRoIH0pXG4gIH1cblxuICAvKiogW0RvY3VtZW50YXRpb25dKGh0dHBzOi8vZ2l0aHViLmNvbS9lbnNvLW9yZy9lbnNvL2Jsb2IvZGV2ZWxvcC9kb2NzL2xhbmd1YWdlLXNlcnZlci9wcm90b2NvbC1sYW5ndWFnZS1zZXJ2ZXIubWQjdGV4dHNhdmUpICovXG4gIHNhdmVUZXh0RmlsZShwYXRoOiBQYXRoLCBjdXJyZW50VmVyc2lvbjogQ2hlY2tzdW0pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KCd0ZXh0L3NhdmUnLCB7IHBhdGgsIGN1cnJlbnRWZXJzaW9uIH0pXG4gIH1cblxuICAvKiogW0RvY3VtZW50YXRpb25dKGh0dHBzOi8vZ2l0aHViLmNvbS9lbnNvLW9yZy9lbnNvL2Jsb2IvZGV2ZWxvcC9kb2NzL2xhbmd1YWdlLXNlcnZlci9wcm90b2NvbC1sYW5ndWFnZS1zZXJ2ZXIubWQjdGV4dGFwcGx5ZWRpdCkgKi9cbiAgYXBwbHlFZGl0KGVkaXQ6IEZpbGVFZGl0LCBleGVjdXRlOiBib29sZWFuKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCgndGV4dC9hcHBseUVkaXQnLCB7IGVkaXQsIGV4ZWN1dGUgfSlcbiAgfVxuXG4gIC8qKiBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL2Vuc28tb3JnL2Vuc28vYmxvYi9kZXZlbG9wL2RvY3MvbGFuZ3VhZ2Utc2VydmVyL3Byb3RvY29sLWxhbmd1YWdlLXNlcnZlci5tZCNmaWxld3JpdGUpICovXG4gIHdyaXRlRmlsZShwYXRoOiBQYXRoLCBjb250ZW50czogVGV4dEZpbGVDb250ZW50cyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoJ2ZpbGUvd3JpdGUnLCB7IHBhdGgsIGNvbnRlbnRzIH0pXG4gIH1cblxuICAvKiogW0RvY3VtZW50YXRpb25dKGh0dHBzOi8vZ2l0aHViLmNvbS9lbnNvLW9yZy9lbnNvL2Jsb2IvZGV2ZWxvcC9kb2NzL2xhbmd1YWdlLXNlcnZlci9wcm90b2NvbC1sYW5ndWFnZS1zZXJ2ZXIubWQjZmlsZXJlYWQpICovXG4gIHJlYWRGaWxlKHBhdGg6IFBhdGgpOiBQcm9taXNlPHJlc3BvbnNlLkZpbGVDb250ZW50cz4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoJ2ZpbGUvcmVhZCcsIHsgcGF0aCB9KVxuICB9XG5cbiAgLyoqIFtEb2N1bWVudGF0aW9uXShodHRwczovL2dpdGh1Yi5jb20vZW5zby1vcmcvZW5zby9ibG9iL2RldmVsb3AvZG9jcy9sYW5ndWFnZS1zZXJ2ZXIvcHJvdG9jb2wtbGFuZ3VhZ2Utc2VydmVyLm1kI2ZpbGVjcmVhdGUpICovXG4gIGNyZWF0ZUZpbGUob2JqZWN0OiBGaWxlU3lzdGVtT2JqZWN0KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCgnZmlsZS9jcmVhdGUnLCB7IG9iamVjdCB9KVxuICB9XG5cbiAgLyoqIFtEb2N1bWVudGF0aW9uXShodHRwczovL2dpdGh1Yi5jb20vZW5zby1vcmcvZW5zby9ibG9iL2RldmVsb3AvZG9jcy9sYW5ndWFnZS1zZXJ2ZXIvcHJvdG9jb2wtbGFuZ3VhZ2Utc2VydmVyLm1kI2ZpbGVkZWxldGUpICovXG4gIGRlbGV0ZUZpbGUocGF0aDogUGF0aCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoJ2ZpbGUvZGVsZXRlJywgeyBwYXRoIH0pXG4gIH1cblxuICAvKiogW0RvY3VtZW50YXRpb25dKGh0dHBzOi8vZ2l0aHViLmNvbS9lbnNvLW9yZy9lbnNvL2Jsb2IvZGV2ZWxvcC9kb2NzL2xhbmd1YWdlLXNlcnZlci9wcm90b2NvbC1sYW5ndWFnZS1zZXJ2ZXIubWQjZmlsZWNvcHkpICovXG4gIGNvcHlGaWxlKGZyb206IFBhdGgsIHRvOiBQYXRoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCgnZmlsZS9jb3B5JywgeyBmcm9tLCB0byB9KVxuICB9XG5cbiAgLyoqIFtEb2N1bWVudGF0aW9uXShodHRwczovL2dpdGh1Yi5jb20vZW5zby1vcmcvZW5zby9ibG9iL2RldmVsb3AvZG9jcy9sYW5ndWFnZS1zZXJ2ZXIvcHJvdG9jb2wtbGFuZ3VhZ2Utc2VydmVyLm1kI2ZpbGVtb3ZlKSAqL1xuICBtb3ZlRmlsZShmcm9tOiBQYXRoLCB0bzogUGF0aCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoJ2ZpbGUvbW92ZScsIHsgZnJvbSwgdG8gfSlcbiAgfVxuXG4gIC8qKiBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL2Vuc28tb3JnL2Vuc28vYmxvYi9kZXZlbG9wL2RvY3MvbGFuZ3VhZ2Utc2VydmVyL3Byb3RvY29sLWxhbmd1YWdlLXNlcnZlci5tZCNmaWxlZXhpc3RzKSAqL1xuICBmaWxlRXhpc3RzKHBhdGg6IFBhdGgpOiBQcm9taXNlPHJlc3BvbnNlLkZpbGVFeGlzdHM+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KCdmaWxlL2V4aXN0cycsIHsgcGF0aCB9KVxuICB9XG5cbiAgLyoqIFtEb2N1bWVudGF0aW9uXShodHRwczovL2dpdGh1Yi5jb20vZW5zby1vcmcvZW5zby9ibG9iL2RldmVsb3AvZG9jcy9sYW5ndWFnZS1zZXJ2ZXIvcHJvdG9jb2wtbGFuZ3VhZ2Utc2VydmVyLm1kI2ZpbGV0cmVlKSAqL1xuICBmaWxlVHJlZShwYXRoOiBQYXRoLCBkZXB0aD86IG51bWJlcik6IFByb21pc2U8cmVzcG9uc2UuRmlsZVRyZWU+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KCdmaWxlL3RyZWUnLCB7IHBhdGgsIGRlcHRoIH0pXG4gIH1cblxuICAvKiogW0RvY3VtZW50YXRpb25dKGh0dHBzOi8vZ2l0aHViLmNvbS9lbnNvLW9yZy9lbnNvL2Jsb2IvZGV2ZWxvcC9kb2NzL2xhbmd1YWdlLXNlcnZlci9wcm90b2NvbC1sYW5ndWFnZS1zZXJ2ZXIubWQjZmlsZWxpc3QpICovXG4gIGxpc3RGaWxlcyhwYXRoOiBQYXRoKTogUHJvbWlzZTxyZXNwb25zZS5GaWxlTGlzdD4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoJ2ZpbGUvbGlzdCcsIHsgcGF0aCB9KVxuICB9XG5cbiAgLyoqIFtEb2N1bWVudGF0aW9uXShodHRwczovL2dpdGh1Yi5jb20vZW5zby1vcmcvZW5zby9ibG9iL2RldmVsb3AvZG9jcy9sYW5ndWFnZS1zZXJ2ZXIvcHJvdG9jb2wtbGFuZ3VhZ2Utc2VydmVyLm1kI2ZpbGVpbmZvKSAqL1xuICBmaWxlSW5mbyhwYXRoOiBQYXRoKTogUHJvbWlzZTxyZXNwb25zZS5GaWxlSW5mbz4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoJ2ZpbGUvaW5mbycsIHsgcGF0aCB9KVxuICB9XG5cbiAgLyoqIFtEb2N1bWVudGF0aW9uXShodHRwczovL2dpdGh1Yi5jb20vZW5zby1vcmcvZW5zby9ibG9iL2RldmVsb3AvZG9jcy9sYW5ndWFnZS1zZXJ2ZXIvcHJvdG9jb2wtbGFuZ3VhZ2Utc2VydmVyLm1kI2ZpbGVjaGVja3N1bSkgKi9cbiAgZmlsZUNoZWNrc3VtKHBhdGg6IFBhdGgpOiBQcm9taXNlPHJlc3BvbnNlLkZpbGVDaGVja3N1bT4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoJ2ZpbGUvY2hlY2tzdW0nLCB7IHBhdGggfSlcbiAgfVxuXG4gIC8qKiBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL2Vuc28tb3JnL2Vuc28vYmxvYi9kZXZlbG9wL2RvY3MvbGFuZ3VhZ2Utc2VydmVyL3Byb3RvY29sLWxhbmd1YWdlLXNlcnZlci5tZCN2Y3Npbml0KSAqL1xuICB2Y3NJbml0KHJvb3Q6IFBhdGgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KCd2Y3MvaW5pdCcsIHsgcm9vdCB9KVxuICB9XG5cbiAgLyoqIFtEb2N1bWVudGF0aW9uXShodHRwczovL2dpdGh1Yi5jb20vZW5zby1vcmcvZW5zby9ibG9iL2RldmVsb3AvZG9jcy9sYW5ndWFnZS1zZXJ2ZXIvcHJvdG9jb2wtbGFuZ3VhZ2Utc2VydmVyLm1kI3Zjc3NhdmUpICovXG4gIHZjc1NhdmUocm9vdDogUGF0aCwgbmFtZT86IHN0cmluZyk6IFByb21pc2U8cmVzcG9uc2UuVkNTQ29tbWl0PiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCgndmNzL3NhdmUnLCB7IHJvb3QsIG5hbWUgfSlcbiAgfVxuXG4gIC8qKiBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL2Vuc28tb3JnL2Vuc28vYmxvYi9kZXZlbG9wL2RvY3MvbGFuZ3VhZ2Utc2VydmVyL3Byb3RvY29sLWxhbmd1YWdlLXNlcnZlci5tZCN2Y3NzdGF0dXMpICovXG4gIHZjc1N0YXR1cyhyb290OiBQYXRoKTogUHJvbWlzZTxyZXNwb25zZS5WQ1NTdGF0dXM+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KCd2Y3Mvc3RhdHVzJywgeyByb290IH0pXG4gIH1cblxuICAvKiogW0RvY3VtZW50YXRpb25dKGh0dHBzOi8vZ2l0aHViLmNvbS9lbnNvLW9yZy9lbnNvL2Jsb2IvZGV2ZWxvcC9kb2NzL2xhbmd1YWdlLXNlcnZlci9wcm90b2NvbC1sYW5ndWFnZS1zZXJ2ZXIubWQjdmNzcmVzdG9yZSkgKi9cbiAgdmNzUmVzdG9yZShyb290OiBQYXRoLCBjb21taXRJZD86IHN0cmluZyk6IFByb21pc2U8cmVzcG9uc2UuVkNTQ2hhbmdlcz4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoJ3Zjcy9yZXN0b3JlJywgeyByb290LCBjb21taXRJZCB9KVxuICB9XG5cbiAgLyoqIFtEb2N1bWVudGF0aW9uXShodHRwczovL2dpdGh1Yi5jb20vZW5zby1vcmcvZW5zby9ibG9iL2RldmVsb3AvZG9jcy9sYW5ndWFnZS1zZXJ2ZXIvcHJvdG9jb2wtbGFuZ3VhZ2Utc2VydmVyLm1kI3Zjc2xpc3QpICovXG4gIHZjc0xpc3Qocm9vdDogUGF0aCwgbGltaXQ/OiBudW1iZXIpOiBQcm9taXNlPHJlc3BvbnNlLlZDU1NhdmVzPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCgndmNzL2xpc3QnLCB7IHJvb3QsIGxpbWl0IH0pXG4gIH1cblxuICAvKiogW0RvY3VtZW50YXRpb25dKGh0dHBzOi8vZ2l0aHViLmNvbS9lbnNvLW9yZy9lbnNvL2Jsb2IvZGV2ZWxvcC9kb2NzL2xhbmd1YWdlLXNlcnZlci9wcm90b2NvbC1sYW5ndWFnZS1zZXJ2ZXIubWQjZXhlY3V0aW9uY29udGV4dGNyZWF0ZSkgKi9cbiAgY3JlYXRlRXhlY3V0aW9uQ29udGV4dChjb250ZXh0SWQ/OiBDb250ZXh0SWQpOiBQcm9taXNlPHJlc3BvbnNlLkV4ZWN1dGlvbkNvbnRleHQ+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KCdleGVjdXRpb25Db250ZXh0L2NyZWF0ZScsIHsgY29udGV4dElkIH0pXG4gIH1cblxuICAvKiogW0RvY3VtZW50YXRpb25dKGh0dHBzOi8vZ2l0aHViLmNvbS9lbnNvLW9yZy9lbnNvL2Jsb2IvZGV2ZWxvcC9kb2NzL2xhbmd1YWdlLXNlcnZlci9wcm90b2NvbC1sYW5ndWFnZS1zZXJ2ZXIubWQjZXhlY3V0aW9uY29udGV4dGRlc3Ryb3kpICovXG4gIGRlc3Ryb3lFeGVjdXRpb25Db250ZXh0KGNvbnRleHRJZDogQ29udGV4dElkKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCgnZXhlY3V0aW9uQ29udGV4dC9kZXN0cm95JywgeyBjb250ZXh0SWQgfSlcbiAgfVxuXG4gIC8qKiBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL2Vuc28tb3JnL2Vuc28vYmxvYi9kZXZlbG9wL2RvY3MvbGFuZ3VhZ2Utc2VydmVyL3Byb3RvY29sLWxhbmd1YWdlLXNlcnZlci5tZCNleGVjdXRpb25jb250ZXh0Zm9yaykgKi9cbiAgZm9ya0V4ZWN1dGlvbkNvbnRleHQoY29udGV4dElkOiBDb250ZXh0SWQpOiBQcm9taXNlPHJlc3BvbnNlLkV4ZWN1dGlvbkNvbnRleHQ+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KCdleGVjdXRpb25Db250ZXh0L2ZvcmsnLCB7IGNvbnRleHRJZCB9KVxuICB9XG5cbiAgLyoqIFtEb2N1bWVudGF0aW9uXShodHRwczovL2dpdGh1Yi5jb20vZW5zby1vcmcvZW5zby9ibG9iL2RldmVsb3AvZG9jcy9sYW5ndWFnZS1zZXJ2ZXIvcHJvdG9jb2wtbGFuZ3VhZ2Utc2VydmVyLm1kI2V4ZWN1dGlvbmNvbnRleHRwdXNoKSAqL1xuICBwdXNoRXhlY3V0aW9uQ29udGV4dEl0ZW0oY29udGV4dElkOiBDb250ZXh0SWQsIHN0YWNrSXRlbTogU3RhY2tJdGVtKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCgnZXhlY3V0aW9uQ29udGV4dC9wdXNoJywgeyBjb250ZXh0SWQsIHN0YWNrSXRlbSB9KVxuICB9XG5cbiAgLyoqIFtEb2N1bWVudGF0aW9uXShodHRwczovL2dpdGh1Yi5jb20vZW5zby1vcmcvZW5zby9ibG9iL2RldmVsb3AvZG9jcy9sYW5ndWFnZS1zZXJ2ZXIvcHJvdG9jb2wtbGFuZ3VhZ2Utc2VydmVyLm1kI2V4ZWN1dGlvbmNvbnRleHRwb3ApICovXG4gIHBvcEV4ZWN1dGlvbkNvbnRleHRJdGVtKGNvbnRleHRJZDogQ29udGV4dElkKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCgnZXhlY3V0aW9uQ29udGV4dC9wb3AnLCB7IGNvbnRleHRJZCB9KVxuICB9XG5cbiAgLyoqIFtEb2N1bWVudGF0aW9uXShodHRwczovL2dpdGh1Yi5jb20vZW5zby1vcmcvZW5zby9ibG9iL2RldmVsb3AvZG9jcy9sYW5ndWFnZS1zZXJ2ZXIvcHJvdG9jb2wtbGFuZ3VhZ2Utc2VydmVyLm1kI2V4ZWN1dGlvbmNvbnRleHRyZWNvbXB1dGUpICovXG4gIHJlY29tcHV0ZUV4ZWN1dGlvbkNvbnRleHQoXG4gICAgY29udGV4dElkOiBDb250ZXh0SWQsXG4gICAgaW52YWxpZGF0ZWRFeHByZXNzaW9ucz86ICdhbGwnIHwgc3RyaW5nW10sXG4gICAgZXhlY3V0aW9uRW52aXJvbm1lbnQ/OiBFeGVjdXRpb25FbnZpcm9ubWVudCxcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCgnZXhlY3V0aW9uQ29udGV4dC9yZWNvbXB1dGUnLCB7XG4gICAgICBjb250ZXh0SWQsXG4gICAgICBpbnZhbGlkYXRlZEV4cHJlc3Npb25zLFxuICAgICAgZXhlY3V0aW9uRW52aXJvbm1lbnQsXG4gICAgfSlcbiAgfVxuXG4gIC8qKiBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL2Vuc28tb3JnL2Vuc28vYmxvYi9kZXZlbG9wL2RvY3MvbGFuZ3VhZ2Utc2VydmVyL3Byb3RvY29sLWxhbmd1YWdlLXNlcnZlci5tZCNleGVjdXRpb25jb250ZXh0aW50ZXJydXB0KSAqL1xuICBpbnRlcnJ1cHRFeGVjdXRpb25Db250ZXh0KGNvbnRleHRJZDogQ29udGV4dElkKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCgnZXhlY3V0aW9uQ29udGV4dC9pbnRlcnJ1cHQnLCB7IGNvbnRleHRJZCB9KVxuICB9XG5cbiAgLyoqIFtEb2N1bWVudGF0aW9uXShodHRwczovL2dpdGh1Yi5jb20vZW5zby1vcmcvZW5zby9ibG9iL2RldmVsb3AvZG9jcy9sYW5ndWFnZS1zZXJ2ZXIvcHJvdG9jb2wtbGFuZ3VhZ2Utc2VydmVyLm1kI2V4ZWN1dGlvbmNvbnRleHRzZXRleGVjdXRpb25lbnZpcm9ubWVudCkgKi9cbiAgc2V0RXhlY3V0aW9uRW52aXJvbm1lbnQoXG4gICAgY29udGV4dElkOiBDb250ZXh0SWQsXG4gICAgZXhlY3V0aW9uRW52aXJvbm1lbnQ/OiBFeGVjdXRpb25FbnZpcm9ubWVudCxcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCgnZXhlY3V0aW9uQ29udGV4dC9zZXRFeGVjdXRpb25FbnZpcm9ubWVudCcsIHtcbiAgICAgIGNvbnRleHRJZCxcbiAgICAgIGV4ZWN1dGlvbkVudmlyb25tZW50LFxuICAgIH0pXG4gIH1cblxuICAvKiogW0RvY3VtZW50YXRpb25dKGh0dHBzOi8vZ2l0aHViLmNvbS9lbnNvLW9yZy9lbnNvL2Jsb2IvZGV2ZWxvcC9kb2NzL2xhbmd1YWdlLXNlcnZlci9wcm90b2NvbC1sYW5ndWFnZS1zZXJ2ZXIubWQjZXhlY3V0aW9uY29udGV4dGV4ZWN1dGVleHByZXNzaW9uKSAqL1xuICBleGVjdXRlRXhwcmVzc2lvbihcbiAgICBleGVjdXRpb25Db250ZXh0SWQ6IFV1aWQsXG4gICAgdmlzdWFsaXphdGlvbklkOiBVdWlkLFxuICAgIGV4cHJlc3Npb25JZDogRXhwcmVzc2lvbklkLFxuICAgIGV4cHJlc3Npb246IHN0cmluZyxcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCgnZXhlY3V0aW9uQ29udGV4dC9leGVjdXRlRXhwcmVzc2lvbicsIHtcbiAgICAgIGV4ZWN1dGlvbkNvbnRleHRJZCxcbiAgICAgIHZpc3VhbGl6YXRpb25JZCxcbiAgICAgIGV4cHJlc3Npb25JZCxcbiAgICAgIGV4cHJlc3Npb24sXG4gICAgfSlcbiAgfVxuXG4gIC8qKiBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL2Vuc28tb3JnL2Vuc28vYmxvYi9kZXZlbG9wL2RvY3MvbGFuZ3VhZ2Utc2VydmVyL3Byb3RvY29sLWxhbmd1YWdlLXNlcnZlci5tZCNleGVjdXRpb25jb250ZXh0YXR0YWNodmlzdWFsaXphdGlvbikgKi9cbiAgYXR0YWNoVmlzdWFsaXphdGlvbihcbiAgICB2aXN1YWxpemF0aW9uSWQ6IFV1aWQsXG4gICAgZXhwcmVzc2lvbklkOiBFeHByZXNzaW9uSWQsXG4gICAgdmlzdWFsaXphdGlvbkNvbmZpZzogVmlzdWFsaXphdGlvbkNvbmZpZ3VyYXRpb24sXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoJ2V4ZWN1dGlvbkNvbnRleHQvYXR0YWNoVmlzdWFsaXphdGlvbicsIHtcbiAgICAgIHZpc3VhbGl6YXRpb25JZCxcbiAgICAgIGV4cHJlc3Npb25JZCxcbiAgICAgIHZpc3VhbGl6YXRpb25Db25maWcsXG4gICAgfSlcbiAgfVxuXG4gIC8qKiBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL2Vuc28tb3JnL2Vuc28vYmxvYi9kZXZlbG9wL2RvY3MvbGFuZ3VhZ2Utc2VydmVyL3Byb3RvY29sLWxhbmd1YWdlLXNlcnZlci5tZCNleGVjdXRpb25jb250ZXh0ZGV0YWNodmlzdWFsaXphdGlvbikgKi9cbiAgZGV0YWNoVmlzdWFsaXphdGlvbihcbiAgICB2aXN1YWxpemF0aW9uSWQ6IFV1aWQsXG4gICAgZXhwcmVzc2lvbklkOiBFeHByZXNzaW9uSWQsXG4gICAgY29udGV4dElkOiBDb250ZXh0SWQsXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoJ2V4ZWN1dGlvbkNvbnRleHQvZGV0YWNoVmlzdWFsaXphdGlvbicsIHtcbiAgICAgIHZpc3VhbGl6YXRpb25JZCxcbiAgICAgIGV4cHJlc3Npb25JZCxcbiAgICAgIGNvbnRleHRJZCxcbiAgICB9KVxuICB9XG5cbiAgLyoqIFtEb2N1bWVudGF0aW9uXShodHRwczovL2dpdGh1Yi5jb20vZW5zby1vcmcvZW5zby9ibG9iL2RldmVsb3AvZG9jcy9sYW5ndWFnZS1zZXJ2ZXIvcHJvdG9jb2wtbGFuZ3VhZ2Utc2VydmVyLm1kI2V4ZWN1dGlvbmNvbnRleHRtb2RpZnl2aXN1YWxpemF0aW9uKSAqL1xuICBtb2RpZnlWaXN1YWxpemF0aW9uKFxuICAgIHZpc3VhbGl6YXRpb25JZDogVXVpZCxcbiAgICB2aXN1YWxpemF0aW9uQ29uZmlnOiBWaXN1YWxpemF0aW9uQ29uZmlndXJhdGlvbixcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCgnZXhlY3V0aW9uQ29udGV4dC9tb2RpZnlWaXN1YWxpemF0aW9uJywge1xuICAgICAgdmlzdWFsaXphdGlvbklkLFxuICAgICAgdmlzdWFsaXphdGlvbkNvbmZpZyxcbiAgICB9KVxuICB9XG5cbiAgLyoqIFtEb2N1bWVudGF0aW9uXShodHRwczovL2dpdGh1Yi5jb20vZW5zby1vcmcvZW5zby9ibG9iL2RldmVsb3AvZG9jcy9sYW5ndWFnZS1zZXJ2ZXIvcHJvdG9jb2wtbGFuZ3VhZ2Utc2VydmVyLm1kI3NlYXJjaGdldHN1Z2dlc3Rpb25zZGF0YWJhc2UpICovXG4gIGdldFN1Z2dlc3Rpb25zRGF0YWJhc2UoKTogUHJvbWlzZTxyZXNwb25zZS5HZXRTdWdnZXN0aW9uc0RhdGFiYXNlPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCgnc2VhcmNoL2dldFN1Z2dlc3Rpb25zRGF0YWJhc2UnLCB7fSlcbiAgfVxuXG4gIC8qKiBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL2Vuc28tb3JnL2Vuc28vYmxvYi9kZXZlbG9wL2RvY3MvbGFuZ3VhZ2Utc2VydmVyL3Byb3RvY29sLWxhbmd1YWdlLXNlcnZlci5tZCNydW50aW1lZ2V0Y29tcG9uZW50Z3JvdXBzKSAqL1xuICBnZXRDb21wb25lbnRHcm91cHMoKTogUHJvbWlzZTxyZXNwb25zZS5HZXRDb21wb25lbnRHcm91cHM+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KCdydW50aW1lL2dldENvbXBvbmVudEdyb3VwcycsIHt9KVxuICB9XG5cbiAgLyoqIFtEb2N1bWVudGF0aW9uXShodHRwczovL2dpdGh1Yi5jb20vZW5zby1vcmcvZW5zby9ibG9iL2RldmVsb3AvZG9jcy9sYW5ndWFnZS1zZXJ2ZXIvcHJvdG9jb2wtbGFuZ3VhZ2Utc2VydmVyLm1kI3Byb2ZpbGluZ3N0YXJ0KSAqL1xuICBwcm9maWxpbmdTdGFydChtZW1vcnlTbmFwc2hvdD86IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KCdwcm9maWxpbmcvc3RhcnQnLCB7IG1lbW9yeVNuYXBzaG90IH0pXG4gIH1cblxuICAvKiogW0RvY3VtZW50YXRpb25dKGh0dHBzOi8vZ2l0aHViLmNvbS9lbnNvLW9yZy9lbnNvL2Jsb2IvZGV2ZWxvcC9kb2NzL2xhbmd1YWdlLXNlcnZlci9wcm90b2NvbC1sYW5ndWFnZS1zZXJ2ZXIubWQjcHJvZmlsaW5nc3RvcCkgKi9cbiAgcHJvZmlsaW5nU3RvcCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KCdwcm9maWxpbmcvc3RvcCcsIHt9KVxuICB9XG5cbiAgYWlDb21wbGV0aW9uKHByb21wdDogc3RyaW5nLCBzdG9wU2VxdWVuY2U6IHN0cmluZyk6IFByb21pc2U8cmVzcG9uc2UuQUlDb21wbGV0aW9uPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCgnYWkvY29tcGxldGlvbicsIHsgcHJvbXB0LCBzdG9wU2VxdWVuY2UgfSlcbiAgfVxuXG4gIC8qKiBBIGhlbHBlciBmdW5jdGlvbiB0byBzdWJzY3JpYmUgdG8gZmlsZSB1cGRhdGVzLlxuICAgKiBQbGVhc2UgdXNlIGBscy5vbignZmlsZS9ldmVudCcpYCBkaXJlY3RseSBpZiB0aGUgaW5pdGlhbCBgJ0FkZGVkJ2Agbm90aWZpY2F0aW9ucyBhcmUgbm90XG4gICAqIG5lZWRlZC4gKi9cbiAgd2F0Y2hGaWxlcyhcbiAgICByb290SWQ6IFV1aWQsXG4gICAgc2VnbWVudHM6IHN0cmluZ1tdLFxuICAgIGNhbGxiYWNrOiAoZXZlbnQ6IEV2ZW50PCdmaWxlL2V2ZW50Jz4pID0+IHZvaWQsXG4gICAgcmV0cnk6IDxUPihjYjogKCkgPT4gUHJvbWlzZTxUPikgPT4gUHJvbWlzZTxUPiA9IChmKSA9PiBmKCksXG4gICkge1xuICAgIGxldCBydW5uaW5nID0gdHJ1ZVxuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgcmV0dXJuIHtcbiAgICAgIHByb21pc2U6IChhc3luYyAoKSA9PiB7XG4gICAgICAgIHNlbGYub24oJ2ZpbGUvZXZlbnQnLCBjYWxsYmFjaylcbiAgICAgICAgYXdhaXQgcmV0cnkoYXN5bmMgKCkgPT4gcnVubmluZyAmJiBzZWxmLmFjcXVpcmVSZWNlaXZlc1RyZWVVcGRhdGVzKHsgcm9vdElkLCBzZWdtZW50cyB9KSlcbiAgICAgICAgYXdhaXQgd2Fsa0ZzKHNlbGYsIHsgcm9vdElkLCBzZWdtZW50cyB9LCAodHlwZSwgcGF0aCkgPT4ge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFydW5uaW5nIHx8XG4gICAgICAgICAgICB0eXBlICE9PSAnRmlsZScgfHxcbiAgICAgICAgICAgIHBhdGguc2VnbWVudHMubGVuZ3RoIDwgc2VnbWVudHMubGVuZ3RoIHx8XG4gICAgICAgICAgICBzZWdtZW50cy5zb21lKChzZWdtZW50LCBpKSA9PiBzZWdtZW50ICE9PSBwYXRoLnNlZ21lbnRzW2ldKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgIHBhdGg6IHsgcm9vdElkOiBwYXRoLnJvb3RJZCwgc2VnbWVudHM6IHBhdGguc2VnbWVudHMuc2xpY2Uoc2VnbWVudHMubGVuZ3RoKSB9LFxuICAgICAgICAgICAga2luZDogJ0FkZGVkJyxcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSkoKSxcbiAgICAgIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICBydW5uaW5nID0gZmFsc2VcbiAgICAgICAgc2VsZi5vZmYoJ2ZpbGUvZXZlbnQnLCBjYWxsYmFjaylcbiAgICAgIH0sXG4gICAgfVxuICB9XG5cbiAgcmV0YWluKCkge1xuICAgIGlmICh0aGlzLnJldGFpbkNvdW50ID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyeWluZyB0byByZXRhaW4gYWxyZWFkeSBkaXNwb3NlZCBsYW5ndWFnZSBzZXJ2ZXIuJylcbiAgICB9XG4gICAgdGhpcy5yZXRhaW5Db3VudCArPSAxXG4gIH1cblxuICByZWxlYXNlKCkge1xuICAgIGlmICh0aGlzLnJldGFpbkNvdW50ID4gMCkge1xuICAgICAgdGhpcy5yZXRhaW5Db3VudCAtPSAxXG4gICAgICBpZiAodGhpcy5yZXRhaW5Db3VudCA9PT0gMCkge1xuICAgICAgICB0aGlzLmNsaWVudC5jbG9zZSgpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVsZWFzZWQgYWxyZWFkeSBkaXNwb3NlZCBsYW5ndWFnZSBzZXJ2ZXIuJylcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVUZXh0Q2hlY2tzdW0odGV4dDogc3RyaW5nKTogQ2hlY2tzdW0ge1xuICByZXR1cm4gYnl0ZXNUb0hleChTSEEzLmNyZWF0ZSgpLnVwZGF0ZSh0ZXh0KS5kaWdlc3QoKSkgYXMgQ2hlY2tzdW1cbn1cbiIsICJjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfZGlybmFtZSA9IFwiQzpcXFxcUHJvamVjdHNcXFxcZW5zb1xcXFxlbnNvXFxcXGFwcFxcXFxndWkyXFxcXHNoYXJlZFxcXFxsYW5ndWFnZVNlcnZlclwiO2NvbnN0IF9fdml0ZV9pbmplY3RlZF9vcmlnaW5hbF9maWxlbmFtZSA9IFwiQzpcXFxcUHJvamVjdHNcXFxcZW5zb1xcXFxlbnNvXFxcXGFwcFxcXFxndWkyXFxcXHNoYXJlZFxcXFxsYW5ndWFnZVNlcnZlclxcXFxmaWxlcy50c1wiO2NvbnN0IF9fdml0ZV9pbmplY3RlZF9vcmlnaW5hbF9pbXBvcnRfbWV0YV91cmwgPSBcImZpbGU6Ly8vQzovUHJvamVjdHMvZW5zby9lbnNvL2FwcC9ndWkyL3NoYXJlZC9sYW5ndWFnZVNlcnZlci9maWxlcy50c1wiO2ltcG9ydCB7IHR5cGUgTGFuZ3VhZ2VTZXJ2ZXIgfSBmcm9tICdzaGFyZWQvbGFuZ3VhZ2VTZXJ2ZXInXG5pbXBvcnQgdHlwZSB7IEZpbGVTeXN0ZW1PYmplY3QsIFBhdGggfSBmcm9tICdzaGFyZWQvbGFuZ3VhZ2VTZXJ2ZXJUeXBlcydcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdhbGtGcyhcbiAgbHM6IExhbmd1YWdlU2VydmVyLFxuICBwYXRoOiBQYXRoLFxuICBjYjogKHR5cGU6IEZpbGVTeXN0ZW1PYmplY3RbJ3R5cGUnXSwgcGF0aDogUGF0aCkgPT4gdm9pZCxcbikge1xuICBmb3IgKGNvbnN0IGZpbGUgb2YgKGF3YWl0IGxzLmxpc3RGaWxlcyhwYXRoKSkucGF0aHMpIHtcbiAgICBjb25zdCBmaWxlUGF0aDogUGF0aCA9IHtcbiAgICAgIHJvb3RJZDogZmlsZS5wYXRoLnJvb3RJZCxcbiAgICAgIHNlZ21lbnRzOiBbLi4uZmlsZS5wYXRoLnNlZ21lbnRzLCBmaWxlLm5hbWVdLFxuICAgIH1cbiAgICBjYihmaWxlLnR5cGUsIGZpbGVQYXRoKVxuICAgIHN3aXRjaCAoZmlsZS50eXBlKSB7XG4gICAgICBjYXNlICdEaXJlY3RvcnknOlxuICAgICAgY2FzZSAnRGlyZWN0b3J5VHJ1bmNhdGVkJzoge1xuICAgICAgICB3YWxrRnMobHMsIGZpbGVQYXRoLCBjYilcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ0ZpbGUnOlxuICAgICAgY2FzZSAnT3RoZXInOlxuICAgICAgY2FzZSAnU3ltbGlua0xvb3AnOiB7XG4gICAgICAgIC8vIElnbm9yZWQuXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGNvbnN0IHVuZXhwZWN0ZWQ6IG5ldmVyID0gZmlsZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkodW5leHBlY3RlZCkpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCAiY29uc3QgX192aXRlX2luamVjdGVkX29yaWdpbmFsX2Rpcm5hbWUgPSBcIkM6XFxcXFByb2plY3RzXFxcXGVuc29cXFxcZW5zb1xcXFxhcHBcXFxcZ3VpMlxcXFxzaGFyZWRcIjtjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfZmlsZW5hbWUgPSBcIkM6XFxcXFByb2plY3RzXFxcXGVuc29cXFxcZW5zb1xcXFxhcHBcXFxcZ3VpMlxcXFxzaGFyZWRcXFxccmV0cnkudHNcIjtjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfaW1wb3J0X21ldGFfdXJsID0gXCJmaWxlOi8vL0M6L1Byb2plY3RzL2Vuc28vZW5zby9hcHAvZ3VpMi9zaGFyZWQvcmV0cnkudHNcIjtpbXBvcnQgeyB3YWl0IH0gZnJvbSAnbGliMC9wcm9taXNlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIEJhY2tvZmZPcHRpb25zPEU+IHtcbiAgbWF4UmV0cmllcz86IG51bWJlclxuICByZXRyeURlbGF5PzogbnVtYmVyXG4gIHJldHJ5RGVsYXlNdWx0aXBsaWVyPzogbnVtYmVyXG4gIHJldHJ5RGVsYXlNYXg/OiBudW1iZXJcbiAgLyoqIENhbGxlZCB3aGVuIHRoZSBwcm9taXNlIHRocm93cyBhbiBlcnJvciwgYW5kIHRoZSBuZXh0IHJldHJ5IGlzIGFib3V0IHRvIGJlIGF0dGVtcHRlZC5cbiAgICogV2hlbiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYCwgdGhlIGJhY2tvZmYgaXMgaW1tZWRpYXRlbHkgYWJvcnRlZC4gV2hlbiB0aGlzIGZ1bmN0aW9uXG4gICAqIGlzIG5vdCBwcm92aWRlZCwgdGhlIGJhY2tvZmYgd2lsbCBhbHdheXMgY29udGludWUgdW50aWwgdGhlIG1heGltdW0gbnVtYmVyIG9mIHJldHJpZXNcbiAgICogaXMgcmVhY2hlZC4gKiAqL1xuICBvbkJlZm9yZVJldHJ5PzogKFxuICAgIGVycm9yOiBFLFxuICAgIHJldHJ5Q291bnQ6IG51bWJlcixcbiAgICBtYXhSZXRyaWVzOiBudW1iZXIsXG4gICAgZGVsYXk6IG51bWJlcixcbiAgKSA9PiBib29sZWFuIHwgdm9pZFxuICAvKiogQ2FsbGVkIHJpZ2h0IGJlZm9yZSByZXR1cm5pbmcuICovXG4gIG9uU3VjY2Vzcz86IChyZXRyeUNvdW50OiBudW1iZXIpID0+IHZvaWRcbiAgLyoqIENhbGxlZCBhZnRlciB0aGUgZmluYWwgcmV0cnksIHJpZ2h0IGJlZm9yZSB0aHJvd2luZyBhbiBlcnJvci5cbiAgICogTm90ZSB0aGF0IGBvbkJlZm9yZVJldHJ5YCBpcyAqbm90KiBjYWxsZWQgb24gdGhlIGZpbmFsIHJldHJ5LCBhcyB0aGVyZSBpcyBub3RoaW5nIGFmdGVyIHRoZVxuICAgKiBmaW5hbCByZXRyeS4gKi9cbiAgb25GYWlsdXJlPzogKGVycm9yOiBFLCByZXRyeUNvdW50OiBudW1iZXIpID0+IHZvaWRcbn1cblxuY29uc3QgZGVmYXVsdEJhY2tvZmZPcHRpb25zOiBSZXF1aXJlZDxCYWNrb2ZmT3B0aW9uczx1bmtub3duPj4gPSB7XG4gIG1heFJldHJpZXM6IDMsXG4gIHJldHJ5RGVsYXk6IDEwMDAsXG4gIHJldHJ5RGVsYXlNdWx0aXBsaWVyOiAyLFxuICByZXRyeURlbGF5TWF4OiAxMDAwMCxcbiAgb25CZWZvcmVSZXRyeTogKCkgPT4ge30sXG4gIG9uU3VjY2VzczogKCkgPT4ge30sXG4gIG9uRmFpbHVyZTogKCkgPT4ge30sXG59XG5cbi8qKiBSZXRyeSBhIGZhaWxpbmcgcHJvbWlzZSBmdW5jdGlvbiB3aXRoIGV4cG9uZW50aWFsIGJhY2tvZmYuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXhwb25lbnRpYWxCYWNrb2ZmPFQsIEU+KFxuICBmOiAoKSA9PiBQcm9taXNlPFQ+LFxuICBiYWNrb2ZmT3B0aW9ucz86IEJhY2tvZmZPcHRpb25zPEU+LFxuKTogUHJvbWlzZTxUPiB7XG4gIGNvbnN0IHtcbiAgICBtYXhSZXRyaWVzLFxuICAgIHJldHJ5RGVsYXksXG4gICAgcmV0cnlEZWxheU11bHRpcGxpZXIsXG4gICAgcmV0cnlEZWxheU1heCxcbiAgICBvbkJlZm9yZVJldHJ5LFxuICAgIG9uU3VjY2VzcyxcbiAgICBvbkZhaWx1cmUsXG4gIH0gPSB7XG4gICAgLi4uZGVmYXVsdEJhY2tvZmZPcHRpb25zLFxuICAgIC4uLmJhY2tvZmZPcHRpb25zLFxuICB9XG4gIGZvciAoXG4gICAgbGV0IHJldHJpZXMgPSAwLCBkZWxheSA9IHJldHJ5RGVsYXk7XG4gICAgO1xuICAgIHJldHJpZXMgKz0gMSwgZGVsYXkgPSBNYXRoLm1pbihyZXRyeURlbGF5TWF4LCBkZWxheSAqIHJldHJ5RGVsYXlNdWx0aXBsaWVyKVxuICApIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZigpXG4gICAgICBvblN1Y2Nlc3MocmV0cmllcylcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKHJldHJpZXMgPj0gbWF4UmV0cmllcykge1xuICAgICAgICBvbkZhaWx1cmUoZXJyb3IgYXMgRSwgcmV0cmllcylcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICAgIGlmIChvbkJlZm9yZVJldHJ5KGVycm9yIGFzIEUsIHJldHJpZXMsIG1heFJldHJpZXMsIGRlbGF5KSA9PT0gZmFsc2UpIHRocm93IGVycm9yXG4gICAgICBhd2FpdCB3YWl0KGRlbGF5KVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdE9uQmVmb3JlUmV0cnkoXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmcsXG4pOiBOb25OdWxsYWJsZTxCYWNrb2ZmT3B0aW9uczxhbnk+WydvbkJlZm9yZVJldHJ5J10+IHtcbiAgcmV0dXJuIChlcnJvciwgcmV0cnlDb3VudCwgbWF4UmV0cmllcywgZGVsYXkpID0+IHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgJ0NvdWxkIG5vdCAnICtcbiAgICAgICAgZGVzY3JpcHRpb24gK1xuICAgICAgICBgICgke3JldHJ5Q291bnR9LyR7bWF4UmV0cmllc30gcmV0cmllcyksIHJldHJ5aW5nIGFmdGVyICR7ZGVsYXl9bXMuLi5gLFxuICAgIClcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0T25GYWlsdXJlKFxuICBkZXNjcmlwdGlvbjogc3RyaW5nLFxuKTogTm9uTnVsbGFibGU8QmFja29mZk9wdGlvbnM8YW55Plsnb25GYWlsdXJlJ10+IHtcbiAgcmV0dXJuIChlcnJvciwgcmV0cnlDb3VudCkgPT4ge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAnQ291bGQgbm90ICcgKyBkZXNjcmlwdGlvbiArIGAgKCR7cmV0cnlDb3VudH0vJHtyZXRyeUNvdW50fSByZXRyaWVzKSwgdGhyb3dpbmcgZXJyb3IuYCxcbiAgICApXG4gICAgY29uc29sZS5lcnJvcihlcnJvcilcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdE9uU3VjY2VzcyhcbiAgZGVzY3JpcHRpb246IHN0cmluZyxcbik6IE5vbk51bGxhYmxlPEJhY2tvZmZPcHRpb25zPGFueT5bJ29uU3VjY2VzcyddPiB7XG4gIHJldHVybiAocmV0cnlDb3VudCkgPT4ge1xuICAgIGlmIChyZXRyeUNvdW50ID09PSAwKSByZXR1cm5cbiAgICBjb25zb2xlLmluZm8oXG4gICAgICAnU3VjY2Vzc2Z1bGx5ICcgK1xuICAgICAgICBkZXNjcmlwdGlvbiArXG4gICAgICAgIGAgYWZ0ZXIgJHtyZXRyeUNvdW50fSAke3JldHJ5Q291bnQgPT09IDEgPyAnZmFpbHVyZScgOiAnZmFpbHVyZXMnfS5gLFxuICAgIClcbiAgfVxufVxuXG4vKiogQHBhcmFtIHN1Y2Nlc3NEZXNjcmlwdGlvbiBTaG91bGQgYmUgaW4gcGFzdCB0ZW5zZSwgd2l0aG91dCBhbiBpbml0aWFsIGNhcGl0YWwgbGV0dGVyLlxuICogQHBhcmFtIGVycm9yRGVzY3JpcHRpb24gU2hvdWxkIGJlIGluIHByZXNlbnQgdGVuc2UsIHdpdGhvdXQgYW4gaW5pdGlhbCBjYXBpdGFsIGxldHRlci4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmludGluZ0NhbGxiYWNrcyhzdWNjZXNzRGVzY3JpcHRpb246IHN0cmluZywgZXJyb3JEZXNjcmlwdGlvbjogc3RyaW5nKSB7XG4gIHJldHVybiB7XG4gICAgb25CZWZvcmVSZXRyeTogZGVmYXVsdE9uQmVmb3JlUmV0cnkoZXJyb3JEZXNjcmlwdGlvbiksXG4gICAgb25TdWNjZXNzOiBkZWZhdWx0T25TdWNjZXNzKHN1Y2Nlc3NEZXNjcmlwdGlvbiksXG4gICAgb25GYWlsdXJlOiBkZWZhdWx0T25GYWlsdXJlKGVycm9yRGVzY3JpcHRpb24pLFxuICB9IHNhdGlzZmllcyBCYWNrb2ZmT3B0aW9uczx1bmtub3duPlxufVxuIiwgImNvbnN0IF9fdml0ZV9pbmplY3RlZF9vcmlnaW5hbF9kaXJuYW1lID0gXCJDOlxcXFxQcm9qZWN0c1xcXFxlbnNvXFxcXGVuc29cXFxcYXBwXFxcXGd1aTJcXFxcc2hhcmVkXFxcXHV0aWxcIjtjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfZmlsZW5hbWUgPSBcIkM6XFxcXFByb2plY3RzXFxcXGVuc29cXFxcZW5zb1xcXFxhcHBcXFxcZ3VpMlxcXFxzaGFyZWRcXFxcdXRpbFxcXFxuZXQudHNcIjtjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfaW1wb3J0X21ldGFfdXJsID0gXCJmaWxlOi8vL0M6L1Byb2plY3RzL2Vuc28vZW5zby9hcHAvZ3VpMi9zaGFyZWQvdXRpbC9uZXQudHNcIjtpbXBvcnQgdHlwZSB7IE9ic2VydmFibGVWMiB9IGZyb20gJ2xpYjAvb2JzZXJ2YWJsZSdcblxuaW50ZXJmYWNlIERpc3Bvc2FibGUge1xuICBkaXNwb3NlKCk6IHZvaWRcbn1cblxuZXhwb3J0IGNsYXNzIEFib3J0U2NvcGUge1xuICBwcml2YXRlIGN0cmw6IEFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICBnZXQgc2lnbmFsKCkge1xuICAgIHJldHVybiB0aGlzLmN0cmwuc2lnbmFsXG4gIH1cblxuICBkaXNwb3NlKHJlYXNvbj86IHN0cmluZykge1xuICAgIHRoaXMuY3RybC5hYm9ydChyZWFzb24pXG4gIH1cblxuICBoYW5kbGVEaXNwb3NlKGRpc3Bvc2FibGU6IERpc3Bvc2FibGUpIHtcbiAgICB0aGlzLnNpZ25hbC50aHJvd0lmQWJvcnRlZCgpXG4gICAgdGhpcy5vbkFib3J0KGRpc3Bvc2FibGUuZGlzcG9zZS5iaW5kKGRpc3Bvc2FibGUpKVxuICB9XG5cbiAgb25BYm9ydChsaXN0ZW5lcjogKCkgPT4gdm9pZCkge1xuICAgIGlmICh0aGlzLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICBzZXRUaW1lb3V0KGxpc3RlbmVyLCAwKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGxpc3RlbmVyLCB7IG9uY2U6IHRydWUgfSlcbiAgICB9XG4gIH1cblxuICBoYW5kbGVPYnNlcnZlPFxuICAgIEVWRU5UUyBleHRlbmRzIHsgW2tleSBpbiBrZXlvZiBFVkVOVFNdOiAoLi4uYXJnMDogYW55W10pID0+IHZvaWQgfSxcbiAgICBOQU1FIGV4dGVuZHMga2V5b2YgRVZFTlRTICYgc3RyaW5nLFxuICA+KG9ic2VydmFibGU6IE9ic2VydmFibGVWMjxFVkVOVFM+LCBuYW1lOiBOQU1FLCBmOiBFVkVOVFNbTkFNRV0pIHtcbiAgICBpZiAodGhpcy5zaWduYWwuYWJvcnRlZCkgcmV0dXJuXG4gICAgb2JzZXJ2YWJsZS5vbihuYW1lLCBmKVxuICAgIHRoaXMub25BYm9ydCgoKSA9PiBvYnNlcnZhYmxlLm9mZihuYW1lLCBmKSlcbiAgICByZXR1cm4gZlxuICB9XG59XG4iLCAiY29uc3QgX192aXRlX2luamVjdGVkX29yaWdpbmFsX2Rpcm5hbWUgPSBcIkM6XFxcXFByb2plY3RzXFxcXGVuc29cXFxcZW5zb1xcXFxhcHBcXFxcZ3VpMlxcXFx5ZG9jLXNlcnZlclwiO2NvbnN0IF9fdml0ZV9pbmplY3RlZF9vcmlnaW5hbF9maWxlbmFtZSA9IFwiQzpcXFxcUHJvamVjdHNcXFxcZW5zb1xcXFxlbnNvXFxcXGFwcFxcXFxndWkyXFxcXHlkb2Mtc2VydmVyXFxcXGVkaXRzLnRzXCI7Y29uc3QgX192aXRlX2luamVjdGVkX29yaWdpbmFsX2ltcG9ydF9tZXRhX3VybCA9IFwiZmlsZTovLy9DOi9Qcm9qZWN0cy9lbnNvL2Vuc28vYXBwL2d1aTIveWRvYy1zZXJ2ZXIvZWRpdHMudHNcIjsvKipcbiAqIEBmaWxlIEEgbW9kdWxlIHJlc3BvbnNpYmxlIGZvciB0cmFuc2xhdGluZyBmaWxlIGVkaXRzIGJldHdlZW4gdGhlIFlqcyBkb2N1bWVudCB1cGRhdGVzIGFuZCB0aGVcbiAqIExhbmd1YWdlIHNlcnZlciBwcm90b2NvbCBzdHJ1Y3R1cmVzLlxuICovXG5cbmltcG9ydCBkaWZmIGZyb20gJ2Zhc3QtZGlmZidcbmltcG9ydCB0eXBlIHsgTW9kdWxlVXBkYXRlIH0gZnJvbSAnLi4vc2hhcmVkL2FzdCdcbmltcG9ydCB7IE11dGFibGVNb2R1bGUsIHByaW50LCBzcGFuTWFwVG9JZE1hcCB9IGZyb20gJy4uL3NoYXJlZC9hc3QnXG5pbXBvcnQgeyBFbnNvRmlsZVBhcnRzIH0gZnJvbSAnLi4vc2hhcmVkL2Vuc29GaWxlJ1xuaW1wb3J0IHsgVGV4dEVkaXQgfSBmcm9tICcuLi9zaGFyZWQvbGFuZ3VhZ2VTZXJ2ZXJUeXBlcydcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJy4uL3NoYXJlZC91dGlsL2Fzc2VydCdcbmltcG9ydCB7IElkTWFwLCBNb2R1bGVEb2MsIHR5cGUgVmlzdWFsaXphdGlvbk1ldGFkYXRhIH0gZnJvbSAnLi4vc2hhcmVkL3lqc01vZGVsJ1xuaW1wb3J0ICogYXMgZmlsZUZvcm1hdCBmcm9tICcuL2ZpbGVGb3JtYXQnXG5cbi8qKlxuICogVGhlIHNpbXVsYXRlZCBtZXRhZGF0YSBvZiB0aGlzIHNpemUgdGFrZXMgYy5hLiAxIHNlY29uZCBvbiBteSBtYWNoaW5lLiBJdCBzaG91bGQgYmUgcXVpdGVcbiAqIGJlYXJhYmxlLCBldmVuIG9uIHNsb3dlciBtYWNoaW5lcy5cbiAqXG4gKiBGdWxsIGJlbmNobWFyayByZXN1bHRzIChmcm9tIGVkaXRzLmJlbmNoLnRzKTpcbiAqICAgbmFtZSAgICAgICAgICAgICAgICBoeiAgICAgICAgbWluICAgICAgICBtYXggICAgICAgbWVhbiAgICAgICAgcDc1ICAgICAgICBwOTkgICAgICAgcDk5NSAgICAgICBwOTk5ICAgICAgcm1lICBzYW1wbGVzXG4gKiBcdTAwQjcgRGlmZmluZyAxMDAwMCAgIDguNzM3MCAgICAgMTA4LjY2ICAgICAxMzIuOTMgICAgIDExNC40NiAgICAgMTExLjczICAgICAxMzIuOTMgICAgIDEzMi45MyAgICAgMTMyLjkzICBcdTAwQjExMS4yOCUgICAgICAgIDVcbiAqIFx1MDBCNyBEaWZmaW5nIDE1MDAwICAgNC4wNDgzICAgICAyMzkuODIgICAgIDI1Ny45OSAgICAgMjQ3LjAyICAgICAyNTcuOTkgICAgIDI1Ny45OSAgICAgMjU3Ljk5ICAgICAyNTcuOTkgICBcdTAwQjE5LjcxJSAgICAgICAgM1xuICogXHUwMEI3IERpZmZpbmcgMjAwMDAgICAyLjE1NzcgICAgIDQ2Mi40MCAgICAgNDY0LjUyICAgICA0NjMuNDYgICAgIDQ2NC41MiAgICAgNDY0LjUyICAgICA0NjQuNTIgICAgIDQ2NC41MiAgIFx1MDBCMTIuOTAlICAgICAgICAyXG4gKiBcdTAwQjcgRGlmZmluZyAyNTAwMCAgIDEuMzc0NCAgICAgNzI3LjYxICAgICA3MjcuNjEgICAgIDcyNy42MSAgICAgNzI3LjYxICAgICA3MjcuNjEgICAgIDcyNy42MSAgICAgNzI3LjYxICAgXHUwMEIxMC4wMCUgICAgICAgIDFcbiAqIFx1MDBCNyBEaWZmaW5nIDMwMDAwICAgMC45ODUwICAgMSwwMTUuMjUgICAxLDAxNS4yNSAgIDEsMDE1LjI1ICAgMSwwMTUuMjUgICAxLDAxNS4yNSAgIDEsMDE1LjI1ICAgMSwwMTUuMjUgICBcdTAwQjEwLjAwJSAgICAgICAgMVxuICogXHUwMEI3IERpZmZpbmcgMzUwMDAgICAwLjY5MzQgICAxLDQ0Mi4yNyAgIDEsNDQyLjI3ICAgMSw0NDIuMjcgICAxLDQ0Mi4yNyAgIDEsNDQyLjI3ICAgMSw0NDIuMjcgICAxLDQ0Mi4yNyAgIFx1MDBCMTAuMDAlICAgICAgICAxXG4gKiBcdTAwQjcgRGlmZmluZyA0MDAwMCAgIDAuNTE0MSAgIDEsOTQ1LjI0ICAgMSw5NDUuMjQgICAxLDk0NS4yNCAgIDEsOTQ1LjI0ICAgMSw5NDUuMjQgICAxLDk0NS4yNCAgIDEsOTQ1LjI0ICAgXHUwMEIxMC4wMCUgICAgICAgIDFcbiAqIFx1MDBCNyBEaWZmaW5nIDUwMDAwICAgMC4zMzE1ICAgMywwMTYuNTkgICAzLDAxNi41OSAgIDMsMDE2LjU5ICAgMywwMTYuNTkgICAzLDAxNi41OSAgIDMsMDE2LjU5ICAgMywwMTYuNTkgICBcdTAwQjEwLjAwJSAgICAgICAgMVxuICogXHUwMEI3IERpZmZpbmcgNjAwMDAgICAwLjIyNzAgICA0LDQwNS40NiAgIDQsNDA1LjQ2ICAgNCw0MDUuNDYgICA0LDQwNS40NiAgIDQsNDA1LjQ2ICAgNCw0MDUuNDYgICA0LDQwNS40NiAgIFx1MDBCMTAuMDAlICAgICAgICAxXG4gKiBcdTAwQjcgRGlmZmluZyA3MDAwMCAgIDAuMTYwMiAgIDYsMjQwLjUyICAgNiwyNDAuNTIgICA2LDI0MC41MiAgIDYsMjQwLjUyICAgNiwyNDAuNTIgICA2LDI0MC41MiAgIDYsMjQwLjUyICAgXHUwMEIxMC4wMCUgICAgICAgIDFcbiAqIFx1MDBCNyBEaWZmaW5nIDgwMDAwICAgMC4xMjMzICAgOCwxMTAuNTQgICA4LDExMC41NCAgIDgsMTEwLjU0ICAgOCwxMTAuNTQgICA4LDExMC41NCAgIDgsMTEwLjU0ICAgOCwxMTAuNTQgICBcdTAwQjEwLjAwJSAgICAgICAgMVxuICogXHUwMEI3IERpZmZpbmcgOTAwMDAgICAwLjA5NTQgIDEwLDQ4MS40NyAgMTAsNDgxLjQ3ICAxMCw0ODEuNDcgIDEwLDQ4MS40NyAgMTAsNDgxLjQ3ICAxMCw0ODEuNDcgIDEwLDQ4MS40NyAgIFx1MDBCMTAuMDAlICAgICAgICAxXG4gKiBcdTAwQjcgRGlmZmluZyAxMDAwMDAgIDAuMDc4OCAgMTIsNjgzLjQ2ICAxMiw2ODMuNDYgIDEyLDY4My40NiAgMTIsNjgzLjQ2ICAxMiw2ODMuNDYgIDEyLDY4My40NiAgMTIsNjgzLjQ2ICAgXHUwMEIxMC4wMCUgICAgICAgIDFcbiAqIFx1MDBCNyBEaWZmaW5nIDI1MDAwMCAgMC4wMTA3ICA5MywyNTMuOTcgIDkzLDI1My45NyAgOTMsMjUzLjk3ICA5MywyNTMuOTcgIDkzLDI1My45NyAgOTMsMjUzLjk3ICA5MywyNTMuOTcgICBcdTAwQjEwLjAwJSAgICAgICAgMVxuICovXG5jb25zdCBNQVhfU0laRV9GT1JfTk9STUFMX0RJRkYgPSAzMDAwMFxuXG5pbnRlcmZhY2UgQXBwbGllZFVwZGF0ZXMge1xuICBuZXdDb2RlOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgbmV3SWRNYXA6IElkTWFwIHwgdW5kZWZpbmVkXG4gIG5ld01ldGFkYXRhOiBmaWxlRm9ybWF0LklkZU1ldGFkYXRhWydub2RlJ10gfCB1bmRlZmluZWRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5RG9jdW1lbnRVcGRhdGVzKFxuICBkb2M6IE1vZHVsZURvYyxcbiAgc3luY2VkOiBFbnNvRmlsZVBhcnRzLFxuICB1cGRhdGU6IE1vZHVsZVVwZGF0ZSxcbik6IEFwcGxpZWRVcGRhdGVzIHtcbiAgY29uc3QgY29kZUNoYW5nZWQgPSB1cGRhdGUubm9kZXNVcGRhdGVkLnNpemUgfHwgdXBkYXRlLm5vZGVzQWRkZWQuc2l6ZSB8fCB1cGRhdGUubm9kZXNEZWxldGVkLnNpemVcbiAgbGV0IGlkc0NoYW5nZWQgPSBmYWxzZVxuICBsZXQgbWV0YWRhdGFDaGFuZ2VkID0gZmFsc2VcbiAgZm9yIChjb25zdCB7IGNoYW5nZXMgfSBvZiB1cGRhdGUubWV0YWRhdGFVcGRhdGVkKSB7XG4gICAgZm9yIChjb25zdCBba2V5XSBvZiBjaGFuZ2VzKSB7XG4gICAgICBpZiAoa2V5ID09PSAnZXh0ZXJuYWxJZCcpIHtcbiAgICAgICAgaWRzQ2hhbmdlZCA9IHRydWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1ldGFkYXRhQ2hhbmdlZCA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlkc0NoYW5nZWQgJiYgbWV0YWRhdGFDaGFuZ2VkKSBicmVha1xuICB9XG5cbiAgbGV0IG5ld0lkTWFwID0gdW5kZWZpbmVkXG4gIGxldCBuZXdDb2RlID0gdW5kZWZpbmVkXG4gIGxldCBuZXdNZXRhZGF0YSA9IHVuZGVmaW5lZFxuXG4gIGNvbnN0IHN5bmNNb2R1bGUgPSBuZXcgTXV0YWJsZU1vZHVsZShkb2MueWRvYylcbiAgY29uc3Qgcm9vdCA9IHN5bmNNb2R1bGUucm9vdCgpXG4gIGFzc2VydChyb290ICE9IG51bGwpXG4gIGlmIChjb2RlQ2hhbmdlZCB8fCBpZHNDaGFuZ2VkIHx8IHN5bmNlZC5pZE1hcEpzb24gPT0gbnVsbCkge1xuICAgIGNvbnN0IHsgY29kZSwgaW5mbyB9ID0gcHJpbnQocm9vdClcbiAgICBpZiAoY29kZUNoYW5nZWQpIG5ld0NvZGUgPSBjb2RlXG4gICAgbmV3SWRNYXAgPSBzcGFuTWFwVG9JZE1hcChpbmZvKVxuICB9XG4gIGlmIChjb2RlQ2hhbmdlZCB8fCBpZHNDaGFuZ2VkIHx8IG1ldGFkYXRhQ2hhbmdlZCkge1xuICAgIC8vIFVwZGF0ZSB0aGUgbWV0YWRhdGEgb2JqZWN0LlxuICAgIC8vIERlcHRoLWZpcnN0IGtleSBvcmRlciBrZWVwcyBkaWZmcyBzbWFsbC5cbiAgICBuZXdNZXRhZGF0YSA9IHt9IHNhdGlzZmllcyBmaWxlRm9ybWF0LklkZU1ldGFkYXRhWydub2RlJ11cbiAgICByb290LnZpc2l0UmVjdXJzaXZlQXN0KChhc3QpID0+IHtcbiAgICAgIGxldCBwb3MgPSBhc3Qubm9kZU1ldGFkYXRhLmdldCgncG9zaXRpb24nKVxuICAgICAgY29uc3QgdmlzID0gYXN0Lm5vZGVNZXRhZGF0YS5nZXQoJ3Zpc3VhbGl6YXRpb24nKVxuICAgICAgY29uc3QgY29sb3JPdmVycmlkZSA9IGFzdC5ub2RlTWV0YWRhdGEuZ2V0KCdjb2xvck92ZXJyaWRlJylcbiAgICAgIGlmICh2aXMgJiYgIXBvcykgcG9zID0geyB4OiAwLCB5OiAwIH1cbiAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgbmV3TWV0YWRhdGEhW2FzdC5leHRlcm5hbElkXSA9IHtcbiAgICAgICAgICBwb3NpdGlvbjogeyB2ZWN0b3I6IFtNYXRoLnJvdW5kKHBvcy54KSwgTWF0aC5yb3VuZCgtcG9zLnkpXSB9LFxuICAgICAgICAgIHZpc3VhbGl6YXRpb246IHZpcyAmJiB0cmFuc2xhdGVWaXN1YWxpemF0aW9uVG9GaWxlKHZpcyksXG4gICAgICAgICAgY29sb3JPdmVycmlkZSxcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4geyBuZXdDb2RlLCBuZXdJZE1hcCwgbmV3TWV0YWRhdGEgfVxufVxuXG5mdW5jdGlvbiB0cmFuc2xhdGVWaXN1YWxpemF0aW9uVG9GaWxlKFxuICB2aXM6IFZpc3VhbGl6YXRpb25NZXRhZGF0YSxcbik6IGZpbGVGb3JtYXQuVmlzdWFsaXphdGlvbk1ldGFkYXRhIHwgdW5kZWZpbmVkIHtcbiAgbGV0IHByb2plY3QgPSB1bmRlZmluZWRcbiAgc3dpdGNoICh2aXMuaWRlbnRpZmllcj8ubW9kdWxlLmtpbmQpIHtcbiAgICBjYXNlICdCdWlsdGluJzpcbiAgICAgIHByb2plY3QgPSB7IHByb2plY3Q6ICdCdWlsdGluJyB9IGFzIGNvbnN0XG4gICAgICBicmVha1xuICAgIGNhc2UgJ0N1cnJlbnRQcm9qZWN0JzpcbiAgICAgIHByb2plY3QgPSB7IHByb2plY3Q6ICdDdXJyZW50UHJvamVjdCcgfSBhcyBjb25zdFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdMaWJyYXJ5JzpcbiAgICAgIHByb2plY3QgPSB7IHByb2plY3Q6ICdMaWJyYXJ5JywgY29udGVudHM6IHZpcy5pZGVudGlmaWVyLm1vZHVsZS5uYW1lIH0gYXMgY29uc3RcbiAgICAgIGJyZWFrXG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzaG93OiB2aXMudmlzaWJsZSxcbiAgICBmdWxsc2NyZWVuOiB2aXMuZnVsbHNjcmVlbixcbiAgICB3aWR0aDogdmlzLndpZHRoID8/IHVuZGVmaW5lZCxcbiAgICAuLi4ocHJvamVjdCA9PSBudWxsIHx8IHZpcy5pZGVudGlmaWVyID09IG51bGwgP1xuICAgICAge31cbiAgICA6IHtcbiAgICAgICAgcHJvamVjdDogcHJvamVjdCxcbiAgICAgICAgbmFtZTogdmlzLmlkZW50aWZpZXIubmFtZSxcbiAgICAgIH0pLFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2xhdGVWaXN1YWxpemF0aW9uRnJvbUZpbGUoXG4gIHZpczogZmlsZUZvcm1hdC5WaXN1YWxpemF0aW9uTWV0YWRhdGEsXG4pOiBWaXN1YWxpemF0aW9uTWV0YWRhdGEgfCB1bmRlZmluZWQge1xuICBsZXQgbW9kdWxlXG4gIHN3aXRjaCAodmlzLnByb2plY3Q/LnByb2plY3QpIHtcbiAgICBjYXNlICdCdWlsdGluJzpcbiAgICAgIG1vZHVsZSA9IHsga2luZDogJ0J1aWx0aW4nIH0gYXMgY29uc3RcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnQ3VycmVudFByb2plY3QnOlxuICAgICAgbW9kdWxlID0geyBraW5kOiAnQ3VycmVudFByb2plY3QnIH0gYXMgY29uc3RcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnTGlicmFyeSc6XG4gICAgICBtb2R1bGUgPSB7IGtpbmQ6ICdMaWJyYXJ5JywgbmFtZTogdmlzLnByb2plY3QuY29udGVudHMgfSBhcyBjb25zdFxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgbW9kdWxlID0gbnVsbFxuICB9XG4gIHJldHVybiB7XG4gICAgaWRlbnRpZmllcjogbW9kdWxlICYmIHZpcy5uYW1lID8geyBuYW1lOiB2aXMubmFtZSwgbW9kdWxlIH0gOiBudWxsLFxuICAgIHZpc2libGU6IHZpcy5zaG93LFxuICAgIGZ1bGxzY3JlZW46IHZpcy5mdWxsc2NyZWVuID8/IGZhbHNlLFxuICAgIHdpZHRoOiB2aXMud2lkdGggPz8gbnVsbCxcbiAgfVxufVxuXG4vKipcbiAqIEEgc2ltcGxpZmllZCBkaWZmIGFsZ29yaXRobS5cbiAqXG4gKiBUaGUgYGZhc3QtZGlmZmAgcGFja2FnZSB1c2VzIE15ZXJzJyBodHRwczovL25laWwuZnJhc2VyLm5hbWUvd3JpdGluZy9kaWZmL215ZXJzLnBkZiB3aXRoIHNvbWVcbiAqIG9wdGltaXphdGlvbnMgdG8gZ2VuZXJhdGUgbWluaW1hbCBkaWZmLiBVbmZvcnR1bmF0ZWx5LCBldmVudCB0aGlzIGFsZ29yaXRobSBpcyBzdGlsbCB0byBzbG93XG4gKiBmb3Igb3VyIG1ldGFkYXRhLiBUaGVyZWZvcmUgd2UgbmVlZCB0byB1c2UgZmFzdGVyIGFsZ29yaXRobSB3aGljaCB3aWxsIG5vdCBwcm9kdWNlIHRoZW9yZXRpY2FsbHlcbiAqIG1pbmltYWwgZGlmZi5cbiAqXG4gKiBUaGlzIGlzIHF1aWNrIGltcGxlbWVudGF0aW9uIG1ha2luZyBkaWZmIHdoaWNoIGp1c3QgcmVwbGFjZXMgZW50aXJlIHN0cmluZyBleGNlcHQgY29tbW9uIHByZWZpeFxuICogYW5kIHN1ZmZpeC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0dXBpZEZhc3REaWZmKG9sZFN0cmluZzogc3RyaW5nLCBuZXdTdHJpbmc6IHN0cmluZyk6IGRpZmYuRGlmZltdIHtcbiAgY29uc3QgbWluTGVuZ3RoID0gTWF0aC5taW4ob2xkU3RyaW5nLmxlbmd0aCwgbmV3U3RyaW5nLmxlbmd0aClcbiAgbGV0IGNvbW1vblByZWZpeExlbiwgY29tbW9uU3VmZml4TGVuXG4gIGZvciAoY29tbW9uUHJlZml4TGVuID0gMDsgY29tbW9uUHJlZml4TGVuIDwgbWluTGVuZ3RoOyArK2NvbW1vblByZWZpeExlbilcbiAgICBpZiAob2xkU3RyaW5nW2NvbW1vblByZWZpeExlbl0gIT09IG5ld1N0cmluZ1tjb21tb25QcmVmaXhMZW5dKSBicmVha1xuICBpZiAob2xkU3RyaW5nLmxlbmd0aCA9PT0gbmV3U3RyaW5nLmxlbmd0aCAmJiBvbGRTdHJpbmcubGVuZ3RoID09PSBjb21tb25QcmVmaXhMZW4pXG4gICAgcmV0dXJuIFtbMCwgb2xkU3RyaW5nXV1cbiAgZm9yIChjb21tb25TdWZmaXhMZW4gPSAwOyBjb21tb25TdWZmaXhMZW4gPCBtaW5MZW5ndGggLSBjb21tb25QcmVmaXhMZW47ICsrY29tbW9uU3VmZml4TGVuKVxuICAgIGlmIChvbGRTdHJpbmcuYXQoLTEgLSBjb21tb25TdWZmaXhMZW4pICE9PSBuZXdTdHJpbmcuYXQoLTEgLSBjb21tb25TdWZmaXhMZW4pKSBicmVha1xuICBjb25zdCBjb21tb25QcmVmaXggPSBvbGRTdHJpbmcuc3Vic3RyaW5nKDAsIGNvbW1vblByZWZpeExlbilcbiAgY29uc3QgcmVtb3ZlZCA9IG9sZFN0cmluZy5zdWJzdHJpbmcoY29tbW9uUHJlZml4TGVuLCBvbGRTdHJpbmcubGVuZ3RoIC0gY29tbW9uU3VmZml4TGVuKVxuICBjb25zdCBhZGRlZCA9IG5ld1N0cmluZy5zdWJzdHJpbmcoY29tbW9uUHJlZml4TGVuLCBuZXdTdHJpbmcubGVuZ3RoIC0gY29tbW9uU3VmZml4TGVuKVxuICBjb25zdCBjb21tb25TdWZmaXggPSBvbGRTdHJpbmcuc3Vic3RyaW5nKG9sZFN0cmluZy5sZW5ndGggLSBjb21tb25TdWZmaXhMZW4sIG9sZFN0cmluZy5sZW5ndGgpXG4gIHJldHVybiAoY29tbW9uUHJlZml4ID8gKFtbMCwgY29tbW9uUHJlZml4XV0gYXMgZGlmZi5EaWZmW10pIDogW10pXG4gICAgLmNvbmNhdChyZW1vdmVkID8gW1stMSwgcmVtb3ZlZF1dIDogW10pXG4gICAgLmNvbmNhdChhZGRlZCA/IFtbMSwgYWRkZWRdXSA6IFtdKVxuICAgIC5jb25jYXQoY29tbW9uU3VmZml4ID8gW1swLCBjb21tb25TdWZmaXhdXSA6IFtdKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlEaWZmQXNUZXh0RWRpdHMoXG4gIGxpbmVPZmZzZXQ6IG51bWJlcixcbiAgb2xkU3RyaW5nOiBzdHJpbmcsXG4gIG5ld1N0cmluZzogc3RyaW5nLFxuKTogVGV4dEVkaXRbXSB7XG4gIGNvbnN0IGNoYW5nZXMgPVxuICAgIG9sZFN0cmluZy5sZW5ndGggKyBuZXdTdHJpbmcubGVuZ3RoID4gTUFYX1NJWkVfRk9SX05PUk1BTF9ESUZGID9cbiAgICAgIHN0dXBpZEZhc3REaWZmKG9sZFN0cmluZywgbmV3U3RyaW5nKVxuICAgIDogZGlmZihvbGRTdHJpbmcsIG5ld1N0cmluZylcbiAgbGV0IG5ld0luZGV4ID0gMFxuICBsZXQgbGluZU51bSA9IGxpbmVPZmZzZXRcbiAgbGV0IGxpbmVTdGFydElkeCA9IDBcbiAgY29uc3QgZWRpdHMgPSBbXVxuICBmb3IgKGNvbnN0IFtvcCwgdGV4dF0gb2YgY2hhbmdlcykge1xuICAgIGlmIChvcCA9PT0gMSkge1xuICAgICAgY29uc3QgcG9zID0ge1xuICAgICAgICBjaGFyYWN0ZXI6IG5ld0luZGV4IC0gbGluZVN0YXJ0SWR4LFxuICAgICAgICBsaW5lOiBsaW5lTnVtLFxuICAgICAgfVxuICAgICAgZWRpdHMucHVzaCh7IHJhbmdlOiB7IHN0YXJ0OiBwb3MsIGVuZDogcG9zIH0sIHRleHQgfSlcbiAgICAgIGNvbnN0IG51bUxpbmVCcmVha3MgPSAodGV4dC5tYXRjaCgvXFxuL2cpID8/IFtdKS5sZW5ndGhcbiAgICAgIGlmIChudW1MaW5lQnJlYWtzID4gMCkge1xuICAgICAgICBsaW5lTnVtICs9IG51bUxpbmVCcmVha3NcbiAgICAgICAgbGluZVN0YXJ0SWR4ID0gbmV3SW5kZXggKyB0ZXh0Lmxhc3RJbmRleE9mKCdcXG4nKSArIDFcbiAgICAgIH1cbiAgICAgIG5ld0luZGV4ICs9IHRleHQubGVuZ3RoXG4gICAgfSBlbHNlIGlmIChvcCA9PT0gLTEpIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0ge1xuICAgICAgICBjaGFyYWN0ZXI6IG5ld0luZGV4IC0gbGluZVN0YXJ0SWR4LFxuICAgICAgICBsaW5lOiBsaW5lTnVtLFxuICAgICAgfVxuICAgICAgY29uc3QgbnVtTGluZUJyZWFrcyA9ICh0ZXh0Lm1hdGNoKC9cXG4vZykgPz8gW10pLmxlbmd0aFxuICAgICAgY29uc3QgY2hhcmFjdGVyID1cbiAgICAgICAgbnVtTGluZUJyZWFrcyA+IDAgP1xuICAgICAgICAgIHRleHQubGVuZ3RoIC0gKHRleHQubGFzdEluZGV4T2YoJ1xcbicpICsgMSlcbiAgICAgICAgOiBuZXdJbmRleCAtIGxpbmVTdGFydElkeCArIHRleHQubGVuZ3RoXG4gICAgICBjb25zdCBlbmQgPSB7XG4gICAgICAgIGNoYXJhY3RlcixcbiAgICAgICAgbGluZTogbGluZU51bSArIG51bUxpbmVCcmVha3MsXG4gICAgICB9XG4gICAgICBlZGl0cy5wdXNoKHsgcmFuZ2U6IHsgc3RhcnQsIGVuZCB9LCB0ZXh0OiAnJyB9KVxuICAgIH0gZWxzZSBpZiAob3AgPT09IDApIHtcbiAgICAgIGNvbnN0IG51bUxpbmVCcmVha3MgPSAodGV4dC5tYXRjaCgvXFxuL2cpID8/IFtdKS5sZW5ndGhcbiAgICAgIGxpbmVOdW0gKz0gbnVtTGluZUJyZWFrc1xuICAgICAgaWYgKG51bUxpbmVCcmVha3MgPiAwKSB7XG4gICAgICAgIGxpbmVTdGFydElkeCA9IG5ld0luZGV4ICsgdGV4dC5sYXN0SW5kZXhPZignXFxuJykgKyAxXG4gICAgICB9XG4gICAgICBuZXdJbmRleCArPSB0ZXh0Lmxlbmd0aFxuICAgIH1cbiAgfVxuICByZXR1cm4gZWRpdHNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByZXR0eVByaW50RGlmZihmcm9tOiBzdHJpbmcsIHRvOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBjb2xSZXNldCA9ICdcXHgxYlswbSdcbiAgY29uc3QgY29sUmVkID0gJ1xceDFiWzMxbSdcbiAgY29uc3QgY29sR3JlZW4gPSAnXFx4MWJbMzJtJ1xuXG4gIGNvbnN0IGRpZmZzID1cbiAgICBmcm9tLmxlbmd0aCArIHRvLmxlbmd0aCA+IE1BWF9TSVpFX0ZPUl9OT1JNQUxfRElGRiA/IHN0dXBpZEZhc3REaWZmKGZyb20sIHRvKSA6IGRpZmYoZnJvbSwgdG8pXG4gIGlmIChkaWZmcy5sZW5ndGggPT09IDEgJiYgZGlmZnNbMF0hWzBdID09PSAwKSByZXR1cm4gJ05vIGNoYW5nZXMnXG4gIGxldCBjb250ZW50ID0gJydcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaWZmcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IFtvcCwgdGV4dF0gPSBkaWZmc1tpXSFcbiAgICBpZiAob3AgPT09IDEpIHtcbiAgICAgIGNvbnRlbnQgKz0gY29sR3JlZW4gKyB0ZXh0XG4gICAgfSBlbHNlIGlmIChvcCA9PT0gLTEpIHtcbiAgICAgIGNvbnRlbnQgKz0gY29sUmVkICsgdGV4dFxuICAgIH0gZWxzZSBpZiAob3AgPT09IDApIHtcbiAgICAgIGNvbnRlbnQgKz0gY29sUmVzZXRcbiAgICAgIGNvbnN0IG51bU5ld2xpbmVzID0gKHRleHQubWF0Y2goL1xcbi9nKSA/PyBbXSkubGVuZ3RoXG4gICAgICBpZiAobnVtTmV3bGluZXMgPCAyKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gdGV4dFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZmlyc3ROZXdsaW5lID0gdGV4dC5pbmRleE9mKCdcXG4nKVxuICAgICAgICBjb25zdCBsYXN0TmV3bGluZSA9IHRleHQubGFzdEluZGV4T2YoJ1xcbicpXG4gICAgICAgIGNvbnN0IGZpcnN0TGluZSA9IHRleHQuc2xpY2UoMCwgZmlyc3ROZXdsaW5lICsgMSlcbiAgICAgICAgY29uc3QgbGFzdExpbmUgPSB0ZXh0LnNsaWNlKGxhc3ROZXdsaW5lICsgMSlcbiAgICAgICAgY29uc3QgaXNGaXJzdCA9IGkgPT09IDBcbiAgICAgICAgY29uc3QgaXNMYXN0ID0gaSA9PT0gZGlmZnMubGVuZ3RoIC0gMVxuICAgICAgICBpZiAoIWlzRmlyc3QpIGNvbnRlbnQgKz0gZmlyc3RMaW5lXG4gICAgICAgIGlmICghaXNGaXJzdCAmJiAhaXNMYXN0KSBjb250ZW50ICs9ICcuLi5cXG4nXG4gICAgICAgIGlmICghaXNMYXN0KSBjb250ZW50ICs9IGxhc3RMaW5lXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnRlbnQgKz0gY29sUmVzZXRcbiAgcmV0dXJuIGNvbnRlbnRcbn1cblxuaWYgKGltcG9ydC5tZXRhLnZpdGVzdCkge1xuICBjb25zdCB7IHRlc3QsIGV4cGVjdCB9ID0gaW1wb3J0Lm1ldGEudml0ZXN0XG5cbiAgdGVzdC5lYWNoYFxuICAgIG9sZFN0ciAgICAgfCBuZXdTdHIgICAgICB8IGV4cGVjdGVkXG4gICAgJHsnJ30gICAgICB8ICR7J2Zvbyd9ICAgIHwgJHtbWzEsICdmb28nXV19XG4gICAgJHsnZm9vJ30gICB8ICR7Jyd9ICAgICAgIHwgJHtbWy0xLCAnZm9vJ11dfVxuICAgICR7J2Zvbyd9ICAgfCAkeydmb28nfSAgICB8ICR7W1swLCAnZm9vJ11dfVxuICAgICR7J2Zvbyd9ICAgfCAkeydiYXInfSAgICB8ICR7W1stMSwgJ2ZvbyddLCBbMSwgJ2JhciddXX1cbiAgICAkeydhYmFieCd9IHwgJHsnYWNhY3gnfSAgfCAke1tbMCwgJ2EnXSwgWy0xLCAnYmFiJ10sIFsxLCAnY2FjJ10sIFswLCAneCddXX1cbiAgICAkeydheCd9ICAgIHwgJHsnYWNhY3gnfSAgfCAke1tbMCwgJ2EnXSwgWzEsICdjYWMnXSwgWzAsICd4J11dfVxuICAgICR7J2FiYWJ4J30gfCAkeydheCd9ICAgICB8ICR7W1swLCAnYSddLCBbLTEsICdiYWInXSwgWzAsICd4J11dfVxuICAgICR7J2FiYWJ4J30gfCAkeydhYmFjYXgnfSB8ICR7W1swLCAnYWJhJ10sIFstMSwgJ2InXSwgWzEsICdjYSddLCBbMCwgJ3gnXV19XG4gICAgJHsnYXh4eGEnfSB8ICR7J2EnfSAgICAgIHwgJHtbWzAsICdhJ10sIFstMSwgJ3h4eGEnXV19XG4gIGAoJ1N0dXBpZCBkaWZmIG9mICRvbGRTdHIgYW5kICRuZXdTdHInLCAoeyBvbGRTdHIsIG5ld1N0ciwgZXhwZWN0ZWQgfSkgPT4ge1xuICAgIGV4cGVjdChzdHVwaWRGYXN0RGlmZihvbGRTdHIsIG5ld1N0cikpLnRvRXF1YWwoZXhwZWN0ZWQpXG4gIH0pXG59XG4iLCAiY29uc3QgX192aXRlX2luamVjdGVkX29yaWdpbmFsX2Rpcm5hbWUgPSBcIkM6XFxcXFByb2plY3RzXFxcXGVuc29cXFxcZW5zb1xcXFxhcHBcXFxcZ3VpMlxcXFx5ZG9jLXNlcnZlclwiO2NvbnN0IF9fdml0ZV9pbmplY3RlZF9vcmlnaW5hbF9maWxlbmFtZSA9IFwiQzpcXFxcUHJvamVjdHNcXFxcZW5zb1xcXFxlbnNvXFxcXGFwcFxcXFxndWkyXFxcXHlkb2Mtc2VydmVyXFxcXGZpbGVGb3JtYXQudHNcIjtjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfaW1wb3J0X21ldGFfdXJsID0gXCJmaWxlOi8vL0M6L1Byb2plY3RzL2Vuc28vZW5zby9hcHAvZ3VpMi95ZG9jLXNlcnZlci9maWxlRm9ybWF0LnRzXCI7aW1wb3J0ICogYXMganNvbiBmcm9tICdsaWIwL2pzb24nXG5pbXBvcnQgeiBmcm9tICd6b2QnXG5cbmV4cG9ydCB0eXBlIFZlY3RvciA9IHouaW5mZXI8dHlwZW9mIHZlY3Rvcj5cbmV4cG9ydCBjb25zdCB2ZWN0b3IgPSB6LnR1cGxlKFt6Lm51bWJlcigpLCB6Lm51bWJlcigpXSlcblxuY29uc3QgdmlzdWFsaXphdGlvblByb2plY3QgPSB6LmRpc2NyaW1pbmF0ZWRVbmlvbigncHJvamVjdCcsIFtcbiAgei5vYmplY3QoeyBwcm9qZWN0OiB6LmxpdGVyYWwoJ0J1aWx0aW4nKSB9KSxcbiAgei5vYmplY3QoeyBwcm9qZWN0OiB6LmxpdGVyYWwoJ0N1cnJlbnRQcm9qZWN0JykgfSksXG4gIHoub2JqZWN0KHsgcHJvamVjdDogei5saXRlcmFsKCdMaWJyYXJ5JyksIGNvbnRlbnRzOiB6LnN0cmluZygpIH0pLFxuXSlcblxuZXhwb3J0IHR5cGUgVmlzdWFsaXphdGlvbk1ldGFkYXRhID0gei5pbmZlcjx0eXBlb2YgdmlzdWFsaXphdGlvbk1ldGFkYXRhPlxuY29uc3QgdmlzdWFsaXphdGlvbk1ldGFkYXRhID0gelxuICAub2JqZWN0KHtcbiAgICBzaG93OiB6LmJvb2xlYW4oKS5kZWZhdWx0KHRydWUpLFxuICAgIHdpZHRoOiB6Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gICAgZnVsbHNjcmVlbjogei5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICBwcm9qZWN0OiB2aXN1YWxpemF0aW9uUHJvamVjdC5vcHRpb25hbCgpLFxuICAgIG5hbWU6IHouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgfSlcbiAgLnBhc3N0aHJvdWdoKClcblxuZXhwb3J0IHR5cGUgTm9kZU1ldGFkYXRhID0gei5pbmZlcjx0eXBlb2Ygbm9kZU1ldGFkYXRhPlxuZXhwb3J0IGNvbnN0IG5vZGVNZXRhZGF0YSA9IHpcbiAgLm9iamVjdCh7XG4gICAgcG9zaXRpb246IHoub2JqZWN0KHsgdmVjdG9yIH0pLmNhdGNoKChjdHgpID0+IHtcbiAgICAgIHByaW50RXJyb3IoY3R4KVxuICAgICAgcmV0dXJuIHsgdmVjdG9yOiBbMCwgMF0gc2F0aXNmaWVzIFZlY3RvciB9XG4gICAgfSksXG4gICAgdmlzdWFsaXphdGlvbjogdmlzdWFsaXphdGlvbk1ldGFkYXRhLm9wdGlvbmFsKCkuY2F0Y2goKCkgPT4gdW5kZWZpbmVkKSxcbiAgICBjb2xvck92ZXJyaWRlOiB6LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIH0pXG4gIC5wYXNzdGhyb3VnaCgpXG5cbmV4cG9ydCB0eXBlIEltcG9ydE1ldGFkYXRhID0gei5pbmZlcjx0eXBlb2YgaW1wb3J0TWV0YWRhdGE+XG5leHBvcnQgY29uc3QgaW1wb3J0TWV0YWRhdGEgPSB6Lm9iamVjdCh7fSkucGFzc3Rocm91Z2goKVxuXG5leHBvcnQgdHlwZSBJZGVNZXRhZGF0YSA9IHouaW5mZXI8dHlwZW9mIGlkZU1ldGFkYXRhPlxuZXhwb3J0IGNvbnN0IGlkZU1ldGFkYXRhID0gelxuICAub2JqZWN0KHtcbiAgICBub2RlOiB6LnJlY29yZCh6LnN0cmluZygpLnV1aWQoKSwgbm9kZU1ldGFkYXRhKSxcbiAgICBpbXBvcnQ6IHoucmVjb3JkKHouc3RyaW5nKCksIGltcG9ydE1ldGFkYXRhKSxcbiAgfSlcbiAgLnBhc3N0aHJvdWdoKClcbiAgLmRlZmF1bHQoKCkgPT4gZGVmYXVsdE1ldGFkYXRhKCkuaWRlKVxuICAuY2F0Y2goKGN0eCkgPT4ge1xuICAgIHByaW50RXJyb3IoY3R4KVxuICAgIHJldHVybiBkZWZhdWx0TWV0YWRhdGEoKS5pZGVcbiAgfSlcblxuZXhwb3J0IHR5cGUgTWV0YWRhdGEgPSB6LmluZmVyPHR5cGVvZiBtZXRhZGF0YT5cbmV4cG9ydCBjb25zdCBtZXRhZGF0YSA9IHpcbiAgLm9iamVjdCh7XG4gICAgaWRlOiBpZGVNZXRhZGF0YSxcbiAgfSlcbiAgLnBhc3N0aHJvdWdoKClcbiAgLmNhdGNoKChjdHgpID0+IHtcbiAgICBwcmludEVycm9yKGN0eClcbiAgICByZXR1cm4gZGVmYXVsdE1ldGFkYXRhKClcbiAgfSlcblxuZXhwb3J0IHR5cGUgSWRNYXBWYWx1ZSA9IHouaW5mZXI8dHlwZW9mIGlkTWFwVmFsdWU+XG5leHBvcnQgY29uc3QgaWRNYXBWYWx1ZSA9IHoub2JqZWN0KHtcbiAgdmFsdWU6IHoubnVtYmVyKCksXG59KVxuXG5leHBvcnQgdHlwZSBJZE1hcFJhbmdlID0gei5pbmZlcjx0eXBlb2YgaWRNYXBSYW5nZT5cbmV4cG9ydCBjb25zdCBpZE1hcFJhbmdlID0gei5vYmplY3Qoe1xuICBpbmRleDogaWRNYXBWYWx1ZSxcbiAgc2l6ZTogaWRNYXBWYWx1ZSxcbn0pXG5cbmV4cG9ydCB0eXBlIElkTWFwRW50cnkgPSB6LmluZmVyPHR5cGVvZiBpZE1hcEVudHJ5PlxuZXhwb3J0IGNvbnN0IGlkTWFwRW50cnkgPSB6LnR1cGxlKFtpZE1hcFJhbmdlLCB6LnN0cmluZygpLnV1aWQoKV0pXG5cbmV4cG9ydCB0eXBlIElkTWFwID0gei5pbmZlcjx0eXBlb2YgaWRNYXA+XG5leHBvcnQgY29uc3QgaWRNYXAgPSB6LmFycmF5KGlkTWFwRW50cnkpLmNhdGNoKChjdHgpID0+IHtcbiAgcHJpbnRFcnJvcihjdHgpXG4gIHJldHVybiBbXVxufSlcblxuZnVuY3Rpb24gZGVmYXVsdE1ldGFkYXRhKCkge1xuICByZXR1cm4ge1xuICAgIGlkZToge1xuICAgICAgbm9kZToge30sXG4gICAgICBpbXBvcnQ6IHt9LFxuICAgIH0sXG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRFcnJvcihjdHg6IHsgZXJyb3I6IHouWm9kRXJyb3I7IGlucHV0OiBhbnkgfSkge1xuICBjb25zb2xlLmVycm9yKCc9PT0gTUVUQURBVEEgUEFSU0UgRVJST1IgPT09JylcbiAgY29uc29sZS5lcnJvcignRXJyb3I6JywgY3R4LmVycm9yLmlzc3VlcylcbiAgY29uc29sZS5lcnJvcignSW5wdXQ6JywgY3R4LmlucHV0KVxuICBjb25zb2xlLmVycm9yKCc9PT09PT09PT09PT09PT09PT09PT09PT09PT09Jylcbn1cblxuLyoqXG4gKiBQYXJzZXMgdGhlIG1ldGFkYXRhIEpTT04gc3RyaW5nIGlmIHByb3ZpZGVkLiBJZiBwYXJ0cyBvZiB0aGUgbWV0YWRhdGEgYXJlIG1pc3Npbmcgb3IgaW52YWxpZCxcbiAqIHRoZXkgYXJlIGZpbGxlZCBpbiB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEZhaWx1cmUgdG8gcGFyc2UgdGhlIG1ldGFkYXRhIEpTT04gc3RyaW5nIGlzIGxvZ2dlZCB0byB0aGUgY29uc29sZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyeVBhcnNlTWV0YWRhdGFPckZhbGxiYWNrKG1ldGFkYXRhSnNvbjogc3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbCk6IE1ldGFkYXRhIHtcbiAgaWYgKG1ldGFkYXRhSnNvbiA9PSBudWxsKSByZXR1cm4gZGVmYXVsdE1ldGFkYXRhKClcbiAgY29uc3QgcGFyc2VkTWV0YSA9IHRyeVBhcnNlSnNvbihtZXRhZGF0YUpzb24pXG4gIHJldHVybiBtZXRhZGF0YS5wYXJzZShwYXJzZWRNZXRhKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJ5UGFyc2VJZE1hcE9yRmFsbGJhY2soaWRNYXBKc29uOiBzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsKTogSWRNYXAge1xuICBpZiAoaWRNYXBKc29uID09IG51bGwpIHJldHVybiBbXVxuICBjb25zdCBwYXJzZWRJZE1hcCA9IHRyeVBhcnNlSnNvbihpZE1hcEpzb24pXG4gIHJldHVybiBpZE1hcC5wYXJzZShwYXJzZWRJZE1hcClcbn1cblxuZnVuY3Rpb24gdHJ5UGFyc2VKc29uKGpzb25TdHJpbmc6IHN0cmluZykge1xuICB0cnkge1xuICAgIHJldHVybiBqc29uLnBhcnNlKGpzb25TdHJpbmcpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcGFyc2UgbWV0YWRhdGEgSlNPTjonKVxuICAgIGNvbnNvbGUuZXJyb3IoZSlcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG4iLCAiY29uc3QgX192aXRlX2luamVjdGVkX29yaWdpbmFsX2Rpcm5hbWUgPSBcIkM6XFxcXFByb2plY3RzXFxcXGVuc29cXFxcZW5zb1xcXFxhcHBcXFxcZ3VpMlxcXFx5ZG9jLXNlcnZlclwiO2NvbnN0IF9fdml0ZV9pbmplY3RlZF9vcmlnaW5hbF9maWxlbmFtZSA9IFwiQzpcXFxcUHJvamVjdHNcXFxcZW5zb1xcXFxlbnNvXFxcXGFwcFxcXFxndWkyXFxcXHlkb2Mtc2VydmVyXFxcXHNlcmlhbGl6YXRpb24udHNcIjtjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfaW1wb3J0X21ldGFfdXJsID0gXCJmaWxlOi8vL0M6L1Byb2plY3RzL2Vuc28vZW5zby9hcHAvZ3VpMi95ZG9jLXNlcnZlci9zZXJpYWxpemF0aW9uLnRzXCI7LyoqIFRyYW5zbGF0aW9uIG9mIGB5anNNb2RlbGAgdHlwZXMgdG8gYW5kIGZyb20gdGhlIGBmaWxlRm9ybWF0YCByZXByZXNlbnRhdGlvbi4gKi9cblxuaW1wb3J0ICogYXMganNvbiBmcm9tICdsaWIwL2pzb24nXG5pbXBvcnQgeyBFeHRlcm5hbElkLCBJZE1hcCwgc291cmNlUmFuZ2VGcm9tS2V5IH0gZnJvbSAnLi4vc2hhcmVkL3lqc01vZGVsJ1xuaW1wb3J0ICogYXMgZmlsZUZvcm1hdCBmcm9tICcuL2ZpbGVGb3JtYXQnXG5cbmV4cG9ydCBmdW5jdGlvbiBkZXNlcmlhbGl6ZUlkTWFwKGlkTWFwSnNvbjogc3RyaW5nKSB7XG4gIGNvbnN0IGlkTWFwTWV0YSA9IGZpbGVGb3JtYXQudHJ5UGFyc2VJZE1hcE9yRmFsbGJhY2soaWRNYXBKc29uKVxuICBjb25zdCBpZE1hcCA9IG5ldyBJZE1hcCgpXG4gIGZvciAoY29uc3QgW3sgaW5kZXgsIHNpemUgfSwgaWRdIG9mIGlkTWFwTWV0YSkge1xuICAgIGNvbnN0IHJhbmdlID0gW2luZGV4LnZhbHVlLCBpbmRleC52YWx1ZSArIHNpemUudmFsdWVdXG4gICAgaWYgKHR5cGVvZiByYW5nZVswXSAhPT0gJ251bWJlcicgfHwgdHlwZW9mIHJhbmdlWzFdICE9PSAnbnVtYmVyJykge1xuICAgICAgY29uc29sZS5lcnJvcihgSW52YWxpZCByYW5nZSBmb3IgaWQgJHtpZH06YCwgcmFuZ2UpXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZE1hcC5pbnNlcnRLbm93bklkKFtpbmRleC52YWx1ZSwgaW5kZXgudmFsdWUgKyBzaXplLnZhbHVlXSwgaWQgYXMgRXh0ZXJuYWxJZClcbiAgfVxuICByZXR1cm4gaWRNYXBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZUlkTWFwKG1hcDogSWRNYXApOiBzdHJpbmcge1xuICBtYXAudmFsaWRhdGUoKVxuICByZXR1cm4ganNvbi5zdHJpbmdpZnkoaWRNYXBUb0FycmF5KG1hcCkpXG59XG5cbmZ1bmN0aW9uIGlkTWFwVG9BcnJheShtYXA6IElkTWFwKTogZmlsZUZvcm1hdC5JZE1hcEVudHJ5W10ge1xuICBjb25zdCBlbnRyaWVzOiBmaWxlRm9ybWF0LklkTWFwRW50cnlbXSA9IFtdXG4gIG1hcC5lbnRyaWVzKCkuZm9yRWFjaCgoW3JhbmdlQnVmZmVyLCBpZF0pID0+IHtcbiAgICBjb25zdCBkZWNvZGVkID0gc291cmNlUmFuZ2VGcm9tS2V5KHJhbmdlQnVmZmVyKVxuICAgIGNvbnN0IGluZGV4ID0gZGVjb2RlZFswXVxuICAgIGNvbnN0IGVuZEluZGV4ID0gZGVjb2RlZFsxXVxuICAgIGlmIChpbmRleCA9PSBudWxsIHx8IGVuZEluZGV4ID09IG51bGwpIHJldHVyblxuICAgIGNvbnN0IHNpemUgPSBlbmRJbmRleCAtIGluZGV4XG4gICAgZW50cmllcy5wdXNoKFt7IGluZGV4OiB7IHZhbHVlOiBpbmRleCB9LCBzaXplOiB7IHZhbHVlOiBzaXplIH0gfSwgaWRdKVxuICB9KVxuICBlbnRyaWVzLnNvcnQoaWRNYXBDbXApXG4gIHJldHVybiBlbnRyaWVzXG59XG5cbmZ1bmN0aW9uIGlkTWFwQ21wKGE6IGZpbGVGb3JtYXQuSWRNYXBFbnRyeSwgYjogZmlsZUZvcm1hdC5JZE1hcEVudHJ5KSB7XG4gIGNvbnN0IHZhbDEgPSBhWzBdPy5pbmRleD8udmFsdWUgPz8gMFxuICBjb25zdCB2YWwyID0gYlswXT8uaW5kZXg/LnZhbHVlID8/IDBcbiAgaWYgKHZhbDEgPT09IHZhbDIpIHtcbiAgICBjb25zdCBzaXplMSA9IGFbMF0/LnNpemUudmFsdWUgPz8gMFxuICAgIGNvbnN0IHNpemUyID0gYlswXT8uc2l6ZS52YWx1ZSA/PyAwXG4gICAgcmV0dXJuIHNpemUxIC0gc2l6ZTJcbiAgfVxuICByZXR1cm4gdmFsMSAtIHZhbDJcbn1cbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7O0FBU0EsWUFBWSxZQUFZO0FBQ3hCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxnQkFBZ0I7QUFHNUIsWUFBWSxTQUFTO0FBRXJCLFlBQVksWUFBWTtBQUN4QixZQUFZLGdCQUFnQjtBQW1INUIsZUFBc0IsYUFDbEIsUUFDQSxXQUNBLE9BQXNCLE1BQ1A7QUFDZixnQkFBYyxxQkFBcUI7QUFDbkMsU0FBTyxJQUFJLGdDQUFnQyxRQUFRLE9BQU8sUUFBUSxJQUFJLE1BQU0sRUFBRSxHQUFHO0FBQ2pGLFFBQU0sYUFBYSxzQkFBc0IsUUFBUSxXQUFXLFNBQVM7QUFDckUsRUFBRyxhQUFVLFlBQVksRUFBRSxXQUFXLEtBQUssQ0FBQztBQUM1QyxRQUFNLElBQUksUUFBYyxDQUFBQSxhQUFXO0FBQy9CLFdBQU8sS0FBUyxZQUFRLEVBQUUsS0FBSyxXQUFXLENBQUMsQ0FBQyxFQUFFLEdBQUcsVUFBVUEsUUFBTztBQUFBLEVBQ3RFLENBQUM7QUFDRCxRQUFNLFVBQWEsZUFBWSxVQUFVO0FBQ3pDLFFBQU0sYUFBYSxRQUFRLENBQUM7QUFHNUIsTUFBSSxRQUFRLFdBQVcsS0FBSyxjQUFjLE1BQU07QUFDNUMsUUFBTyxZQUFvQixnQkFBSyxZQUFZLFVBQVUsQ0FBQyxFQUFFLFlBQVksR0FBRztBQUNwRSxZQUFNLHlCQUNGLGFBQWEsSUFBVyxrQkFBVyxFQUFFLE1BQU0sR0FBRyxFQUFF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QUEsSUFDaEI7QUFBQSxJQUNBLFFBQVE7QUFBQSxNQUNOLGdCQUFnQjtBQUFBLElBQ2xCO0FBQUEsRUFDRixDQUFDO0FBQ0g7IiwKICAibmFtZXMiOiBbInJlc29sdmUiLCAicGF0aCIsICJtZXRhZGF0YSIsICJmcyIsICJvcyIsICJ0YXIiLCAiY29tbW9uIiwgInJlc3VsdCIsICJzdGF0IiwgIm1ldGFkYXRhIiwgInJlc29sdmUiLCAiRmlsZVN5c3RlbUVudHJ5VHlwZSIsICJmaWxlVVJMVG9QYXRoIiwgImRlZmluZUNvbmZpZyIsICJwYXJzZSIsICJwdHIiLCAiX192aXRlX2luamVjdGVkX29yaWdpbmFsX2ltcG9ydF9tZXRhX3VybCIsICJwYXRoIiwgImZzIiwgImZpbGVVUkxUb1BhdGgiLCAiWSIsICJPYnNlcnZhYmxlVjIiLCAianNvbiIsICJtYXAiLCAiT2JzZXJ2YWJsZVYyIiwgInJhbmRvbSIsICJZIiwgInJhbmRvbSIsICJjdHgiLCAiYWxsS2V5cyIsICJ2aWV3IiwgImFkZHJlc3MiLCAib2Zmc2V0IiwgIlRyZWUiLCAiVHlwZSIsICJJbnZhbGlkIiwgIkJvZHlCbG9jayIsICJJZGVudCIsICJOdW1iZXIiLCAiV2lsZGNhcmQiLCAiVGV4dExpdGVyYWwiLCAiQXBwIiwgIk9wckFwcCIsICJVbmFyeU9wckFwcCIsICJBc3NpZ25tZW50IiwgIkZ1bmN0aW9uIiwgIkltcG9ydCIsICJHcm91cCIsICJBcnJheSIsICJEb2N1bWVudGVkIiwgIkJhc2UiLCAiVG9rZW4iLCAiVGV4dEVsZW1lbnQiLCAiYXN0IiwgInJhbmRvbSIsICJZIiwgIm1ldGFkYXRhIiwgIm1hcCIsICJUb2tlbiIsICJuYW1lU3BlY2lmaWNhdGlvbiIsICJ0cmVlIiwgIlRva2VuIiwgImxlbmd0aCIsICJpZE1hcCIsICJzcGFuIiwgInBhcnNlIiwgImZpeGVzIiwgImFzdCIsICJwYXJlbnRJZCIsICJtZXRhZGF0YSIsICJwYXJlbnRJZCIsICJwYXJzZSIsICJNdXRhYmxlQXN0IiwgIm1hcCIsICJuZXdWYWx1ZSIsICJUb2tlbiIsICJuYW1lU3BlY2lmaWNhdGlvbiIsICJwYXRoIiwgIk11dGFibGVBc3QiLCAiVG9rZW4iLCAicGFyc2UiLCAicGF0aCIsICJzZWdtZW50IiwgInBhcmVudElkIiwgIk11dGFibGVJbnZhbGlkIiwgIm5hbWUiLCAibWFwIiwgIm1hcCIsICJUb2tlbiIsICJUb2tlbiIsICJ1dWlkdjQiLCAicGF0aCIsICJFcnJvckNvZGUiLCAidXVpZHY0IiwgInBhdGgiLCAib2JqZWN0IiwgImRpZmYiLCAiZGlmZiIsICJ6IiwgInoiLCAianNvbiIsICJpZE1hcCIsICJtYXAiLCAicGF0aCIsICJMc1N5bmNTdGF0ZSIsICJPYnNlcnZhYmxlVjIiLCAicGF0aCIsICJtZXRhZGF0YSIsICJpZE1hcCIsICJyZXN1bHQiLCAiZG9jTmFtZSIsICJPYnNlcnZhYmxlVjIiLCAiZW5jb2RlciIsICJwYXJzZSIsICJkb2NOYW1lIiwgIl9fdml0ZV9pbmplY3RlZF9vcmlnaW5hbF9pbXBvcnRfbWV0YV91cmwiLCAiX192aXRlX2luamVjdGVkX29yaWdpbmFsX2ltcG9ydF9tZXRhX3VybCIsICJkZWZpbmVDb25maWciLCAiZmlsZVVSTFRvUGF0aCJdCn0K
