---
layout: developer-doc
title: AST Generation
category: parser
tags: [parser, ast]
order: 9
---

# AST Generation

The single source of truth for the AST is its Rust implementation. Therefore, in
order to not get out of sync, the Scala AST implementation is generated from it
during compilation along with JNI bindings for calling its construtors directly
from Rust.

<!-- MarkdownTOC levels="2,3" autolink="true" -->

- [Scala AST](#scala-ast)
- [Scala Bindings](#scala-bindings)
- [Constructor API](#constructor-api)

<!-- /MarkdownTOC -->

## Scala AST 

The Scala AST implementation is generated during compilation directly from the Rust ast source file.

The command for generating the Scala ast and storing it in the file
`foo/ast.scala` is following:
`cargo run -p ast -- --generate-scala-ast foo/ast.scala`.

Since there isn't 1:1 mapping between Rust and Scala, only a subset of Rust's
structures is supported. These are follows.


```
u8                                  => Byte,
i16 | i8                            => Short,
i32                                 => Int,
i64                                 => Long,
f32                                 => Float,
f64                                 => Double,
Vec                                 => ArrayBuffer,
Uuid                                => UUID,
String                              => String,
mod foo { .. }                      => object Foo { .. }
struct Foo<X> { x: X<z::Y>, .. }    => case class Foo[X](x: X[Z.Y], ..)
enum Foo{ Bar{x:X}, Baz{y:Y, z:Z} } => {
    sealed trait Foo
    case class Bar(x:X) extends Foo
    case class Baz(y:Y, z:Z) extends Foo
}
```

Enums with unnamed fields have the following special conversion rule:


```
enum Enum { Foo(x::Foo), Bar(x::Bar), Baz(y::Baz) }

mod x {
    pub struct Foo { .. }
    pub struct Bar { .. }
}

mod y {
    pub struct Baz { .. }
}
```

Becomes:

```
sealed trait Enum

object X {
    sealed trait X extends Enum
    case class Foo( .. ) extends X
    case class Bar( .. ) extends X
}

object Y {
    sealed trait Y extends Enum
    case class Baz( .. ) extends Y
}
```

Note that in contrast to Rust, Scala doesn't support types outside objects.
Therefore, the Scala AST is wrapped inside additional `object Ast { .. }`.

## Scala Bindings

The Rust Parser has the ability to instantiate Scala AST directly during parsing.
The AST constructors are available trough Java Native Interface (JNI) bindings.
These bindings are autogenerated for every AST node during compilation and accessible
from `ast::api`. 

Each AST constructor is wrapped in `ast::ffi::Object`, and stored in struct 
`ast::api::Scala`, with fields corresponding to the constructor name:

```rust
pub enum Shape { Num(num::Number), App(app::App<Shape>) }
pub mod num {
    pub enum Number { Int{num:i64}, Real{num:f64} }
}
pub mod app {
    pub struct App<Ast>{fun:Box<Ast>, arg:Box<super::Shape>}
}
```

Becomes:

```rust
use crate::ffi::Object;
use crate::ffi::StdLib; 
use jni::JNIEnv;

pub struct Scala<'a> {
    pub env  : &'a JNIEnv<'a>,
    pub lib  : StdLib<'a>,
    pub int  : Object<'a>,
    pub real : Object<'a>,
    pub app  : Object<'a>,
}

impl<'a> Scala<'a> {
    pub fn new(env:&'a JNIEnv<'a>) -> Self {
        Self {
            env,
            lib  : StdLib::new(&env),
            int  : Object::new("org/enso/ast/Ast$Num$Int",  "(J)V"),
            real : Object::new("org/enso/ast/Ast$Num$Real", "(F)V"),
            app  : Object::new("org/enso/ast/Ast$App$App",  "(Ljava/lang/Object;Lorg/enso/ast/Ast$Shape;)V"),
        }
    }       
}
```

This struct exposes a low level type-unsafe API for instantiating 
Scala AST. As an example the Scala`Ast.Num.Int(10)` would be constructed by 
`Scala::new(&env).int.init(&[10.into()])`. However, use of this
API is discoureged. Instead, you should use the high-level
[Constructor API](#constructor-api).


## Constructor API 

WIP WIP WIP


