---
layout: developer-doc
title: AST Generation
category: parser
tags: [parser, ast]
order: 9
---

# AST Generation

The single source of truth for the AST is its Rust implementation. Therefore, in
order to not get out of sync, the Scala AST implementation is generated from it
during compilation along with JNI bindings for calling its construtors directly
from Rust.

<!-- MarkdownTOC levels="2,3" autolink="true" -->

- [Scala AST](#scala-ast)
- [Scala Bindings](#scala-bindings)
- [Constructor API](#constructor-api)

<!-- /MarkdownTOC -->

## Scala AST

The Scala AST implementation is generated during compilation directly from the
Rust ast source file.

The command for generating the Scala ast and storing it in the file
`foo/ast.scala` is following:
`cargo run -p ast -- --generate-scala-ast foo/ast.scala`.

Since there isn't 1:1 mapping between Rust and Scala, only a subset of Rust's
structures is supported. These are follows.

```
u8                                  => Byte,
i16 | i8                            => Short,
i32                                 => Int,
i64                                 => Long,
f32                                 => Float,
f64                                 => Double,
Vec                                 => ArrayBuffer,
Uuid                                => UUID,
String                              => String,
mod foo { .. }                      => object Foo { .. }
struct Foo<X> { x: X<z::Y>, .. }    => case class Foo[X](x: X[Z.Y], ..)
enum Foo{ Bar{x:X}, Baz{y:Y, z:Z} } => {
    sealed trait Foo
    case class Bar(x:X) extends Foo
    case class Baz(y:Y, z:Z) extends Foo
}
```

Enums with unnamed fields have the following special conversion rule:

```
enum Enum { Foo(x::Foo), Bar(x::Bar), Baz(y::Baz) }

mod x {
    pub struct Foo { .. }
    pub struct Bar { .. }
}

mod y {
    pub struct Baz { .. }
}
```

Becomes:

```
sealed trait Enum

object X {
    sealed trait X extends Enum
    case class Foo( .. ) extends X
    case class Bar( .. ) extends X
}

object Y {
    sealed trait Y extends Enum
    case class Baz( .. ) extends Y
}
```

Note that in contrast to Rust, Scala doesn't support types outside objects.
Therefore, the Scala AST is wrapped inside additional `object Ast { .. }`.

## Scala Bindings

The Rust Parser has the ability to instantiate Scala AST directly during
parsing. The AST constructors are available trough Java Native Interface (JNI)
bindings. These bindings are autogenerated for every AST node during compilation
and accessible from `ast::api`.

Each AST constructor is wrapped in `ast::ffi::Object`, and stored in struct
`ast::api::Scala`, with fields corresponding to the constructor name:

```rust
pub enum Shape { Num(num::Number), App(app::App<Shape>) }
pub mod num {
    pub enum Number { Int{num:i64}, Real{num:f64} }
}
pub mod app {
    pub struct App<Ast>{fun:Box<Ast>, arg:Box<super::Shape>}
}
```

Becomes:

```rust
use crate::ffi::Object;
use crate::ffi::StdLib;
use jni::JNIEnv;

pub struct Scala<'a> {
    pub env  : &'a JNIEnv<'a>,
    pub lib  : StdLib<'a>,
    pub int  : Object<'a>,
    pub real : Object<'a>,
    pub app  : Object<'a>,
}

impl<'a> Scala<'a> {
    pub fn new(env:&'a JNIEnv<'a>) -> Self {
        Self {
            env,
            lib  : StdLib::new(&env),
            int  : Object::new("org/enso/ast/Ast$Num$Int",  "(J)V"),
            real : Object::new("org/enso/ast/Ast$Num$Real", "(F)V"),
            app  : Object::new("org/enso/ast/Ast$App$App",  
                "(Ljava/lang/Object;Lorg/enso/ast/Ast$Shape;)V"
            ),
        }
    }
}
```

This struct exposes a low level type-unsafe API for instantiating the Scala AST.
As an example the Scala`Ast.Num.Int(10)` would be constructed by
`Scala::new(&env).int.init(&[10.into()])`. However, use of this API is
discoureged. Instead, you should use the high-level
[Constructor API](#constructor-api).

## Constructor API

This is a high level constructor API autogenerated from the Rust AST definition.
The interface is defined by the trait `ast::api::Api` and implemented by the
structs `ast::api::Scala` and `ast::api::Rust`. It presents a uniform way to
instantiate both the Rust and Scala AST by a single function:

```rust
use ast::api;
use jni::JNIEnv;

pub fn build<Api:api::Api>(api:&Api) -> Api::AstShape { .. }

pub fn main(env:JNIEnv) {
    let scala_ast = build(api::Scala::new(&env));
    let rust_ast  = build(api::Rust);
}
```

The API tries to follow the AST constructors as close to possible, but some
modifications had to be made due to the trait limitations:

- All types are moved into the same scope.
- Types parameters are monomorphized. (This won't be necessary with GAT.)

To give you a sense what that means:

```rust
pub enum Shape { Num(num::Number), App(app::App<Shape>) }

pub mod num {
    pub enum Number { Int{num:i64}, Real{num:f64} }
}
pub mod app {
    pub struct App<T>{fun:Box<T>, arg:Box<Shape> }
}
```

Becomes:

```rust
pub trait Api {
    type Shape;
    type Number;
    /// The AST Node app::App<Shape>.
    type AppShape;

    fn shape_num   (&self, variant:Self::Number)        -> Self::Shape;
    fn shape_app   (&self, variant:Self::App)           -> Self::Shape;
    fn number_int  (&self, num:i64)                     -> Self::Number;
    fn number_real (&self, num:f64)                     -> Self::Number;
    fn app_shape
    (&self, fun:Box<Self::Shape>, arg:Box<Self::Shape>) -> Self::AppShape;
}
```

The precise rules for structs are following:

```
struct A(i32)                => type A; fn a(&self, val0:i32) -> Self::A;
struct B<T>{t:T}             => .. no output ..
struct C<T>{t:T, b:B<A>, ..} => type BA; fn ba(&self, t:Self::A) -> Self::BA;
```

The rules for enums are the same, except one type can have multiple
constructors:

```
enum Foo { A{..}, B{..} } => {
    type Foo;
    fn foo_a(&self, ..) -> Self::Foo;
    fn foo_b(&self, ..) -> Self::Foo;
}
```

Note that builtin types (types that are not defined in `ast.rs`) are left intact 
(they do not introduce an additional associated type). Therefore, they need
to implement the trait `ast::ffi::ToJValue` to enable the autogenerated
[Scala Bindings](#scala-bindings) to convert those types to correct JNI values.
