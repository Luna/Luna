{-# LANGUAGE UndecidableInstances      #-}
{-# LANGUAGE OverloadedStrings         #-}
{-# LANGUAGE NoMonomorphismRestriction #-}
{-# LANGUAGE FunctionalDependencies    #-}
{-# LANGUAGE GADTs                     #-}


module Data.Text.CodeBuilder.Builder2 where

import Prelude ()
import Prologue_old

-- import qualified Data.Text.CodeBuilder.Tok as Tok
-- import           Data.Text.CodeBuilder.Tok (Tok(Tok), Prec, doc, precParens)
-- import qualified Data.Text.CodeBuilder.Doc as Doc
-- import           Data.Text.CodeBuilder.Doc (Doc)
-- import qualified Data.Text.Lazy            as Text
-- import qualified Data.Text.Lazy.Builder    as Text
-- import qualified Language.Symbol.Operator.Assoc as Assoc
-- import           Language.Symbol.Operator.Assoc (Assoc)
--
-- import Control.Monad.State hiding (join)
--
-- type family Transformer (m :: * -> *) :: * -> * where
--     Transformer (t m) = m
--
--
-- -------------------------
-- -- === CodeBuilder === --
-- -------------------------
--
-- -- === Definition === --
--
-- newtype CodeBuilderT m a = CodeBuilderT (StateT (Style m) m a) deriving (Functor, Applicative, Alternative)
--
--
-- -- === MonadTokBuilder === --
--
-- class Monad m => MonadCodeBuilder m where
--     type family Style m :: *
--     getStyle :: m (Style m)
--     putStyle :: Style m -> m ()
--
--     -- defaults
--     type instance Style m = Style (Transformer m)
--     default getStyle :: MonadCodeBuilderTrans m t n => m (Style m)
--     default putStyle :: MonadCodeBuilderTrans m t n => Style m -> m ()
--     getStyle = lift   getStyle
--     putStyle = lift . putStyle
--
-- type MonadCodeBuilderTrans m t n = (m ~ t n, Style (t n) ~ Style n, MonadCodeBuilder n, MonadTrans t)
--
--
-- -- === Running === --
--
-- evalCodeBuilderT :: Monad m => CodeBuilderT m a -> Style m -> m a
-- evalCodeBuilderT = evalStateT . unwrap
--
--
-- -- === Instances === --
--
-- instance Monad m => Monad (CodeBuilderT m) where
--     a >>= f = wrap $ unwrap a >>= unwrap . f
--
-- instance MonadTrans CodeBuilderT where
--     lift = wrap . lift
--
-- makeWrapped ''CodeBuilderT
--
--
--
--
-- class Generator style a where
--     render :: style -> a -> Tok

--
--
-- data SimpleStyle = SimpleStyle deriving (Show)
--
-- instance {-# OVERLAPPABLE #-} (s ~ SimpleStyle) => Show (Builder s Tok) where
--     show = Text.unpack . toLazyText . renderCode SimpleStyle
--
--
-- ----------------------------------------------------------------------
-- -- Render styles
-- ----------------------------------------------------------------------
--
-- renderStyled :: (MonadTokBuilder s m, Render s a) => a -> m Tok
-- renderStyled p = do
--     s <- getStyle
--     return $ render s p
--
--
-- class Render style a where
--     render :: style -> a -> Tok
--
--
-- renderCode :: s -> Builder s Tok -> Text.Builder
-- renderCode style f = Doc.render . view doc $ runBuilder f style
--
-- renderStr :: s -> Builder s Tok -> String
-- renderStr s = Text.unpack . toLazyText . renderCode s
--
-- ----------------------------------------------------------------------
-- -- Combinators
-- ----------------------------------------------------------------------
--
-- tok :: Prec -> Doc -> Builder s Tok
-- tok p d = pure $ Tok p d
--
-- parensed, bracked, braced, sbox, weak :: Builder s Tok -> Builder s Tok
-- parensed = fmap Tok.parensed
-- bracked  = fmap Tok.bracked
-- braced   = fmap Tok.braced
-- sbox     = fmap Tok.sbox
-- weak     = fmap Tok.weak
--
-- appWith :: Doc -> Assoc -> Prec -> Builder s Tok -> Builder s Tok -> Builder s Tok
-- appWith sep assoc aprec mbase marg = do
--     base <- mbase
--     arg  <- marg
--     return $ case assoc of
--         Assoc.Left  -> Tok aprec $ base^.doc <> sep <> precParens aprec arg
--         Assoc.Right -> Tok aprec $ precParens aprec base <> sep <> arg^.doc
--
-- app :: Builder s Tok -> Builder s Tok -> Builder s Tok
-- app = appWith " " Assoc.Left 10
--
-- apps :: Builder s Tok -> [Builder s Tok] -> Builder s Tok
-- apps = foldl app
--
-- ifx :: Builder s Tok -> Builder s Tok -> Builder s Tok -> Builder s Tok
-- ifx ma ml mr = do
--     Tok prec d <- ma
--     l <- ml
--     r <- mr
--     return . Tok prec $ precParens prec l <> " " <> d <> " " <> precParens prec r
--
-- tuple, list :: [Builder s Tok] -> Builder s Tok
-- tuple items = parensed $ fmap (intercalate ", ") $ sequence items
-- list  items = bracked  $ fmap (intercalate ", ") $ sequence items
--
-- (<+>) = app
--
-- ----------------------------------------------------------------------
-- -- Instances
-- ----------------------------------------------------------------------
--
-- instance MonadTokBuilder s (Builder s) where
--     getStyle = Builder $ get
--     putStyle = Builder . put
--
-- instance IsString a => IsString (Builder s a) where
--     fromString = pure . fromString
--
-- instance Convertible t a => Convertible t (Builder s a) where
--     convert = pure . convert
--
-- instance Monoid a => Monoid (Builder s a) where
--     mempty        = return mempty
--     a `mappend` b = do
--         va <- a
--         vb <- b
--         return $ va <> vb
