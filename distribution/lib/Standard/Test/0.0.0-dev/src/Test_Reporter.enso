private

from Standard.Base import all
import Standard.Base.Errors.Illegal_Argument.Illegal_Argument
import Standard.Base.Runtime.Context
import Standard.Base.Runtime.Ref.Ref
from Standard.Base.Logging import all
from Standard.Base.Runtime import assert

import project.Group.Group
import project.Internal.Stack_Trace_Helpers
import project.Spec_Result.Spec_Result
import project.Suite_Config.Suite_Config
import project.Test.Test
import project.Test_Result.Test_Result

polyglot java import java.lang.IllegalArgumentException
polyglot java import java.lang.StringBuilder
polyglot java import java.lang.System as Java_System

## PRIVATE
   Write the JUnit XML header.
wrap_junit_testsuites : Suite_Config -> (StringBuilder|Nothing) -> Any -> Nothing
wrap_junit_testsuites config builder ~action =
    if config.should_output_junit then
        builder.append '<?xml version="1.0" encoding="UTF-8"?>\n'
        builder.append '<testsuites>\n'

    result = action

    if config.should_output_junit then
        builder.append '</testsuites>\n'

        Context.Output.with_enabled <|
            config.output_path.parent.create_directory
            builder.toString.write config.output_path

    result


red text =
    '\u001b[31;1m' + text + '\u001b[0m'

green text =
    '\u001b[32;1m' + text + '\u001b[0m'

highlighted text =
    '\u001b[1;1m' + text + '\u001b[0m'

grey text =
    '\u001b[90m' + text + '\u001b[0m'

maybe_red_text (text : Text) (config : Suite_Config) =
    if config.use_ansi_colors then (red text) else text

maybe_green_text (text : Text) (config : Suite_Config) =
    if config.use_ansi_colors then (green text) else text

maybe_highlighted_text (text : Text) (config : Suite_Config) =
    if config.use_ansi_colors then (highlighted text) else text

maybe_grey_text (text : Text) (config : Suite_Config) =
    if config.use_ansi_colors then (grey text) else text

## Print result for a single Spec run
print_single_result : Test_Result -> Suite_Config -> Nothing
print_single_result (test_result : Test_Result) (config : Suite_Config) =
    times_suffix =
        times = test_result.time_taken.total_milliseconds.to_text + "ms"
        "[" + times + "]"

    decorate_stack_trace = case config.use_ansi_colors && config.caller_project_root.is_nothing.not of
        True -> Stack_Trace_Helpers.decorate_stack_trace_text config.caller_project_root (maybe_highlighted_text _ config)
        False -> (x->x)

    case test_result.spec_result of
        Spec_Result.Success ->
            if config.print_only_failures.not then
                txt = "    - " + test_result.spec_name + " " + times_suffix
                IO.println (maybe_green_text txt config)
        Spec_Result.Failure msg details ->
            report_github_error_message test_result.spec_name msg
            IO.println ""
            txt = "    - [FAILED] " + test_result.spec_name + " " + times_suffix
            IO.println (maybe_red_text txt config)
            IO.println ("        Reason: " + msg)
            if details.is_nothing.not then
                IO.println (decorate_stack_trace details)
            IO.println ""
        Spec_Result.Pending reason ->
            IO.println (maybe_grey_text ("    - [PENDING] " + test_result.spec_name) config)
            IO.println ("        Reason: " + reason)

## PRIVATE
   Reports an error message to show up as a note in GitHub Actions,
   only if running in the GitHub Actions environment.
report_github_error_message (title : Text) (message : Text) =
    is_enabled = Environment.get "GITHUB_ACTIONS" == "true"
    if is_enabled then
        IO.println (generate_github_error_annotation title message)

## PRIVATE
   Generates a GitHub Actions annotation for a failing test.
generate_github_error_annotation (title : Text) (message : Text) =
    sanitize_message txt = txt.replace '\n' '%0A'
    sanitize_parameter txt = txt . replace '\n' '%0A' . replace ',' '%2C'

    location_match = Regex.compile "\(at ((?:[A-Za-z]:)?[^:]+):([0-9\-]+):([0-9\-]+)\)" . match message
    split_on_dash start_field_name end_field_name text =
        if text.contains "-" . not then start_field_name+"="+text else
            parts = text.split "-"
            if parts.length != 2 then Panic.throw (Illegal_Argument.Error "Invalid range format: "+text) else
                start = parts.at 0
                end = parts.at 1
                start_field_name+"="+start+","+end_field_name+"="+end
    on_location_failing_to_parse caught_panic =
        Test_Result.log_message "Failed to parse file location ["+location_match.to_display_text+"]: "+caught_panic.payload.to_display_text
        ""
    location_part = if location_match.is_nothing then "" else
        Panic.catch Any handler=on_location_failing_to_parse <|
            repo_root = enso_project.root.parent.parent.absolute.normalize
            path = File.new (location_match.get 1)
            ## We try to relativize the path, but if it fails, we just use the original path.
               (It may fail eg. if the project root and the test files are on different drives -
               very unlikely but not impossible if tests import other libraries located in weird places.)
            relative_path = Panic.catch IllegalArgumentException (repo_root.relativize path) _->path
            lines_part = split_on_dash "line" "endLine" (location_match.get 2)
            columns_part = split_on_dash "col" "endColumn" (location_match.get 3)
            ",file="+(sanitize_parameter relative_path.path)+","+lines_part+","+columns_part

    "::error title="+(sanitize_parameter title)+location_part+"::"+(sanitize_message message)

## Prints all the results, optionally writing them to a jUnit XML output.

   Arguments:
   - test_results: Vector of `Test_Result`. Can be empty. Can contain results from multiple
                   groups.
   - builder: StringBuilder or Nothing. If StringBuilder, then a jUnit XML format is appended to
              that StringBuilder.
print_report : Vector Test_Result -> Suite_Config -> (StringBuilder | Nothing) -> Nothing
print_report (test_results : Vector Test_Result) (config : Suite_Config) (builder : (StringBuilder | Nothing)) =
    distinct_group_names = test_results.map (_.group_name) . distinct
    results_per_group = distinct_group_names.fold Dictionary.empty acc-> group_name->
        group_results = test_results.filter res->
            res.group_name == group_name
        assert (group_results.length > 0)
        acc.insert group_name group_results
    results_per_group.each_with_key group_name-> group_results->
        print_group_report group_name group_results config builder

## Prints a pending group, optionally writing it to a jUnit XML output.
print_pending_group : Group -> Suite_Config -> (StringBuilder | Nothing) -> Nothing
print_pending_group group config builder =
    assert group.pending.is_nothing.not "Group in print_pending_group should be pending"
    if config.should_output_junit then
        assert builder.is_nothing.not "Builder must be specified when JUnit output is enabled"
        builder.append ('    <testsuite name="' + (escape_xml group.name inside_attribute=True) + '" timestamp="' + (Date_Time.now.format "yyyy-MM-dd'T'HH:mm:ss") + '"')
        builder.append (' tests="0" disabled="1" errors="0" time="0.0">\n')
        builder.append ('        <testcase name="PENDING" time="0.0">\n')
        builder.append ('            <skipped message="Reason: '+(escape_xml group.pending inside_attribute=True)+'"/>\n')
        builder.append ('        </testcase>\n')
        builder.append '    </testsuite>\n'
    IO.println <| maybe_grey_text ("[PENDING] " + group.name) config
    IO.println ("    Reason: " + group.pending)

## Prints report for test_results from a single group.

   Arguments:
   - test_results: Test test_results from a single group
print_group_report : Text -> Vector Test_Result -> Suite_Config -> (StringBuilder|Nothing) -> Nothing
print_group_report group_name test_results config builder =
    distinct_groups = test_results.distinct (res-> res.group_name)
    assert (distinct_groups.length == 1)
    total_time = test_results.fold Duration.zero acc-> res->
        acc + res.time_taken
    if config.should_output_junit then
        assert builder.is_nothing.not "Builder must be specified when JUnit output is enabled"
        builder.append ('    <testsuite name="' + (escape_xml group_name inside_attribute=True) + '" timestamp="' + (Date_Time.now.format "yyyy-MM-dd'T'HH:mm:ss") + '"')
        builder.append (' tests="' + test_results.length.to_text + '"')
        builder.append (' disabled="' + test_results.filter _.is_pending . length . to_text + '"')
        builder.append (' errors="' + test_results.filter _.is_fail . length . to_text + '"')
        builder.append (' time="' + total_time.total_seconds.to_text + '"')
        builder.append ('>\n')

        test_results.each result->
            builder.append ('        <testcase name="' + (escape_xml result.spec_name inside_attribute=True) + '" time="' + ((result.time_taken.total_milliseconds / 1000.0).to_text) + '">')
            case result.spec_result of
                Spec_Result.Success -> Nothing
                Spec_Result.Failure msg details ->
                    builder.append ('\n            <failure message="' + (escape_xml msg inside_attribute=True) + '">\n')
                    # We always print the message again as content - otherwise the GitHub action may fail to parse it.
                    builder.append (escape_xml msg)
                    if details.is_nothing.not then
                        ## If there are additional details, we print them as well.
                        builder.append '\n\n'
                        builder.append (escape_xml details)
                    builder.append '\n            </failure>\n'
                Spec_Result.Pending msg -> builder.append ('\n            <skipped message="' + (escape_xml msg inside_attribute=True) + '"/>\n        ')
            builder.append '        </testcase>\n'
        builder.append '    </testsuite>\n'

    should_print_behavior = config.print_only_failures.not || test_results.any (r -> r.is_fail) || test_results.any (r -> r.is_pending)
    if should_print_behavior then
        tests_succeeded = test_results.fold 0 acc-> res->
            if res.is_success then acc + 1 else acc
        tests_failed = test_results.fold 0 acc-> res->
            if res.is_fail then acc + 1 else acc
        some_test_failed = tests_failed > 0
        tests_executed = tests_succeeded + tests_failed
        group_description =
            counts = tests_succeeded.to_text + "/" + tests_executed.to_text
            times = total_time.total_milliseconds.to_text + "ms"
            group_name + ": " + "[" + counts + ", " + times + "]"
        IO.println <| case some_test_failed of
            True -> maybe_red_text ("[FAILED] " + group_description) config
            False -> maybe_green_text group_description config
        test_results.each result->
            print_single_result result config

## PRIVATE
   Escape Text for XML
escape_xml : Text -> Boolean -> Text
escape_xml input inside_attribute=False =
    escaped = input.replace '&' '&amp;' . replace '"' '&quot;' . replace "'" '&apos;' . replace '<' '&lt;' . replace '>' '&gt;'
    if inside_attribute then escaped.replace '\n' '&#10;' else escaped

## PRIVATE
progress_width = 70

## PRIVATE
print_progress current_progress total_count status_text =
    total_count_as_text = total_count.to_text
    counter_width = total_count_as_text.length
    current_progress_as_text = current_progress.to_text.pad counter_width at=..Left
    line = " ("+ current_progress_as_text + " / " + total_count_as_text + ") " + status_text
    truncated_line = if line.length <= progress_width then line else
        line.take (progress_width - 3) + '...'

    IO.print '\r'
    IO.print (' ' * progress_width)
    IO.print '\r'
    IO.print truncated_line
    IO.print '\r'

## PRIVATE
clear_progress =
    IO.print '\r'
    IO.print (' ' * progress_width)
    IO.print '\r'

## PRIVATE
type Ignore_Progress_Reporter
    ## PRIVATE
    report_progress self (status_text : Text) (increment : Integer = 1) =
        _ = [increment, status_text]
        Nothing

    ## PRIVATE
    clear = Nothing

## PRIVATE
type Command_Line_Progress_Reporter
    ## PRIVATE
    Value current_progress total_count

    ## PRIVATE
    make total_expected =
        Command_Line_Progress_Reporter.Value (Ref.new 0) total_expected

    ## PRIVATE
    report_progress self (status_text : Text) (increment : Integer = 1) =
        self.current_progress.modify (+increment)
        print_progress self.current_progress.get self.total_count status_text

    ## PRIVATE
    clear self = clear_progress

## PRIVATE
   Checks if the current process is running in an interactive terminal session.
is_terminal_interactive -> Boolean =
    Java_System.console != Nothing
