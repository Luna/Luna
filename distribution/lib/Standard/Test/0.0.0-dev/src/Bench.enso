from Standard.Base import all
import Standard.Base.Errors.Illegal_Argument.Illegal_Argument


## The benchmark options for a `Bench_Group`. These options roughly corresponds to the options
   defined in the JMH benchmarking library. See the JMH documentation for more details:
   https://javadoc.io/doc/org.openjdk.jmh/jmh-core/latest/org/openjdk/jmh/annotations/package-summary.html
type Bench_Options
    ## PRIVATE
    Impl (warmup_secs:Integer) (measure_secs:Integer)

    ## Sets the minimal warmup phase duration in seconds.
    set_warmup : Integer -> Bench_Options
    set_warmup self (warm:Integer) = Bench_Options.Impl warm self.measure_secs

    ## Sets the minimal measurement phase duration in seconds.
    set_measure : Integer -> Bench_Options
    set_measure self (meas:Integer) = Bench_Options.Impl self.warmup_secs meas

    to_text self = "[warmup={" + self.warmup_secs.to_text + " seconds}, measurement={" + self.measure_secs.to_text + " seconds}]"

    ## Validates the config and throws a Panic if it is invalid.
    validate : Nothing
    validate self =
        if self.warmup_secs < 0 then Panic.throw (Illegal_Argument.Error "Warmup seconds must be positive")
        if self.measure_secs < 0 then Panic.throw (Illegal_Argument.Error "Measure seconds must be positive")


type Bench_Builder
    ## PRIVATE
    Impl builder

    group : Text -> Bench_Options -> (Group_Builder -> Any) -> Any
    group self (name:Text) (configuration:Bench_Options) fn =
        validate_name name
        b = Vector.new_builder
        fn (Group_Builder.Impl b)
        self.builder.append <| Bench.Group name configuration b.to_vector

type Group_Builder
    ## PRIVATE
    Impl builder

    ## Adds a benchmark specification to the group.

       Arguments:
       - name: The name of the benchmark. Must be a valid Java identifier.
    specify : Text -> Any -> Bench
    specify self (name:Text) ~benchmark =
        validate_name name
        self.builder.append <| Bench.Spec name (_ -> benchmark)


type Bench
    All (groups : Vector Bench)
    Group (name:Text) (configuration:Bench_Options) (specs : Vector Bench)
    Spec (name:Text) (code : Any -> Any)

    build : (Bench_Builder -> Any) -> Bench
    build fn =
        b = Vector.new_builder
        fn (Bench_Builder.Impl b)
        groups_vec = b.to_vector
        Bench.All groups_vec . validate

    options : Bench_Options
    options = Bench_Options.Impl 3 3

    ## Validates the benchmark and throws a Panic if it is invalid. Returns self
       if the benchmark is valid.
    validate : Bench
    validate self =
        ensure_distinct_names names =
            if names.length != names.distinct.length then Panic.throw (Illegal_Argument.Error ("Benchmark names must be unique, got: " + names.to_text))
        case self of
            Bench.All groups ->
                group_names = groups.map (_.name)
                ensure_distinct_names group_names
                groups.each _.validate
            Bench.Group name conf specs ->
                validate_name name
                conf.validate
                ensure_distinct_names <| specs.map (_.name)
            Bench.Spec name code ->
                validate_name name
                if code == Nothing then Panic.throw (Illegal_Argument.Error "Benchmark code must be specified")
        self

    fold : Any -> (Any -> Bench -> Bench -> Any) -> Any
    fold self value fn = case self of
        Bench.All groups -> groups.fold value (v-> g-> g.fold v fn)
        Bench.Group _ _ specs -> specs.fold value (v-> s-> fn v self s)
        Bench.Spec _ _ -> fn value self self

    run_main self =
        count = self.fold 0 v-> _-> _-> v+1
        IO.println <| "Found " + count.to_text + " cases to execute"

        self.fold Nothing _-> g-> s->
            c = g.configuration
            bench_name = g.name + "." + s.name
            IO.println <| "Benchmarking '" + bench_name + "' configuration: " + c.to_text
            Bench.measure bench_name c.warmup_secs c.measure_secs (s.code 0)

    ## Measure the amount of time it takes to execute a given computation.

       Arguments:
       - act: The action to perform.
       - label: A name for the benchmark.
       - warmup_secs: The minimal amount number of seconds of warmup phase.
       - measure_secs: The minimal amount number of seconds of measure phase.

       > Example
         Measure a computation called "foo" with an iteration size of 2 and a number
         of iterations of 1.

             import Standard.Examples
             from Standard.Test import Bench

             example_measure =
                 Bench.measure "foo" warmup_secs=2 measurement_secs=1 Examples.get_boolean
    measure : Text -> Integer -> Integer -> Boolean -> Any -> Nothing
    measure (label:Text) (warmup_secs:Integer) (measure_secs:Integer) ~act =
        dry_run = Environment.get "ENSO_BENCHMARK_TEST_DRY_RUN" "False" == "True"

        single_call = _ ->
            x1 = System.nano_time
            Runtime.no_inline act
            x2 = System.nano_time
            x2 - x1

        run_phase (phase_name:Text) (seconds:Integer) =
            phase_start = System.nano_time
            durations =
                stop_ns = phase_start + seconds * 1000000000
                go = durations -> cur_ns ->
                    if cur_ns  > stop_ns then durations else
                        dur = single_call Nothing
                        @Tail_Call go (durations + [dur]) (cur_ns + dur)
                go [] phase_start
            sum = durations.reduce (_ + _)
            run_iters = durations.length
            avg = sum / run_iters
            fmt = (avg / 1000000).format "#.###"
            phase_end = System.nano_time
            phase_duration_ms = (phase_end - phase_start) / 1000000
            IO.println <| phase_name + " duration: " + phase_duration_ms.to_text + " ms"
            IO.println <| phase_name + " iterations: " + run_iters.to_text
            IO.println <| phase_name + " avg time: " + fmt + " ms"

        measure_start = System.nano_time
        case dry_run of
            True ->
                single_call Nothing
                measure_end = System.nano_time
                measure_duration_ms = (measure_end - measure_start) / 1000000
                fmt_duration_ms = measure_duration_ms.format "#.###"
                IO.println <| "[DRY-RUN] Benchmark '" + label + "' finished in " + fmt_duration_ms + " ms"
            False ->
                run_phase "Warmup" warmup_secs
                run_phase "Measurement" measure_secs
                measure_end = System.nano_time
                measure_duration_ms = (measure_end - measure_start) / 1000000
                fmt_duration_ms = measure_duration_ms.format "#.###"
                IO.println <| "Benchmark '" + label + "' finished in " + fmt_duration_ms + " ms"

## PRIVATE

   Checks whether the given name is a valid benchmark name - either group name
   or a spec name. The name should be a valid Java identifier.
   Throw a Panic error if the validation fails.
validate_name : Text -> Nothing
validate_name name =
    # Cannot start with a digit
    valid_java_identifier_regex = Regex.compile "[A-Za-z_$][a-zA-Z0-9_$]*"
    if valid_java_identifier_regex.matches name then Nothing else
        Panic.throw (Illegal_Argument.Error ("Invalid benchmark name: '" + name + "'"))
