from Standard.Base import all
import Standard.Base.Errors.Illegal_Argument.Illegal_Argument

## Configuration for a measurement phase or a warmup phase of a benchmark.
type Phase_Conf
    ## The minimal number of seconds for which the phase should run.
    Seconds (secs:Integer)
    ## Number of iterations of the phase.
    Iterations (iters:Integer)

    iterations : Integer|Nothing
    iterations self = case self of
        Phase_Conf.Seconds _ -> Nothing
        Phase_Conf.Iterations iters -> iters

    seconds : Integer|Nothing
    seconds self = case self of
        Phase_Conf.Seconds secs -> secs
        Phase_Conf.Iterations _ -> Nothing

    to_text self = case self of
        Phase_Conf.Seconds secs -> secs.to_text + " seconds"
        Phase_Conf.Iterations iters -> iters.to_text + " iterations"

    ## Validates the config and throws a Panic if it is invalid.
    validate : Nothing
    validate self = case self of
        Phase_Conf.Seconds secs ->
            if secs < 0 then Panic.throw (Illegal_Argument.Error "Seconds must be positive")
        Phase_Conf.Iterations iters ->
            if iters < 0 then Panic.throw (Illegal_Argument.Error "Iterations must be positive")


## The benchmark options for a `Bench_Group`. These options roughly corresponds to the options
   defined in the JMH benchmarking library. See the JMH documentation for more details:
   https://javadoc.io/doc/org.openjdk.jmh/jmh-core/latest/org/openjdk/jmh/annotations/package-summary.html
type Bench_Options
    ## PRIVATE
    Impl (warmup:Phase_Conf) (measure:Phase_Conf)

    ## Sets the warmup phase.
    set_warmup : Phase_Conf -> Bench_Options
    set_warmup self (warm:Phase_Conf) = Bench_Options.Impl warm self.measure

    ## Sets the measurement phase.
    set_measure : Phase_Conf -> Bench_Options
    set_measure self (meas:Phase_Conf) = Bench_Options.Impl self.warmup meas

    to_text self = "[warmup={" + self.warmup.to_text + "}, measurement={" + self.measure.to_text + "}]"

    ## Validates the config and throws a Panic if it is invalid.
    validate : Nothing
    validate self =
        self.warmup.validate
        self.measure.validate


type Bench_Builder
    ## PRIVATE
    Impl builder

    group : Text -> Bench_Options -> (Group_Builder -> Any) -> Any
    group self (name:Text) (configuration:Bench_Options) fn =
        validate_name name
        b = Vector.new_builder
        fn (Group_Builder.Impl b)
        self.builder.append <| Bench.Group name configuration b.to_vector


type Group_Builder
    ## PRIVATE
    Impl builder

    ## Adds a benchmark specification to the group.

       Arguments:
       - name: The name of the benchmark. Must be a valid Java identifier.
    specify : Text -> Any -> Bench
    specify self (name:Text) ~benchmark =
        validate_name name
        self.builder.append <| Bench.Spec name (_ -> benchmark)


type Bench
    All (groups : Vector Bench)
    Group (name:Text) (configuration:Bench_Options) (specs : Vector Bench)
    Spec (name:Text) (code : Any -> Any)

    build : (Bench_Builder -> Any) -> Bench
    build fn =
        b = Vector.new_builder
        fn (Bench_Builder.Impl b)
        groups_vec = b.to_vector
        Bench.All groups_vec . validate

    options : Bench_Options
    options = Bench_Options.Impl (Phase_Conf.Seconds 3) (Phase_Conf.Seconds 3)

    ## Validates the benchmark and throws a Panic if it is invalid. Returns self
       if the benchmark is valid.
    validate : Bench
    validate self =
        ensure_distinct_names names =
            if names.length != names.distinct.length then Panic.throw (Illegal_Argument.Error ("Benchmark names must be unique, got: " + names.to_text))
        case self of
            Bench.All groups ->
                group_names = groups.map (_.name)
                ensure_distinct_names group_names
                groups.each _.validate
            Bench.Group name conf specs ->
                validate_name name
                conf.validate
                ensure_distinct_names <| specs.map (_.name)
            Bench.Spec name code ->
                validate_name name
                if code == Nothing then Panic.throw (Illegal_Argument.Error "Benchmark code must be specified")
        self

    fold : Any -> (Any -> Bench -> Bench -> Any) -> Any
    fold self value fn = case self of
        Bench.All groups -> groups.fold value (v-> g-> g.fold v fn)
        Bench.Group _ _ specs -> specs.fold value (v-> s-> fn v self s)
        Bench.Spec _ _ -> fn value self self

    run_main self =
        count = self.fold 0 v-> _-> _-> v+1
        IO.println <| "Found " + count.to_text + " cases to execute"

        self.fold Nothing _-> g-> s->
            c = g.configuration
            bench_name = g.name + "." + s.name
            IO.println <| "Benchmarking '" + bench_name + "' configuration: " + c.to_text
            Bench.measure bench_name c.warmup c.measure (s.code 0)

    ## Measure the amount of time it takes to execute a given computation.

       Arguments:
       - act: The action to perform.
       - label: A name for the benchmark.
       - warmup_conf: Warmup phase configuration.
       - measure_conf: Measurement phase configuration.

       > Example
         Measure a computation called "foo" with an iteration size of 2 and a number
         of iterations of 1.

             import Standard.Examples
             from Standard.Test import Bench

             example_measure =
                 Bench.measure "foo" warmup_iters=2 measurement_iters=1 Examples.get_boolean
    measure : Text -> Phase_Conf -> Phase_Conf -> Boolean -> Any -> Nothing
    measure (label:Text) (warmup_conf:Phase_Conf) (measure_conf:Phase_Conf) ~act =
        dry_run = Environment.get "ENSO_BENCHMARK_TEST_DRY_RUN" "False" == "True"
        measure_start = System.nano_time

        single_call = _ ->
            x1 = System.nano_time
            Runtime.no_inline act
            x2 = System.nano_time
            x2 - x1

        run_phase (phase_name:Text) (conf:Phase_Conf) =
            phase_start = System.nano_time
            durations = case conf of
                Phase_Conf.Seconds secs ->
                    stop_ns = phase_start + secs * 1000000000
                    go = durations -> cur_ns ->
                        if cur_ns  > stop_ns then durations else
                            dur = single_call Nothing
                            @Tail_Call go (durations + [dur]) (cur_ns + dur)
                    go [] phase_start
                Phase_Conf.Iterations iters ->
                    go = durations -> cur_iter ->
                        if cur_iter >= iters then durations else
                            dur = single_call Nothing
                            @Tail_Call go (durations + [dur]) (cur_iter + 1)
                    go [] 0
            sum = durations.reduce (_ + _)
            run_iters = durations.length
            avg = sum / run_iters
            fmt = (avg / 1000000).format "#.###"
            phase_end = System.nano_time
            phase_duration_ms = (phase_end - phase_start) / 1000000
            IO.println <| phase_name + " duration: " + phase_duration_ms.to_text + " ms"
            IO.println <| phase_name + " iterations: " + run_iters.to_text
            IO.println <| phase_name + " avg time: " + fmt + " ms"

        empty_conf = Phase_Conf.Iterations 1
        if dry_run then run_phase "dummy" empty_conf else
            run_phase "Warmup" warmup_conf
            run_phase "Measurement" measure_conf
            measure_end = System.nano_time
            measure_duration_ms = (measure_end - measure_start) / 1000000
            fmt_duration_ms = measure_duration_ms.format "#.###"
            IO.println <| "Benchmark '" + label + "' finished in " + fmt_duration_ms + " ms"

## PRIVATE

   Checks whether the given name is a valid benchmark name - either group name
   or a spec name. The name should be a valid Java identifier.
   Throw a Panic error if the validation fails.
validate_name : Text -> Nothing
validate_name name =
    # Cannot start with a digit
    valid_java_identifier_regex = Regex.compile "[A-Za-z_$][a-zA-Z0-9_$]*"
    if valid_java_identifier_regex.matches name then Nothing else
        Panic.throw (Illegal_Argument.Error ("Invalid benchmark name: '" + name + "'"))
