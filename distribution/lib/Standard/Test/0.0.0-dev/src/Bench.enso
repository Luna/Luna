from Standard.Base import all
import Standard.Base.Runtime.Ref.Ref

## Configuration for a measurement phase or a warmup phase of a benchmark.
type Phase_Conf
    ## The minimal number of seconds for which the phase should run.
    Secs (secs:Integer)
    ## Number of iterations of the phase.
    Iters (iters:Integer)

    to_text self = case self of
        Phase_Conf.Secs secs -> secs.to_text + " seconds"
        Phase_Conf.Iters iters -> iters.to_text + " iterations"

## The benchmark options for a `Bench_Group`. These options roughly corresponds to the options
   defined in the JMH benchmarking library. See the JMH documentation for more details:
   https://javadoc.io/doc/org.openjdk.jmh/jmh-core/latest/org/openjdk/jmh/annotations/package-summary.html
type Bench_Options
    ## PRIVATE
    Impl (warmup:Phase_Conf) (measure:Phase_Conf)

    ## Sets the warmup phase.
    set_warmup : Phase_Conf -> Bench_Options
    set_warmup self (warm:Phase_Conf) = Bench_Options.Impl warm self.measure

    ## Sets the measurement phase.
    set_measure : Phase_Conf -> Bench_Options
    set_measure self (meas:Phase_Conf) = Bench_Options.Impl self.warmup meas

    to_text self = "[warmup=" + self.warmup.to_text + ", measurement=" + self.measure.to_text + "]"

type Bench_Builder
    ## PRIVATE
    Impl builder

    group : Text -> Bench_Options -> (Group_Builder -> Any) -> Any
    group self (name:Text) (configuration:Bench_Options) fn =
        b = Vector.new_builder
        fn (Group_Builder.Impl b)
        self.builder.append <| Bench.Group name configuration b.to_vector

type Group_Builder
    ## PRIVATE
    Impl builder

    specify : Text -> Any -> Bench
    specify self (name:Text) ~benchmark =
        self.builder.append <| Bench.Spec name (_ -> benchmark)


type Bench
    All (groups : Vector Bench)
    Group (name:Text) (configuration:Bench_Options) (specs : Vector Bench)
    Spec (name:Text) (code : Any -> Any)

    build : (Bench_Builder -> Any) -> Bench
    build fn =
        b = Vector.new_builder
        fn (Bench_Builder.Impl b)
        Bench.All b.to_vector

    options : Bench_Options
    options = Bench_Options.Impl (Phase_Conf.Secs 3) (Phase_Conf.Secs 3)

    fold : Any -> (Any -> Bench -> Bench -> Any) -> Any
    fold self value fn = case self of
        Bench.All groups -> groups.fold value (v-> g-> g.fold v fn)
        Bench.Group _ _ specs -> specs.fold value (v-> s-> fn v self s)
        Bench.Spec _ _ -> fn value self self

    run_main self =
        count = self.fold 0 v-> _-> _-> v+1
        IO.println <| "Found " + count.to_text + " cases to execute"

        self.fold Nothing _-> g-> s->
            c = g.configuration
            IO.println <| "Benchmarking '" + s.name + "' from group '" + g.name + "' configuration: " + c.to_text
            Bench.measure s.name c.warmup c.measure (s.code 0)

    ## Measure the amount of time it takes to execute a given computation.

       Arguments:
       - act: The action to perform.
       - label: A name for the benchmark.
       - warmup_iters: The number of warmup iterations.
       - measurement_iters: The number of measurement iterations.
       - run_gc_between_iterations: Whether to try running the garbage collector
         between iterations. Defaults to False. This is helpful when testing
         memory intensive operations, to ensure that GC runs between iterations
         and not _during_ iterations. The time taken to run the requested
         garbage collection will not be counted into the iteration time, however
         there is no guarantee that the JVM will actually accept the GC hint and
         it is still possible the JVM may run GC during an iteration. But
         setting this option to True should make it less likely for GC to
         interrupt measurements.

       > Example
         Measure a computation called "foo" with an iteration size of 2 and a number
         of iterations of 1.

             import Standard.Examples
             from Standard.Test import Bench

             example_measure =
                 Bench.measure "foo" warmup_iters=2 measurement_iters=1 Examples.get_boolean
    measure : Text -> Phase_Conf -> Phase_Conf -> Boolean -> Any -> Nothing
    measure (label:Text) (warmup_conf:Phase_Conf) (measure_conf:Phase_Conf) ~act =
        dry_run = Environment.get "ENSO_BENCHMARK_TEST_DRY_RUN" "False" == "True"
        measure_start = System.nano_time

        single_call = _ ->
            x1 = System.nano_time
            Runtime.no_inline act
            x2 = System.nano_time
            x2 - x1

        run_phase (phase_name:Text) (conf:Phase_Conf) =
            phase_start = System.nano_time
            durations = case conf of
                Phase_Conf.Secs secs ->
                    stop_ns = phase_start + secs * 1000000000
                    go = durations -> cur_ns ->
                        if cur_ns  > stop_ns then durations else
                            dur = single_call Nothing
                            @Tail_Call go (durations + [dur]) (cur_ns + dur)
                    go [] phase_start
                Phase_Conf.Iters iters ->
                    go = durations -> cur_iter ->
                        if cur_iter >= iters then durations else
                            dur = single_call Nothing
                            @Tail_Call go (durations + [dur]) (cur_iter + 1)
                    go [] 0
            sum = durations.reduce (_ + _)
            run_iters = durations.length
            avg = sum / run_iters
            fmt = (avg / 1000000).format "#.##"
            phase_end = System.nano_time
            phase_duration_ms = (phase_end - phase_start) / 1000000
            IO.println <| phase_name + " duration: " + phase_duration_ms.to_text + " ms"
            IO.println <| phase_name + " iterations: " + run_iters.to_text
            IO.println <| phase_name + " avg time: " + fmt + " ms"

        empty_conf = Phase_Conf.Iters 0
        if dry_run then run_phase "dummy" empty_conf else
            warmup_durations = run_phase "Warmup" warmup_conf
            measure_durations = run_phase "Measurement" measure_conf
            # TODO: Print some stats at the end of the phase
            measure_end = System.nano_time
            measure_duration_ms = (measure_end - measure_start) / 1000000
            fmt_duration_ms = measure_duration_ms.format "#.##"
            IO.println <| "Benchmark '" + label + "' finished in " + fmt_duration_ms + " ms"

## PRIVATE

   Reverses the provided list.

   Arguments:
   - list: The list to reverse.
reverse_list : List -> List
reverse_list list =
    go = list -> acc -> case list of
        List.Cons h t -> @Tail_Call go t (List.Cons h acc)
        List.Nil -> acc
    res = go list List.Nil
    res

## PRIVATE

   Sums the elements of the list.

   Arguments:
   - list: The list of numbers to sum.
sum_list : List -> Number
sum_list list =
    go = list -> acc -> case list of
        List.Cons a b -> @Tail_Call go b (acc + a)
        List.Nil -> acc

    res = go list 0
    res

## PRIVATE

   Calculate the average of the elements of a numeric list.

   Arguments:
   - list: The list of numbers to calculate the average of.
avg_list : List -> Number
avg_list list = sum_list list / len_list list

## PRIVATE

   Calculates the length of the provided list.

   Arguments:
   - list: The list to calculate the length of.
len_list : List -> Integer
len_list list =
    go = list -> acc -> case list of
        List.Cons _ b -> @Tail_Call go b (acc + 1)
        List.Nil -> acc
    res = go list 0
    res

## PRIVATE

   Perform an action a number of times.

   Arguments:
   - act: The action to perform `count` number of times.
times : Integer -> (Integer -> Any) -> List Any
times count act =
    go = results -> number -> if number == 0 then results else
        @Tail_Call go (List.Cons (act number) results) number-1
    res = reverse_list (go List.Nil count)
    res
