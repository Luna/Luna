from Standard.Base import all
import Standard.Base.Data.Time.Duration
import Standard.Base.Runtime.State
import Standard.Base.System

polyglot java import java.lang.StringBuilder

## Creates a new test group, describing properties of the object
   described by `self`.

   Arguments:
   - name: The name of the test group.
   - behaviors: An action containing a set of specs for the group.
   - pending: A reason for why the test is pending, or `Nothing` when it is not
     pending.

   > Example
     Adding a test group.

         import Standard.Test

         example_group = Test.Suite.run <|
             Test.group "Number" <| Nothing
group : Text -> Any -> (Text | Nothing) -> Nothing
group name ~behaviors pending=Nothing =
    suite = State.get Suite
    config = suite.config
    if config.should_run_group name then
        case pending of
            Nothing ->
                r = State.run Spec (Spec_Data name  Nil) <|
                    behaviors
                    State.get Spec
                r.print_report config suite.builder
                new_suite = Suite_Data suite.config (Cons r suite.specs) suite.builder
                State.put Suite new_suite
            reason ->
                report_pending_group name reason config suite.builder

## Specifies a single behavior, described by `self`.

   Arguments:
   - label: A description of the behavior being tested.
   - behavior: An action that executes tests.
   - pending: A reason for why the test is pending, or `Nothing` when it is not
     pending.

   > Example
     Adding a specification to the test group.

         import Standard.Test

         example_group = Test.Suite.run <|
             Test.group "Number" <|
                 Test.specify "should define addition" <|
                     2+3 . should_equal 5
   > Example
     Adding a pending specification to the test group.

         import Standard.Test

         example_group = Test.Suite.run <|
             Test.group "Number" <|
                 Test.specify "should define addition" pending="Reason" <|
                     2+3 . should_equal 5
specify : Text -> Any -> (Text | Nothing) -> Nothing
specify label ~behavior pending=Nothing =
    pair = case pending of
        Nothing -> Duration.time_execution (run_spec behavior)
        reason -> Pair_Data Duration.zero (Pending reason)
    result = pair.second
    time_taken = pair.first
    spec = State.get Spec
    new_spec = Spec_Data spec.name (Cons (Behavior_Data label result time_taken) spec.behaviors)
    State.put Spec new_spec


## Expect a function to fail with the provided panic.

   Arguments:
   - action: The action to evaluate that is expected to fail with a panic.
   - matcher: The expected type of the panic thrown by `action`.

   > Example
     Expect that a computation should panic as part of a test.

         import Standard.Examples
         import Standard.Test

         example_expect_panic_with =
             Test.expect_panic_with Examples.throw_panic Examples.My_Error
expect_panic_with : Any -> Any -> Assertion
expect_panic_with ~action matcher =
    res = Panic.recover Any action
    case res of
        _ ->
            loc = Meta.get_source_location 2
            return_suffix = if res.is_nothing then "" else "and returned ["+res.to_text+"]"
            fail ("Expected a " + matcher.to_text + " to be thrown, but the action succeeded " + return_suffix + " (at "+loc+").")
    err = res.catch
    if err.is_a matcher then Nothing else
        fail ("Expected a " + matcher.to_text + ", but " + err.to_text + " was thrown instead.")


## Checks that the provided action returns without any errors or warnings.

   If you just want to check for errors, usage of the `.should_succeed`
   extension function is preferred.
assert_no_problems value frames_to_skip=0 =
    value.catch Any _->
        fail_match_on_unexpected_error value 2+frames_to_skip
    warnings = Warning.get_all value . map .value
    if warnings.not_empty then
        loc = Meta.get_source_location 2+frames_to_skip
        msg = "The action returned unexpected warnings: " + warnings.to_text + " (at " + loc + ")."
        fail msg

## Fail a test with the given message.

   Arguments:
   - message: The message printed when failing the test.

   > Example
     Failing a test manually.

         import Standard.Test

         example_fail = Test.fail "Something went wrong."
fail : Text -> Assertion
fail message details=Nothing =
    failure = Failure message details
    Panic.throw failure


from project.Main.Suite_Config import all

## PRVATE
type Suite_Config
    Suite_Config_Data only_group_regexp print_only_failures output_path

    should_run_group self name =
        regexp = self.only_group_regexp
        case regexp of
            _ : Text -> name.matches regexp . catch Any (_->True)
            _ -> True

    should_output_junit self =
        self.output_path.is_nothing.not

from project.Main.Suite import all

## PRIVATE

   The top-level entry point for a test suite.

   Arguments:
   - config: Suite_Config controlloing the test run.
   - specs: The specs contained within the test suite.
   - builder: StringBuilder for JUnit output.
type Suite
    Suite_Data config specs builder

from project.Main.Spec import all

## PRIVATE

   A group of behaviors for a test.

   Arguments:
   - name: The name of the spec.
   - behaviors: The results of the behaviors encapsulated in that spec.
type Spec
    Spec_Data name behaviors

from project.Main.Behavior import all

## PRIVATE

   A description of a behaviors in a test.

   Arguments:
   - name: The name of the behavior.
   - result: The result of the behavior.
   - time_taken: The duration that the behaviour took to run.
type Behavior
    Behavior_Data name result time_taken

## PRIVATE

   Checks if the behavior is a failure.
Behavior.is_fail : Boolean
Behavior.is_fail self = self.result.is_fail

## PRIVATE

   Checks if the spec group contains any failures and hence fails itself.
Spec.is_fail : Boolean
Spec.is_fail self = self.behaviors.any .is_fail

## PRIVATE

   Checks if the suite contains any failures, and hence fails itself.
Suite.is_fail : Boolean
Suite.is_fail self = self.specs.any .is_fail

from project.Main.Finished_With_Error import all

## PRIVATE

   An error describing that a test finished with an unexpected error.

   Arguments:
   - err: The payload of the error that triggered this error.
   - stack_trace_text: A textual representation of the stack trace for the
     error.
type Finished_With_Error
    Finished_With_Error_Data err stack_trace_text

from project.Main.Assertion import all
from project.Main.Assertion export all

## PRIVATE
type Assertion

    ## PRIVATE

       Represents a successful behavioral test.
    Success

    ## PRIVATE

       Represents a failing behavioral test.

       Arguments:
       - message: The reason why the test failed.
       - details: Additional context of the error, for example the stack trace.
    Failure message details

    ## PRIVATE

       Represents a pending behavioral test.

       Arguments:
       - reason: Text describing why the test is pending.
    Pending reason

    ## PRIVATE

       Checks if the Assertion is a failure.
    is_fail : Boolean
    is_fail self = case self of
        Success -> False
        Failure _ _ -> True
        Pending _ -> False

## PRIVATE

   Executes a behavior test.

   Arguments:
   - behavior: The behavior to execute.
run_spec : Any -> Assertion
run_spec ~behavior =
    recovery = Panic.recover Any <|
        result = behavior
        result.catch Any err->
            Panic.throw (Finished_With_Error_Data err result.get_stack_trace_text)
        Nothing
    maybeExc = case recovery of
        _ -> Success
    result = maybeExc.catch Any ex->
        case ex of
            Failure _ _ -> ex
            Finished_With_Error_Data err stack_trace_text ->
                Failure ("An unexpected error was returned: " + err.to_text) details=stack_trace_text
            _ -> Failure ("An unexpected panic was thrown: " + ex.to_text) details=maybeExc.get_stack_trace_text
    result

## PRIVATE
   Reports an unexpected dataflow error has occurred.
fail_match_on_unexpected_error : Error -> Integer -> Nothing
fail_match_on_unexpected_error error frames_to_skip =
    payload = error.catch
    loc = Meta.get_source_location 1+frames_to_skip
    msg = "An unexpected dataflow error (" + payload.to_text + ") has been matched (at " + loc + ")."
    fail msg+'\n'+error.get_stack_trace_text


## PRIVATE
   Write the JUnit XML header.
wrap_junit_testsuites : Suite_Config -> (StringBuilder|Nothing) -> Any -> Nothing
wrap_junit_testsuites config builder ~action =
    if config.should_output_junit then
        builder.append '<?xml version="1.0" encoding="UTF-8"?>\n'
        builder.append '<testsuites>\n'

    result = action

    if config.should_output_junit then
        builder.append '</testsuites>\n'
        config.output_path.parent.create_directory
        builder.toString.write config.output_path

    result


## PRIVATE
   Record JUnit PENDING group.
report_pending_group : Text -> Text -> Suite_Config -> (StringBuilder|Nothing) -> Nothing
report_pending_group name reason config builder =
    if config.should_output_junit then
        builder.append ('    <testsuite name="' + (escape_xml name) + '" timestamp="' + (Date_Time.now.format "yyyy-MM-dd'T'HH:mm:ss") + '" time="0">\n')
        builder.append ('        <testcase name="' + (escape_xml name) + '"><skipped message="' + (escape_xml reason) + '" /></testcase>\n')
        builder.append '    </testsuite>\n'

    IO.println ("[PENDING] " + name)
    IO.println ("    Reason: " + reason)


## PRIVATE
   Prints a report on the tests to standard output.
Spec.print_report : Suite_Config -> (StringBuilder|Nothing) -> Nothing
Spec.print_report self config builder =
    total_time = self.behaviors.fold Duration.zero acc-> behavior->
        acc + behavior.time_taken
    if config.should_output_junit then
        builder.append ('    <testsuite name="' + (escape_xml self.name) + '" timestamp="' + (Date_Time.now.format "yyyy-MM-dd'T'HH:mm:ss") + '"')
        builder.append (' tests="' + self.behaviors.length.to_text + '"')
        builder.append (' disabled="' + self.behaviors.filter (x->(x.is_a Pending)) . length . to_text + '"')
        builder.append (' errors="' + self.behaviors.filter (x->(x.is_a Failure)) . length . to_text + '"')
        builder.append (' time="' + (total_time.total_seconds).to_text + '"')
        builder.append ('>\n')

        self.behaviors.reverse.each behavior->
            builder.append ('        <testcase name="' + (escape_xml behavior.name) + '" time="' + ((behavior.time_taken.total_milliseconds / 1000.0).to_text) + '">')
            case behavior.result of
                Success -> Nothing
                Failure msg details ->
                    escaped_message = escape_xml msg . replace '\n' '&#10;'
                    builder.append ('\n            <error message="' + escaped_message + '">\n')
                    if details.is_nothing.not then
                        ## We duplicate the message, because sometimes the
                           attribute is skipped if the node has any content.
                        builder.append (escape_xml msg)
                        builder.append '\n'
                        builder.append (escape_xml details)
                    builder.append '</error>\n'
                Pending msg -> builder.append ('\n            <skipped message="' + (escape_xml msg) + '"/>\n        ')
            builder.append '</testcase>\n'
        builder.append '    </testsuite>\n'

    should_print_behavior = config.print_only_failures.not || self.behaviors.any (b -> b.result.is_a Failure)
    if should_print_behavior then
        IO.println (self.name + ":  [" + total_time.total_milliseconds.to_text + "ms]")
        self.behaviors.reverse.each behavior->
            case behavior.result of
                Success ->
                    if config.print_only_failures.not then
                        IO.println ("    - " + behavior.name + " [" + behavior.time_taken.total_milliseconds.to_text + "ms]")
                Failure msg details ->
                    IO.println ("    - [FAILED] " + behavior.name + " [" + behavior.time_taken.total_milliseconds.to_text + "ms]")
                    IO.println ("        Reason: " + msg)
                    if details.is_nothing.not then
                        IO.println details
                Pending reason ->
                    if config.print_only_failures.not then
                        IO.println ("    - [PENDING] " + behavior.name)
                        IO.println ("        Reason: " + reason)


## PRIVATE
   Escape Text for XML
escape_xml : Text -> Text
escape_xml input =
    input.replace '&' '&amp;' . replace '"' '&quot;' . replace "'" '&apos;' . replace '<' '&lt;' . replace '>' '&gt;'
