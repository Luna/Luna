from Standard.Base import all
import Standard.Base.Errors.Illegal_State.Illegal_State

from Standard.Base.Metadata.Widget import Single_Choice
from Standard.Base.Metadata.Choice import Option
import Standard.Base.Metadata.Display

import Standard.Table.Data.Table.Table as Materialized_Table

import project.Connection.Connection.Connection
import project.Data.Dialect
import project.Data.SQL_Query.SQL_Query
import project.Data.SQL_Statement.SQL_Statement
import project.Data.SQL_Type.SQL_Type
import project.Data.Table.Table as Database_Table
import project.Internal.IR.Query.Query
import project.Internal.JDBC_Connection
import project.Internal.SQL_Type_Reference.SQL_Type_Reference

from project.Internal.Result_Set import read_column

from project.Errors import SQL_Error

type Postgres_Connection

    ## PRIVATE

       A Postgres database connection.

       Arguments:
       - connection: the underlying connection.
       - make_new: a function that returns a new connection.
       - known_temporary_tables: a list of temporary tables that have been
         created with this connection. Note that this list may get out of date
         if the user manually performs CREATE TEMPORARY TABLE or DROP TABLE
         through `execute_update`.
    Value connection make_new known_temporary_tables

    ## Closes the connection releasing the underlying database resources
       immediately instead of waiting for them to be automatically released.

       The connection is not usable afterwards.
    close : Nothing
    close self = self.connection.close

    ## Returns the list of databases (or catalogs) for the connection.
    databases : [Text]
    databases self =
        self.connection.jdbc_connection.with_connection connection->
            result_set = connection.createStatement.executeQuery "select datname from pg_database where datname not in ('template0', 'template1')"
            read_column result_set "datname"

    ## Returns the name of the current database (or catalog).
    database : Text
    database self = self.connection.database

    ## Returns a new Connection with the specified database set as default.

       Arguments:
        - database: The name of the database to connect to.
    @database (self-> Single_Choice display=Display.Always values=(self.databases . map d-> Option d d.pretty))
    set_database : Text -> Connection ! SQL_Error
    set_database self database =
        if database == self.database then self else
            self.make_new database Nothing

    ## Returns the list of schemas for the connection within the current database (or catalog).
    schemas : Vector Text
    schemas self = self.connection.schemas

    ## Returns the name of the current schema.
    schema : Text
    schema self = self.connection.schema

    ## Returns a new Connection with the specified schema set as default.

       Arguments:
        - schema: The name of the schema to connect to.
    @schema (self-> Single_Choice display=Display.Always values=(self.schemas . map s-> Option s s.pretty))
    set_schema : Text -> Connection ! SQL_Error
    set_schema self schema =
        if schema == self.schema then self else
            self.make_new Nothing schema

    ## Gets a list of the table types.
    table_types : Vector Text
    table_types self = self.connection.table_types

    ## Returns a materialised Table of all the matching views and tables.

       ? Temporary Tables

         The Postgres table listing does not include temporary tables by
         default. Our connection uses a workaround, manually keeping the created
         temporary tables, to include them. Note, however, that our workaround
         will not be able to detect tables created manually using
         `execute_update` nor will it react correctly to tables created by
         `create_database_table` being manually dropped by `execute_update`.

       Arguments:
       - name_like: The table name pattern to search for. Support SQL wildcards (`%`, `_`).
       - database: The database name to search in (default is current database).
       - schema: The schema name to search in (defaults to current schema).
       - types: The table types to search for. The list of values can be obtained using the `table_types` method.
       - all_fields: Return all the fields in the metadata table.
    @types (self-> Single_Choice values=(self.table_types.map t-> Option t t.pretty))
    tables : Text -> Text -> Text -> Vector -> Boolean -> Materialized_Table
    tables self name_like=Nothing database=self.database schema=self.schema types=Nothing all_fields=False =
        base_result = self.connection.tables name_like database schema types all_fields
        is_current = self.database == database && self.schema == schema
        case is_current of
            False -> base_result
            True -> base_result.if_not_error <|
                add_temporary_tables = types.is_nothing || types.contains temporary_table_type
                if add_temporary_tables.not then base_result else
                    extend_jdbc_tables_with_temporary self base_result name_like

    ## Set up a query returning a Table object, which can be used to work with data within the database or load it into memory.

       Arguments:
       - query: name of the table or sql statement to query.
         If supplied as `Text`, the name is checked against the `tables` list to determine if it is a table or a query.
       - alias: optionally specify a friendly alias for the query.
    @query (self-> Single_Choice display=Display.Always values=(self.tables.at "Name" . to_vector . map t-> Option t t.pretty))
    query : Text | SQL_Query -> Text -> Database_Table
    query self query alias="" = self.connection.query query alias

    ## Execute the query and load the results into memory as a Table.

       Arguments:
       - query: name of the table or sql statement to query.
         If supplied as `Text`, the name is checked against the `tables` list to determine if it is a table or a query.
       - limit: the maximum number of rows to return.
    @query (self-> Single_Choice display=Display.Always values=(self.tables.at "Name" . to_vector . map t-> Option t t.pretty))
    read : Text | SQL_Query -> Integer | Nothing -> Materialized_Table
    read self query limit=Nothing = self.connection.read query limit

    ## ADVANCED

       Executes a raw update query. If the query was inserting, updating or
       deleting rows, the number of affected rows is returned; otherwise it
       returns 0 for other types of queries (like creating or altering tables).

       Arguments:
       - query: either raw SQL code as Text or an instance of SQL_Statement
         representing the query to execute.
    execute_update : Text | SQL_Statement -> Integer
    execute_update self query =
        self.connection.execute_update query

    ## PRIVATE
       Access the dialect.
    dialect self = self.connection.dialect

    ## PRIVATE
       Access the underlying JDBC connection.
    jdbc_connection self = self.connection.jdbc_connection

    ## PRIVATE
    drop_table : Text -> Nothing
    drop_table self table_name =
        self.connection.drop_table table_name

    ## PRIVATE
       This is essentially an alias for `generate_sql` and `execute_update`, but
       it is a hook notifying the connection of the table being created. The
       connection can use that information. Any table creation should be ran
       through this hook, instead of `execute_update` directly.
    execute_create_table : Query -> Nothing
    execute_create_table self create_table_query =
        result = self.connection.execute_create_table create_table_query
        result.if_not_error <|
            case create_table_statement of
                Query.Create_Table table_name _ _ temporary ->
                    if temporary then
                        self.known_temporary_tables.append table_name
                _ -> Panic.throw (Illegal_State.Error "Impossible: Unexpected query type in execute_create_table.")
            result

## PRIVATE

   Creates a Postgres connection based on a URL, properties and a dialect.

   Arguments:
   - url: The URL to connect to.
   - properties: A vector of properties for the connection.
   - make_new: a function that returns a new connection.
create : Text -> Vector -> (Text -> Text -> Postgres_Connection) -> Postgres_Connection
create url properties make_new =
    jdbc_connection = JDBC_Connection.create url properties
    Postgres_Connection.Value (Connection.Value jdbc_connection Dialect.postgres) make_new Vector.new_builder

## PRIVATE
   Builds a Table like the one returned by `.tables`, from a custom list of
   table names.
build_tables_listing database schema table_type table_names =
    rows = table_names.map table_name->
        [database, self.schema, table_name, "TEMPORARY TABLE", Nothing]
    Table.from_rows ["Database", "Schema", "Name", "Type", "Description"] rows_to_add

## PRIVATE
temporary_table_type = "TEMPORARY TABLE"

## PRIVATE
   This is a workaround for an issue in Postgres where temporary tables are not
   listed by the `DatabaseMetadata.getTables` method. We add any missing tables
   thanks to the `known_temporary_tables` property.
extend_jdbc_tables_with_temporary connection base_result name_like
    known_temporary_tables = connection.known_temporary_tables.to_vector

    # We check if some of the tables are by any chance included in the existing result, to avoid duplicates.
    existing_tables = Map.from_vector allow_duplicates=True <|
        base_result.at "Name" . to_vector . map [_, True]
    missing_temporary_tables = known_temporary_tables.filter name->
        already_included = existing_tables.get name False
        already_included.not

    filtered_tables = if name_like.is_nothing then missing_temporary_tables else
        missing_temporary_tables.filter (Filter_Condition.Like name_like)

    # Currently, the Postgres `tables` listing always puts `Nothing` for database, so we try to be consistent.
    temporary_tables = build_tables_listing database=Nothing schema=connection.schema temporary_table_type filtered_tables
    unioned = base_result.union temporary_tables on_problems=Problem_Behavior.Report_Error
    unioned.catch Any error->
        Panic.throw (Illegal_State.Error "Unexpected error in Postgres_Connection.tables. This is a bug in the Database library. The underlying error was: "+error.to_display_text cause=error)
    unioned
