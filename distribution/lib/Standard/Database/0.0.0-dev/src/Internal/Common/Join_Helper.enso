from Standard.Base import all
import Standard.Base.Error.Illegal_State.Illegal_State

import Standard.Table.Internal.Join_Helpers
import Standard.Table.Internal.Unique_Name_Strategy.Unique_Name_Strategy
import Standard.Table.Data.Join_Kind.Join_Kind
from Standard.Table.Errors import Floating_Point_Grouping

import project.Internal.Helpers
import project.Internal.IR.Context.Context
import project.Internal.IR.From_Spec.From_Spec
import project.Internal.IR.SQL_Expression.SQL_Expression
import project.Data.Table.Table

## PRIVATE
default_prepare_join connection join_kind new_table_name left_subquery right_subquery on_expressions where_expressions columns_to_select =
    new_from = From_Spec.Join join_kind left_subquery right_subquery on_expressions
    new_ctx = Context.for_subquery new_from . set_where_filters where_expressions
    Table.Value new_table_name connection columns_to_select new_ctx

## PRIVATE
make_join_helpers left_table right_table left_column_mapping right_column_mapping =
    ## Resolves the column in the original table and finds the expression
       corresponding to it in the subquery.
    resolve_target_expression column_mapping column =
        new_column = column_mapping.get column.name if_missing=(Panic.throw (Illegal_State.Error "Impossible. Could not find column "+column.name+" in the mapping. This is a bug in the Database library."))
        new_column.expression
    resolve_left = resolve_target_expression left_column_mapping
    resolve_right = resolve_target_expression right_column_mapping

    make_equals problem_builder left right =
        if left.sql_type.is_definitely_double then
            problem_builder.report_other_warning (Floating_Point_Grouping.Error left.name)
        if right.sql_type.is_definitely_double then
            problem_builder.report_other_warning (Floating_Point_Grouping.Error right.name)
        SQL_Expression.Operation "=" [resolve_left left, resolve_right right]
    make_equals_ignore_case _ left right locale =
        Helpers.assume_default_locale locale <|
            SQL_Expression.Operation "equals_ignore_case" [resolve_left left, resolve_right right]
    make_between _ left right_lower right_upper =
        args = [resolve_left left, resolve_right right_lower, resolve_right right_upper]
        SQL_Expression.Operation "BETWEEN" args
    Join_Helpers.Join_Condition_Resolver.Value (left_table.at _) (right_table.at _) make_equals make_equals_ignore_case make_between

## PRIVATE
   Takes columns from the left and right subquery, a list of redundant column
   names and returns a list of new columns that should be present in the join
   result (depending on the kind of performed join), ensuring that any colliding
   columns are properly renamed.
select_columns_for_join join_kind left_new_columns right_new_columns redundant_column_names right_prefix =
    case join_kind of
        Join_Kind.Left_Exclusive -> left_new_columns
        Join_Kind.Right_Exclusive -> right_new_columns
        _ ->
            ## TODO Here we will later need to add the logic for adding a prefix
               before adding the deduplicator numbers. Related to:
               https://www.pivotaltracker.com/story/show/183901439
            _ = right_prefix
            renamer = Unique_Name_Strategy.new
            left_new_columns_names = renamer.make_all_unique <| left_new_columns.map .name
            right_new_kept_columns = right_new_columns.filter c-> redundant_column_names.contains c.name . not
            right_new_kept_columns_names = renamer.make_all_unique <| right_new_kept_columns.map .name

            left_renamed_columns = Helpers.rename_internal_columns left_new_columns left_new_columns_names
            right_renamed_kept_columns = Helpers.rename_internal_columns right_new_kept_columns right_new_kept_columns_names
            new_columns = left_renamed_columns + right_renamed_kept_columns
            new_columns
