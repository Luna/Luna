from Standard.Base import all
import Standard.Base.Errors.Illegal_State.Illegal_State
from Standard.Base.Runtime import assert

import Standard.Table.Data.Join_Kind.Join_Kind
import Standard.Table.Internal.Lookup_Helpers
import Standard.Table.Internal.Lookup_Helpers.Lookup_Column
from Standard.Table.Errors import all

import project.Data.Table.Table
import project.Internal.IR.Context.Context
import project.Internal.IR.From_Spec.From_Spec
import project.Internal.IR.Internal_Column.Internal_Column
import project.Internal.IR.SQL_Expression.SQL_Expression
import project.Internal.IR.SQL_Join_Kind.SQL_Join_Kind
import project.Internal.SQL_Type_Reference.SQL_Type_Reference
from project.Internal.Upload_Table import check_for_null_keys

## PRIVATE
   Implementation of `lookup_and_replace` for Database backend.
   See `Table.lookup_and_replace` for more details.
build_lookup_query : Table -> Table -> (Vector (Integer | Text | Regex) | Text | Integer | Regex) -> Boolean -> Boolean -> Problem_Behavior -> Table ! Missing_Input_Columns | Non_Unique_Key | Unmatched_Rows_In_Lookup
build_lookup_query base_table lookup_table key_columns add_new_columns allow_unmatched_rows on_problems =
    lookup_columns = Lookup_Helpers.prepare_columns_for_lookup base_table lookup_table key_columns add_new_columns allow_unmatched_rows on_problems
    lookup_columns.if_not_error <| check_initial_invariants base_table lookup_table lookup_columns allow_unmatched_rows <|
        table_name_deduplicator = base_table.connection.base_connection.table_naming_helper.create_unique_name_strategy
        self_alias = table_name_deduplicator.make_unique base_table.name
        lookup_alias = table_name_deduplicator.make_unique lookup_table.name
        new_table_name = table_name_deduplicator.make_unique <|
            base_table.name + "_" + lookup_table.name

        column_naming_helper = base_table.connection.base_connection.column_naming_helper
        unique_name_strategy = column_naming_helper.create_unique_name_strategy
        unique_name_strategy.mark_used base_table.column_names
        unique_name_strategy.mark_used lookup_table.column_names

        # First pass - no checking of invariants
        lookup_indicator_base = Internal_Column.Value (unique_name_strategy.make_unique "lookup_indicator") SQL_Type_Reference.null (SQL_Expression.Literal "1")

        self_requested_columns = Vector.new_builder
        lookup_requested_columns = Vector.new_builder

        lookup_columns.each c-> case c of
            Lookup_Column.Key_Column base_column key_column ->
                self_requested_columns.append [base_column]
                lookup_requested_columns.append [key_column]
            Lookup_Column.Keep_Column base_column ->
                self_requested_columns.append [base_column]
                lookup_requested_columns.append []
            Lookup_Column.Replace_Column base_column lookup_column _ ->
                self_requested_columns.append [base_column]
                lookup_requested_columns.append [lookup_column]
            Lookup_Column.Add_Column lookup_column ->
                self_requested_columns.append []
                lookup_requested_columns.append [lookup_column]

        self_sub = base_table.context.as_subquery self_alias self_requested_columns.to_vector
        lookup_sub = lookup_table.context.as_subquery lookup_alias lookup_requested_columns.to_vector+[[lookup_indicator_base]]
        lookup_indicator = lookup_sub.new_columns.at -1 . first

        get_self_column ix = self_sub.new_columns.at ix . first
        get_lookup_column ix = lookup_sub.new_columns.at ix . first

        on_expressions = (_.flatten) <| lookup_columns.map_with_index ix-> c-> case c of
            Lookup_Column.Key_Column _ _ ->
                [SQL_Expression.Operation "==" [(get_self_column ix).expression, (get_lookup_column ix).expression]]
            _ -> []

        # We need to construct the context _before_ constructing the columns, to be able to use it in column construction (for inferring types).
        new_from = From_Spec.Join SQL_Join_Kind.Left self_sub.subquery lookup_sub.subquery on_expressions
        new_ctx = Context.for_subquery new_from
        infer_type_in_result expr =
            SQL_Type_Reference.new base_table.connection new_ctx expr

        ## TODO [RW] here we will perform as many fetches as there are
           Replace_Column instances, but technically we could perform just
           one fetch fetching all column types - TODO we should do that.
           See #6118.
        new_columns = lookup_columns.map_with_index ix-> c-> case c of
            Lookup_Column.Key_Column _ _ -> get_self_column ix
            Lookup_Column.Keep_Column _  -> get_self_column ix
            Lookup_Column.Replace_Column _ _ expected_type ->
                self_col = get_self_column ix
                lookup_col = get_lookup_column ix
                is_lookup_found = SQL_Expression.Operation "NOT" [SQL_Expression.Operation "IS_NULL" [lookup_indicator.expression]]
                expression = case allow_unmatched_rows of
                    True  -> SQL_Expression.Operation "CASE" [is_lookup_found, lookup_col.expression, self_col.expression]
                    False -> Error.throw (Illegal_State.Error "Assumed that prepare_columns_for_lookup never returns Replace_Column if allow_unmatched_rows=False. This is a bug in the Database library.")
                input_column = Internal_Column.Value self_col.name (infer_type_in_result expression) expression
                adapted = base_table.connection.dialect.adapt_unified_column input_column expected_type infer_type_in_result
                Internal_Column.Value self_col.name adapted.sql_type_reference adapted.expression
            Lookup_Column.Add_Column _ -> get_lookup_column ix

        Table.Value new_table_name base_table.connection new_columns new_ctx

## PRIVATE
check_initial_invariants : Table -> Table -> Vector Lookup_Column -> Boolean -> Any -> Any
check_initial_invariants base_table lookup_table lookup_columns allow_unmatched_rows ~continuation =
    key_column_names = lookup_columns.flat_map c-> case c of
        Lookup_Column.Key_Column base_column lookup_column ->
            assert (base_column.name == lookup_column.name) "Columns should have equal names."
            [lookup_column.name]
        _ -> []
    check_for_null_keys lookup_table key_column_names <|
        # TODO check duplicate matches
        if allow_unmatched_rows then continuation else
            unmatched_rows = base_table.join lookup_table on=key_column_names join_kind=Join_Kind.Left_Exclusive . select_columns key_column_names
            unmatched_example = unmatched_rows.read max_rows=1
            if unmatched_example.row_count == 0 then continuation else
                first_row = unmatched_example.rows.first
                Error.throw (Unmatched_Rows_In_Lookup.Error first_row.to_vector)
