from Standard.Base import all
import Standard.Base.Errors.Illegal_Argument.Illegal_Argument
import Standard.Base.System.Input_Stream.Input_Stream

from Standard.Table import all

## PRIVATE
type Enso_Connection
    ## PRIVATE
       Read enso_connection files
    For_File

    for_file_read : File -> Enso_Connection | Nothing
    for_file_read file =
        if file.extension == ".enso_connection" then Enso_Connection.For_File else Nothing

    for_file_write : File -> Enso_Connection | Nothing
    for_file_write file = Enso_Connection.for_file_read file

    ## PRIVATE
       If the File_Format supports reading from the web response, return a configured instance.
    for_web : Text -> URI -> Enso_Connection | Nothing
    for_web content_type uri =
        _ = [content_type]
        if uri.to_text.ends_with ".enso_connection" then Enso_Connection.For_File else Nothing

    ## PRIVATE
       Implements the `File.read` for this `File_Format`
    read : File -> Problem_Behavior -> Any
    read self file on_problems =
        _ = [on_problems]
        file.with_input_stream [File_Access.Read] Enso_Connection.read_stream

    ## PRIVATE
       Implements the `Data.parse` for this `File_Format`
    read_stream : Input_Stream -> Any
    read_stream self stream:Input_Stream =
        decoded = stream.decode_as_json
        case decoded of
            _ : JS_Object -> read_json decoded
            _ -> Error.throw (Illegal_Argument.Value "Enso Connection should be a JSON object with configuration.")

## PRIVATE
read_json : JS_Object -> Any
read_json json:JS_Object =
    connection_type = json.get "connection_type"
    case connection_type of
        "fetch" -> fetch_from_web json
        "file" -> read_from_file json
        "database" -> connect_to_database json
        _ -> Error.throw (Illegal_Argument.Value "Enso Connection should have a valid connection_type (fetch/file/database).")

## PRIVATE
file_format : JS_Object -> File_Format
file_format json:JS_Object = if json.get "format" "Auto" == "Auto" then Auto_Detect else
    formats = File_Format.all
    format = formats.find if_missing=Nothing f->
        name = Meta.meta f . name
        target = json.get "format"
        (name.equals_ignore_case target) || (name.equals_ignore_case (target + "_Format"))
    if format.is_nothing then Error.throw (Illegal_Argument.Value "Enso Connection format is invalid "+(json.get "format" . to_text)+".") else
        json.into format

## PRIVATE
fetch_from_web : JS_Object -> Any
fetch_from_web json:JS_Object =
    url = json.get "url"
    if url == Nothing then Illegal_Argument.throw "Fetch based Enso Connections should have a URL." else
        method = json.get "method" "GET" : HTTP_Method
        headers = json.get "headers" []
        format = file_format json
        result = if format==Auto_Detect then Data.fetch url method headers else
            response = HTTP.fetch url method headers
            response.decode format
        field = if json.contains_key "field" && result.is_a JS_Object then result.get (json.get "field") else result
        if field.is_nothing then field else (if json.get "as_table" False then Table.from_object field else field)

## PRIVATE
read_from_file : JS_Object -> Any
read_from_file json:JS_Object =
    path = json.get "path"
    if path == Nothing then Illegal_Argument.throw "File based Enso Connections should have a path." else
        format = file_format json
        Data.read path format

## PRIVATE
connect_to_database : JS_Object -> Any
connect_to_database json:JS_Object =
    _ = [json]
    Error.throw (Illegal_Argument.Value "Database based Enso Connections are not yet supported.")
