from Standard.Base import all

import Standard.Base.Runtime.Resource
from Standard.Base.Runtime.Resource import Managed_Resource

import Standard.Database.Data.Dialect
import Standard.Database.Data.Internal.IR
import Standard.Database.Data.Sql
import Standard.Database.Data.Table as Database_Table
import Standard.Table.Data.Table as Materialized_Table
import Standard.Table.Data.Storage
import Standard.Database.Data.Internal.Base_Generator
from Standard.Database.Data.Sql import Sql_Type

from Standard.Database.Internal.Result_Set import read_column, result_set_to_table

polyglot java import java.lang.UnsupportedOperationException
polyglot java import java.util.ArrayList
polyglot java import java.util.Properties
polyglot java import java.sql.DriverManager
polyglot java import java.sql.PreparedStatement
polyglot java import java.sql.Types
polyglot java import java.sql.SQLException
polyglot java import java.sql.SQLTimeoutException
polyglot java import java.sql.ResultSet
polyglot java import org.enso.database.JDBCProxy

type Connection

    ## PRIVATE

       A Database connection using a JDBC driver. Allows accessing tables from a database.

       Arguments:
       - connection_resource: the resource managing the underlying JDBC
         connection.
       - dialect: the dialect associated with the database we are connected to.
       - with_database: an action taking a new database name and returning a new
         connection to that database.
       - with_schema: an action taking a new database name and returning a new
         connection to that schema.
       - get_databases: an action returning a list of databases, allowing for
         connection specific overrides.
       - with_schema: an action returning a list of schema, allowing for
         connection specific overrides.
    type Connection connection_resource dialect with_database with_schema get_databases=Nothing get_schemas=Nothing

    ## Closes the connection releasing the underlying database resources
       immediately instead of waiting for them to be automatically released.

       The connection is not usable afterwards.
    close : Nothing
    close self =
        self.connection_resource . finalize

    ## Returns the list of databases (or catalogs) for the connection.
    databases : [Text]
    databases self =
        wrap_sql_errors <|
            self.connection_resource.with connection->
                case self.get_databases.is_nothing of
                    True ->
                        metadata = connection.getMetaData
                        database_result_set = metadata.getCatalogs
                        read_column database_result_set "TABLE_CAT"
                    False ->
                        self.get_databases connection

    ## Returns the name of the current database (or catalog).
    database : Text
    database self =
        self.connection_resource.with connection->
            connection.getCatalog

    ## Returns a new Connection with the specified database set as default.

       Arguments:
        - database: The name of the database to connect to.
    set_database : Text -> Connection ! Sql_Error
    set_database self database =
        if database == self.database then self else
            self.with_database database

    ## Returns the list of schemas for the connection within the current database (or catalog).
    schemas : [Text]
    schemas self =
        wrap_sql_errors <|
            self.connection_resource.with connection->
                case self.get_schemas.is_nothing of
                    True ->
                        metadata = connection.getMetaData
                        schema_result_set = metadata.getSchemas
                        read_column schema_result_set "TABLE_SCHEM"
                    False ->
                        self.get_schemas connection

    ## Returns the name of the current schema.
    schema : Text
    schema self =
        self.connection_resource.with connection->
            connection.getSchema

    ## Returns a new Connection with the specified schema set as default.

       Arguments:
        - schema: The name of the schema to connect to.
    set_schema : Text -> Connection ! Sql_Error
    set_schema self schema =
        if schema == self.schema then self else
            self.with_schema schema

    ## Gets a list of the table types
    table_types : [Text]
    table_types self =
        wrap_sql_errors <|
            self.connection_resource.with connection->
                metadata = connection.getMetaData
                types_result_set = metadata.getTableTypes
                read_column types_result_set "TABLE_TYPE"

    ## Returns a materialised Table of all the matching views and tables.

       Arguments:
       - name_like: The table name pattern to search for. Support SQL wildcards.
       - database: The database name to search in (default is current database).
       - schema: The schema name to search in (defaults to current schema).
       - types: The table types to search for.
    tables : Text -> Text -> Text -> Materialized_Table
    tables self name_like=Nothing database=self.database schema=self.schema types=Nothing =
        types_array = if types.is_nothing then Nothing else types.to_array
        wrap_sql_errors <|
            self.connection_resource.with connection->
                metadata = connection.getMetaData
                result_set_to_table <|
                    metadata.getTables database schema name_like types_array

    ## UNSTABLE

       Accesses a table within the database, returning an object that can be
       used to create queries for that table.

       Arguments:
       - name: name of the table to access
    access_table : Text -> Database_Table
    access_table self name = handle_sql_errors <|
        columns = self.fetch_columns name
        Database_Table.make_table self name columns

    ## ADVANCED

       Executes a raw query and returns the result as an in-memory Table.

       Arguments:
       - query: either raw SQL code as Text or an instance of Sql.Statement
         representing the query to execute.
       - expected_types: an optional array of expected types of each column;
         meant only for internal use.
    execute_query : Text | Sql.Statement -> Vector Sql_Type -> Materialized_Table =
    execute_query self query expected_types=Nothing = handle_sql_errors <|
        self.with_prepared_statement query stmt->
            result_set_to_table stmt.executeQuery expected_types

    ## ADVANCED

       Executes a raw update query. If the query was inserting, updating or
       deleting rows, the number of affected rows is returned; otherwise it
       returns 0 for other types of queries (like creating or altering tables).

       Arguments:
       - query: either raw SQL code as Text or an instance of Sql.Statement
         representing the query to execute.
    execute_update : Text | Sql.Statement -> Integer
    execute_update self query = handle_sql_errors <|
        self.with_prepared_statement query stmt->
            Panic.catch UnsupportedOperationException stmt.executeLargeUpdate _->
                stmt.executeUpdate

    ## PRIVATE

       Runs the provided action with a prepared statement, adding contextual
       information to any thrown SQL errors.
    with_prepared_statement : Text  | Sql.Statement -> (PreparedStatement -> Any) -> Any
    with_prepared_statement self query action =
        prepare template holes = self.connection_resource . with java_connection->
            stmt = java_connection.prepareStatement template
            Panic.catch Any (set_statement_values stmt holes) caught_panic->
                stmt.close
                Panic.throw caught_panic
            stmt

        go template holes =
            wrap_sql_errors related_query=template <|
                Resource.bracket (prepare template holes) .close action

        case query of
            Text -> go query []
            Sql.Statement _ ->
                compiled = query.prepare
                go compiled.first compiled.second

    ## PRIVATE

       A helper function that fetches column names and sql types associated with
       them for a table in the database.

       Arguments:
       - table_name: The name of the table to fetch the column metadata for.
    # fetch_columns : Text -> Vector [Text, Sql_Type]
    fetch_columns : Text -> Vector Any
    fetch_columns self table_name =
        query = IR.Select_All (IR.make_ctx_from table_name)
        compiled = self.dialect.generate_sql query
        self.with_prepared_statement compiled stmt->
            rs = stmt.executeQuery
            metadata = rs.getMetaData
            ncols = metadata.getColumnCount
            resolve_column ix =
                name = metadata.getColumnName ix+1
                typeid = metadata.getColumnType ix+1
                typename = metadata.getColumnTypeName ix+1
                [name, Sql_Type typeid typename]
            Vector.new ncols resolve_column

    ## PRIVATE
       UNSTABLE
       This is a prototype function used in our test suites. It may change.

       It creates a new table in the database with the given name (will fail if
       the table already existed), inserts the contents of the provided
       in-memory table and returns a handle to the newly created table.

       Arguments:
       - name: The name of the table to create.
       - table: An In-Memory table specifying the contents to upload. Schema of
         the created database table is based on the column types of this table.
       - temporary: Specifies whether the table should be marked as temporary. A
         temporary table will be dropped after the connection closes and will
         usually not be visible to other connections.
       - batch_size: Specifies how many rows should be uploaded in a single
         batch.
    upload_table : Text -> Materialized_Table -> Boolean -> Integer -> Database_Table
    upload_table self name table temporary=True batch_size=1000 = Panic.recover Illegal_State_Error <| handle_sql_errors <|
        column_types = table.columns.map col-> default_storage_type col.storage_type
        column_names = table.columns.map .name
        col_makers = column_names.zip column_types name-> typ->
            Base_Generator.wrap_in_quotes name ++ Sql.code " " ++ Sql.code typ.name
        create_prefix = if temporary then "CREATE TEMPORARY TABLE " else "CREATE TABLE "
        create_sql = (Sql.code create_prefix ++ Base_Generator.wrap_in_quotes name ++ Sql.code " (" ++ (Sql.join ", " col_makers) ++ Sql.code ")").build
        Panic.rethrow <| self.execute_update create_sql
        db_table = Panic.rethrow <| self.access_table name

        pairs = db_table.internal_columns.map col->
            [col.name, IR.Constant col.sql_type Nothing]
        db_types = pairs.map p-> p.second.sql_type
        insert_query = self.dialect.generate_sql <| IR.Insert name pairs
        insert_template = insert_query.prepare.first
        self.connection_resource . with java_connection->
            default_autocommit = java_connection.getAutoCommit
            java_connection.setAutoCommit False
            Resource.bracket Nothing (_ -> java_connection.setAutoCommit default_autocommit) _->
                Resource.bracket (java_connection.prepareStatement insert_template) .close stmt->
                    num_rows = table.row_count
                    columns = table.columns
                    check_rows updates_array expected_size =
                        updates = Vector.Vector updates_array
                        if updates.length != expected_size then Panic.throw <| Illegal_State_Error "The batch update unexpectedly affected "+updates.length.to_text+" rows instead of "+expected_size.to_text+"." else
                            updates.each affected_rows->
                                if affected_rows != 1 then
                                    Panic.throw <| Illegal_State_Error "A single update within the batch unexpectedly affected "+affected_rows.to_text+" rows."
                    0.up_to num_rows . each row_id->
                        values = columns.map col-> col.at row_id
                        holes = values.zip db_types
                        set_statement_values stmt holes
                        stmt.addBatch
                        if (row_id+1 % batch_size) == 0 then check_rows stmt.executeBatch batch_size
                    if (num_rows % batch_size) != 0 then check_rows stmt.executeBatch (num_rows % batch_size)
                java_connection.commit
        db_table

## PRIVATE

   Creates a JDBC connection based on a URL and optionally username and
   password.

   Arguments:
   - url: The URL to connect to.
   - properties: A vector of properties for the connection.
   - dialect: A Dialect object that will be used to generate SQL.
   - with_database: A constructor function to build a new connection for a new
     database.
   - with_schema: A constructor function to build a new connection for a new
     schema.
   - get_databases: A function that returns a list of databases.
   - get_schemas: A function that returns a list of schemas.
create_jdbc_connection : Text -> Vector -> Dialect -> (Text->Connection!Sql_Error) -> (Text->Connection!Sql_Error) -> Any -> Any -> Connection
create_jdbc_connection url properties dialect with_database=(_-> Sql_Error.throw_sql_error "Changing database is not supported.") with_schema=(_-> Sql_Error.throw_sql_error "Changing schema is not supported.") get_databases=Nothing get_schemas=Nothing =
    handle_sql_errors <|
        java_props = Properties.new
        properties.each pair->
            java_props.setProperty pair.first pair.second
        java_connection = JDBCProxy.getConnection url java_props
        resource = Managed_Resource.register java_connection close_connection
        Connection resource dialect with_database with_schema get_databases get_schemas

## PRIVATE

   This cannot be a closure due to limitations of Managed_Resource.

   Arguments:
   - connection: The connection to close.
close_connection : Connection -> Nothing
close_connection connection =
    connection.close

type Sql_Error

    ## UNSTABLE

       Indicates an error with executing a query, update or connecting to the
       database.

       Arguments:
       - java_exception: The underlying exception.
       - related_query (optional): A string representation of a query that this
         error is related to.
    type Sql_Error java_exception related_query=Nothing

    ## UNSTABLE

       Convert the SQL error to a textual representation.
    to_text : Text
    to_text self =
        query = if self.related_query.is_nothing.not then " [Query was: " + self.related_query + "]" else ""
        "There was an SQL error: " + self.java_exception.getMessage.to_text + "." + query

    ## UNSTABLE

       Pretty print the SQL error.
    to_display_text : Text
    to_display_text self = self.to_text

    ## PRIVATE
    throw_sql_error : Text -> Sql_Error
    throw_sql_error message =
        Error.throw (Sql_Error (SQLException.new message))

type Sql_Timeout_Error

    ## UNSTABLE

       Indicates that an operation has timed out.

       Arguments:
       - java_exception: The underlying exception.
       - related_query (optional): A string representation of a query that this
         error is related to.
    type Sql_Timeout_Error java_exception related_query=Nothing

    ## UNSTABLE

       Convert the timeout error to a textual representation.
    to_text : Text
    to_text self =
        query = if self.related_query.is_nothing.not then " [Query was: " + query + "]" else ""
        "The SQL connection timed out: " + self.java_exception.getMessage + "." + query

    ## UNSTABLE

       Pretty print the timeout error.
    to_display_text : Text
    to_display_text self = self.to_text

## PRIVATE

   Executes `action` and returns its result, catching any panics and if they are
   coming from JDBC, wraps them with our own error types and returns as regular
   data-flow errors.

   Arguments:
   - action: The computation to execute. This computation may throw SQL errors.
handle_sql_errors : Any -> (Text | Nothing) -> Any ! (Sql_Error | Sql_Timeout_Error)
handle_sql_errors ~action related_query=Nothing =
    Panic.recover [Sql_Error, Sql_Timeout_Error] <|
        wrap_sql_errors action related_query

## PRIVATE

   Executes `action` and returns its result, converting any SQL exceptions into
   Enso panics.

   Arguments:
   - action: The computation to execute. This computation may throw SQL errors.
   - related_query: A related query that is currently being run, to enrich the
     error metadata.
wrap_sql_errors : Any -> (Text | Nothing) -> Any ! (Sql_Error | Sql_Timeout_Error)
wrap_sql_errors ~action related_query=Nothing =
    Panic.catch SQLException action caught_panic->
        exc = caught_panic.payload.cause
        case Java.is_instance exc SQLTimeoutException of
            True -> Panic.throw (Sql_Timeout_Error exc related_query)
            False -> Panic.throw (Sql_Error exc related_query)

## PRIVATE
   Returns the default database type corresponding to an in-memory storage
   type.
default_storage_type : Storage.Type -> Sql_Type
default_storage_type storage_type = case storage_type of
    Storage.Text -> Sql_Type.text
    Storage.Integer -> Sql_Type.integer
    Storage.Decimal -> Sql_Type.double
    Storage.Boolean -> Sql_Type.boolean
    ## Support for mixed type columns in Table upload is currently very limited,
       falling back to treating everything as text.
    Storage.Any -> Sql_Type.text

## PRIVATE
   Sets values inside of a prepared statement.
set_statement_values : PreparedStatement -> Vector (Pair Any Sql_Type) -> Nothing
set_statement_values stmt holes =
    holes.map_with_index ix-> obj->
        position = ix + 1
        case obj.first of
            Nothing -> stmt.setNull position obj.second.typeid
            _ -> stmt.setObject position obj.first
