from Standard.Base import all

import Standard.Database.Data.Internal.IR
import Standard.Database.Data.Sql
import Standard.Database.Data.Table as Database_Table
import Standard.Table.Data.Table as Materialized_Table
import Standard.Table.Data.Storage
import Standard.Table.Internal.Java_Exports
import Standard.Database.Data.Internal.Base_Generator
from Standard.Database.Data.Sql import Sql_Type, Sql_Type_Data
from Standard.Database.Internal.Result_Set import read_column, result_set_to_table

polyglot java import java.lang.UnsupportedOperationException
polyglot java import java.sql.PreparedStatement

type Connection

    ## PRIVATE

       A Database connection using a JDBC driver.

       Arguments:
       - jdbc_connection: the resource managing the underlying JDBC
         connection.
       - dialect: the dialect associated with the database we are connected to.

       Allows accessing tables from a database.
    Connection_Data jdbc_connection dialect

    ## Closes the connection releasing the underlying database resources
       immediately instead of waiting for them to be automatically released.

       The connection is not usable afterwards.
    close : Nothing
    close self = self.jdbc_connection.close

    ## UNSTABLE

       Accesses a table within the database, returning an object that can be
       used to create queries for that table.

       Arguments:
       - name: name of the table to access
    access_table : Text -> Database_Table
    access_table self name =
        self.jdbc_connection.handle_errors <|
            columns = self.fetch_columns name
            Database_Table.make_table self name columns

    ## Returns the list of databases (or catalogs) for the connection.
    databases : [Text]
    databases self =
        self.jdbc_connection.with_metadata metadata->
            database_result_set = metadata.getCatalogs
            read_column database_result_set "TABLE_CAT"

    ## Returns the name of the current database (or catalog).
    database : Text
    database self =
        self.jdbc_connection.with_connection connection->
            connection.getCatalog

    ## Returns the list of schemas for the connection within the current database (or catalog).
    schemas : [Text]
    schemas self =
        self.jdbc_connection.with_metadata metadata->
            schema_result_set = metadata.getSchemas
            read_column schema_result_set "TABLE_SCHEM"

    ## Returns the name of the current schema.
    schema : Text
    schema self =
        self.jdbc_connection.with_connection connection->
            connection.getSchema

    ## Gets a list of the table types
    table_types : [Text]
    table_types self =
        self.jdbc_connection.with_metadata metadata->
            types_result_set = metadata.getTableTypes
            read_column types_result_set "TABLE_TYPE"

    ## ADVANCED

       Executes a raw query and returns the result as an in-memory Table.

       Arguments:
       - query: either raw SQL code as Text or an instance of Sql.Statement
         representing the query to execute.
       - expected_types: an optional array of expected types of each column;
         meant only for internal use.
    execute_query : Text | Sql.Statement -> Vector Sql.Sql_Type -> Materialized_Table =
    execute_query self query expected_types=Nothing =
        self.jdbc_connection.with_prepared_statement query stmt->
            result_set_to_table stmt.executeQuery expected_types

    ## ADVANCED

       Executes a raw update query. If the query was inserting, updating or
       deleting rows, the number of affected rows is returned; otherwise it
       returns 0 for other types of queries (like creating or altering tables).

       Arguments:
       - query: either raw SQL code as Text or an instance of Sql.Statement
         representing the query to execute.
    execute_update : Text | Sql.Statement -> Integer
    execute_update self query =
        self.jdbc_connection.with_prepared_statement query stmt->
            Panic.catch UnsupportedOperationException stmt.executeLargeUpdate _->
                stmt.executeUpdate

    ## PRIVATE

       A helper function that fetches column names and sql types associated with
       them for a table in the database.

       Arguments:
       - table_name: The name of the table to fetch the column metadata for.
    # fetch_columns : Text -> Vector [Text, Sql_Type]
    fetch_columns : Text -> Vector Any
    fetch_columns self table_name =
        query = IR.Select_All (IR.make_ctx_from table_name)
        compiled = self.dialect.generate_sql query
        self.jdbc_connection.with_prepared_statement compiled stmt->
            rs = stmt.executeQuery
            metadata = rs.getMetaData
            ncols = metadata.getColumnCount
            resolve_column ix =
                name = metadata.getColumnName ix+1
                typeid = metadata.getColumnType ix+1
                typename = metadata.getColumnTypeName ix+1
                [name, Sql_Type_Data typeid typename]
            Vector.new ncols resolve_column

    ## PRIVATE
       UNSTABLE
       This is a prototype function used in our test suites. It may change.

       It creates a new table in the database with the given name (will fail if
       the table already existed), inserts the contents of the provided
       in-memory table and returns a handle to the newly created table.

       Arguments:
       - name: The name of the table to create.
       - table: An In-Memory table specifying the contents to upload. Schema of
         the created database table is based on the column types of this table.
       - temporary: Specifies whether the table should be marked as temporary. A
         temporary table will be dropped after the connection closes and will
         usually not be visible to other connections.
       - batch_size: Specifies how many rows should be uploaded in a single
         batch.
    upload_table : Text -> Materialized_Table -> Boolean -> Integer -> Database_Table
    upload_table self name table temporary=True batch_size=1000 = Panic.recover Illegal_State_Error_Data <|
        column_types = table.columns.map col-> default_storage_type col.storage_type
        column_names = table.columns.map .name
        col_makers = column_names.zip column_types name-> typ->
            Base_Generator.wrap_in_quotes name ++ Sql.code " " ++ Sql.code typ.name
        create_prefix = if temporary then "CREATE TEMPORARY TABLE " else "CREATE TABLE "
        create_sql = (Sql.code create_prefix ++ Base_Generator.wrap_in_quotes name ++ Sql.code " (" ++ (Sql.join ", " col_makers) ++ Sql.code ")").build

        create_table = self.execute_update create_sql
        db_table = if create_table.is_error then create_table else self.access_table name

        if db_table.is_error.not then
            pairs = db_table.internal_columns.map col->[col.name, IR.Constant col.sql_type Nothing]
            db_types = pairs.map p-> p.second.sql_type
            insert_query = self.dialect.generate_sql <| IR.Insert name pairs
            insert_template = insert_query.prepare.first
            self.jdbc_connection.with_connection java_connection->
                default_autocommit = java_connection.getAutoCommit
                java_connection.setAutoCommit False
                Resource.bracket Nothing (_ -> java_connection.setAutoCommit default_autocommit) _->
                    Resource.bracket (java_connection.prepareStatement insert_template) .close stmt->
                        num_rows = table.row_count
                        columns = table.columns
                        check_rows updates_array expected_size =
                            updates = Vector.Vector updates_array
                            if updates.length != expected_size then Panic.throw <| Illegal_State_Error "The batch update unexpectedly affected "+updates.length.to_text+" rows instead of "+expected_size.to_text+"." else
                                updates.each affected_rows->
                                    if affected_rows != 1 then
                                        Panic.throw <| Illegal_State_Error "A single update within the batch unexpectedly affected "+affected_rows.to_text+" rows."
                        0.up_to num_rows . each row_id->
                            values = columns.map col-> col.at row_id
                            holes = values.zip db_types
                            set_statement_values stmt holes
                            stmt.addBatch
                            if (row_id+1 % batch_size) == 0 then check_rows stmt.executeBatch batch_size
                        if (num_rows % batch_size) != 0 then check_rows stmt.executeBatch (num_rows % batch_size)
                    java_connection.commit

        db_table

## PRIVATE

   Creates a builder for a column based on a provided SQL type, trying to infer
   the best type for the builder.

   Arguments:
   - sql_type: The SQL type of the column to create a builder for.
create_builder : Sql_Type -> Builder
create_builder sql_type =
    initial_size = 10
    if sql_type.is_definitely_boolean then Builder_Boolean (Java_Exports.make_bool_builder) else
        if sql_type.is_definitely_integer then Builder_Long (Java_Exports.make_long_builder initial_size) else
            if sql_type.is_definitely_double then Builder_Double (Java_Exports.make_double_builder initial_size) else
                Builder_Inferred (Java_Exports.make_inferred_builder initial_size)

type Builder

    ## PRIVATE

       A builder that has an inferred column type at runtime.

       Arguments:
       - java_builder: The underlying builder object.
    Builder_Inferred java_builder

    ## PRIVATE

       A builder that has an inferred column type at runtime.

       Arguments:
       - java_builder: The underlying builder object.
    Builder_Double java_builder

    ## PRIVATE

       A builder that has an inferred column type at runtime.

       Arguments:
       - java_builder: The underlying builder object.
    Builder_Long java_builder

    ## PRIVATE

       A builder that has an inferred column type at runtime.

       Arguments:
       - java_builder: The underlying builder object.
    Builder_Boolean java_builder

    ## PRIVATE

       Fetches the value of ith column from the current row of the result set
       and appends it to the builder.

       Arguments:
       - rs: the Java ResultSet from which the value will be fetched.
       - i: the index of the column to fetch from (starting from 1 as is the
         ResultSet convention).
    fetch_and_append : ResultSet -> Integer -> Nothing
    fetch_and_append self rs i = case self of
        Builder_Inferred _ ->
            obj = rs.getObject i
            self.java_builder.append obj
        Builder_Boolean _ ->
            bool = rs.getBoolean i
            case rs.wasNull of
                True -> self.java_builder.appendNulls 1
                False -> self.java_builder.appendBoolean bool
        Builder_Long _ ->
            long = rs.getLong i
            case rs.wasNull of
                True -> self.java_builder.appendNulls 1
                False -> self.java_builder.appendLong long
        Builder_Double _ ->
            double = rs.getDouble i
            case rs.wasNull of
                True -> self.java_builder.appendNulls 1
                False -> self.java_builder.appendDouble double

    ## PRIVATE

       Seals the builder and returns a built Java-column.

       Argument:
       - name: The name of the column.
    make_column : Text -> Java_Exports.Column
    make_column self name =
        storage = self.java_builder.seal
        Java_Exports.make_column name storage

## PRIVATE
   Returns the default database type corresponding to an in-memory storage
   type.
default_storage_type : Storage.Type -> Sql_Type
default_storage_type storage_type = case storage_type of
    Storage.Text -> Sql_Type.text
    Storage.Integer -> Sql_Type.integer
    Storage.Decimal -> Sql_Type.double
    Storage.Boolean -> Sql_Type.boolean
    ## Support for mixed type columns in Table upload is currently very limited,
       falling back to treating everything as text.
    Storage.Any -> Sql_Type.text

## PRIVATE
   Sets values inside of a prepared statement.
set_statement_values : PreparedStatement -> Vector (Pair Any Sql_Type) -> Nothing
set_statement_values stmt holes =
    holes.map_with_index ix-> obj->
        position = ix + 1
        case obj.first of
            Nothing -> stmt.setNull position obj.second.typeid
            _ -> stmt.setObject position obj.first
