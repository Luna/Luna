from Standard.Base import all

import Standard.Base.Runtime.Resource

import Standard.Database.Data.Internal.IR
import Standard.Database.Data.Sql
import Standard.Database.Data.Table as Database_Table
import Standard.Table.Data.Table as Materialized_Table

from Standard.Database.Data.Sql import Sql_Type, Sql_Type_Data
from Standard.Database.Internal.JDBC_Connection import create_table_statement
from Standard.Database.Internal.Result_Set import read_column, result_set_to_table

polyglot java import java.lang.UnsupportedOperationException


type Connection

    ## PRIVATE

       A Database connection using a JDBC driver.

       Arguments:
       - jdbc_connection: the resource managing the underlying JDBC
         connection.
       - dialect: the dialect associated with the database we are connected to.

       Allows accessing tables from a database.
    Connection_Data jdbc_connection dialect

    ## Closes the connection releasing the underlying database resources
       immediately instead of waiting for them to be automatically released.

       The connection is not usable afterwards.
    close : Nothing
    close self = self.jdbc_connection.close

    ## UNSTABLE

       Accesses a table within the database, returning an object that can be
       used to create queries for that table.

       Arguments:
       - name: name of the table to access
    access_table : Text -> Database_Table
    access_table self name =
        self.jdbc_connection.handle_errors <|
            columns = self.fetch_columns name
            Database_Table.make_table self name columns

    ## Returns the list of databases (or catalogs) for the connection.
    databases : [Text]
    databases self =
        self.jdbc_connection.with_metadata metadata->
            read_column metadata.getCatalogs "TABLE_CAT"

    ## Returns the name of the current database (or catalog).
    database : Text
    database self =
        self.jdbc_connection.with_connection connection->connection.getCatalog

    ## Returns the list of schemas for the connection within the current database (or catalog).
    schemas : [Text]
    schemas self =
        self.jdbc_connection.with_metadata metadata->
            read_column metadata.getSchemas "TABLE_SCHEM"

    ## Returns the name of the current schema.
    schema : Text
    schema self =
        self.jdbc_connection.with_connection connection->
            connection.getSchema

    ## Gets a list of the table types
    table_types : [Text]
    table_types self =
        self.jdbc_connection.with_metadata metadata->
            types_result_set = metadata.getTableTypes
            read_column types_result_set "TABLE_TYPE"

    ## ADVANCED

       Executes a raw query and returns the result as an in-memory Table.

       Arguments:
       - query: either raw SQL code as Text or an instance of Sql.Statement
         representing the query to execute.
       - expected_types: an optional array of expected types of each column;
         meant only for internal use.
    execute_query : Text | Sql.Statement -> Vector Sql.Sql_Type -> Materialized_Table =
    execute_query self query expected_types=Nothing =
        self.jdbc_connection.with_prepared_statement query stmt->
            result_set_to_table stmt.executeQuery expected_types

    ## ADVANCED

       Executes a raw update query. If the query was inserting, updating or
       deleting rows, the number of affected rows is returned; otherwise it
       returns 0 for other types of queries (like creating or altering tables).

       Arguments:
       - query: either raw SQL code as Text or an instance of Sql.Statement
         representing the query to execute.
    execute_update : Text | Sql.Statement -> Integer
    execute_update self query =
        self.jdbc_connection.with_prepared_statement query stmt->
            Panic.catch UnsupportedOperationException stmt.executeLargeUpdate _->
                stmt.executeUpdate

    ## PRIVATE

       A helper function that fetches column names and sql types associated with
       them for a table in the database.

       Arguments:
       - table_name: The name of the table to fetch the column metadata for.
    # fetch_columns : Text -> Vector [Text, Sql_Type]
    fetch_columns : Text -> Vector Any
    fetch_columns self table_name =
        query = IR.Select_All (IR.make_ctx_from table_name)
        compiled = self.dialect.generate_sql query
        self.jdbc_connection.with_prepared_statement compiled stmt->
            rs = stmt.executeQuery
            metadata = rs.getMetaData
            ncols = metadata.getColumnCount
            resolve_column ix =
                name = metadata.getColumnName ix+1
                typeid = metadata.getColumnType ix+1
                typename = metadata.getColumnTypeName ix+1
                [name, Sql_Type_Data typeid typename]
            Vector.new ncols resolve_column

    ## PRIVATE
       UNSTABLE
       This is a prototype function used in our test suites. It may change.

       It creates a new table in the database with the given name (will fail if
       the table already existed), inserts the contents of the provided
       in-memory table and returns a handle to the newly created table.

       Arguments:
       - name: The name of the table to create.
       - table: An In-Memory table specifying the contents to upload. Schema of
         the created database table is based on the column types of this table.
       - temporary: Specifies whether the table should be marked as temporary. A
         temporary table will be dropped after the connection closes and will
         usually not be visible to other connections.
       - batch_size: Specifies how many rows should be uploaded in a single
         batch.
    upload_table : Text -> Materialized_Table -> Boolean -> Integer -> Database_Table
    upload_table self name table temporary=True batch_size=1000 = Panic.recover Illegal_State_Error_Data <|
        create_sql = create_table_statement name table temporary
        create_table = self.execute_update create_sql
        db_table = if create_table.is_error then create_table else self.access_table name

        if db_table.is_error.not then
            pairs = db_table.internal_columns.map col->[col.name, IR.Constant col.sql_type Nothing]
            db_types = pairs.map p-> p.second.sql_type
            insert_query = self.dialect.generate_sql <| IR.Insert name pairs
            insert_template = insert_query.prepare.first
            self.jdbc_connection.with_connection java_connection->
                default_autocommit = java_connection.getAutoCommit
                java_connection.setAutoCommit False
                Resource.bracket Nothing (_ -> java_connection.setAutoCommit default_autocommit) _->
                    Resource.bracket (java_connection.prepareStatement insert_template) .close stmt->
                        num_rows = table.row_count
                        columns = table.columns
                        check_rows updates_array expected_size =
                            updates = Vector.Vector updates_array
                            if updates.length != expected_size then Panic.throw <| Illegal_State_Error "The batch update unexpectedly affected "+updates.length.to_text+" rows instead of "+expected_size.to_text+"." else
                                updates.each affected_rows->
                                    if affected_rows != 1 then
                                        Panic.throw <| Illegal_State_Error "A single update within the batch unexpectedly affected "+affected_rows.to_text+" rows."
                        0.up_to num_rows . each row_id->
                            values = columns.map col-> col.at row_id
                            holes = values.zip db_types
                            set_statement_values stmt holes
                            stmt.addBatch
                            if (row_id+1 % batch_size) == 0 then check_rows stmt.executeBatch batch_size
                        if (num_rows % batch_size) != 0 then check_rows stmt.executeBatch (num_rows % batch_size)
                    java_connection.commit

        db_table

