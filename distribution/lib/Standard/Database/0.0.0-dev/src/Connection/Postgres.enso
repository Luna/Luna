from Standard.Base import all

import Standard.Base.System.Platform

import Standard.Database.Data.Dialect
import Standard.Database.Connection.Connection
from Standard.Database.Connection.Credentials as Credentials_Module import Credentials
import Standard.Database.Connection.Connection_Options
import Standard.Database.Connection.SSL_Mode
from Standard.Database.Connection.SSL_Mode import all
import Standard.Database.Connection.Client_Certificate
import Standard.Base.System.File.Posix_File_Permission

polyglot java import org.postgresql.Driver

type Postgres
    ## Connect to a PostgreSQL database.

       Arguments:
       - host: The hostname of the database server (defaults to localhost).
       - port: The port of the database server (defaults to 5432).
       - database: The database to connect to. If empty, the default database will be used.
       - credentials: The credentials to use for the connection (defaults to PGPass or No Authentication).
       - use_ssl: Whether to use SSL (defaults to `Prefer`).
       - client_cert: The client certificate to use or `Nothing` if not needed.
    type Postgres (host:Text='localhost') (port:Integer=5432) (database:Text='') (credentials:(Credentials|Nothing)=Nothing) (use_ssl:SSL_Mode=Prefer) (client_cert:(Client_Certificate|Nothing)=Nothing)

    ## Build the Connection resource.

       Arguments:
       - options: Overrides for the connection properties.
    connect : Connection_Options
    connect options =
        if Driver.isRegistered.not then Driver.register

        properties = options.merge self.jdbc_properties
        Connection.create_jdbc_connection self.jdbc_url properties self.dialect

    ## Provides the jdbc url for the connection.
    jdbc_url : Text
    jdbc_url =
        'jdbc:postgresql://' + self.host + ':' + self.port.to_text + (if self.database == '' then '' else '/' + self.database)

    ## Provides the properties for the connection.
    jdbc_properties : [Pair Text Text]
    jdbc_properties =
        # TODO env vars
        credentials = case self.credentials of
            Nothing -> read_pgpass self.host self.port self.database
            Credentials username password ->
                [Pair 'user' username, Pair 'password' password]

        ssl_properties = ssl_mode_to_jdbc_properties self.use_ssl

        cert_properties = if self.client_cert.is_nothing then [] else
            self.client_cert.properties

        credentials + ssl_properties + cert_properties

    ## Provides the dialect needed for creating SQL statements.
    dialect : Dialect
    dialect = Dialect.postgres

## PRIVATE
   Read the .pgpass file from the User's home directory and obtain username
   and password.

   See https://www.postgresql.org/docs/current/libpq-pgpass.html

   On Windows this file is expected to be located at
   `%APPDATA%\postgresql\pgpass.conf`.
   On Linux and macOS this file is expected to be located at `~/.pgpass` and
   it is should be inaccessible by other users and the group - otherwise it
   will be ignored. This can be achieved by running `chmod 0600 ~/.pgpass`.

   If `PGPASSFILE` environment variable is set, the provided location is
   used instead of the default one.

   Arguments:
   - host: The hostname of the database server.
   - port: The port of the database server.
   - database: The database to connect to.
read_pgpass : Text -> Integer -> Text -> [Pair Text Text]
read_pgpass host port database =
    pgpass_file = locate_pgpass
    if pgpass_file.is_nothing || (verify_pgpass pgpass_file . not) then [] else
        entries = parse_pgpass pgpass_file
        # TODO possibly? determine username from env
        found = entries.find entry->
            entry.matches host port database
        case found.catch Nothing of
            Nothing -> []
            Just entry -> [Pair 'user' entry.username, Pair 'password' entry.password]

type Pgpass_Entry
    ## PRIVATE
    type Pgpass_Entry host port database username password

    ## PRIVATE
    matches : Text -> Integer -> Text -> Text -> Boolean
    matches host port database username=Nothing =
        wildcard='*'
        host_match = self.host==wildcard || self.host==host
        port_match = self.port==wildcard || self.port==port
        database_match = self.database==wildcard || self.database==database
        username_match = username==Nothing || self.username==wildcard || self.username=username
        host_match && port_match && database_match && username_match

## PRIVATE
   Determines the location of the .pgpass file to use.
locate_pgpass = case Environment.get "PGPASSFILE" of
    path -> File.new path
    Nothing -> case Platform.os of
        Platform.Windows -> case Environment.get "APPDATA" of
            Nothing -> Nothing
            appdata -> File.new appdata / "postgresql" / "pgpass.conf"
        _ -> case Environment.get "HOME" of
            Nothing -> Nothing
            home -> File.new home / ".pgpass"

## PRIVATE
   Checks if the given .pgpass file can be used.

   The file can be used if it exists and has correct permissions on UNIX systems.
verify_pgpass file = case Platform.os of
    Platform.Windows -> file.exists
    _ -> case file.exists of
        False -> False
        True ->
            permissions = file.posix_permissions
            owner_only = [Posix_File_Permission.Owner_Read, Posix_File_Permission.Owner_Write, Posix_File_Permission.Owner_Execute]
            only_owner_can_access = permissions.all owner_only.contains
            only_owner_can_access

## PRIVATE
parse_pgpass file =
    parse line =
        if line.starts_with "#" || line.is_empty then Nothing else
            # TODO
            Nothing

    File.read_text file . lines . map parse . filter (x -> x.is_nothing.not)

## PRIVATE
   Given an `SSL_Mode`, create the JDBC properties to secure a Postgres-based
   connection.
ssl_mode_to_jdbc_properties : SSL_Mode -> [Pair Text Text]
ssl_mode_to_jdbc_properties use_ssl = case use_ssl of
    Disable -> []
    Prefer -> [Pair 'sslmode' 'prefer']
    Require -> [Pair 'sslmode' 'require']
    Verify_CA cert_file ->
        if cert_file.is_nothing then [Pair 'sslmode' 'verify-ca'] else
            [Pair 'sslmode' 'verify-ca', Pair 'sslrootcert' (File.new cert_file).absolute.path]
    Full_Verification cert_file ->
        if cert_file.is_nothing then [Pair 'sslmode' 'verify-full'] else
            [Pair 'sslmode' 'verify-full', Pair 'sslrootcert' (File.new cert_file).absolute.path]
