import project.Any.Any
import project.Data.Array_Proxy.Array_Proxy
import project.Data.Numbers.Integer
import project.Data.Text.Encoding.Encoding
import project.Data.Text.Text
import project.Data.Vector.Vector
import project.Error.Error
import project.Errors.Common.Index_Out_Of_Bounds
import project.Errors.File_Error.File_Error
import project.Nothing.Nothing
import project.System.File.File
from project.Data.Boolean import Boolean, False, True
from project.Data.Range.Extensions import all
from project.Data.Text.Extensions import all

polyglot java import java.io.RandomAccessFile
polyglot java import org.enso.base.Array_Utils
polyglot java import org.enso.base.arrays.IntArrayBuilder
polyglot java import org.enso.base.arrays.LongArrayList
polyglot java import java.util.logging.Logger

type File_By_Line
    ## PUBLIC
       Creates a new File_By_Line object.

       Arguments
       - file: The file to read.
       - encoding: The encoding to use when reading the file (defaults to UTF 8).
       - limit: The number of lines to read (defaults to all lines).
    new : File->Encoding->File_By_Line
    new file:File encoding:Encoding=Encoding.utf_8 =
        File_By_Line.Reader file encoding Nothing Nothing (create_row_map 0)

    ## PRIVATE
       Creates a new File_By_Line object.

       Arguments
       - file: The file to read.
       - encoding: The encoding to use when reading the file (defaults to UTF 8).
       - limit_lines: The number of lines to read (defaults to all lines).
       - filter_func: The filter to apply to each line (defaults to no filter).
       - row_map: The row map to use (defaults to a new row map).
    Reader file:File encoding:Encoding limit_lines:(Integer|Nothing) filter_func ~row_map

    ## Reads a specific line from the file.

       Arguments
       - line: The line to read (0 indexed).
    get : Integer->Text
    get self line:Integer = if self.limit_lines.is_nothing.not && line>self.limit_lines then Error.throw (Index_Out_Of_Bounds.Error line self.limit_lines) else
        read_line self line

    ## Reads the first line
    first : Text
    first self = self.get 0

    ## Reads the first line
    second : Text
    second self = self.get 1

    ## Transforms each line in the file and returns the result as a vector.

       Arguments
       - action: The action to perform on each line.
    map : (Text -> Any) -> Vector Any
    map self action =
        builder = Vector.new_builder
        wrapped_action t = builder.append (action t)
        for_each_lines self 0 self.limit_lines wrapped_action
        builder.to_vector

    ## Skips the specified number of lines.

       Arguments
       - lines: The number of lines to skip.
    skip : Integer -> File_By_Line
    skip self lines:Integer =
        lazy_scanner parent line =
            parent.get line
            position = parent.row_map.get line
            row_map = LongArrayList.new
            row_map.add position
            log "Created Skipped Parent"
            row_map

        new_limit = if self.limit_lines.is_nothing then Nothing else (self.limit_lines - lines).max 0
        File_By_Line.Reader self.file self.encoding new_limit self.filter_func (lazy_scanner self lines)

    ## Limits a file to a specific number of lines.

       Arguments
       - lines: The number of lines to limit the file to.
    limit : Integer -> File_By_Line
    limit self lines:Integer =
        File_By_Line.Reader self.file self.encoding lines self.filter_func self.row_map

    ## Filters the file by a predicate.

       Arguments
       - predicate: The predicate to filter by.
    filter : (Text -> Boolean) -> File_By_Line
    filter self predicate =
        ## Merge the two predicates together.
        new_predicate = if self.filter_func.is_nothing then predicate else (text -> self.filter_func text && predicate text)

        ## Need to ensure the parent limit is obeyed - for now we just use it but should be applied on level above
        File_By_Line.Reader self.file self.encoding self.limit_lines new_predicate self.row_map

    ## ADVANCED
       Exports the row_map
    row_positions : Vector Integer
    row_positions self = Vector.from_polyglot_array <|
        Array_Proxy.new self.row_map.getSize (i-> self.row_map.get i)

## PRIVATE
   Creates a default row_map
create_row_map : Integer -> LongArrayList
create_row_map position:Integer =
    row_map = LongArrayList.new
    row_map.add position
    log "Created row map"
    row_map

## PRIVATE
   Reads a specific line from the file.
read_line : File_By_Line->Integer->Any->Any
read_line file:File_By_Line line:Integer=0 ~default=Nothing = File_Error.handle_java_exceptions file.file <|
    raf = RandomAccessFile.new file.file.path "r"
    scan_file raf file.row_map line line file.encoding file.filter_func Nothing
    result = if raf.getFilePointer >= raf.length then default else Text.from_bytes (file_read_line raf) file.encoding
    raf.close
    result

## PRIVATE
   Performs an action on each line in the file.
for_each_lines : File_By_Line->Integer->Any->Any
for_each_lines file:File_By_Line start_at:Integer end_at:Integer action = File_Error.handle_java_exceptions file.file <|
    raf = RandomAccessFile.new file.file.path "r"
    scan_file raf file.row_map start_at end_at file.encoding file.filter_func action
    raf.close

## PRIVATE
   Scanner for reading a file line by line and performing an action
scan_file raf:RandomAccessFile row_map:LongArrayList start_at:Integer end_at:Integer encoding:Encoding filter step_action =
    ## First if we haven't read the found the start_at line we need to find that.
    file_scan_lines raf row_map start_at start_at encoding filter

    ## Now we can read the lines we need.
    if raf.getFilePointer >= raf.length then Error.throw (Index_Out_Of_Bounds.Error start_at -1) else
        file_scan_lines raf row_map start_at end_at encoding filter step_action

## PRIVATE
   Reads a line line by line.
   Leaves the file pointer at the start of the end_at line.
file_scan_lines : RandomAccessFile -> LongArrayList -> Integer -> Integer | Nothing -> Encoding -> ((Text -> Boolean) | Nothing) -> ((Text -> Any) | Nothing) -> Any
file_scan_lines raf:RandomAccessFile row_map:LongArrayList start_at:Integer end_at:(Integer|Nothing) encoding:Encoding filter action=Nothing =
    start_position = if start_at < row_map.getSize then row_map.get start_at else
         file_scan_lines raf row_map row_map.getSize-1 start_at encoding filter
         row_map.get start_at

    file_length = raf.length
    raf.seek start_position

    do_step i = case raf.getFilePointer >= file_length of
        True ->
            if end_at.is_nothing.not then i.up_to end_at _-> row_map.add raf.getFilePointer
            Nothing
        False ->
            valid = case i < row_map.getSize of
                True -> if action.is_nothing then raf.seek (row_map.get i) else
                    end_position = row_map.get i
                    action (Text.from_bytes (file_read_line raf) encoding (end_position-raf.getFilePointer))
                    raf.seek end_position
                False ->
                    collect = filter.is_nothing.not || action.is_nothing.not
                    bytes = file_read_line raf collect
                    text = if collect then Nothing else Text.from_bytes bytes encoding
                    result = filter.is_nothing || (filter text)
                    if result.not then False else
                        row_map.add raf.getFilePointer
                        action.if_not_nothing (action text)
                        Nothing
            if end_at.is_nothing || i < end_at then @Tail_Call do_step (i+(if valid.is_nothing then 1 else 0)) else Nothing

    if start_at < end_at then do_step start_at

## PRIVATE
   Reads a single line from a file as raw bytes
   Same as readLine but allows for handling encoding afterwards.
file_read_line : RandomAccessFile -> Boolean -> Integer -> Vector Integer | Nothing
file_read_line raf:RandomAccessFile collect:Boolean=True capacity:Integer=32 =
    find_next_line raf append =
        char = raf.read
        case char of
            -1 -> Nothing
            10 -> Nothing
            13 ->
                if raf.read != 10 then raf.seek raf.getFilePointer-1
                Nothing
            _ ->
                append char
                @Tail_Call find_next_line raf append
    if collect.not then find_next_line raf _->Nothing else
        builder = IntArrayBuilder.new capacity
        find_next_line raf (i-> builder.add i)
        builder.build

## PRIVATE
   Log a message.
log : Text -> Log_Level -> Nothing
log message:Text level:Log_Level=Log_Level.Info =
    logger = Logger.getLogger "enso-std-base-file_by_line"
    case level of
        Log_Level.Finest -> logger.finest message
        Log_Level.Fine -> logger.fine message
        Log_Level.Info -> logger.info message
        Log_Level.Warning -> logger.warning message
        Log_Level.Severe -> logger.severe message
    Nothing

## PRIVATE
type Log_Level
    ## Finest (Trace) level log message.
    Finest

    ##  Fine (Debug) level log message.
    Fine

    ## Info level log message.
    Info

    ## Warning level log message.
    Warning

    ## Severe level log message.
    Severe
