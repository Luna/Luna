import project.Any.Any
import project.Data.Array_Proxy.Array_Proxy
import project.Data.Numbers.Integer
import project.Data.Text.Encoding.Encoding
import project.Data.Text.Text
import project.Data.Vector.Vector
import project.Error.Error
import project.Errors.Common.Index_Out_Of_Bounds
import project.Errors.File_Error.File_Error
import project.Nothing.Nothing
import project.System.File.File
from project.Data.Boolean import Boolean, False, True
from project.Data.Range.Extensions import all
from project.Data.Text.Extensions import all
from project.Logging import all

polyglot java import java.io.RandomAccessFile
polyglot java import org.enso.base.Array_Utils
polyglot java import org.enso.base.arrays.IntArrayBuilder
polyglot java import org.enso.base.arrays.LongArrayList
polyglot java import org.enso.base.File_Utils

type File_By_Line
    ## PUBLIC
       Creates a new File_By_Line object.

       Arguments
       - file: The file to read.
       - encoding: The encoding to use when reading the file (defaults to UTF 8).
       - offset: The position within the file to read from (defaults to first byte).
    new : File->Encoding->File_By_Line
    new file:File encoding:Encoding=Encoding.utf_8 offset:Integer=0 =
        create_row_map =
            row_map = LongArrayList.new
            row_map.add offset
            File_By_Line.log "Created row map"
            row_map
        File_By_Line.Reader file encoding Nothing Nothing create_row_map

    ## PRIVATE
       Creates a new File_By_Line object.

       Arguments
       - file: The file to read.
       - encoding: The encoding to use when reading the file (defaults to UTF 8).
       - limit_lines: The number of lines to read (defaults to all lines).
       - filter_func: The filter to apply to each line (defaults to no filter).
       - row_map: The row map to use (defaults to a new row map).
    Reader file:File encoding:Encoding limit_lines:(Integer|Nothing) filter_func row_map

    ## Reads a specific line from the file.

       Arguments
       - line: The line to read (0 indexed).
    get : Integer->Text
    get self line:Integer = if self.limit_lines.is_nothing.not && line>self.limit_lines then Error.throw (Index_Out_Of_Bounds.Error line self.limit_lines) else
        read_line self line

    ## Reads the first line
    first : Text
    first self = self.get 0

    ## Reads the first line
    second : Text
    second self = self.get 1

    ## Counts the number of lines in the file.
    count : Integer
    count self =
        end_at = if self.limit_lines.is_nothing then Nothing else self.limit_lines
        for_each_lines self 0 end_at Nothing
        ## We've added all the indexes to the row map including the last one so we need to subtract 1
           As row_map can be shared if we have a limit return that.
        end_at.min self.row_map.getSize-1

    ## Returns the lines in the file as a vector.
    to_vector : Vector Text
    to_vector self = self.map x->x

    ## Performs an action on each line.

       Arguments
       - function: The action to perform on each line.
    each : (Text -> Any) -> Nothing
    each self function =
        new_function _ t = function t
        self.each_with_index new_function

    ## Performs an action on each line.

       Arguments
       - function: The action to perform on each line.
    each_with_index : (Integer -> Text -> Any) -> Nothing
    each_with_index self function =
        end_at = if self.limit_lines.is_nothing then Nothing else self.limit_lines-1
        for_each_lines self 0 end_at function

    ## Transforms each line in the file and returns the result as a vector.

       Arguments
       - action: The action to perform on each line.
    map : (Text -> Any) -> Vector Any
    map self action =
        builder = Vector.new_builder
        wrapped_action t = builder.append (action t)
        self.each wrapped_action
        builder.to_vector

    ## Skips the specified number of lines.

       Arguments
       - lines: The number of lines to skip.
    skip : Integer -> File_By_Line
    skip self lines:Integer =
        ## Read the line
        position = if self.row_map.getSize > lines then self.row_map.get lines else
            for_each_lines self 0 lines Nothing
            self.row_map.get self.row_map.getSize-1
        row_map = LongArrayList.new
        row_map.add position
        self.log "Created Skipped Parent"

        new_limit = if self.limit_lines.is_nothing then lines else lines.min self.limit_lines
        File_By_Line.Reader self.file self.encoding new_limit self.filter_func row_map

    ## Limits a file to a specific number of lines.

       Arguments
       - lines: The number of lines to limit the file to.
    limit : Integer -> File_By_Line
    limit self lines:Integer =
        File_By_Line.Reader self.file self.encoding lines self.filter_func self.row_map

    ## Filters the file by a predicate.

       Arguments
       - predicate: The predicate to filter by.
    filter : (Text -> Boolean) -> File_By_Line
    filter self predicate =
        ## Merge the two predicates together.
        new_predicate = if self.filter_func.is_nothing then predicate else (text -> self.filter_func text && predicate text)

        ## Need to ensure the parent limit is obeyed - for now we just use it but should be applied on level above
        File_By_Line.Reader self.file self.encoding self.limit_lines new_predicate self.row_map

    ## ADVANCED
       Exports the row_map
    row_positions : Vector Integer
    row_positions self = Vector.from_polyglot_array <|
        Array_Proxy.new self.row_map.getSize (i-> self.row_map.get i)

## PRIVATE
   Reads a specific line from the file.
read_line : File_By_Line->Integer->Any->Any
read_line file:File_By_Line line:Integer=0 ~default=Nothing = File_Error.handle_java_exceptions file.file <|
    raf = RandomAccessFile.new file.file.path "r"
    scan_file raf file.row_map line line file.encoding file.filter_func Nothing
    result = if raf.getFilePointer >= raf.length then default else File_Utils.readLine raf file.encoding.to_java_charset
    raf.close
    result

## PRIVATE
   Performs an action on each line in the file.
for_each_lines : File_By_Line->Integer->(Integer|Nothing)->Any->Any
for_each_lines file:File_By_Line start_at:Integer end_at:(Integer|Nothing) action = File_Error.handle_java_exceptions file.file <|
    raf = RandomAccessFile.new file.file.path "r"
    scan_file raf file.row_map start_at end_at file.encoding file.filter_func action
    raf.close

## PRIVATE
   Scanner for reading a file line by line and performing an action
scan_file raf:RandomAccessFile row_map:LongArrayList start_at:Integer end_at:(Integer|Nothing) encoding:Encoding filter step_action =
    ## First if we haven't read the found the start_at line we need to find that.
    if start_at < row_map.getSize then raf.seek (row_map.get start_at) else
        file_scan_lines raf row_map start_at start_at encoding filter

    ## Now we can read the lines we need.
    if raf.getFilePointer >= raf.length then Error.throw (Index_Out_Of_Bounds.Error start_at row_map.getSize) else
        file_scan_lines raf row_map start_at end_at encoding filter step_action

## PRIVATE
   Reads a line line by line.
   Leaves the file pointer at the start of the end_at line.
file_scan_lines : RandomAccessFile -> LongArrayList -> Integer -> Integer | Nothing -> Encoding -> ((Text -> Boolean) | Nothing) -> ((Text -> Any) | Nothing) -> Nothing
file_scan_lines raf:RandomAccessFile row_map:LongArrayList start_at:Integer end_at:(Integer|Nothing) encoding:Encoding filter action=Nothing =
    if start_at >= row_map.getSize then file_scan_lines raf row_map row_map.getSize-1 start_at encoding filter

    ## If no action to apply start at the last known index
    effective_start = if action.is_nothing then start_at.max row_map.getSize-1 else start_at

    ## Move file to correct location
    start_position = row_map.get (if effective_start >= row_map.getSize then row_map.getSize-1 else effective_start)
    file_length = raf.length
    raf.seek start_position

    ## If no filter or action, then do all the scanning in Java and just expand the row_map.
    if filter.is_nothing && action.is_nothing then File_Utils.scanLines raf row_map end_at else
        charset = encoding.to_java_charset

        ## Run the ones we know already
        if action.is_nothing.not then
            existing_end = if end_at.is_nothing then row_map.getSize else (end_at+1).min row_map.getSize
            effective_start.up_to existing_end . each i->
                position = row_map.get i
                if position < file_length then
                    raf.seek (row_map.get i)
                    action i (File_Utils.readLine raf charset)
                    if (i+1)==row_map.getSize then row_map.add raf.getFilePointer

        ## Run from where we were
        do_step i = if raf.getFilePointer >= file_length then Nothing else
            text = File_Utils.readLine raf charset
            valid = i < row_map.getSize || filter.is_nothing || (filter text)
            if valid.not then @Tail_Call do_step i else
                if i%100000==0 then File_By_Line.log "Scanned line: "+(i.to_text)
                row_map.add raf.getFilePointer
                action.if_not_nothing (action i text)
                if end_at.is_nothing || i+1<=end_at then @Tail_Call do_step (i+1)
        if end_at.is_nothing || row_map.getSize<=end_at then do_step row_map.getSize-1
