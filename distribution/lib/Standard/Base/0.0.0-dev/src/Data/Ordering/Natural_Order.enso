from Standard.Base import all

import Standard.Base.Data.Text.Regex
import Standard.Base.Data.Text.Regex.Mode
import Standard.Base.Data.Ordering.Vector_Lexicographic_Order

polyglot java import org.enso.base.Text_Utils
polyglot java import com.ibm.icu.text.BreakIterator

## Compares two text values according to the natural dictionary ordering.

   > Example
     Compare two texts according to the natural dictionary ordering.

         Natural_Order.compare "a2" "a100" == Ordering.Less

   > Example
     Sort a vector of texts according to the natural dictionary ordering.

         ["a2", "a1", "a100", "a001", "a0001"].sort by=Natural_Order.compare . should_equal ["a0001", "a001", "a1", "a2", "a100"]
compare : Text -> Text -> Ordering
compare text1 text2 =
    iter1 = BreakIterator.getCharacterInstance
    iter1.setText text1

    iter2 = BreakIterator.getCharacterInstance
    iter2.setText text2

    is_digit=c -> c>=48 && c<=57

    get_number text prev next iter =
        find_number text next iter =
            new_next = iter.next
            if (new_next == -1) then -next else
                substring = Text_Utils.substring text next new_next
                c = Text_Utils.get_chars substring . at 0
                if (is_digit c).not then next else
                    @Tail_Call find_number text new_next iter

        n = find_number text next iter
        s = Text_Utils.substring text prev n.abs
        
        ## TODO [RW] Currently there is no `Integer.parse` method, so we
               parse a decimal and convert it to an integer. Once
               https://www.pivotaltracker.com/story/show/181176522 is
               implemented, this should be changed to use `Integer.parse`.        
        d = Decimal.parse s . floor

        i = if n < 0 then -1 else iter.current
        [s, d, n, i]


    ## Ordering: Nothing < Number < Text
    order prev1 next1 prev2 next2 =
        case (next1 == -1) of
            True ->
                if (next2 == -1) then Ordering.Equal else Ordering.Less
            False ->
                if (next2 == -1) then Ordering.Greater else
                    s1 = Text_Utils.substring text1 prev1 next1
                    c1 = Text_Utils.get_chars s1 . at 0

                    s2 = Text_Utils.substring text2 prev2 next2
                    c2 = Text_Utils.get_chars s2 . at 0

                    case (is_digit c1) of
                        True ->
                            if (is_digit c2).not then Ordering.Less else
                                a1 = get_number text1 prev1 next1 iter1
                                a2 = get_number text2 prev2 next2 iter2

                                if (a1.at 1) != (a2.at 1) then (a1.at 1).compare_to (a2.at 1) else
                                    if (a1.at 0) != (a2.at 0) then (a1.at 0).compare_to (a2.at 0) else
                                        @Tail_Call order (a1.at 2) (a1.at 3) (a2.at 2) (a2.at 3)
                        False ->
                            if (is_digit c2) then Ordering.Greater else
                                if s2 != s1 then s1.compare_to s2 else
                                    @Tail_Call order next1 iter1.next next2 iter2.next

    order 0 iter1.next 0 iter2.next
