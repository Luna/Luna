import project.Any.Any
import project.Data.Numeric.Math_Context.Math_Context
import project.Data.Numeric.Rounding_Mode.Rounding_Mode
import project.Data.Text.Text
import project.Error.Error
import project.Errors.Illegal_Argument.Illegal_Argument
import project.IO
import project.Meta
import project.Nothing.Nothing
import project.Panic.Panic
import project.Warning.Warning
from project.Data.Boolean import Boolean, False, True
from project.Data.Numbers import Integer, Float, Number_Parse_Error
from project.Errors.Common import Loss_Of_Numeric_Precision

polyglot java import java.lang.NumberFormatException
polyglot java import java.math.BigDecimal
polyglot java import org.enso.base.numeric.Decimal_Utils

## Decimal is the type of decimal (base-10-scaled) nubmers in Enso. An Enso
   `Decimal` is a wrapper around a Java `BigDecimal`.
type Decimal
    Value (big_decimal:BigDecimal)

    ## Construct a `Decimal` from a string or integer.

       Arguments:
       - x: The `Text`, `Integer`, or `Float` to construct a `Decimal` from.
       - mc: The `Math_Context` to use to specify precision and `Rounding_Mode`.
         If a `Math_Context` is used, there is a possibility of a loss of
         precision.

       ? Number Format

         The textual format for a Decimal is defined at
         https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html#BigDecimal-java.lang.String-.

       ! Error Conditions

         - If the `Text` argument is incorrectly formatted, a `Number_Parse_Error`
           is thrown.
         - If the construction of the Decimal results in a loss of precision, a
           `Loss_Of_Numeric_Precision` warning is attached. This can only happen
           if a `Math_Context` value is explicitly passed.
    new : Text | Integer | Float -> Math_Context -> Decimal | Number_Parse_Error
    new (x : Text | Integer | Float) (mc : Math_Context | Nothing)=Nothing -> Decimal | Number_Parse_Error =
        IO.println 'AAA new'
        IO.println x
        IO.println (Meta.get_simple_type_name x)
        case x of
            _ : Text -> Decimal.from_text x mc
            _ : Integer -> Decimal.from_integer x mc
            _ : Float -> Decimal.from_float x mc

    ## Construct a `Decimal` from a `Text`.

       Arguments:
       - s: The `Text` to construct a `Decimal` from.
       - mc: The `Math_Context` to use to specify precision and `Rounding_Mode`.
         If a `Math_Context` is used, there is a possibility of a loss of
         precision.

       ? Number Format

         The textual format for a Decimal is defined at
         https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html#BigDecimal-java.lang.String-.

       ! Error Conditions

         - If `s` is incorrectly formatted, a `Number_Parse_Error` is thrown.
         - If the construction of the Decimal results in a loss of precision, a
           `Loss_Of_Numeric_Precision` warning is attached. This can only happen
           if a `Math_Context` value is explicitly passed.
    from_text : Text -> Math_Context -> Decimal | Number_Parse_Error
    from_text (s : Text) (mc : Math_Context | Nothing)=Nothing -> Decimal | Number_Parse_Error =
        IO.println "AAA ft"
        handle_number_format_exception <|
            case mc of
                _ : Math_Context -> Decimal.Value <| handle_precision_loss s <| Decimal_Utils.fromString s mc.math_context
                _ : Nothing -> Decimal.Value (Decimal_Utils.fromString s)

    ## Construct a `Decimal` from an `Integer`.

       Arguments:
       - i: The `Integer` to construct a `Decimal` from.
       - mc: The `Math_Context` to use to specify precision and `Rounding_Mode`.
         If a `Math_Context` is used, there is a possibility of a loss of
         precision.

       ! Error Conditions

         - If the construction of the Decimal results in a loss of precision, a
           `Loss_Of_Numeric_Precision` warning is attached. This can only happen
           if a `Math_Context` value is explicitly passed.
    from_integer : Integer -> Math_Context -> Decimal ! Loss_Of_Numeric_Precision
    from_integer (i : Integer) (mc : Math_Context | Nothing)=Nothing -> Decimal ! Loss_Of_Numeric_Precision =
        case mc of
            _ : Math_Context -> Decimal.Value <| handle_precision_loss i <| Decimal_Utils.fromEnsoInteger i mc.math_context
            _ : Nothing -> Decimal.Value (Decimal_Utils.fromEnsoInteger i)

    ## Construct a `Decimal` from a `Float`.

       Arguments:
       - f: The `Float` to construct a `Decimal` from.
       - mc: The `Math_Context` to use to specify precision and `Rounding_Mode`.
         If a `Math_Context` is used, there is a possibility of a loss of
         precision.

       ! Error Conditions

         - If the construction of the Decimal results in a loss of precision, a
           `Loss_Of_Numeric_Precision` warning is attached. This can only happen
           if a `Math_Context` value is explicitly passed.
         - If `f` is NaN or +/-Inf, an Illegal_Argument error is thrown.
    from_float : Float -> Math_Context -> Decimal ! Loss_Of_Numeric_Precision ! Illegal_Argument
    from_float (f : Float) (mc : Math_Context | Nothing)=Nothing -> Decimal ! Loss_Of_Numeric_Precision ! Illegal_Argument =
        is_exceptional = f.is_nan || f.is_infinite
        if is_exceptional then Error.throw (Illegal_Argument.Error "Cannot convert "+f.to_text+" to a Decimal") else
            case mc of
                _ : Math_Context -> Decimal.Value <| handle_precision_loss f <| Decimal_Utils.fromEnsoFloat f mc.math_context
                _ : Nothing -> Decimal.Value (Decimal_Utils.fromEnsoFloat f)

    + : Decimal -> Decimal -> Decimal
    + self (that:Decimal) = self.add that

    / : Decimal -> Decimal -> Decimal
    / self (that:Decimal) = self.divide that

    == self that =
        case that of
            _ : Integer -> self.big_decimal.compareTo(Decimal.from_integer that . big_decimal) == 0
            _ : Float -> self.big_decimal.compareTo(Decimal.from_float that . big_decimal) == 0
            _ : Decimal -> self.big_decimal.compareTo(that.big_decimal) == 0

    add : Decimal -> Decimal -> Math_Context | Nothing -> Decimal
    add self (that:Decimal) (math_context : Math_Context | Nothing)=Nothing -> Decimal =
        case math_context of
            Nothing -> Decimal.Value (self.big_decimal.add that.big_decimal)
            _ -> Decimal.Value (self.big_decimal.add that.big_decimal math_context.math_context)

    divide : Decimal -> Decimal -> Math_Context | Nothing -> Decimal
    divide self (that:Decimal) (math_context : Math_Context | Nothing)=Nothing -> Decimal =
        case math_context of
            Nothing -> Decimal.Value (self.big_decimal.divide that.big_decimal)
            _ -> Decimal.Value (self.big_decimal.divide that.big_decimal math_context.math_context)

    get_precision : Integer
    get_precision self = self.big_decimal.precision

    get_scale : Integer
    get_scale self = self.big_decimal.scale

    get_unscaled_value : Integer
    get_unscaled_value  self = self.big_decimal.unscaledValue

    get_internal_representation : [Integer]
    get_internal_representation self = [self.get_unscaled_value, self.get_precision, self.get_scale]

    to_text : Text
    to_text self = self.big_decimal.toString

## PRIVATE
handle_number_format_exception ~action =
    Panic.catch NumberFormatException action caught_panic->
        Error.throw (Number_Parse_Error.Error caught_panic.payload.getMessage)

## PRIVATE
handle_precision_loss : Any -> Decimal_Utils.Conversion_Result -> Any ! Loss_Of_Numeric_Precision
handle_precision_loss original_value conversion_result:Decimal_Utils.Conversion_Result -> Any ! Loss_Of_Numeric_Precision =
    if conversion_result.hasPrecisionLoss.not then conversion_result.newValue else
        new_value = conversion_result.newValue
        Warning.attach (Loss_Of_Numeric_Precision.Warning original_value new_value) new_value

Decimal.from (that:Text) = Decimal.from_text that
Decimal.from (that:Integer) = Decimal.from_integer that
Decimal.from (that:Float) = Decimal.from_float that
