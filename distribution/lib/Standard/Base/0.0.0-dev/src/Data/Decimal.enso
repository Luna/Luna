import project.Any.Any
import project.Data.Numeric.Math_Context.Math_Context
import project.Data.Numeric.Rounding_Mode.Rounding_Mode
import project.Data.Text.Text
import project.Error.Error
import project.Errors.Illegal_Argument.Illegal_Argument
import project.IO
import project.Meta
import project.Nothing.Nothing
import project.Panic.Panic
import project.Warning.Warning
from project.Data.Boolean import Boolean, False, True
from project.Data.Numbers import Integer, Float, Number, Number_Parse_Error
from project.Data.Ordering import Comparable, Ordering
from project.Errors.Common import Loss_Of_Numeric_Precision

polyglot java import java.lang.NumberFormatException
polyglot java import java.math.BigDecimal
polyglot java import org.enso.base.numeric.Decimal_Utils

## Decimal is the type of decimal (base-10-scaled) nubmers in Enso. An Enso
   `Decimal` is a wrapper around a Java `BigDecimal`.
type Decimal
    Value (big_decimal:BigDecimal)

    ## Construct a `Decimal` from a string or integer.

       Arguments:
       - x: The `Text`, `Integer`, or `Float` to construct a `Decimal` from.
       - mc: The `Math_Context` to use to specify precision and `Rounding_Mode`.
         If a `Math_Context` is used, there is a possibility of a loss of
         precision.

       ? Number Format

         The textual format for a Decimal is defined at
         https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html#BigDecimal-java.lang.String-.

       ! Error Conditions

         - If the `Text` argument is incorrectly formatted, a `Number_Parse_Error`
           is thrown.
         - If the construction of the Decimal results in a loss of precision, a
           `Loss_Of_Numeric_Precision` warning is attached. This can only happen
           if a `Math_Context` value is explicitly passed.

        ^ Example
          Create a `Decimal` from a string.

              c = Decimal.new "12.345"
    new : Text | Integer | Float -> Math_Context -> Decimal | Number_Parse_Error
    new (x : Text | Integer | Float) (mc : Math_Context | Nothing)=Nothing -> Decimal | Number_Parse_Error =
        case x of
            _ : Text ->
                #IO.println "AAA D.new t"
                #IO.println x
                Decimal.from_text x mc
            _ : Integer ->
                #IO.println "AAA D.new i"
                #IO.println x
                Decimal.from_integer x mc
            _ : Float ->
                r = Decimal.from_float x mc
                #IO.println "AAA D.new f"
                #IO.println x
                #IO.println r
                r

    ## GROUP conversions
       Construct a `Decimal` from a `Text`.

       Arguments:
       - s: The `Text` to construct a `Decimal` from.
       - mc: The `Math_Context` to use to specify precision and `Rounding_Mode`.
         If a `Math_Context` is used, there is a possibility of a loss of
         precision.

       ? Number Format

         The textual format for a Decimal is defined at
         https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html#BigDecimal-java.lang.String-.

       ! Error Conditions

         - If `s` is incorrectly formatted, a `Number_Parse_Error` is thrown.
         - If the construction of the Decimal results in a loss of precision, a
           `Loss_Of_Numeric_Precision` warning is attached. This can only happen
           if a `Math_Context` value is explicitly passed.

        ^ Example
          Create a `Decimal` from a string.

              d = Decimal.from_text "12.345"
    from_text : Text -> Math_Context -> Decimal | Number_Parse_Error
    from_text (s : Text) (mc : Math_Context | Nothing)=Nothing -> Decimal | Number_Parse_Error =
        handle_number_format_exception <|
            case mc of
                _ : Math_Context -> Decimal.Value <| handle_precision_loss s <| Decimal_Utils.fromString s mc.math_context
                _ : Nothing -> Decimal.Value (Decimal_Utils.fromString s)

    ## GROUP conversions
       Construct a `Decimal` from an `Integer`.

       Arguments:
       - i: The `Integer` to construct a `Decimal` from.
       - mc: The `Math_Context` to use to specify precision and `Rounding_Mode`.
         If a `Math_Context` is used, there is a possibility of a loss of
         precision.

       ! Error Conditions

         - If the construction of the Decimal results in a loss of precision, a
           `Loss_Of_Numeric_Precision` warning is attached. This can only happen
           if a `Math_Context` value is explicitly passed.

        ^ Example
          Create a `Decimal` from an integer.

              d = Decimal.from_integer 12
    from_integer : Integer -> Math_Context -> Decimal ! Loss_Of_Numeric_Precision
    from_integer (i : Integer) (mc : Math_Context | Nothing)=Nothing -> Decimal ! Loss_Of_Numeric_Precision =
        case mc of
            _ : Math_Context -> Decimal.Value <| handle_precision_loss i <| Decimal_Utils.fromEnsoInteger i mc.math_context
            _ : Nothing -> Decimal.Value (Decimal_Utils.fromEnsoInteger i)

    ## GROUP conversions
       Construct a `Decimal` from a `Float`.

       Arguments:
       - f: The `Float` to construct a `Decimal` from.
       - mc: The `Math_Context` to use to specify precision and `Rounding_Mode`.
         If a `Math_Context` is used, there is a possibility of a loss of
         precision.

       ! Error Conditions

         - If the construction of the Decimal results in a loss of precision, a
           `Loss_Of_Numeric_Precision` warning is attached. This can only happen
           if a `Math_Context` value is explicitly passed.
         - If `f` is NaN or +/-Inf, an Illegal_Argument error is thrown.

        ^ Example
          Create a `Decimal` from a float.

              d = Decimal.from_integer 12.345
    from_float : Float -> Math_Context -> Decimal ! Loss_Of_Numeric_Precision ! Illegal_Argument
    from_float (f : Float) (mc : Math_Context | Nothing)=Nothing -> Decimal ! Loss_Of_Numeric_Precision ! Illegal_Argument =
        is_exceptional = f.is_nan || f.is_infinite
        if is_exceptional then Error.throw (Illegal_Argument.Error "Cannot convert "+f.to_text+" to a Decimal") else
            case mc of
                _ : Math_Context -> Decimal.Value <| handle_precision_loss f <| Decimal_Utils.fromEnsoFloat f mc.math_context
                _ : Nothing ->
                    r = Decimal.Value (Decimal_Utils.fromEnsoFloat f)
                    #IO.println "AAA D.from_float"
                    #IO.println f
                    #IO.println r
                    r

    float_id : Float -> Float
    float_id f =
        r = Decimal_Utils.floatId f
        #IO.println "AAA float_id"
        #IO.println f
        #IO.println r
        r

    < self (that:Decimal) = Decimal_Comparator.compare self that == Ordering.Less
    > self (that:Decimal) = Decimal_Comparator.compare self that == Ordering.Greater
    <= self (that:Decimal) =
        ordering = Decimal_Comparator.compare self that
        ordering == Ordering.Less || ordering == Ordering.Equal
    >= self (that:Decimal) =
        ordering = Decimal_Comparator.compare self that
        ordering == Ordering.Greater || ordering == Ordering.Equal

    ## ALIAS plus
       GROUP Operators
       ICON math
       Adds a `Decimal` to another `Decimal` or other kind of number. A
       `Math_Context` value can be specified to set the precision and
       `Rounding_Mode`.

       Arguments:
       - that: The number to add to this.
       - math_context: Used to optionally specify precision and `Rounding_Mode`.

       Addition in Enso will undergo automatic conversions such that you need
       not convert other numeric types to `Decimal` manually.

       > Example
         Adding 10.1 and 20.2.

             a = Decimal.new "10.1"
             b = Decimal.new "20.2"
             c = a.add b
             # => 30.3

       > Example
         Adding 10.22 and 20.33, rounding to 3 digits of precision (1 decimal
         place), and rounding half-down.

             a = Decimal.new "10.22"
             b = Decimal.new "20.33"
             a.add b (Math_Context.new 3 Rounding_Mode.half_down)
             # => 30.5
    add : Decimal -> Decimal -> Math_Context | Nothing -> Decimal
    add self (that:Decimal) (math_context : Math_Context | Nothing)=Nothing -> Decimal =
        case math_context of
            Nothing -> Decimal.Value (self.big_decimal.add that.big_decimal)
            _ -> Decimal.Value (self.big_decimal.add that.big_decimal math_context.math_context)

    ## ALIAS plus
       GROUP Operators
       ICON math
       Adds a `Decimal` to another `Decimal` or other kind of number.

       Arguments:
       - that: The number to add to this.

       Addition in Enso will undergo automatic conversions such that you need
       not convert other numeric types to `Decimal` manually.

       > Example
         Adding 10.1 and 20.2.

             a = Decimal.new "10.1"
             b = Decimal.new "20.2"
             a + b
             # => 30.3
    + : Decimal -> Decimal -> Decimal
    + self (that:Decimal) = self.add that

    * self that = Decimal.Value (self.big_decimal.multiply that.big_decimal)

    negate self = Decimal.Value self.big_decimal.negate

    to_double self = self.big_decimal.doubleValue

    ##
        / : Decimal -> Decimal -> Decimal
        / self (that:Decimal) = self.divide that

    ##
        == self that =
            case that of
                _ : Integer -> self.big_decimal.compareTo(Decimal.from_integer that . big_decimal) == 0
                _ : Float -> self.big_decimal.compareTo(Decimal.from_float that . big_decimal) == 0
                _ : Decimal -> self.big_decimal.compareTo(that.big_decimal) == 0

    divide : Decimal -> Decimal -> Math_Context | Nothing -> Decimal
    divide self (that:Decimal) (math_context : Math_Context | Nothing)=Nothing -> Decimal =
        case math_context of
            Nothing -> Decimal.Value (self.big_decimal.divide that.big_decimal)
            _ -> Decimal.Value (self.big_decimal.divide that.big_decimal math_context.math_context)

    get_precision : Integer
    get_precision self = self.big_decimal.precision

    get_scale : Integer
    get_scale self = self.big_decimal.scale

    get_unscaled_value : Integer
    get_unscaled_value  self = self.big_decimal.unscaledValue

    get_internal_representation : [Integer]
    get_internal_representation self = [self.get_unscaled_value, self.get_precision, self.get_scale]

    to_text : Text
    to_text self = self.big_decimal.toString

## PRIVATE
handle_number_format_exception ~action =
    Panic.catch NumberFormatException action caught_panic->
        Error.throw (Number_Parse_Error.Error caught_panic.payload.getMessage)

## PRIVATE
handle_precision_loss : Any -> Decimal_Utils.Conversion_Result -> Any ! Loss_Of_Numeric_Precision
handle_precision_loss original_value conversion_result:Decimal_Utils.Conversion_Result -> Any ! Loss_Of_Numeric_Precision =
    if conversion_result.hasPrecisionLoss.not then conversion_result.newValue else
        new_value = conversion_result.newValue
        Warning.attach (Loss_Of_Numeric_Precision.Warning original_value new_value) new_value

type Decimal_Comparator
    #compare x:Decimal y:Decimal =
    compare x:Decimal y:Decimal =
        r = Ordering.from_sign (x.big_decimal.compareTo y.big_decimal)
        IO.println "BBB dc "+x.to_text+" "+y.to_text+" "+r.to_text
        r
    hash x:Decimal = Decimal_Utils.hashCodeOf x.big_decimal

Comparable.from (_:Decimal) = Decimal_Comparator
Comparable.from (_:Number) = Decimal_Comparator

Decimal.from (that:Text) = Decimal.from_text that
Decimal.from (that:Float) =
    r = Decimal.new that
    IO.println "AAA D from F"
    IO.println that
    IO.println r
    r
Decimal.from (that:Number) =
    r = Decimal.new that
    IO.println "AAA D from N"
    IO.println that
    IO.println r
    r
