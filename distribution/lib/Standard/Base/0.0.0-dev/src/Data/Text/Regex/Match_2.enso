from project.Data.Boolean import Boolean, True, False
import project.Any.Any
import project.Data.Numbers.Integer
import project.Data.Map.Map
import project.Data.Range.Extensions
import project.Data.Range.Range
import project.Data.Text.Span.Span
import project.Data.Text.Span.Utf_16_Span
import project.Data.Text.Text
import project.Data.Vector.Vector
import project.Nothing.Nothing

type Match_2
    ## internal_regex_result : RegexResult (Truffle)
       (See https://github.com/oracle/graal/blob/master/regex/docs/README.md)
    Value (pattern : Pattern_2) (internal_regex_result : Any) (input : Text)

    ## PRIVATE
       Returns the start character of group n.

       Arguments:
       - n: the integer group number. Note that the groups explicitly
         defined in the regex are numbered starting at 1; group 0 refers to the
         entire match range.
    start : Integer -> Integer
    start self n = self.internal_regex_result.getStart n

    ## PRIVATE
       Returns the start character of group n

       Arguments:
       - n: the integer group number
    end : Integer -> Integer
    end self n = self.internal_regex_result.getEnd n

    ## PRIVATE

       Gets the text matched by the group with the provided identifier, or
       a default value if the group did not participate in the match. If no such group
       exists for the provided identifier, a `No_Such_Group` is returned.

       Arguments:
       - id: The integer index or name of that group.

       ? The Full Match
         The group with index 0 is always the full match of the pattern.

       ? Named Groups by Index
         If the regex contained named groups, these may also be accessed by
         index based on their position in the pattern.

       Note that it is possible for a group to "not participate in the match",
       for example with a disjunction. In the example below, the "(d)" group
       does not participate -- it neither matches nor fails.

            "ab((c)|(d))".find "abc"

       In this case, the group id for "(d)", which is 3, is a valid group id and
       (Pattern_2.lookup_group 3) will return 3. If the caller tries to get group 3,
       Match_2.group will return the default value.
    group : Integer | Text -> Any | Nothing -> Span ! No_Such_Group
    group self id default=Nothing =
        n = self.pattern.lookup_group id
        start = self.start n
        end = self.end n
        does_not_participate = start == -1 || end == -1
        case does_not_participate of
            True -> default
            False ->
                range = Range.new (self.start n) (self.end n)
                (Utf_16_Span.Value range self.input).to_grapheme_span

    ## Gets a vector containing the results of _all_ of the capturing groups in
       the pattern, including group 0 (containing the entire match).

       Arguments:
       ? The Full Match
         The group with index 0 is always the full match of the pattern.

       ? Named Groups by Index
         If the regex contained named groups, these may also be accessed by
         index based on their position in the pattern.
    groups : Vector Span
    groups self =
        group_numbers = 0.up_to self.pattern.group_count
        group_numbers.map n-> self.group n

    ## Gets a map containing the named capturing groups for the pattern,
       replacing the value for groups that did not participate in the match with
       `default`.

       Arguments:
       - default: The value to return for a given name when the group at that
         index did not participate in the match.

       Note that it is possible for a group to "not participate in the match",
       for example with a disjunction. In the example below, the "(d)" group
       does not participate -- it neither matches nor fails.

            "ab((c)|(d))".find "abc"

       In this case, the group id for "(d)", which is 3, is a valid group id and
       (Pattern_2.lookup_group 3) will return 3. If the caller tries to get group 3,
       Match_2.group will return the default value.

       > Example
         Get the map of all of the named groups in this match, replacing the
         value for groups that didn't participate in the match with "UNMATCHED".

            pattern = Regex_2.compile "(.. .. )(?<letters>.+)()??(?<empty>)??"
            input = "aa ab abc a bc bcd"
            match = pattern.match input
            ## match.named_groups.keys.sort == ["empty", "letters"]
    named_groups : Any -> Map Text (Text | Any)
    named_groups self default=Nothing =
        named_group_names = self.pattern.group_names
        spans = named_group_names.map name-> self.group name default=default
        Map.from_vector (named_group_names.zip spans)
    ##
        ## PRIVATE

           Returns the span matched by the group with the provided identifier, or
           `Nothing` if the group did not participate in the match.


           Arguments:
           - id: The identifier for the group to fetch the end index for.
        span : Integer | Text -> Span | Nothing ! No_Such_Group
        span self _ = Unimplemented.throw "This is an interface only."

        ## PRIVATE

           Returns the start character index of the match's region.
        start_position : Integer
        start_position self = Unimplemented.throw "This is an interface only."

        ## Returns the end character index of the match's region.
        end_position : Integer
        end_position self = Unimplemented.throw "This is an interface only."
