import project.Any.Any
import project.Data.Boolean.Boolean
import project.Data.Map.Map
import project.Data.Numbers.Integer
import project.Data.Text.Text
import project.Data.Vector.Vector
import project.Error.Error
import project.Errors.Common.Index_Out_Of_Bounds
import project.Errors.File_Error.File_Error
import project.Errors.Illegal_State.Illegal_State
import project.Errors.No_Such_Key.No_Such_Key
import project.IO
import project.Nothing.Nothing
import project.Panic.Panic
import project.System.File.File
import project.System.File.File_Access.File_Access
import project.System.Input_Stream.Input_Stream
from project.Data.Range.Extensions import all
from project.Data.Text.Extensions import all

polyglot java import java.io.StringReader
polyglot java import java.lang.Exception as JException
polyglot java import javax.xml.parsers.DocumentBuilderFactory
polyglot java import javax.xml.parsers.DocumentBuilder
polyglot java import javax.xml.xpath.XPathConstants
polyglot java import javax.xml.xpath.XPathFactory
polyglot java import org.w3c.dom.Document
polyglot java import org.w3c.dom.Element
polyglot java import org.w3c.dom.Node
polyglot java import org.w3c.dom.NodeList
polyglot java import org.w3c.dom.Text as Java_Text
polyglot java import org.xml.sax.InputSource
polyglot java import org.xml.sax.SAXException
polyglot java import org.xml.sax.SAXParseException

polyglot java import org.enso.base.XML_Utils

type XML_Document
    ## Read an XML document from a file.

       Arguments:
       - file: the `File` to read the XML document from.

       If there is an error reading the file, `File_Error` is thrown.

       If there is a parsing error, `XML_Error.Parse_Error` is thrown.

       > Example
         Read an XML document in 'doc.xml'.

             file = enso_project.data / "doc.xml"
             doc = XML_Document.from_file test_file
    from_file : File -> XML_Document ! XML_Error | File_Error
    from_file file =
        File_Error.handle_java_exceptions file <| XML_Error.handle_java_exceptions <|
            file.with_input_stream [File_Access.Read] XML_Document.from_stream

    ## Read an XML document from an input stream.

       Arguments:
       - input_stream: the input stread to read the XML document from.

       If there is a parsing error, `XML_Error.Parse_Error` is thrown.

       > Example
         Read an XML document from an input_stream.

             input_stream = get_input_stream
             doc = XML_Document.from_stream input_stream
    from_stream : Input_Stream -> XML_Document ! XML_Error
    from_stream input_stream =
        XML_Error.handle_java_exceptions <|
           input_stream.with_java_stream java_stream->
               document_builder_factory = DocumentBuilderFactory.newInstance
               document_builder = document_builder_factory.newDocumentBuilder
               XML_Document.Value (document_builder.parse java_stream)

    ## Read an XML document from a string.

       Arguments:
       - xml_string: The string to read the XML document from.

       If there is a parsing error, `XML_Error.Parse_Error` is thrown.

       > Example
         Read an XML document from an string.

             xml_string = "<foo></foo>"
             doc = XML_Document.from_string xml_string
    from_string : Text -> XML_Document ! XML_Error
    from_string xml_string =
        XML_Error.handle_java_exceptions <|
            string_reader = StringReader.new xml_string
            input_source = InputSource.new string_reader
            document_builder_factory = DocumentBuilderFactory.newInstance
            document_builder = document_builder_factory.newDocumentBuilder
            XML_Document.Value (document_builder.parse input_source)

    ## PRIVATE
    Value (java_document:Document)

    root_element : XML_Element
    root_element self =
        java_element = self.java_document.getDocumentElement
        self.java_document.getDocumentElement.normalize
        XML_Element.Value java_element

##
    type XML_Format
        # Implements the File_Format interface, using XML_Document.from_file
        # Include mime type (with encoding??) and from_stream

type XML_Element
    ## PRIVATE
    Value (java_element:Element)

    ## Gets the tag of an xml element.

       Example:
           XML_Document.from_string '<foo>hello</foo>' . root_element . at 0 . tag
           # => "foo"
    name : Text
    name self = self.java_element.getNodeName

    ## Gets a child of an xml element.

       Example:
           XML_Document.from_string '<foo><baz>hello</baz></foo>' . at 0 . at 0
           # => XML_Document.from_string "<baz>hello</baz>"
    get : Text | Integer -> Any -> Any | Text | XML_Element | Vector XML_Element
    get self key ~if_missing=Nothing =
        case key of
            _ : Integer -> self.get_child_element key if_missing
            _ : Text -> if is_attribute_key key then self.attribute (key.drop 1) if_missing else self.get_xpath key

    ## Gets a child or attribute of an xml element.

       Arguments:
       - key: If an `Integer`, returns the element at position `at` in its list
         of children. If a `Text`, treats `at` as an XPath specifier, and
         returns the element it points to. If a `Text` that starts with `"@"`,
         returns the attribute with the given name.

       > Example
         Get a nested tag:

             XML_Document.from_string '<foo><baz>hello</baz></foo>' . at 0 . at 0
             # => XML_Document.from_string "<baz>hello</baz>"
    at : Text | Integer -> Text | XML_Element | Vector XML_Element ! No_Such_Key | Index_Out_Of_Bounds
    at self key =
        if_missing = case key of
            _ : Integer -> Error.throw (Index_Out_Of_Bounds.Error key self.num_children)
            _ : Text -> Error.throw (No_Such_Key.Error self key)
        self.get key if_missing

    ## Get elements denoted by the given XPath key.

       Arguments:
       - key: The XPath string to use to search for elements.
    get_xpath : Text -> Vector XML_Element
    get_xpath self key =
        xpath = XPathFactory.newInstance.newXPath
        only_wanted_nodes (nodelist_to_vector (xpath.evaluate key self.java_element XPathConstants.NODESET))

    ## PRIVATE
       Get the child element indicated by the index. This ignores all
       non-element children.
    get_child_element : Integer -> Any -> Any | Text | XML_Element ! No_Such_Key
    get_child_element self n:Integer ~if_missing =
        self.children.get n if_missing

    ## Get an attribute of an XML element.

       Arguments:
       - name: The name of the attribute to get.
       - if_missing: The value returned if the attribute does not exist.
    attribute : Text -> Any -> Text | Any
    attribute self name ~if_missing=(Error.throw (No_Such_Key.Error self name)) =
        attr = self.java_element.getAttributeNode name
        if attr.is_nothing then if_missing else attr.getValue

    ## PRIVATE
       Get all children of this element.
    all_children : Vector Any
    all_children self = nodelist_to_vector self.java_element.getChildNodes

    ## Gets a map of the attributes of an xml element.

       Example:
           XML_Document.from_string '<foo bar="one">hello</foo>' . at 0 . attributes
           # => Map.from_vector [["bar", "one"]]
    attributes : Map Text Text
    attributes self =
        named_node_map = self.java_element.getAttributes
        keys_and_values = 0.up_to named_node_map.getLength . map i->
            node = named_node_map.item i
            [node.getNodeName, node.getNodeValue]
        Map.from_vector keys_and_values

    ## Gets the child elements of an XML element. This ignores all non-element
       children.

       Example:
           XML_Document.from_string '<foo><baz>hello</baz></foo>' . at 0 . children
           # => [XML_Document.from_string "<baz>hello</baz>"]
    children : Vector (XML_Element | Text)
    children self = only_wanted_nodes self.all_children

    ## Gets the non-markup contents of the element.

       Example:
           XML_Document.from_string '<foo>hello</foo>' . at 0 . tag
           # => "hello"
    text : Text
    text self = self.java_element.getTextContent

    ## Gets the raw XML of the element (including tag, attributes and contents).
    outer_xml : Text ! XML_Error
    outer_xml self =
        XML_Error.handle_java_exceptions <|
            XML_Utils.outerXML self.java_element

    ##
        ## Gets the raw XML contents of the element.
        inner_xml : Text

    ##
        ## PRIVATE
        get_xpath_one_value : Text -> Any -> Any | XML_Element
        get_xpath_one_value key ~if_missing =
            values = get_xpath key
            case values.length of
                0 -> if_missing
                1 -> values.at 0
                n -> Error.throw (XML_Error.Multiple_Values_Found key n)

    ## Gets the number children of an xml element.

       Example:
           XML_Document.from_string '<foo><baz>hello</baz></foo>' . at 0 . num_children
           # => 1
    num_children : Integer
    num_children self = self.children.length

    ##
        ## Gets elements matching a given tag name

           Example:
               XML_Document.from_string '<foo><baz>hello</baz></foo>' . get_elements_by_tag_name "baz"
               # => [XML_Document.from_string "<baz>hello</baz>"]
        get_elements_by_tag_name : Text -> Vector XML_Element

type XML_Error
    # An error that indicates that the XML data could not be parsed.

      Arguments:
      - line_number: the line on which the parse failed.
      - column_number: the column at which the parse failed.
    Parse_Error (line_number : Integer) (column_number : Integer)

    # An error that indicates multiple elements were found for a given key.

      Arguments:
      - key: The key at which multiple values were found.
      - num_values: The number of values found at `key`.
    Multiple_Values_Found (key : Text) (num_values : Integer)

    # Any other Java exception.
    Other (error : Text)

    ## PRIVATE
       Convert the XML_Error to a human-readable format.
    to_display_text : Text
    to_display_text self = case self of
        XML_Error.Parse_Error line_number column_number -> "The XML document could not be parsed at line " + line_number.to_text + ", column " + column_number.to_text
        XML_Error.Multiple_Values_Found key num_values -> "The specified key produced " + num_values.to_text + " values: " + key
        XML_Error.Other error -> error

    ## PRIVATE

       Utility method for running an action with Java exceptions mapping.
    handle_java_exceptions ~action =
        Panic.catch JException action caught_panic->
            XML_Error.wrap_java_exception caught_panic.payload

    ## PRIVATE

       Converts a Java `SAXException` into its Enso counterpart.
    wrap_java_exception exception = case exception of
        _ : SAXParseException -> Error.throw (XML_Error.Parse_Error exception.getLineNumber exception.getColumnNumber)
        _ -> Error.throw (XML_Error.Other "An Exception has occurred: "+exception.to_text)

## PRIVATE
   Filter out unwanted nodes.
   Wanted nodes are:
   - Elements
   - Text (if not completely whitespace)
only_wanted_nodes : Vector Any -> Vector (Text | XML_Element)
only_wanted_nodes nodes:(Vector Any) =
    # If an Element, wrap in XML_Element. If Java_Text, extract the string.
    convert node =
        ##
            case node.getNodeType of
                Node.ELEMENT_NODE -> XML_Element.Value node
                Node.TEXT_NODE -> node.nodeValue
        if node.getNodeType == Node.ELEMENT_NODE then XML_Element.Value node else
            if node.getNodeType == Node.TEXT_NODE then node.getNodeValue else
                Panic.throw (Illegal_State.Error ("Unexpected child type " + node.getNodeType.to_text))
    nodes.filter is_element_or_non_whitespace_text . map convert

## PRIVATE
   Return children of this node that pass a filter.
is_element_or_non_whitespace_text : Node -> Boolean
is_element_or_non_whitespace_text node =
    is_element = node.getNodeType == Node.ELEMENT_NODE
    is_non_whitespace_text = node.getNodeType == Node.TEXT_NODE && node.getNodeValue.is_whitespace.not
    is_element || is_non_whitespace_text

## PRIVATE
   Returns true if `key` starts with "@".
is_attribute_key : Text -> Boolean
is_attribute_key s = s.starts_with "@"

## PRIVATE
   Convert NodeList to Vector.
nodelist_to_vector : NodeList -> Vector Any
nodelist_to_vector node_list:NodeList =
    0.up_to (node_list.getLength) . map i->
        node_list.item i
