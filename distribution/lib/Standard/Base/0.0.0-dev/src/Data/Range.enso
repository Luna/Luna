from Standard.Base import all

## Represents a right-exclusive range of integer values.
type Range

    ## UNSTABLE
       A representation of a right-exclusive range of integer values.

       Arguments:
       - start: The left boundary of the range. Its value is included.
       - end: The right boundary of the range. Its value is excluded.
       - step: The step between consecutive elements of the range. It must be
         non-zero. Defaults to 1.
    type Range start end step=1

    ## Creates a copy of this range with a changed step.

       > Example
         Create a range of even numbers from 0 to 10 (exclusive).

             0.up_to 10 . with_step 2
    with_step : Integer -> Range
    with_step new_step =
        if new_step == 0 then here.throw_zero_step_error else
            Range this.start this.end new_step

    ## Returns the last element that is included within the range or `Nothing`
       if the range is empty.
    last : Integer | Nothing
    last = if this.is_empty then Nothing else case this.step > 0 of
        True ->
            diff = this.end - this.start
            rem = diff % this.step
            if rem == 0 then this.end - this.step else this.end - rem
        False ->
            diff = this.start - this.end
            rem = diff % (-this.step)
            if rem == 0 then this.end - this.step else this.end + rem

    ## Get the number of elements in the range.

       > Example
         The following range has 100 elements.

            0.up_to 100 . length
    length : Number
    length = case this.last of
        Nothing -> 0
        last -> ((last - this.start) . div this.step) + 1

    ## Checks if this range is empty.

       > Example
         Checking if the range from 0 to 100 is empty.

             0.up_to 100 . is_empty
    is_empty : Boolean
    is_empty = if this.step > 0 then this.end <= this.start else
        if this.step < 0 then this.start <= this.end else
            here.throw_zero_step_error

    ## Checks if this range is not empty.

       > Example
         Checking if the range from 0 to 100 is not empty.

             0.up_to 100 . not_empty
    not_empty : Boolean
    not_empty = this.is_empty.not

    ## Applies a function to each element in the range, producing a vector of
       results.

       Arguments:
       - function: The function to apply to each integer in the range.

       > Example
         Create a vector that contains the numbers twice that of the numbers in
         the range.

             1.up_to 10 . map (*2)
    map : (Number -> Any) -> Vector Any
    map function =
        Vector.new this.length (i -> function (this.start + i*this.step))

    ## Applies a function for each element in the range.

       Arguments:
       - function: The function to apply to each integer in the range.

       > Example
         To print all the numbers from 1 to 10 use:
             1.up_to 11 . each IO.println
    each : (Number -> Any) -> Nothing
    each function =
        go end_condition current end =
            if end_condition current end then Nothing else
                function current
                @Tail_Call go end_condition current+this.step end
        if this.step > 0 then go (>=) this.start this.end else
            if this.step < 0 then go (<=) this.start this.end else
                here.throw_zero_step_error

    ## Combines all the elements of the range, by iteratively applying the
       passed function with next elements of the range.

       Arguments:
       - init: The initial integral value for the fold.
       - function: A binary function taking an item and a number, and returning
         an item.

       In general, the result of
           Range start end step . fold init f
       is the same as
           f (...(f (f init start) start+step)...) last

       > Example
         In the following example, we'll compute the sum of all even integers
         less than 100.

             0.up_to 100 . with_step 2 . fold 0 (+)
    fold : Any -> (Any -> Number -> Any) -> Any
    fold init function =
        go end_condition acc current end =
            if end_condition current end then acc else
                new_acc = function acc current
                @Tail_Call go end_condition new_acc current+this.step end
        if this.step > 0 then go (>=) init this.start this.end else
            if this.step < 0 then go (<=) init this.start this.end else
                here.throw_zero_step_error

    ## Checks whether `predicate` is satisfied for all numbers in this range.

       Arguments:
       - predicate: A function that takes a list element and returns a boolean
         value that says whether that value satisfies the conditions of the
         function.

       > Example
         Checking that all numbers in the range are greater than 5.

             10.up_to 100 . all (> 5)
    all : (Number -> Boolean) -> Boolean
    all predicate =
        go end_condition current end =
            if end_condition current end then True else
                if predicate current then @Tail_Call go end_condition current+this.step end else False
        if this.step > 0 then go (>=) this.start this.end else
            if this.step < 0 then go (<=) this.start this.end else
                here.throw_zero_step_error

    ## Checks whether `predicate` is satisfied for any number in this range.

       Arguments:
       - predicate: A function that takes a list element and returns a boolean
         value that says whether that value satisfies the conditions of the
         function.

       > Example
         Checking that at least one number in the range is greater than 10.

             1.up_to 100 . exists (> 10)
    exists : (Number -> Boolean) -> Boolean
    exists predicate = this.find predicate . is_nothing . not

    ## Checks whether `predicate` is satisfied for any number in this range.

       Arguments:
       - predicate: A function that takes a list element and returns a boolean
         value that says whether that value satisfies the conditions of the
         function.

       > Example
         Checking that at least one number in the range is greater than 10.

             1.up_to 100 . any (> 10)
    any : (Number -> Boolean) -> Boolean
    any predicate = this.exists predicate

    ## Gets the first index when `predicate` is satisfied this range.
       If no index satisfies the predicate, return Nothing

       Arguments:
       - predicate: A function that takes a list element and returns a boolean
         value that says whether that value satisfies the conditions of the
         function.

       > Example
         Get the first number in the range divisible by 2, 3 and 5.

             1.up_to 100 . find i->(i%2==0 && i%3==0 && i%5==0)
    find : (Integer -> Boolean) -> Integer | Nothing
    find predicate =
        go end_condition current end =
            if end_condition current end then Nothing else
                if predicate current then current else
                    @Tail_Call go end_condition current+this.step end
        if this.step > 0 then go (>=) this.start this.end else
            if this.step < 0 then go (<=) this.start this.end else
                here.throw_zero_step_error

    ## Converts the range to a vector containing the numbers in the range.

       > Example
         Getting a vector of the numbers 1 to 5.

             1.up_to 6 . to_vector
    to_vector : Vector.Vector
    to_vector =
        Vector.new this.length (i -> this.start + i*this.step)

    ## Does the range contain the specified value

       > Example
         Check if an index is in the range of a Vector

              vec = ["A", "B", "C", "D", "E"]
              0.up_to vec.length . contains 3
    contains : Integer -> Boolean
    contains value =
        if this.step > 0 then (value >= this.start) && (value < this.end) && (((value - this.start) % this.step) == 0) else
            if this.step < 0 then (value <= this.start) && (value > this.end) && (((this.start - value) % (-this.step)) == 0) else
                here.throw_zero_step_error

## PRIVATE
throw_zero_step_error = Error.throw (Illegal_State_Error "A range with step = 0 is ill-formed.")
