import project.Data.Numbers.Integer
import project.Data.Vector.Vector
import project.Data.Pair.Pair

from project.Data.Boolean import Boolean, True, False
from project import Error, Nothing, Any, Panic
from project.Error.No_Such_Key import No_Such_Key


@Builtin_Type
type Hash_Map key value
    empty : Hash_Map
    empty = @Builtin_Method "Hash_Map.empty"

    singleton : Any -> Any -> Map
    singleton key value = Hash_Map.empty.insert key value

    from_vector : Vector Any -> Map
    from_vector vec = vec.fold Hash_Map.empty (m -> el -> m.insert (el.at 0) (el.at 1))

    insert : Any -> Any -> Map
    insert self key value = @Builtin_Method "Hash_Map.insert"

    is_empty : Boolean
    is_empty self = self.size == 0

    not_empty : Boolean
    not_empty self = self.is_empty.not

    size : Integer
    size self = @Builtin_Method "Hash_Map.size"

    at : Any -> Any ! No_Such_Key
    at self key = self.get key (Error.throw (No_Such_Key.Error self key))

    get : Any -> Any -> Any
    get self key ~if_missing=Nothing = self.get_builtin key if_missing

    # Workaround - we cannot have a builtin method with default parameters
    get_builtin : Any -> Any -> Any
    get_builtin self key ~if_missing = @Builtin_Method "Hash_Map.get_builtin"

    contains_key : Any -> Boolean
    contains_key self key = @Builtin_Method "Hash_Map.contains_key"

    keys : Vector Any
    keys self = self.to_vector.map pair-> pair.at 0

    values : Vector Any
    values self = self.to_vector.map pair-> pair.at 1

    map : (Any -> Any) -> Hash_Map
    map self function =
        kv_func = _ -> function
        self.map_with_key kv_func

    map_with_key : (Any -> Any -> Any) -> Hash_Map
    map_with_key self function =
        Hash_Map.from_vector <| self.to_vector.map pair->
            key = pair.first
            value = pair.last
            [key, (function key value)]

    map_keys : (Any -> Any) -> Map
    map_keys self function =
        trans_function = k -> v -> [function k, v]
        self.transform trans_function

    transform : (Any -> Any -> [Any, Any]) -> Hash_Map
    transform self function =
        func_pairs = p -> function (p.at 0) (p.at 1)
        vec_transformed = self.to_vector.map func_pairs
        Hash_Map.from_vector vec_transformed

    fold : Any -> (Any -> Any -> Any) -> Any
    fold self init function = self.values.fold init function

    fold_with_key : Any -> (Any -> Any -> Any -> Any) -> Any
    fold_with_key self init function =
        self.to_vector.fold init acc-> pair->
            function acc pair.first pair.last

    each : (Any -> Any) -> Nothing
    each self function =
        kv_func = _ -> function
        self.each_with_key kv_func

    each_with_key : (Any -> Any -> Any) -> Nothing
    each_with_key self function =
        self.to_vector.each pair->
            function pair.first pair.last

    # Returns unsorted vector of key-value pairs (nested 2 element vectors).
    to_vector : Vector Any
    to_vector self = @Builtin_Method "Hash_Map.to_vector"

    to_text : Text
    to_text self = @Builtin_Method "Hash_Map.to_text"

    ## Get a key value pair of the lowest key in the map.
       If the map is empty, returns Nothing.
    first : Pair
    first self =
        case self.is_empty of
            True -> Nothing
            False ->
                Pair.new (self.to_vector.first.at 0) (self.to_vector.first.at 1)

    ## Get a key value pair of the highest key in the map.
       If the map is empty, returns Nothing.
    last : Pair
    last self =
        case self.is_empty of
            True -> Nothing
            False ->
                Pair.new (self.to_vector.last.at 0) (self.to_vector.last.at 1)

