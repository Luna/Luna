import project.Data.Numbers.Integer
import project.Data.Vector.Vector
import project.Data.Pair.Pair

from project.Data.Boolean import Boolean, True, False
from project import Error, Nothing, Any, Panic
from project.Error.No_Such_Key import No_Such_Key


@Builtin_Type
type Hash_Map key value
    empty : Hash_Map
    empty = @Builtin_Method "Hash_Map.empty"

    singleton : Any -> Any -> Map
    singleton key value = Hash_Map.empty.insert key value

    from_vector : Vector Any -> Map
    from_vector vec = vec.fold Hash_Map.empty (m -> el -> m.insert (el.at 0) (el.at 1))

    insert : Any -> Any -> Map
    insert self key value = @Builtin_Method "Hash_Map.insert"

    is_empty : Boolean
    is_empty self = self.size == 0

    not_empty : Boolean
    not_empty self = self.is_empty.not

    size : Integer
    size self = @Builtin_Method "Hash_Map.size"

    at : Any -> Any ! No_Such_Key
    at self key = self.get key (Error.throw (No_Such_Key.Error self key))

    get : Any -> Any -> Any
    get self key ~if_missing=Nothing = self.get_builtin key if_missing

    # Workaround - we cannot have a builtin method with default parameters
    get_builtin : Any -> Any -> Any
    get_builtin self key ~if_missing = @Builtin_Method "Hash_Map.get_builtin"

    contains_key : Any -> Boolean
    contains_key self key = @Builtin_Method "Hash_Map.contains_key"

    keys : Vector Any
    keys self =
        flat_vec = self.to_flat_vector
        Vector.new (flat_vec.length.div 2) idx->
            flat_vec.at (idx * 2)

    values : Vector Any
    values self =
        flat_vec = self.to_flat_vector
        Vector.new (flat_vec.length.div 2) idx->
            flat_vec.at (idx * 2 + 1)

    map : (Any -> Any) -> Hash_Map
    map self function =
        kv_func = _ -> function
        self.map_with_key kv_func

    map_with_key : (Any -> Any -> Any) -> Hash_Map
    map_with_key self function =
        Hash_Map.from_vector <| self.to_vector.map pair->
            key = pair.first
            value = pair.last
            [key, (function key value)]

    map_keys : (Any -> Any) -> Map
    map_keys self function =
        trans_function = k -> v -> [function k, v]
        self.transform trans_function

    transform : (Any -> Any -> [Any, Any]) -> Hash_Map
    transform self function =
        func_pairs = p -> function (p.at 0) (p.at 1)
        vec_transformed = self.to_vector.map func_pairs
        Hash_Map.from_vector vec_transformed

    fold : Any -> (Any -> Any -> Any) -> Any
    fold self init function = self.values.fold init function

    fold_with_key : Any -> (Any -> Any -> Any -> Any) -> Any
    fold_with_key self init function =
        self.to_vector.fold init acc-> pair->
            function acc pair.first pair.last

    each : (Any -> Any) -> Nothing
    each self function =
        kv_func = _ -> function
        self.each_with_key kv_func

    each_with_key : (Any -> Any -> Any) -> Nothing
    each_with_key self function =
        self.to_vector.each pair->
            function pair.first pair.last

    ## PRIVATE
    ## UNSTABLE
    to_flat_vector : Vector Any
    to_flat_vector self = @Builtin_Method "Hash_Map.to_flat_vector"

    to_vector : Vector Any
    to_vector self =
        flat_vec = self.to_flat_vector
        vec = Vector.new (flat_vec.length.div 2) idx->
            [(flat_vec.at idx*2), (flat_vec.at (idx*2 + 1))]
        vec.sort by=(x-> y-> x.first.compare_to y.first)

    to_text : Text
    to_text self = @Builtin_Method "Hash_Map.to_text"

    ## Get a key value pair of the lowest key in the map.
       If the map is empty, returns Nothing.
    first : Pair
    first self =
        case self.is_empty of
            True -> Nothing
            False ->
                flat_vec_part = self.to_flat_vector.take 2
                case flat_vec_part.length of
                    2 -> Pair.new (flat_vec_part.at 0) (flat_vec_part.at 1)
                    _ -> Panic.throw "flat_vector should have length exactly 2"

    ## Get a key value pair of the highest key in the map.
       If the map is empty, returns Nothing.
    last : Pair
    last self =
        case self.is_empty of
            True -> Nothing
            False ->
                vec_part = self.to_flat_vector.drop (self.to_flat_vector.length - 2)
                case vec_part.length of
                    2 -> Pair.new (vec_part.at 0) (vec_part.at 1)
                    _ -> Panic.throw "flat_vector should have length exactly 2"

