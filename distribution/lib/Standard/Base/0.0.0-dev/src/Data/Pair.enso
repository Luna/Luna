import project.Any.Any
import project.Data.Boolean.Boolean
import project.Data.Numbers.Integer
import project.Data.Vector.Vector
import project.Error.Common.Index_Out_Of_Bounds
import project.Error.Common.Not_Found
import project.Error.Error
import project.Nothing.Nothing

## A pair of elements.
type Pair
    ## Create a new Pair from two elements.

       Arguments:
       - first: The first element.
       - second: The second element.
    new : Any -> Any -> Pair
    new first second = Pair.Value first second

    ## UNSTABLE

       A simple pair of elements.

       Arguments:
       - first: The first element.
       - second: The second element.
    Value first second

    ## Get the last element of the pair.

       > Example
         The following code returns 4.

             Pair.new 2 4 . last
    last : Any
    last self = self.second

    ## UNSTABLE

       Applies the provided function to both elements of the pair.

       > Example
         Adding one to two elements of the pair.

         (Pair 1 2).map (+1) == (Pair 2 3)
    map : (Any -> Any) -> Pair
    map self fun =
        Pair.new (fun self.first) (fun self.second)

    ## UNSTABLE
       Returns the length (2) of the Pair.
    length : Integer
    length self = 2

    ## UNSTABLE
       Returns the pair as a Vector.
    to_vector : Vector
    to_vector self = [self.first, self.second]

    ## Gets an element from the pair at a specified index (0-based).

       Arguments:
       - index: The location in the pair to get the element from. The index is
         also allowed be negative, then the elements are indexed from the back
         of the pair, i.e. -1 will correspond to the last element.
    at : Integer -> Any
    at self index =
        self.get index (Error.throw (Index_Out_Of_Bounds.Error index 2))

    ## Gets an element from the pair at a specified index (0-based).
       If the index is invalid then `if_missing` is returned.

       Arguments:
       - index: The location in the pair to get the element from. The index is
         also allowed be negative, then the elements are indexed from the back
         of the pair, i.e. -1 will correspond to the last element.
       - if_missing: The value to return if the index is out of bounds.
    get : Integer -> Any -> Any
    get self index ~if_missing=Nothing =
        case index of
            0 -> self.first
            1 -> self.second
            -1 -> self.second
            -2 -> self.first
            _ -> if_missing

    ## Checks whether a predicate holds for at least one element of self pair.

       Arguments:
       - predicate: A function that takes a list element and returns a boolean
         value that says whether that value satisfies the conditions of the
         function.

       > Example
         Checking if any element of the list is larger than 3.

             Pair.new 1 5 . any (> 3)
    any : (Any -> Boolean) -> Boolean
    any self predicate = predicate self.first || predicate self.second

    ## Checks whether a predicate holds for all elements in this pair.

       Arguments:
       - predicate: A function that takes a list element and returns a boolean
         value that says whether that value satisfies the conditions of the
         function.

       > Example
         Check if all elements in the pair are less than zero.

             Pair.new -1 3 . all (< 0)
    all : (Any -> Boolean) -> Boolean
    all self predicate = predicate self.first && predicate self.second

    ## Checks whether this pair contains a given value as an element.

       Arguments:
       - elem: The item to see if it exists in the pair.

       > Example
         Checking if the vector contains the number 72.

             Pair.new 1 42 . contains 72
    contains : Any -> Boolean
    contains self elem = self.first == elem || self.second == elem

    ## Returns the first element of the pair that satisfies the predicate or
       if no elements satisfy the predicate, it throws nothing.

       Arguments:
       - predicate: A function that takes a list element and returns a boolean
         value that says whether that value satisfies the conditions of the
         function.
       - start: The index to start searching from.

       > Example
         Finding a first element of the pair that is larger than 3.

             Pair.new 1 6 .find (> 3)
    find : (Any -> Boolean) -> Integer -> Any -> Any
    find self predicate start=0 ~if_missing=(Error.throw Not_Found) =
        used_start = 0.max (if start < 0 then start + 2 else start)
        if used_start<1 && predicate self.first then self.first else
            if used_start<2 && predicate self.second then self.second else
                if_missing
