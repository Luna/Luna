import project.Any.Any
import project.Data.Array.Array
import project.Data.Numbers.Decimal
import project.Data.Numbers.Integer
import project.Data.Numbers.Number
import project.Data.Ordering.Comparator
import project.Data.Ordering.Ordering
import project.Data.Range.Extensions
import project.Data.Vector.Vector
import project.Error.Error
import project.Error.Illegal_Argument.Illegal_Argument
import project.Error.Incomparable_Values.Incomparable_Values
import project.Meta
import project.Nothing.Nothing
import project.Panic.Panic

from project.Data.Boolean import Boolean, True, False
from project.Data.Vector import Empty_Error
from project.Error.Common import Unsupported_Argument_Types

polyglot java import org.enso.base.statistics.Moments
polyglot java import org.enso.base.statistics.MomentStatistic
polyglot java import org.enso.base.statistics.CountMinMax
polyglot java import org.enso.base.statistics.CorrelationStatistics
polyglot java import org.enso.base.statistics.Rank

polyglot java import java.lang.ClassCastException
polyglot java import java.lang.NullPointerException

## Specifies how to handle ranking of equal values.
type Rank_Method
    ## Use the mean of all ranks for equal values.
    Average

    ## Use the lowest of all ranks for equal values.
    Minimum

    ## Use the highest of all ranks for equal values.
    Maximum

    ## Use same rank value for equal values and next group is the immediate
       following ranking number.
    Dense

    ## Equal values are assigned the next rank in order that they occur.
    Ordinal

    ## Assigns a rank to each value of data, dealing with equal values according to the method.

       Arguments:
       - data: Input data to rank.
    compute : Vector -> Vector
    compute self input =
        java_method = case self of
            Rank_Method.Minimum -> Rank.Method.MINIMUM
            Rank_Method.Maximum -> Rank.Method.MAXIMUM
            Rank_Method.Average -> Rank.Method.AVERAGE
            Rank_Method.Ordinal -> Rank.Method.ORDINAL
            Rank_Method.Dense -> Rank.Method.DENSE

        report_nullpointer caught_panic = Error.throw (Illegal_Argument.Error caught_panic.payload.cause.getMessage)
        handle_nullpointer = Panic.catch NullPointerException handler=report_nullpointer
        handle_classcast = Panic.catch ClassCastException handler=(_ -> Error.throw Incomparable_Values)

        handle_classcast <| handle_nullpointer <|
            java_ranks = Rank.rank input.to_array Comparator.new java_method
            Vector.from_polyglot_array java_ranks

type Statistic
    ## Count the number of non-Nothing and non-NaN values.
    Count

    ## The minimum value.
    Minimum

    ## The maximum value.
    Maximum

    ## Sum the non-Nothing and non-NaN values.
    Sum

    ## The sample mean of the values.
    Mean

    ## The variance of the values.
       Arguments:
       - population: specifies if data is a sample or the population.
    Variance (population:Boolean=False)

    ## The standard deviation of the values.
       Arguments:
       - population: specifies if data is a sample or the population.
    Standard_Deviation (population:Boolean=False)

    ## The skewness of the values.
       Arguments:
       - population: specifies if data is a sample or the population.
    Skew (population:Boolean=False)

    ## The sample kurtosis of the values.
    Kurtosis

    ## Calculate the Covariance between data and series.

       Arguments:
       - series: the series to compute the covariance with.
    Covariance (series:Vector)

    ## Calculate the Pearson Correlation between data and series.

       Arguments:
       - series: the series to compute the correlation with.
    Pearson (series:Vector)

    ## Calculate the Spearman Rank Correlation between data and series.

       Arguments:
       - series: the series to compute the correlation with.
    Spearman (series:Vector)

    ## Calculate the coefficient of determination between data and predicted
       series.

       Arguments:
       - predicted: the series to compute the r_squared with.
    R_Squared (predicted:Vector)

    ## Compute a single statistic on a vector like object.

       Arguments:
       - data: Vector like object which has a `to_array` method.
       - statistic: Statistic to calculate.
    compute : Vector -> Statistic -> Any
    compute data statistic=Statistic.Count =
        Statistic.compute_bulk data [statistic] . first

    ## Compute a set of statistics on a vector like object.

       Arguments:
       - data: Vector like object which has a `to_array` method.
       - statistics: Set of statistics to calculate.
    compute_bulk : Vector -> Vector Statistic -> Vector Any
    compute_bulk data statistics=[Statistic.Count, Statistic.Sum] =
        count_min_max = statistics.any s->
            case s of
                Statistic.Count -> True
                Statistic.Minimum -> True
                Statistic.Maximum -> True
                _ -> False

        java_stats = statistics.map to_moment_statistic
        skip_java_stats = java_stats.all s->s.is_nothing

        report_invalid _ =
            statistics.map_with_index i->v->
                if java_stats.at i . is_nothing then Nothing else
                    Error.throw (Illegal_Argument.Error ("Can only compute " + v.to_text + " on numerical data sets."))
        handle_unsupported = Panic.catch Unsupported_Argument_Types.Error handler=report_invalid

        empty_map s = if (s == Statistic.Count) || (s == Statistic.Sum) then 0 else
            if (s == Statistic.Minimum) || (s == Statistic.Maximum) then Error.throw Empty_Error else
                Number.nan

        if data.length == 0 then statistics.map empty_map else
            count_min_max_values = if count_min_max then CountMinMax.new (CountMinMax.toObjectStream data.to_array) Comparator.new else Nothing
            stats_array = if skip_java_stats then Nothing else
                handle_unsupported <| Moments.compute data.to_array java_stats.to_array

            statistics.map_with_index i->s->case s of
                Statistic.Count -> count_min_max_values.count
                Statistic.Minimum ->
                    if count_min_max_values.comparatorError then (Error.throw Incomparable_Values) else
                        count_min_max_values.minimum
                Statistic.Maximum ->
                    if count_min_max_values.comparatorError then (Error.throw Incomparable_Values) else
                        count_min_max_values.maximum
                Statistic.Covariance s -> calculate_correlation_statistics data s . covariance
                Statistic.Pearson s -> calculate_correlation_statistics data s . pearsonCorrelation
                Statistic.Spearman s -> calculate_spearman_rank data s
                Statistic.R_Squared s -> calculate_correlation_statistics data s . rSquared
                _ -> stats_array.at i

    ## Compute a set of statistics on a vector like object.

       Arguments:
       - data: Vector like object which has a `to_array` method.
       - statistics: Set of statistics to calculate.
    compute_bulk_enso : Vector -> Vector Statistic -> Vector Any
    compute_bulk_enso data statistics=[Statistic.Count, Statistic.Sum] =
        empty_map s = if (s == Statistic.Count) || (s == Statistic.Sum) then 0 else
            if (s == Statistic.Minimum) || (s == Statistic.Maximum) then Error.throw Empty_Error else
                Number.nan

        if data.length == 0 then statistics.map empty_map else
            orders = statistics.map Statistic_Aggregator.get_order
            order = orders.fold Nothing c->v-> if c.is_nothing then v else if v.is_nothing then c else c.max v
            aggr = if order.is_nothing then Nothing else data.fold (Statistic_Aggregator.new order) c->v-> c.append v
            statistics.map s->case s of
                Statistic.Covariance s -> calculate_correlation_statistics data s . covariance
                Statistic.Pearson s -> calculate_correlation_statistics data s . pearsonCorrelation
                Statistic.Spearman s -> calculate_spearman_rank data s
                Statistic.R_Squared s -> calculate_correlation_statistics data s . rSquared
                _ -> aggr.compute s

    ## Calculate a variance-covariance matrix between the input series.

       Arguments:
       - data: The input data sets
    covariance_matrix : Vector Vector -> Vector Vector
    covariance_matrix data =
        stats_vectors = calculate_correlation_statistics_matrix data
        stats_vectors.map v->(v.map .covariance)

    ## Calculate a Pearson correlation matrix between the input series.

       Arguments:
       - data: The input data sets
    pearson_correlation : Vector Vector -> Vector Vector
    pearson_correlation data =
        stats_vectors = calculate_correlation_statistics_matrix data
        stats_vectors.map v->(v.map .pearsonCorrelation)

    ## Calculate a Spearman Rank correlation matrix between the input series.

       Arguments:
       - data: The input data sets
    spearman_correlation : Vector Vector -> Vector Vector
    spearman_correlation data =
        Panic.handle_wrapped_dataflow_error <|
            output = Vector.new_builder data.length

            0.up_to data.length . each i->
                output.append <|
                    Vector.new data.length j->
                        if j == i then 1 else
                            if j < i then (output.at j . at i) else
                                Panic.throw_wrapped_if_error <|
                                    calculate_spearman_rank (data.at i) (data.at j)

            output.to_vector

    ## Assigns a rank to each value of data, dealing with equal values according to the method.

       Arguments:
       - data: Input data to rank.
       - method: Method used to deal with equal values.
    rank_data : Vector -> Rank_Method -> Vector
    rank_data input method=Rank_Method.Average =
        method.compute input

## PRIVATE
   Convert the Enso Statistic into Java equivalent.
to_moment_statistic : Statistic -> MomentStatistic
to_moment_statistic s = case s of
    Statistic.Sum -> Moments.SUM
    Statistic.Mean -> Moments.MEAN
    Statistic.Variance p -> if p then Moments.VARIANCE_POPULATION else Moments.VARIANCE
    Statistic.Standard_Deviation p -> if p then Moments.STANDARD_DEVIATION_POPULATION else Moments.STANDARD_DEVIATION
    Statistic.Skew p -> if p then Moments.SKEW_POPULATION else Moments.SKEW
    Statistic.Kurtosis -> Moments.KURTOSIS
    _ -> Nothing

## PRIVATE
wrap_java_call : Any -> Any
wrap_java_call ~function =
    report_unsupported _ = Error.throw (Illegal_Argument.Error ("Can only compute correlations on numerical data sets."))
    handle_unsupported = Panic.catch Unsupported_Argument_Types.Error handler=report_unsupported

    handle_unsupported <| Illegal_Argument.handle_java_exception <| function

## PRIVATE
   Given two series, get a computed CorrelationStatistics object
calculate_correlation_statistics : Vector -> Vector -> CorrelationStatistics
calculate_correlation_statistics x_data y_data =
    wrap_java_call <| CorrelationStatistics.compute x_data.to_array y_data.to_array

## PRIVATE
   Given two series, get a compute the Spearman Rank correlation
calculate_spearman_rank : Vector -> Vector -> Decimal
calculate_spearman_rank x_data y_data =
    wrap_java_call <| CorrelationStatistics.spearmanRankCorrelation x_data.to_array y_data.to_array

## PRIVATE
   Given a set of series get CorrelationStatistics objects
calculate_correlation_statistics_matrix : Vector Vector -> Vector CorrelationStatistics
calculate_correlation_statistics_matrix data =
    data_array = Vector.new data.length i->(data.at i).to_array . to_array
    stats_array = wrap_java_call <| CorrelationStatistics.computeMatrix data_array
    Vector.new stats_array.length i->(Vector.from_polyglot_array (stats_array.at i))

## Compute a single statistic on the vector.

   Arguments:
   - statistic: Statistic to calculate.
Vector.compute : Statistic -> Any
Vector.compute self statistic=Statistic.Count =
    self.compute_bulk [statistic] . first

## Compute statistics on the vector.

   Arguments:
   - statistics: Set of statistics to calculate.
Vector.compute_bulk : Vector Statistic -> Vector Any
Vector.compute_bulk self statistics=[Statistic.Count, Statistic.Sum] =
    Statistic.compute_bulk self statistics

type Statistic_Aggregator
    ## PRIVATE
       Aggregator for computing moments.
       This class is used to compute the moments of a data set.
    Value order:Integer count:Integer incomparable:Boolean minimum:(Any|Nothing) maximum:(Any|Nothing) sums:(Vector Decimal)

    ## ADVANCED
       Gets the required order for a Statistic or Nothing if not a Statistic_Aggregator based one.Statistic
    get_order : Statistic -> (Integer|Nothing)
    get_order statistic = case statistic of
        Statistic.Count -> 0
        Statistic.Minimum -> 0
        Statistic.Maximum -> 0
        Statistic.Sum -> 1
        Statistic.Mean -> 1
        Statistic.Variance _ -> 2
        Statistic.Standard_Deviation _ -> 2
        Statistic.Skew _ -> 3
        Statistic.Kurtosis -> 4
        _ -> Nothing

    ## Create an aggregator for computing moments.
    new : Integer -> Statistic_Aggregator
    new order =
        Statistic_Aggregator.Value order 0 False Nothing Nothing (Vector.fill order 0)

    ## Add a value to the aggregator.
    append : Any -> Statistic_Aggregator
    append self value = if value.is_nothing then self else
        count = self.count + 1

        minimum = if self.incomparable then self.minimum else
            if self.minimum.is_nothing then value else
                case safe_compare_to self.minimum value of
                    Nothing -> Nothing
                    Ordering.Greater -> value
                    _ -> self.minimum

        maximum = if self.incomparable then self.maximum else
            if self.maximum.is_nothing then value else
                case safe_compare_to self.maximum value of
                    Nothing -> Nothing
                    Ordering.Less -> value
                    _ -> self.maximum

        sums = if self.sums.is_nothing then self.sums else
            case value of
                _ : Number -> self.sums.map_with_index i->v-> v + value ^ (i+1)
                _ -> Nothing

        Statistic_Aggregator.Value self.order count (self.incomparable || minimum.is_nothing || maximum.is_nothing) minimum maximum sums

    ## Get a Statistic based off the result of the aggregation.
    compute : Statistic -> Any
    compute self statistic=Statistic.Count = case statistic of
        Statistic.Count -> self.count
        Statistic.Minimum -> if self.incomparable then Error.throw Incomparable_Values else self.minimum
        Statistic.Maximum -> if self.incomparable then Error.throw Incomparable_Values else self.maximum
        Statistic.Sum -> if self.order == 0 then Error.throw (Illegal_Argument.Error "Insufficient order computed for Sum.") else
            if self.sums.is_nothing then Error.throw (Illegal_Argument.Error ("Can only compute Sum on purely numerical data sets.")) else
                self.sums.at 0
        Statistic.Mean -> if self.order == 0 then Error.throw (Illegal_Argument.Error "Insufficient order computed for Mean.") else
            if self.sums.is_nothing then Error.throw (Illegal_Argument.Error ("Can only compute Mean on purely numerical data sets.")) else
                self.sums.at 0 / self.count
        Statistic.Variance p -> if self.order < 2 then Error.throw (Illegal_Argument.Error "Insufficient order computed for Variance.") else
            if self.sums.is_nothing then Error.throw (Illegal_Argument.Error ("Can only compute Variance on purely numerical data sets.")) else
                min_count = if p then 0 else 1
                if self.count <= min_count then Number.nan else
                    (self.sums.at 1 - self.sums.at 0 ^ 2 / self.count) / (self.count - min_count)
        Statistic.Standard_Deviation p -> if self.order < 2 then Error.throw (Illegal_Argument.Error "Insufficient order computed for Standard_Deviation.") else
            if self.sums.is_nothing then Error.throw (Illegal_Argument.Error ("Can only compute Standard_Deviation on purely numerical data sets.")) else
                min_count = if p then 0 else 1
                if self.count <= min_count then Number.nan else
                    (self.sums.at 1 - self.sums.at 0 ^ 2 / self.count) / (self.count - min_count) ^ 0.5
        Statistic.Skew p -> if self.order < 3 then Error.throw (Illegal_Argument.Error "Insufficient order computed for Skew.") else
            if self.sums.is_nothing then Error.throw (Illegal_Argument.Error ("Can only compute Skew on purely numerical data sets.")) else
                if self.count < 3 then Number.nan else
                    avg = self.sums.at 0 / self.count
                    st_dev = self.compute (Statistic.Standard_Deviation p)
                    scale = 1 / (st_dev ^ 3) / (if p then self.count else (self.count - 1) * (self.count - 2) / self.count)
                    (self.sums.at 2 - 3 * avg * self.sums.at 1 + 2 * avg * avg * self.sums 0) * scale
        Statistic.Kurtosis -> if self.order < 4 then Error.throw (Illegal_Argument.Error "Insufficient order computed for Kurtosis.") else
            if self.sums.is_nothing then Error.throw (Illegal_Argument.Error ("Can only compute Kurtosis on purely numerical data sets.")) else
                if self.count < 4 then Number.nan else
                    n = self.count
                    avg = self.sums.at 0 / n
                    var = self.compute (Statistic.Variance False)
                    scale = n * (n + 1) / ((n - 1) * (n - 2) * (n - 3) * var * var)
                    shift = 3 * (n - 1) * (n - 1) / ((n - 2) * (n - 3))
                    (self.sums.at 3 - 4 * avg * self.sums.at 2 + 6 * avg * avg * self.sums.at 1 - avg * avg * avg * self.sums.at 0) * scale - shift
        _ -> Error.throw (Illegal_Argument.Error ("Cannot compute " + statistic.to_text + " on a single data set."))

## PRIVATE
safe_compare_to : Any -> Any -> Ordering | Nothing
safe_compare_to a b =
    result = Incomparable_Values.handle_errors <| a.compare_to b
    result.catch Incomparable_Values _->Nothing
