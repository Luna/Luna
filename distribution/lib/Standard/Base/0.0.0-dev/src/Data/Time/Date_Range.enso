import project.Any.Any
import project.Data.Numbers.Integer
import project.Data.Text.Text
import project.Data.Time.Date.Date
import project.Data.Time.Date_Period.Date_Period
import project.Data.Time.Period.Period
import project.Data.Vector.Vector
import project.Error.Error
import project.Errors.Common.Index_Out_Of_Bounds
import project.Errors.Time_Error.Time_Error
import project.Nothing.Nothing

from project.Data.Boolean import Boolean, True, False

## Represents a range of dates.
type Date_Range
    ## PRIVATE
       Never use the constructor directly to construct a range, as it does not
       allow to verify invariants and may lead to unexpected behavior.
    Internal_Constructor (start : Date) (end : Date) (step : Period) (increasing : Boolean) (cached_length : Integer)

    ## Create a representation of a right-exclusive range of dates.

       Arguments:
       - start: The left boundary of the range. Its value is included.
       - end: The right boundary of the range. Its value is excluded.
       - step: The step between values.
    new : Date -> Date -> Date_Period|Period -> Date_Range
    new start=Date.now end=Date.now step=Date_Period.Day =
        increasing = start <= end
        Date_Range.new_internal start end increasing step

    ## PRIVATE
    new_internal : Date -> Date -> Boolean -> Date_Period|Period -> Date_Range
    new_internal start end increasing step =
        one_day = Period.new days=1
        base_step = if increasing then one_day else one_day.negated
        base_length = start.days_until end . abs
        Date_Range.Internal_Constructor start end base_step increasing base_length . with_step step

    ## Creates a copy of this range with a changed step.

       > Example
         Create a range representing the first day of every month in a year.

             (Date.new 2020 1 1).up_to (Date.new 2020 12 31) . with_step Date_Period.Month

       > Example
         Create a a decreasing range of every other day between two dates.

             (Date.new 2022 10 23).down_to (Date.new 2022 10 1) . with_step (Period.new days=2)
    with_step : Date_Period|Period -> Date_Range
    with_step self new_step = case new_step of
        _ : Period ->
            effective_step = if self.start > self.end then new_step.negated else new_step
            effective_length = compute_length_and_verify self.start self.end effective_step self.increasing
            effective_length.if_not_error <|
                Date_Range.Internal_Constructor self.start self.end effective_step self.increasing effective_length
        _ : Date_Period ->
            self.with_step new_step.to_period

    ## Convert to a textual representation.
    to_text : Text
    to_text self =
        step = if (self.step.days.abs == 1) && (self.step.years == 0) && (self.step.months == 0) then "" else
            " by " + self.step.to_text
        "(Date_Range from " + self.start.to_text + " until " + self.end.to_text + step + ")"

    ## Convert to a display representation.
    to_display_text : Text
    to_display_text self = self.to_text

    ## Returns the first element that is included within the range or `Nothing`
       if the range is empty.
    first : Integer ! Index_Out_Of_Bounds
    first self = if self.is_empty then Error.throw (Index_Out_Of_Bounds.Error 0 0) else self.start

    ## Returns the second element that is included within the range or `Nothing`
       if the range has less than 2 element
    second : Integer ! Index_Out_Of_Bounds
    second self = if self.length < 2 then Error.throw (Index_Out_Of_Bounds.Error 1 self.length) else self.start + self.step

    ## Returns the last element that is included within the range or `Nothing`
       if the range is empty.
    last : Integer ! Index_Out_Of_Bounds
    last self = if self.is_empty then Error.throw (Index_Out_Of_Bounds.Error 0 0) else
        self.start + self.step*(self.length - 1)

    ## Get the number of elements in the range.

       > Example
         The following range has 2 elements.

            (Date.new 2023 04 05) . up_to (Date.new 2023 04 07) . length
    length : Integer
    length self = self.cached_length

    ## Gets an element from the range at a specified index (0-based).

       Arguments:
       - index: The location in the range to get the element from. The index is
         also allowed be negative, then the elements are indexed from the back,
         i.e. -1 will correspond to the last element.

       > Example
         Get the second element of a range.

              (Date.new 2023 04 05) . up_to (Date.new 2023 04 07) . get 1 == (Date.new 2023 04 06)

       > Example
         Get the last element of a range with step.

            (Date.new 2023 04 05) . up_to (Date.new 2023 10 07) . with_step Date_Period.Month . get -1 == (Date.new 2023 10 05)
    at : Integer -> Any ! Index_Out_Of_Bounds
    at self index =
        self.get index (Error.throw (Index_Out_Of_Bounds.Error index self.length))

    ## Gets an element from the range at a specified index (0-based).
       If the index is invalid then `if_missing` is returned.

       Arguments:
       - index: The location in the range to get the element from. The index is
         also allowed be negative, then the elements are indexed from the back,
         i.e. -1 will correspond to the last element.
       - if_missing: The value to return if the index is out of bounds.
    get : Integer -> Any -> Any
    get self index ~if_missing=Nothing =
        len = self.length
        effective_index = if index < 0 then len + index else index
        if effective_index >= 0 && effective_index < len then self.internal_at effective_index else
            if_missing

    ## PRIVATE
       Generates the i-th element of the range.

       This method does no bounds checking, it should be used only internally.
    internal_at self i =
        nth_element_of_range self.start self.step i

    ## Applies a function to each element in the range, producing a vector of
       results.

       Arguments:
       - function: The function to apply to each date in the range.

       > Example
         Create a vector that contains the numbers twice that of the numbers in
         the range.

             1.up_to 10 . map (*2)
    map : (Date -> Any) -> Vector Any
    map self function =
        Vector.new self.length (i -> function (self.internal_at i))

    ## Converts the range to a vector containing the dates in the range.

       > Example
         Getting a vector of dates from 2021-05-07 to 2021-05-10 (exclusive).

             (Date.new 2021 05 07).up_to (Date.new 2021 05 10) . to_vector
    to_vector : Vector Date
    to_vector self = self.map x->x

    ## Checks if this range is empty.

       > Example
         Checking if the range of days from start of 2020 to start of 2023 is empty.

             (Date.new 2020).up_to (Date.new 2023) . is_empty
    is_empty : Boolean
    is_empty self = self.length == 0

    ## Checks if this range is not empty.

       > Example
         Checking if the range of days from start of 2020 to start of 2023 is not empty.

             (Date.new 2020).up_to (Date.new 2023) . is_empty
    not_empty : Boolean
    not_empty self = self.is_empty.not

    ## Returns a vector of all elements of this range which satisfy a condition.

       Arguments:
       - filter: The filter to apply to the range. It can either be an instance
         of `Filter_Condition` or a predicate taking a value and returning a
         boolean value indicating whether the corresponding element should be
         kept or not.

       > Example
         Selecting all elements that are greater than 2020-10-12.

             (Date.new 2020 10 01).up_to (Date.new 2020 10 15) . filter (> (Date.new 2020 10 12))
             (Date.new 2020 10 01).up_to (Date.new 2020 10 15) . filter (Filter_Condition.Greater than=(Date.new 2020 10 12))
    filter : (Filter_Condition | (Date -> Boolean)) -> Vector Date
    filter self filter = case filter of
        _ : Filter_Condition -> self.filter filter.to_predicate
        predicate : Function ->
            builder = self.fold Vector.new_builder builder-> elem->
                if predicate elem then builder.append elem else builder
            builder.to_vector

    ## Applies a function for each element in the range.

       Arguments:
       - function: The function to apply to each integer in the range.

       > Example
         To print all dates from 2020-10-01 to 2020-10-05.
             (Date.new 2020 10 01).up_to (Date.new 2020 10 05) include_end=True . each IO.println
    each : (Date -> Any) -> Nothing
    each self function =
        (0.up_to self.length).each ix->
            function (self.internal_at ix)

    ## PRIVATE
       Applies a function to each element of the range.

       Essentially acts like `range.to_vector.each_with_index`, but it is more
       efficient.

       Arguments:
       - function: A function to apply that takes two parameters: first the
         index of a given range element and then the actual range element.

       > Example
         Print range elements with their indices within the range.

             (Date.new 2020 10 01).up_to (Date.new 2020 10 05).each_with_index ix-> elem-> IO.println (Pair ix elem)
    each_with_index : (Integer -> Date -> Nothing) -> Nothing
    each_with_index self function =
        (0.up_to self.length).each_with_index ix->
            function ix (self.internal_at ix)

    ## Combines all the elements of the range, by iteratively applying the
       passed function with next elements of the range.

       Arguments:
       - init: The initial value for the fold.
       - function: A binary function taking an item and a date, and returning
         an item.

       > Example
         In the following example, we'll compute how many days in the range are
         a Monday.

             (Date.new 2020 10 01).up_to (Date.new 2020 10 31) . fold 0 acc-> date->
                if date.day_of_week == Day_Of_Week.Monday then acc+1 else acc
    fold : Any -> (Any -> Number -> Any) -> Any
    fold self init function =
        (0.up_to self.length).fold init acc-> ix->
            function acc (self.internal_at ix)

    ## Combines all the elements of the range, by iteratively applying the
       passed function with the next element of the range. After each step the
       value is stored resulting in a new Vector of the same size as self.

       Arguments:
       - init: The initial value for the fold.
       - function: A function taking two elements and combining them.
    running_fold : Any -> (Any -> Any -> Any) -> Vector Any
    running_fold self init function =
        (0.up_to self.length).running_fold init acc-> ix->
            function acc (self.internal_at ix)

    ## Checks whether `predicate` is satisfied for all dates in this range.

       Arguments:
       - predicate: A function that takes a list element and returns a boolean
         value that says whether that value satisfies the conditions of the
         function.

       > Example
         Checking that all dates in the range are after 2020-10-01.

             (Date.new 2020 10 01).up_to (Date.new 2020 10 31) . all (> (Date.new 2020 10 01))
    all : (Date -> Boolean) -> Boolean
    all self predicate = self . any (predicate >> .not) . not

    ## Checks whether `predicate` is satisfied for any date in this range.

       Arguments:
       - predicate: A function that takes a list element and returns a boolean
         value that says whether that value satisfies the conditions of the
         function.

       > Example
         Checking that at least one date in the range is after 2020-10-01.

             (Date.new 2020 10 01).up_to (Date.new 2020 10 31) . any (> (Date.new 2020 10 01))
    any : (Number -> Boolean) -> Boolean
    any self predicate = self.find predicate . is_nothing . not

    ## Gets the first index when `predicate` is satisfied this range.
       If no index satisfies the predicate, returns `if_missing`.

       Arguments:
       - predicate: A function that takes a list element and returns a boolean
         value that says whether that value satisfies the conditions of the
         function.
       - start: The index to start searching from. If the index is negative, it
         is counted from the end of the range.
       - if_missing: Value returned if no element satisfies the predicate.

       > Example
         Get the first date in the range that is a Monday.

                (Date.new 2020 10 01).up_to (Date.new 2020 10 31) . find (d-> d.day_of_week == Day_Of_Week.Monday)
    find : (Date -> Boolean) -> Integer -> Any -> Any
    find self predicate start=0 ~if_missing=Nothing =
        index = self.index_of predicate start
        case index of
            Nothing -> if_missing
            _ : Integer -> self.internal_at index

    ## Checks if the range contains the specified value.

       > Example
         Check if a particular date is in the range.

              (Date.new 2020 10 01).up_to (Date.new 2020 10 31) . with_step (Period.new days=2) . contains (Date.new 2020 10 15)
    contains : Date -> Boolean
    contains self value = self.find (== value) . is_nothing . not

    ## Returns the index of an element in the range.
       Returns Nothing if the element is not found.

       Arguments:
       - element: The date to search for or a predicate function to test for
         each element.
       - start: The index to start searching from. If the index is negative, it
         is counted from the end of the range.

       > Example
         Find the index of a first day that is a Monday.

             (Date.new 2020 10 01).up_to (Date.new 2020 10 31) . index_of (d-> d.day_of_week == Day_Of_Week.Monday)
    index_of : (Date | (Date -> Boolean)) -> Integer -> Integer | Nothing
    index_of self element start=0 =
        predicate = case element of
            d : Date ->
                ix-> self.internal_at ix == d
            f : Function ->
                ix-> f (self.internal_at ix)
        (0.up_to self.length).index_of predicate start

    ## Returns the last index of an element in the range.
       Returns Nothing if the element is not found.

       Arguments:
       - element: The date to search for or a predicate function to test for
         each element.
       - start: The index to start searching backwards from. If the index is
         negative, it is counted from the end of the range.

       > Example
         Find the index of a first day that is a Monday.

             (Date.new 2020 10 01).up_to (Date.new 2020 10 31) . last_index_of (d-> d.day_of_week == Day_Of_Week.Monday)
    last_index_of : (Date | (Date -> Boolean)) -> Integer -> Integer | Nothing
    last_index_of self element start=-1 =
        predicate = case element of
            d : Date ->
                ix-> self.internal_at ix == d
            f : Function ->
                ix-> f (self.internal_at ix)
        (0.up_to self.length).last_index_of predicate start

    ## Reverses the range, returning a range with the same elements, but in
       the opposite order.

       > Example
         Reverse a range of dates.

             (Date.new 2020 10 01).up_to (Date.new 2020 10 31) . reverse
    reverse : Date_Range
    reverse self = case self.is_empty of
        True ->
            Date_Range.new_internal self.end self.start self.increasing.not self.step
        False ->
            new_start = self.last
            new_end_inclusive = self.first
            increasing = new_start <= new_end_inclusive
            new_end_exclusive = if increasing then new_end_inclusive.next else new_end_inclusive.previous
            Date_Range.new_internal new_start new_end_exclusive increasing self.step

    ## Converts the range to a vector containing the numbers in the range.

       > Example
         Getting a vector of the numbers 1 to 5.

             1.up_to 6 . to_vector
    to_vector : Vector Integer
    to_vector self = self.map x->x

    ## Combines all the elements of a non-empty range using a binary operation.
       If the range is empty, returns `if_empty`.

       Arguments:
       - function: A binary operation that takes two dates and combines them
         into a new date.
       - if_empty: Value returned if the range is empty.
    reduce : (Date -> Date -> Date) -> Any -> Any
    reduce self function ~if_empty=(Error.throw Empty_Error) =
        case self.length of
            0 -> if_empty
            1 -> self.start
            length ->
                (1.up_to length).fold self.start acc-> ix->
                    function acc (self.internal_at ix)


## PRIVATE
   Computes the length of the range and verifies its invariants.

   If any of the invariants are violated, a dataflow error is raised.
compute_length_and_verify : Date -> Date -> Period -> Boolean -> Integer ! Time_Error
compute_length_and_verify start end step increasing =
    # First a few heuristics for a fast path.
    if (step.days == 0) && (step.total_months == 0) then Error.throw (Time_Error.Error "The step must not be zero.") else
        # TODO implement heuristics
        #if (step.total_months == 0) then compute_length_step_days start end step.days else
        # TODO check if this is able to handle edge cases correctly
        #if (step.days == 0) then compute_length_step_months start end step.total_months else
        # Then we go brute force for the general case.
        compute_length_step_brute_force start end step increasing

## PRIVATE
nth_element_of_range start step n =
    start + step*n

## PRIVATE
compute_length_step_brute_force start end step increasing =
    is_exceeded = case increasing of
        True -> (x -> x >= end)
        False -> (x -> x <= end)
    go current_date acc_length =
        if is_exceeded current_date then acc_length else
            # TODO is cycle of length > 1 possible?
            next_date = nth_element_of_range start step (acc_length + 1)
            if next_date == current_date then Error.throw (Time_Error.Error "The provided step ["+step.to_display_text+"] is malformed - for the date ["+current_date.to_display_text+"] that would be included in the range, it does not progress - the shifted date is the same as the starting date.") else
                @Tail_Call go next_date (acc_length + 1)
    go start 0
