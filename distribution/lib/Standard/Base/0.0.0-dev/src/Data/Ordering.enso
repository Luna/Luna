import project.Data.Numbers.Integer
import project.Data.Numbers.Decimal
import project.Data.Numbers.Number
import project.Error.Common.Type_Error
import project.Error.Error
import project.Error.Unimplemented.Unimplemented
import project.Nothing
import project.Any.Any
from project.Data.Boolean import all
import project.Meta
import project.Meta.Atom

## Provides custom ordering, equality check and hash code for types that need it.

    The Enso runtime system offers default implementation of _equality_
    as well as capability to _compute hash code_ (for use in `Map`) automatically.
    The default implementation is sufficient for most of the programming activities.
    Especially when defining new type and its constructors, they get sensible
    implementation of both functions.

    Should there be a need to redefine the default implementation, here is a way:
    Define conversion function `Comparable.from` for your `type` and return pointer to
    another `type` that satisfies either of the following two definitions:

    ```
    type Default_Ordered_Comparator T
        is_ordered = True
        compare : T -> T -> Ordering
        hash : T -> Integer

    type Default_Unordered_Comparator T
        is_ordered = False
        equals : T -> T -> Boolean
        hash : T -> Integer
    ```

    There is an implicit conversion from any type to `Comparable` with `Comparable.from`.
    But due to technical limitations, we cannot specify its signature in code.
    The return type of `Comparable.from (_ : MyType)` is
    `(Default_Ordered_Comparator|Default_Unordered_Comparator|Incomparable)`.

    > Example
        Representation of _rational numbers_ as a pair of integers needs a
        special equality. Here is a way to define it:

        ```
        type Rational
            Fraction (numerator:Integer) (denominator:Integer)

        Comparable.from (_:Rational) = Rational_Ordering
        ```

        The `comparator` definition overrides the extension function on
        `Any` defined by `Ordering` module and returns reference to the following
        type:

        ```
        type Rational_Ordering
            is_ordered = True
            compare self r1 r2 =
                v1 = r1.numerator * r2.denominator
                v2 = r2.numerator * r1.denominator
                if v1 < v2 then Ordering.Less else
                    if v1 > v2 then Ordering.Greater else
                        Ordering.Equal
            hash self r1 = 42 # or something better
        ```

        By defining the `Rational_Ordering` and making it available via
        `Comparable.from (_:Rational)` method, all parts of the Enso system will use
        the custom comparator whenever equality or hash code is needed.

        The equality check of two objects:
        - verifies both objects share the same type of `comparator`
        - consults their `compare`, or `equals` method, based on whether the comparator is
          ordered or unordered.
        - if the result is `Ordering.Equal` the system also checks that both instances have the same `hash`
        - the `hash` code check may be done only from time to time to speed things up
@Builtin_Type
type Comparable
    ## PRIVATE
       Called as a callback from internal engine code for an atom with a custom
       comparator. It is assumed that the given atom has a custom comparator, that is
       a comparator different than `Default_Unordered_Comparator`.:
    hash_callback : Atom -> Integer
    hash_callback atom = (Comparable.from atom).hash atom

    ## PRIVATE
    has_custom_comparator : Atom -> Boolean
    has_custom_comparator atom =
        comp = Comparable.from atom
        (comp.is_a Default_Unordered_Comparator).not && (comp.is_a Default_Unordered_Comparator).not

## Singleton denoting that values of certain type are not comparable.
type Incomparable
    Singleton

## Default implementation of unordered comparator. Uses the builtin equals and hash_code.
@Builtin_Type
type Default_Unordered_Comparator
    is_ordered = False

    equals : Any -> Any -> Boolean
    equals x y = Comparable.equals_builtin x y

    hash : Any -> Integer
    hash object = Comparable.hash_builtin object


## Default implementation of an ordered _comparator_ that forwards to `>`, `<` etc.
   operators.
@Builtin_Type
type Default_Ordered_Comparator
    is_ordered = True

    compare : Any -> Any -> Ordering
    compare x y =
        if Comparable.less_than_builtin x y then Ordering.Less else
            if Comparable.equals_builtin x y then Ordering.Equal else
                if Comparable.less_than_builtin y x then Ordering.Greater

    hash : Number -> Integer
    hash x = Comparable.hash_builtin x


# By default, there is no conversion from Any to Default_Ordered_Comparator
# Note that we allow also conversion from types, e.g., `Comparable.from Integer`
# for convenience.
Comparable.from (that:Any) =
    case that of
        _ : Number -> Default_Ordered_Comparator
        Integer -> Default_Ordered_Comparator
        Decimal -> Default_Ordered_Comparator
        Number -> Default_Ordered_Comparator
        _ -> Default_Unordered_Comparator


## Types representing the ordering of values.

   These are intended to be returned from the `compare_to` function, that has a
   type as follows for a type `A`: `A.compare_to : A -> Ordering`.

   The result should be returned in terms of how `self` orders in comparison to
   `that`. So, if `self` is greater than `that`, you should return `Greater.`
@Builtin_Type
type Ordering
    ## A representation that the first value orders as less than the second.
    Less

    ## A representation that the first value orders as equal to the second.
    Equal

    ## A representation that the first value orders as greater than the second.
    Greater

    ## Converts the ordering to the signed notion of ordering based on integers.

       > Example
         Converting equal ordering to a signed number.

             import Standard.Base.Data.Ordering

             example_to_sign = Ordering.Equal.to_sign
    to_sign : Integer
    to_sign self = case self of
        Ordering.Less -> -1
        Ordering.Greater -> 1
        Ordering.Equal -> 0

    ## A lexicographical comparison.

    and_then : Ordering -> Ordering
    and_then self ~other = case self of
        Ordering.Less -> Ordering.Less
        Ordering.Equal -> other
        Ordering.Greater -> Ordering.Greater

    compare_to : Ordering -> Ordering
    compare_to self that = case that of
        _ : Ordering -> self.to_sign.compare_to that.to_sign
        _ -> Error.throw (Type_Error.Error Ordering that "that")

    ## Converts a sign-based representation of ordering to Enso's native ordering.

       Arguments:
       - sign: The number representing the relative ordering of two entities.

       > Example
         Convert the number 0 to an Enso ordering.

             Ordering.from_sign 0
    from_sign : Integer -> Ordering
    from_sign sign = if sign == 0 then Ordering.Equal else
        if sign > 0 then Ordering.Greater else Ordering.Less
