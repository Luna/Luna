import project.Any.Any
import project.Data.Text.Text
import project.Error.Error
import project.Meta
import project.Panic.Panic
from project.Data.Boolean import Boolean, False, True
from project.Runtime import assert

## PRIVATE
   `Exception` is not a type of error; rather, it is a way to throw an `Error`
   in imperative-style code and ensure that it is always handled or propagated
   to the top level.

   `throw_exception` works by wrapping the error in an `Uncaught_Exception` and
   raising it with `Panic.throw`. This should occur inside a `catch_exception`
   block, which catches the `Panic` and rethrows the wrapped error as a dataflow
   error.

    > Example
      Abort an imperative block with `throw_exception`.

          handler e =
              IO.println 'Caught: '+e.to_text

          Exception.catch_exception My_Error handler=handler <|
              a = 10
              b = a + a
              IO.println a
              IO.println b
              Exception.throw_exception (My_Error.Error "error")
              IO.println "Does not reach here"

          # Prints:
          # 10
          # 20
          # Caught: (My_Error.Error 'error')
type Exception
    ## PRIVATE

       Catch a dataflow error wrapped in a `Panic` and rethrow it as an `Error`.

       `catch_exception` specifies the type of `Error` to catch; other throw
       `Errors` will be ignored, possibly to be caught by a different
       `catch_exception` block.

       The default error handler rethrows the `Error`.

       ! Error Conditions

         - If `throw_exception` is not wrapped in a `catch_exception` block for
         the type of `Error` thrown, the `Uncaught_Exception` panic simply
         propagates as a normal panic.

       Arguments
       - exception: The type of `Error` to catch.
       - action: The block containing the code that might throw the `Error`.
       - handler: An error handler that receives the caught dataflow error.
    catch_exception : Any -> (Any -> Any) -> Any -> Any
    catch_exception exception_type ~action (handler : Any -> Any = Exception.default_handler) =
        Panic.catch Uncaught_Exception action cp->
            assert (cp.payload . is_a Uncaught_Exception)
            error = cp.payload.error
            if error.is_a exception_type . not then Panic.throw cp.payload else
                handler error

    ## PRIVATE

       Throw a dataflow error wrapped as a `Panic`, to be caught by an enclosing
       `catch_exception` block.
    throw_exception : Any -> Panic
    throw_exception error -> Panic =
        ## TODO: Should preserve the stack trace here and re-attach it in the
           default catch callback, which propagates it as a dataflow error.
        Panic.throw (Uncaught_Exception.Error error)

    ## PRIVATE
       The default error handler rethrows the `Error`.
    default_handler : Any -> Any
    default_handler = Error.throw

## PRIVATE
   An `Uncaught_Exception` is actually a wrapper around a regular `Error`. The
   `Error` is wrapped in an `Uncaught_Exception` and thrown via `Panic.throw`.
   This should all happen inside an `Exception.catch_exception` block; the
   `catch` removes the `Uncaught_Exception` wrapper and propagates the `Error`
   via normal `Error` propagation.
type Uncaught_Exception
    Error error

    ## PRIVATE
       Convert the Uncaught_Exception error to a human-readable format.
    to_display_text : Text
    to_display_text self = "Uncaught Exception: "+self.error.to_text