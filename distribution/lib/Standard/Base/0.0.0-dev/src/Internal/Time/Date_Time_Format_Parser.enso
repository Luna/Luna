import project.Data.Numbers.Integer
import project.Data.Text.Text
import project.Data.Time.Date_Time_Format_Pattern.Date_Time_Format_Parse_Error
import project.Data.Vector.Vector
from project.Data.Boolean import Boolean, False, True
from project.Data.Text.Extensions import all

polyglot java import org.enso.base.Text_Utils

## PRIVATE
type Format_Token
    ## PRIVATE
       A format pattern described by a single character and count.
    Pattern character:Text count:Integer

    ## PRIVATE
       A literal text string.
    Literal text:Text

    ## PRIVATE
       Indicates beginning of an optional section.
    Optional_Section_Start

    ## PRIVATE
       Indicates end of an optional section.
    Optional_Section_End

    ## PRIVATE
       A special parameter in curly braces.

       Currently only used to customize base year for `yy`, i.e. `yy{2099}`.
    Curly_Section (inner_text : Text)


## PRIVATE
tokenize : Text -> Vector Format_Token
tokenize text = Panic.recover Date_Time_Format_Parse_Error <|
    # Nothing is a guard to finish parsing
    chars = text.characters+[Nothing]
    tokens_builder = Vector.new_builder
    is_in_optional = Ref.new False

    finalize_token current_token = case current_token of
        Nothing -> Nothing
        _ -> tokens_builder.append current_token

    parse_normal position current_token = case chars.at position of
        Nothing ->
            if is_in_optional.get then
                Panic.throw (Date_Time_Format_Parse_Error.Error "Unterminated optional section within the pattern "+text.to_display_text)
            finalize_token current_token
            Nothing
        "'" ->
            finalize_token current_token
            @Tail_Call parse_quoted position+1 ""
        "[" ->
            if is_in_optional.get then
                Panic.throw (Date_Time_Format_Parse_Error.Error "Nested optional sections are not allowed (at position "+position.to_text+" in pattern "+text.to_display_text+").")
            finalize_token current_token
            tokens_builder.append Optional_Section_Start
            is_in_optional.put True
            @Tail_Call parse_normal position+1 Nothing
        "]" ->
            if is_in_optional.get.not then
                Panic.throw (Date_Time_Format_Parse_Error.Error "Unmatched closing bracket ] (at position "+position.to_text+" in pattern "+text.to_display_text+").")
            finalize_token current_token
            tokens_builder.append Optional_Section_End
            is_in_optional.put False
            @Tail_Call parse_normal position+1 Nothing
        "{" ->
            finalize_token current_token
            @Tail_Call parse_curly position+1 ""
        new_character ->
            case Text_Utils.is_all_letters new_character of
                True ->
                    is_matching_current_token = case current_token of
                        Format_Token.Pattern current_pattern_character _ ->
                            current_pattern_character == new_character
                        _ -> False
                    case is_matching_current_token of
                        True ->
                            @Tail_Call parse_normal position+1 (Format_Token.Pattern current_token.character current_token.count+1)
                        False ->
                            finalize_token current_token
                            @Tail_Call parse_normal position+1 (Format_Token.Pattern new_character 1)
                False ->
                    finalize_token current_token
                    tokens_builder.append (Format_Token.Literal other_character)
                    @Tail_Call parse_normal position+1 Nothing

    parse_quoted position text_accumulator = case chars.at position of
        Nothing ->
            Panic.throw (Date_Time_Format_Parse_Error.Error "Unterminated quoted sequence within the pattern "+text.to_display_text)
        "'" ->
            # Next letter is always accessible, but it may be Nothing.
            next_letter = chars.at position+1
            case next_letter of
                # If the next letter is a quote, that means an escaped single quote within a quoted section.
                "'" ->
                    @Tail_Call parse_quoted position+2 text_accumulator+"'"

                # If the next letter is not a quote, that means the end of the quoted sequence.
                _ ->
                    case text_accumulator.is_empty of
                        # If there is no text between the quotes, that means this whole quoted sequence was just an escaped single quote OUTSIDE a quoted section.
                        True ->
                            tokens_builder.append (Format_Token.Literal "'")
                        False ->
                            tokens_builder.append (Format_Token.Literal text_accumulator)
                    @Tail_Call parse_normal position+1 Nothing
        other_character -> @Tail_Call parse_quoted position+1 text_accumulator+other_character

    parse_curly position text_accumulator = case chars.at position of
        Nothing ->
            Panic.throw (Date_Time_Format_Parse_Error.Error "Unterminated curly sequence within the pattern "+text.to_display_text)
        "}" ->
            tokens_builder.append (Format_Token.Curly_Section text_accumulator)
            @Tail_Call parse_normal position+1 Nothing
        other_character ->
            @Tail_Call parse_curly position+1 text_accumulator+other_character

    parse_normal 0 Nothing
    tokens_builder.to_vector
