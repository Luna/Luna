## Enso's default regular expression matching engine.

   ==== TODO ====
   Regex engines should conform to the following requirements:
   - Regex engines should be Unicode compliant by default. In such a mode, all
     character classes must behave as specified in the "Unicode Technical
     Standard 18: Unicode Regular Expression Annex C: Compatability Properties"
   - All engines must support the common regex syntax as described in
     `Standard.Base.Data.Text.Regex`.
   - Regex engines must provide the standard options as described in
     `Standard.Base.Data.Text.Regex.Option`.
   - Engines should provide a _full specification of their syntax_ along with
     their type.

   How on earth do we acually do this with unicode-aware character boundaries?

from Standard.Base import all

import Standard.Base.Data.Text.Regex
import Standard.Base.Data.Text.Regex.Engine
import Standard.Base.Data.Text.Regex.Option as Global_Option
import Standard.Base.Data.Text.Regex.Mode
import Standard.Base.Polyglot.Java as Java_Ext
import Standard.Base.Data.Text.Span

from Standard.Builtins import Java

import Standard.Base.Error.Extensions as Errors

polyglot java import java.lang.IllegalArgumentException
polyglot java import java.lang.IndexOutOfBoundsException
polyglot java import java.util.regex.PatternSyntaxException
polyglot java import java.util.regex.Pattern as Java_Pattern
polyglot java import java.util.regex.Matcher as Java_Matcher
polyglot java import com.ibm.icu.impl.UnicodeRegex
polyglot java import org.enso.base.Regex_Utils

## Construct an instance of the default engine.

   Arguments:
   - opts: Any engine-specific options.

   > Example
     Build a new default engine specifying literal mode.

         import Standard.Base.Data.Text.Regex.Engine.Default as Default_Engine

         example_new =
             engine_opts = [Default_Engine.Literal_Pattern]
             Default_Engine.new engine_opts
new : Vector.Vector Option -> Engine
new opts=[] = Engine opts

## Engine is an interface that must...
   TODO syntax
   TODO Write down and document the expected interface.
type Engine

    ## PRIVATE

       The default regex engine for Enso.

       Arguments:
       - engine_opts: Options for regex matching that are specific to this
         engine.
    type Engine (engine_opts : Vector.Vector Option)

    ## ADVANCED

       Compile the provided `expression` into a regex pattern that can be used
       for matching.

       Arguments
       - expression: The text representing the regular expression that you want
         to compile.
       - options: The options to configure the matching process with. These are
         merged with the specific `engine_opts`.

       ? Why Compile?
         While many regex engines are able to cache ad-hoc patterns, it is often
         useful to be able to manually retain a pattern that you have computed.
         This function exists so you can hold onto the resultant `Pattern`
         object, instead of immediately proceeding to match using it.

       > Example
         Compile the regex `"^a$"` in multiline mode so it matches all lines
         consisting of a single "a".

             import Standard.Base.Data.Text.Regex.Engine.Default as Default_Engine
             import Standard.Base.Data.Text.Regex.Option as Global_Option

             example_compile =
                 expression = "^a$"
                 options = [Global_Option.Multiline]
                 engine = Default_Engine.new
                 engine.compile expression options
    compile : Text -> Vector Global_Option.Option -> Pattern ! (Regex.Compile_Error | Invalid_Option_Error)
    compile expression options =
        all_options = options + this.engine_opts
        options_bitmask = here.from_enso_options all_options
        unicode_regex = UnicodeRegex.new

        maybe_java_pattern = Panic.recover <|
            Java_Pattern.compile (unicode_regex.transform expression) options_bitmask

        internal_pattern = maybe_java_pattern.map_error case _ of
            Polyglot_Error err ->
                if Java.is_instance err PatternSyntaxException . not then err else
                    Regex.Syntax_Error err.getMessage
            other -> other

        Pattern internal_pattern all_options this

    ## ADVANCED

       Escape the special characters in `expression` such that the result is a
       valid literal pattern for the original string.

       Arguments:
       - expression: The expression to escape metacharacters in.

       > Example
         Turn a literal string into a regex that matches that string exactly.

             import Standard.Base.Data.Text.Regex.Engine.Default as Default_Engine
             import Standard.Base.Data.Text.Regex.Option as Global_Option

             example_escape =
                 literal_string = "\!\.|abcde"
                 engine = Default_Engine.new
                 engine.escape literal_string
    escape : Text -> Text
    escape expression = Java_Pattern.quote expression

## Pattern is an interface that must...
   TODO Document this.
type Pattern

    ## PRIVATE

       The default pattern type for Enso, produced by the default regex engine.

       Arguments:
       - internal_pattern: The internal representation of the compiled pattern.
       - options: The vector of options with which this pattern was built.
       - engine: A handle to the engine that built this pattern.
    type Pattern (internal_pattern : Java_Pattern) (options : Vector.Vector (Global_Option.Option | Option)) (engine : Engine)

    ## PRIVATE
    build_matcher : Text -> Integer -> Integer -> Java_Matcher
    build_matcher input start end =
        internal_matcher = this.internal_pattern.matcher input . region start end

        if this.options.contains No_Anchoring_Bounds then
            internal_matcher.useAnchoringBounds False
        if this.options.contains Transparent_Bounds then
            internal_matcher.useTransparentBounds True

        internal_matcher

    ## TODO
    match : Text -> Mode.Mode -> Match | Vector.Vector Match | Nothing
    match input mode=Mode.All =
        do_match_mode mode start end =
            case mode of
                Mode.First ->
                    internal_matcher = this.build_matcher input start end

                    if internal_matcher . find start . not then Nothing else
                        Match internal_matcher start end
                Integer ->
                    builder = Vector.new_builder

                    go : Integer -> Integer -> Nothing
                    go offset remaining_count =
                        should_continue = remaining_count > 0
                        if should_continue.not then Nothing else
                            internal_matcher = this.build_matcher input start end
                            found = internal_matcher.find offset

                            if found.not then Nothing else
                                builder.append (Match internal_matcher start end)

                                if internal_matcher.hitEnd then Nothing else
                                    @Tail_Call go (internal_matcher.end 0) (remaining_count - 1)

                    go start mode
                    vector = builder.to_vector

                    if vector.is_empty then Nothing else vector
                Mode.All ->
                    builder = Vector.new_builder

                    go : Integer -> Nothing
                    go offset =
                        internal_matcher = this.build_matcher input start end
                        found = internal_matcher.find offset

                        if found.not then Nothing else
                            builder.append (Match internal_matcher start end)

                            if internal_matcher.hitEnd then Nothing else
                                @Tail_Call go (internal_matcher.end 0)

                    go start
                    vector = builder.to_vector

                    if vector.is_empty then Nothing else vector
                Mode.Full ->
                    internal_matcher = this.build_matcher input start end
                    if internal_matcher.matches.not then Nothing else
                        Match internal_matcher start end
                Mode.Bounded _ _ _ -> Panic.throw Recursive_Mode_Error

        case mode of
            Mode.Bounded start end sub_mode -> do_match_mode sub_mode start end
            _ -> do_match_mode mode 0 input.length

    ## TODO
    # find : Text -> Mode.Mode -> Text | Vector.Veector Text | Nothing
    # find input mode=Mode.All = Errors.unimplemented

    ## TODO
    # split : Text -> Mode.Mode -> Vector.Vector Text | Nothing
    # split input mode=Mode.All = Errors.unimplemented

    ## TODO
    # replace : Text -> Text -> Mode.Mode -> Text
    # replace input replacement mode=Mode.All = Errors.unimplemented

type Match

    ## PRIVATE

       A representation of a regular expression match.
    type Match (internal_match : Java_Matcher) (region_start : Integer) (region_end : Integer)

    ## Gets the text matched by the group with the provided identifier, or
       `Nothing` if the group did not participate in the match. If no such group
       exists for the provided identifier, a `No_Such_Group_Error` is returned.

       Arguments:
       - id: The index or name of that group.

       ? The Full Match
         The group with index 0 is always the full match of the pattern.

       ? Named Groups by Index
         If the regex contained named groups, these may also be accessed by
         index based on their position in the pattern.

       > Example
         TODO
    group : Integer | Text -> Text | Nothing ! Regex.No_Such_Group_Error
    group id =
        Panic.recover (this.internal_match.group id) . map_error (here.handle_error _ id)

    ## Gets a vector containing the results of _all_ of the capturing groups in
       the pattern, replacing the value of groups that did not participate in
       the match with `default`.

       Arguments:
       - default: The value to return for a given index when the group at that
         index did not participate in the match.

       ? The Full Match
         The group with index 0 is always the full match of the pattern.

       ? Named Groups by Index
         If the regex contained named groups, these may also be accessed by
         index based on their position in the pattern.

       > Example
         TODO
    groups : (a : Any) -> Vector.Vector (Text | a)
    groups default=Nothing =
        group_numbers = 0.up_to this.internal_match.groupCount+1
        group_numbers.map n->
            case this.group n of
                Nothing -> default
                a -> a

    ## Gets a map containing the named capturing groups for the pattern,
       replacing the value for groups that did not participate in the match with
       `default`.

       Arguments:
       - default: The value to return for a given name when the group at that
         index did not participate in the match.

       > Example
         TODO
    named_groups : (a : Any) -> Map Text (Text | a)
    named_groups default=Nothing =
        group_names = Vector.Vector <|
            Regex_Utils.get_group_names this.internal_match.pattern
        pairs = group_names.map name->
            value = case this.group name of
                Nothing -> default
                a -> a
            [name, value]
        Map.from_vector pairs

    ## Gets the index of the first character captured by the group with the
       given identifier, or `Nothing` if the group did not participate in the
       match.

       Arguments:
       - id: The identifier for the group to fetch the start index for.

       ! What is a Character?
         A character is defined as an Extended Grapheme Cluster, see Unicode
         Standard Annex 29. This is the smallest unit that still has semantic
         meaning in most text-processing applications.

       > Example
         TODO
    start : Integer | Text -> Integer | Nothing ! Regex.No_Such_Group_Error
    start id =
        result = Panic.recover (this.internal_match.start id)
        no_errors = result.map_error (here.handle_error _ id)
        if no_errors == -1 then Nothing else no_errors

    ## Gets the index of the first character after `start` that was not captured
       by the group with the given identifier, or `Nothing` if the group did not
       participate in the match.

       Arguments:
       - id: The identifier for the group to fetch the end index for.

       ! What is a Character?
         A character is defined as an Extended Grapheme Cluster, see Unicode
         Standard Annex 29. This is the smallest unit that still has semantic
         meaning in most text-processing applications.

       > Example
         TODO
    end : Integer | Text -> Integer | Nothing ! Regex.No_Such_Group_Error
    end id =
        result = Panic.recover (this.internal_match.end id)
        no_errors = result.map_error (here.handle_error _ id)
        if no_errors == -1 then Nothing else no_errors

    ## Returns the span matched by the group with the provided identifier, or
       `Nothing` if the group did not participate in the match.

       Arguments:
       - id: The identifier for the group to fetch the end index for.

       ! What is a Character?
         A character is defined as an Extended Grapheme Cluster, see Unicode
         Standard Annex 29. This is the smallest unit that still has semantic
         meaning in most text-processing applications.

       > Example
         TODO
    span : Integer | Text -> Span | Nothing ! Regex.No_Such_Group_Error
    span id = case this.group id of
        Nothing -> Nothing
        _ -> Span.new (this.start id) (this.end id) (this.group 0)

    ## Returns the start character index of the match's region.

       ! What is a Character?
         A character is defined as an Extended Grapheme Cluster, see Unicode
         Standard Annex 29. This is the smallest unit that still has semantic
         meaning in most text-processing applications.

       > Example
         TODO
    start_position : Integer
    start_position = this.region_start

    ## Returns the end character index of the match's region.

       ! What is a Character?
         A character is defined as an Extended Grapheme Cluster, see Unicode
         Standard Annex 29. This is the smallest unit that still has semantic
         meaning in most text-processing applications.

       > Example
         TODO
    end_position : Integer
    end_position = this.region_end

## PRIVATE

   Handle errors when looking up group info.
handle_error : Any -> (Text | Integer) -> Any
handle_error error id = case error of
    Polyglot_Error err ->
        is_ioob = Java.is_instance err IndexOutOfBoundsException
        is_iae = Java.is_instance err IllegalArgumentException
        maps_to_no_such_group = is_ioob || is_iae

        if maps_to_no_such_group.not then err else
            Regex.No_Such_Group_Error id
    other -> other

## Options specific to the `Default` regular expression engine.
type Option

    ## Specifies that the input expression to the pattern be treated as a
       sequence of literal characters. Metacharacters and escape sequences have
       no special meaning in this mode.
    type Literal_Pattern

    ## Disables anchoring to the region's boundaries.

       By default, the regex engine will allow `^` and `$` to match the
       boundaries of a restricted region. With this option specified, they will
       only match the start and end of the input.
    type No_Anchoring_Bounds

    ## Enables transparent bounds.

       Setting this option will allow the regex engine to look "through" the
       boundaries of the engine's region for the purposes of lookahead,
       lookbehind, and boundary matching.

       Without this flag, the region boundaries are treated as opaque, meaning
       that the above constructs will fail to match anything outside the region.
    type Transparent_Bounds

    ## Specifies that only the unix line ending `''\n'` be considered in the
       behaviour of the `^` and `$` special characters.
    type Unix_Lines

## PRIVATE

   Generates a Java bitmask representing the options used to configure the
   regex.

   Arguments:
   - opts: The enso-side options to configure the regex.
from_enso_options : Vector.Vector (Option | Global_Option.Option) -> Integer
from_enso_options opts =
    java_flags = Panic.recover <| opts.flat_map case _ of
        Literal_Pattern -> [Java_Pattern.LITERAL]
        Unix_Lines -> [Java_Pattern.UNIX_LINES]
        Global_Option.Case_Insensitive -> [Java_Pattern.CASE_INSENSITIVE]
        Global_Option.Dotall -> [Java_Pattern.DOTALL]
        Global_Option.Multiline -> [Java_Pattern.MULTILINE]
        Global_Option.Verbose -> [Java_Pattern.COMMENTS]
        Global_Option.Ascii_Matching -> []
        No_Anchoring_Bounds -> []
        Transparent_Bounds -> []
        other -> Panic.throw (Invalid_Option_Error other)

    options_bitmask = java_flags.fold 0 .bit_or

    if opts.contains Global_Option.Ascii_Matching then options_bitmask else
        unicode = [Java_Pattern.CANON_EQ, Java_Pattern.UNICODE_CASE, Java_Pattern.UNICODE_CHARACTER_CLASS].fold 0 .bit_or
        options_bitmask.bit_or unicode

## PRIVATE
type Recursive_Mode_Error

## PRIVATE
Recursive_Mode_Error.to_display_text : Text
Recursive_Mode_Error.to_display_text = "The mode cannot be recursive."

## PRIVATE

   An error representing that one of the passed options was invalid.

   Arguments:
   - opt: The option that was not valid for this regex engine.
type Invalid_Option_Error (opt : Any)

## PRIVATE

   Provides a human-readable representation of the invalid option error.
Invalid_Option_Error.to_display_text : Text
Invalid_Option_Error.to_display_text =
    "The option " + this.opt.to_text + " is not valid for the default regex engine."

