from Standard.Base import all

from Standard.Base.Data.Text.Extensions import slice_text
from Standard.Visualization.Text import get_chunk_from_line

## PRIVATE

   Update about the table layout to be sent to the GUI. Updates can be incremental and only contain
   information about some rows or columns. Even updating information is fine and will be handled
   by the UI.
type TableSpecificationUpdate

    Value row_heights column_widths column_names row_names



## PRIVATE

   Message to be sent to the IDE. Contains information about the table content and the table layout.
   The table content is encoded as chunks of text, together with their respective coordinate in the
   table. Coordinates have a first component that indicates row/column and a second component that
   indicates the chunk index and line.
type TableUpdate

    Value chunks table_specification_update

    ## PRIVATE

       Generate JSON that can be consumed by the visualization.
    to_json : Text
    to_json self =
        chunks = ["chunks", self.chunks]
        table_specification_update = ["table_specification_update", self.table_specification_update]
        Json.from_pairs [chunks, table_specification_update] + ""


## Return a sub-window of a string. The window is defined by line/chunk coordinates. The size of
  a chunk is defined by `chunk_width`. The output is formatted as a message that can be sent to
  the IDE's lazy text visualisation.
get_lazy_visualisation_data : Vector Integer ->  Vector Integer -> Vector Integer -> TableUpdate
get_lazy_visualisation_data table table_cell_position text_window_position text_window_size chunk_size =
    update = compute_table_update table table_cell_position text_window_position text_window_size chunk_size
    update.to_json


compute_table_update table table_cell_position text_window_position text_window_size chunk_size =
    text_window_width = text_window_size.at 0
    text_window_height = text_window_size.at 1

    chunks_to_get = (text_window_width / chunk_size).ceil

    start_column = table_cell_position.at 0
    last_column = find_end_column table start_column text_window_width*chunk_size

    column_ix_iter = start_column.up_to last_column+1

    start_row = table_cell_position.at 1
    last_row = find_end_row table start_row text_window_height
    row_ix_iter = start_row.up_to last_row+1

    row_line_iter = get_row_line_indices table table_cell_position text_window_position text_window_size

    process_row row_ix line_ix =
        chunks = get_chunks_for_row table row_ix line_ix column_ix_iter chunk_size chunks_to_get
        chunks.map (chunk -> [[[row_ix, line_ix], chunk.at 0], chunk.at 1])

    chunks = row_line_iter.map (index -> process_row (index.at 0) (index.at 1)) . flatten

    row_heights = row_ix_iter.map (index -> [index, get_row_height table index])
    column_widths = column_ix_iter.map (column_ix -> [column_ix, get_column_width ((table.at column_ix).to_vector)])
    column_names = column_ix_iter.map (column_ix -> [column_ix, (table.at column_ix).name])

    get_row_name = row_ix -> ((table.columns.at start_column).at row_ix).name
    ## row_names = row_ix_iter.map (index -> [index, get_row_name index])

    layout = TableSpecificationUpdate.Value row_heights column_widths column_names []
    TableUpdate.Value chunks layout

    ## [start_row, last_row, start_column, last_column, text_window_size]

## Return a vector of row index / line index pairs for the for each line in the given cell.
cell_line_indices table cell_ix =
    row_height = get_row_height table cell_ix
    line_indices = 0.up_to row_height
    line_indices.map (line_ix -> [cell_ix, line_ix])

## Return a vector of cell/line indices for each cell in the row defined by the text window.
get_row_line_indices table table_cell_position text_window_position text_window_size =
    start_cell_ix = table_cell_position.at 1
    start_line_ix = text_window_position.at 1
    text_window_height = text_window_size.at 1
    last_cell_ix = find_end_row table start_cell_ix text_window_height
    row_iter = start_cell_ix.up_to (last_cell_ix + 1)
    line_iter = row_iter.map (ix -> cell_line_indices table ix)
    line_iter.flatten

## Compute the text chunks for the row/line defined by the given indices limited to the given
   column indices. The number of chunks to get is defined by `chunks_to_get`.
get_chunks_for_row table row_ix line_ix column__indices chunk_size chunks_to_get =
    process_cell processed_chunks_previously column_ix =
        column = table.at column_ix
        chunks_in_this_column = ((get_column_width column.to_vector) / chunk_size).ceil
        chunks_left = chunks_to_get - processed_chunks_previously
        chunks_to_process = Math.min chunks_in_this_column chunks_left
        cell_text = column.at row_ix . to_text
        text_line = cell_text.lines.at line_ix
        get_chunk_by_index = get_chunk_from_line text_line chunk_size
        new_chunks = (0.up_to chunks_to_process).map get_chunk_by_index
        processed_chunks = processed_chunks_previously + chunks_in_this_column
        processed_chunks_with_ix = (enumerate new_chunks).map (chunk_with_ix -> [[column_ix, chunk_with_ix.at 0 ], chunk_with_ix.at 1])
        Pair.new processed_chunks_with_ix  processed_chunks

    column_indices = column__indices.to_vector
    if column_indices == [] then [] else
        (fold_map 0 process_cell column_indices).flatten

## Return the max value in the given vector.
max : Vector Integer -> Integer
max vector =
    vector.fold 0 (l -> r -> Math.max l r)

## Return the longest line in the given text.
get_longest_line : Text -> Integer
get_longest_line text =
    max (text.lines.map (line -> line.length))

## Return the length of the longest line in the given column.
get_column_width : Column -> Integer
get_column_width column =
    max (column.map (x -> get_longest_line x.to_text))

## Return the height of the row defined by the given index.
get_row_height : Table -> Integer -> Integer
get_row_height table row_ix =
    columns = table.columns
    row = columns.map (column -> column.at row_ix)
    max (row.map (x -> x.to_text.lines.length))

## Return the index of the first item in the given vector that brings the cummulative sum of items
   above the target value. If no such item exists, return `Nothing`.
find_first_over_cum_sum : Vector Integer -> Integer -> Integer | Nothing
find_first_over_cum_sum items target  =
    running_values = map_to_cumulative_sum items
    found = (enumerate running_values).find (x -> (x.at 1) > target)
    case found.catch Nothing of
        Nothing -> Nothing
        value -> value.at 0

## Return the index of the column that is at the end of the given text width, when starting from the
   given start column index.
find_end_column : Table -> Integer -> Integer -> Integer
find_end_column table start_column_ix max_width =
    table_columns_count = table.columns.length
    column_to_check = start_column_ix.up_to table_columns_count
    column_widths = column_to_check.map (ix -> get_column_width ((table.at ix).to_vector))
    found_ix = find_first_over_cum_sum column_widths max_width
    case found_ix.catch Nothing of
        Nothing -> table_columns_count - 1
        value -> value + start_column_ix

## Return the index of the row that is at the end of the given text height, when starting from the
   given start row index.
find_end_row : Table -> Integer -> Integer -> Integer
find_end_row table start_row_ix max_height =
    table_row_count = (table.columns.at 0).length
    rows_to_check = start_row_ix.up_to table_row_count
    row_heights = rows_to_check.map (ix ->  get_row_height table ix)
    found_ix = find_first_over_cum_sum row_heights max_height
    case found_ix.catch Nothing of
        Nothing -> table_row_count - 1
        value -> value + start_row_ix

## Helper for fold_map that takes a function, an accumulator value and the current item and returns
   a tuple of the new accumulator value and the result of the function.
fold_map_inner f acc item =
    previous_mappings = acc.first
    overall_acc_value = acc.second
    current_result = f overall_acc_value item
    current_mapping = current_result.first
    new_acc_value = current_result.second
    new_mappings = previous_mappings.append current_mapping
    Pair.new new_mappings new_acc_value

## Map a function over a vectors, but also pass on a accumulator value from one step to the next.
    The function must return a tuple of the result of the function and the new accumulator value.
fold_map acc f iterable =
    result = iterable.fold (Pair.new [] acc) (fold_map_inner f)
    result.first

## Return a vector of the cumulative sum of the given vector.
map_to_cumulative_sum iterable =
    map_running_sums previous_sum current =
        running_sum = previous_sum + current
        [running_sum, running_sum]
    fold_map 0 map_running_sums iterable

## Return the given vector where each item is mapped to itself and its index in the vector.
enumerate : Vector Any -> Vector Any
enumerate vector =
    (0.up_to vector.length).to_vector.zip vector