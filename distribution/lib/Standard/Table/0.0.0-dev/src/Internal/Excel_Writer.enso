from Standard.Base import all
import Standard.Base.Errors.Illegal_Argument.Illegal_Argument
import Standard.Base.Errors.Illegal_State.Illegal_State
import Standard.Base.Runtime.Managed_Resource.Managed_Resource

import project.Data.Match_Columns.Match_Columns
import project.Data.Table.Table
import project.Excel.Excel_Range.Excel_Range
import project.Excel.Excel_Section.Excel_Section
import project.Internal.Excel_Reader
from project.Errors import Column_Count_Mismatch, Column_Name_Mismatch, Existing_Data, Invalid_Location, Range_Exceeded

polyglot java import java.io.File as Java_File
polyglot java import java.lang.IllegalStateException
polyglot java import org.apache.poi.ss.usermodel.Workbook
polyglot java import org.enso.table.error.ExistingDataException
polyglot java import org.enso.table.error.InvalidLocationException
polyglot java import org.enso.table.error.RangeExceededException
polyglot java import org.enso.table.excel.ExcelConnectionPool
polyglot java import org.enso.table.excel.ExcelFileFormat
polyglot java import org.enso.table.read.ExcelReader
polyglot java import org.enso.table.write.ExcelWriter
polyglot java import org.enso.table.write.ExistingDataMode
polyglot java import org.enso.table.write.ExistingFileBehavior

## PRIVATE
make_java_existing_data_mode : Existing_File_Behavior -> Match_Columns -> ExistingDataMode
make_java_existing_data_mode on_existing_file match_columns = case on_existing_file of
    Existing_File_Behavior.Error -> ExistingDataMode.ERROR
    Existing_File_Behavior.Overwrite -> ExistingDataMode.REPLACE
    Existing_File_Behavior.Backup -> ExistingDataMode.REPLACE
    Existing_File_Behavior.Append -> case match_columns of
        Match_Columns.By_Name -> ExistingDataMode.APPEND_BY_NAME
        Match_Columns.By_Position -> ExistingDataMode.APPEND_BY_INDEX

## PRIVATE
make_java_existing_file_behavior : Existing_File_Behavior -> ExistingFileBehavior
make_java_existing_file_behavior on_existing_file = case on_existing_file of
    Existing_File_Behavior.Error     -> ExistingFileBehavior.ERROR
    Existing_File_Behavior.Overwrite -> ExistingFileBehavior.OVERWRITE
    Existing_File_Behavior.Backup    -> ExistingFileBehavior.BACKUP
    Existing_File_Behavior.Append    -> ExistingFileBehavior.APPEND

## PRIVATE
   Writes a Table to an Excel file.

   Arguments:
   - file: The file to write to.
   - table: The table to serialize.
   - section: The part of the Excel workbook to write to.
   - headers: Controls whether the table headers are written.
   - match_columns: Controls how the columns are matched when appending to an
     existing file.
   - on_problems: Specifies the behavior when a problem occurs during the
     operation. By default, a warning is issued, but the operation proceeds.
     If set to `Report_Error`, the operation fails with a dataflow error.
     If set to `Ignore`, the operation proceeds without errors or warnings.
   - xls_format: If `true`, the file is written in the legacy XLS format.
     Otherwise, the file is written in the modern XLSX format.
write_file : File -> Table -> Existing_File_Behavior -> Excel_Section -> (Boolean|Infer) -> Match_Columns -> Problem_Behavior -> Boolean -> File
write_file (file : File) (table : Table) (on_existing_file : Existing_File_Behavior) (section : Excel_Section) (headers : Boolean|Infer) (match_columns:Match_Columns) (on_problems:Problem_Behavior) (xls_format:Boolean) =
    _ = on_problems
    java_file = Java_File.new file_obj.normalize.path
    file_format = if xls_format then ExcelFileFormat.XLS else ExcelFileFormat.XLSX
    ExcelConnectionPool.INSTANCE.performWrite java_file file_format (make_java_existing_file_behavior on_existing_file)) writable_workbook->
        existing_data_mode = make_java_existing_data_mode on_existing_file match_columns
        java_headers = Excel_Reader.make_java_headers headers
        ExcelWriter.setEnsoToTextCallbackIfUnset (.to_text)
        handle_writer <| case section of
            Excel_Section.Worksheet sheet skip_rows row_limit ->
                ExcelWriter.writeTableToSheet workbook sheet existing_data_mode skip_rows table.java_table row_limit java_headers
            Excel_Section.Cell_Range address skip_rows row_limit -> case address of
                Excel_Range.Value java_range -> ExcelWriter.writeTableToRange workbook java_range existing_data_mode skip_rows table.java_table row_limit java_headers
                _ : Text -> ExcelWriter.writeTableToRange workbook address existing_data_mode skip_rows table.java_table row_limit java_headers
            _ : Excel_Section -> Error.throw (Illegal_Argument.Error "Only a Worksheet or Cell_Range is allowed in write_file")

## PRIVATE
   Handle and map the Java errors when writing an Excel file
handle_writer ~writer =
    bad_location caught_panic = Error.throw (Invalid_Location.Error caught_panic.payload.getCause)
    handle_bad_location = Panic.catch InvalidLocationException handler=bad_location

    throw_range_exceeded caught_panic = Error.throw (Range_Exceeded.Error caught_panic.payload.getMessage)
    handle_range_exceeded = Panic.catch RangeExceededException handler=throw_range_exceeded

    throw_existing_data caught_panic = Error.throw (Existing_Data.Error caught_panic.payload.getMessage)
    handle_existing_data = Panic.catch ExistingDataException handler=throw_existing_data

    ## Should be impossible - occurs if no fallback serializer is provided.
    throw_illegal_state caught_panic = Panic.throw (Illegal_State.Error caught_panic.payload.getMessage)
    handle_illegal_state = Panic.catch IllegalStateException handler=throw_illegal_state

    handle_illegal_state <| Column_Name_Mismatch.handle_java_exception <|
        Column_Count_Mismatch.handle_java_exception <| handle_bad_location <|
            Illegal_Argument.handle_java_exception <| handle_range_exceeded <| handle_existing_data <|
                writer
