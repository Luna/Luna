from Standard.Base import all

from Standard.Table.Data.Column as Column_Module import Column
import Standard.Table.Data.Group_By_Key
from Standard.Table.Data.Aggregate_Column import all

polyglot java import org.enso.table.data.table.aggregate.AggregateColumnDefinition

## Type used to compute an aggregate column
type Aggregate_Column_Aggregator
    type Aggregate_Column_Aggregator initial accumulator finalizer

## PRIVATE
   Given a map of values and counts, find the value at a specified percentile
calculate_percentile p:Decimal value:Map =
    count = value.fold 0 (+)
    if count == 0 then Nothing else
        mid_value = (count - 1)*p + 1
        if mid_value <= 1 then value.first.first else
            if mid_value >= count then value.last.first else
                mid = mid_value.floor
                output = value.fold_with_key [0, Nothing, Nothing] c->k->v->
                    new_v = c.first + v
                    new_s = if c.first.up_to new_v . contains (mid-1) then k else c.second
                    new_t = if c.first.up_to new_v . contains mid then k else (c.at 2)
                    [new_v, new_s, new_t]
                (output.second + (output.at 2 - output.second) * (mid_value - mid))

## PRIVATE
   Creates an aggregator from a resolved `Aggregate_Column`.

   You may need to transform the column with `resolve_columns` first to make
   sure that it is resolved.
new : Aggregate_Column->Aggregate_Column_Aggregator
new column =
    ## This can be removed completely, but it is being removed by other PR so I'm not touching it too much.
    create_closure c function:(Column->Any->Integer->Any) = function c

    is_empty s = if s.is_nothing then True else case s of
        Text -> s.is_empty
        _ -> Error.throw (Invalid_Aggregation_Method this.col "Empty is only valid for Text")

    create_aggregator initial:Any=Nothing (accumulator:(Any->Integer->Any)=c->_->c) (finalizer:(Any->Any)=(v->v)) =
        Aggregate_Column_Aggregator initial accumulator finalizer

    case column of
        Group_By c _ ->
            create_aggregator accumulator=(create_closure c col->_->i->(col.at i))
        Count _ ->
            create_aggregator initial=0 accumulator=(c->_->c+1)
        Count_Distinct columns _ ignore_nothing ->
            key_maker i = Group_By_Key.key (columns.map c->(c.at i))
            accumulator = case ignore_nothing of
                False-> map->i->(map.insert (key_maker i) 1)
                True-> map->i->
                    key = key_maker i
                    if key.values.all .is_nothing then map else (map.insert key 1)
            create_aggregator initial=Map.empty accumulator=accumulator finalizer=(v->v.size)
        Count_Not_Nothing c _ ->
            accumulator = create_closure c col->count->i->(count + if (col.at i).is_nothing then 0 else 1)
            create_aggregator initial=0 accumulator=accumulator
        Count_Nothing c _ ->
            accumulator = create_closure c col->count->i->(count + if (col.at i).is_nothing then 1 else 0)
            create_aggregator initial=0 accumulator=accumulator
        Count_Not_Empty c _ ->
            accumulator = create_closure c col->count->i->(count + if is_empty (col.at i) then 0 else 1)
            create_aggregator initial=0 accumulator=accumulator
        Count_Empty c _ ->
            accumulator = create_closure c col->count->i->(count + if is_empty (col.at i) then 1 else 0)
            create_aggregator initial=0 accumulator=accumulator
        Sum c _ ->
            accumulator = create_closure c col->total->i->
                v = col.at i
                if v.is_nothing then total else
                    if total.is_nothing then v else total + v
            create_aggregator accumulator=accumulator
        Average c _ ->
            accumulator = create_closure c col->a->i->
                v = col.at i
                if v.is_nothing then a else [a.first + 1, a.second + v]
            finalizer value = if value.first == 0 then Nothing else (value.second / value.first)
            create_aggregator initial=[0, 0] accumulator=accumulator finalizer=finalizer
        Median c _ ->
            accumulator = create_closure c col->map->i->
                v = col.at i
                if v.is_nothing then map else (map.insert v (1 + (map.get_or_else v 0)))
            finalizer = here.calculate_percentile 0.5
            create_aggregator initial=Map.empty accumulator=accumulator finalizer=finalizer
        Percentile p c _ ->
            accumulator = create_closure c col->map->i->
                v = col.at i
                if v.is_nothing then map else (map.insert v (1 + (map.get_or_else v 0)))
            finalizer = here.calculate_percentile p
            create_aggregator initial=Map.empty accumulator=accumulator finalizer=finalizer
        Mode c _ ->
            accumulator = create_closure c col->map->i->
                v = col.at i
                if v.is_nothing then map else (map.insert v (1 + (map.get_or_else v 0)))
            finalizer value = (value.fold_with_key (Pair 0 Nothing) p->k->v->(if v>(p.first) then (Pair v k) else p) . second)
            create_aggregator initial=Map.empty accumulator=accumulator finalizer=finalizer
        Concatenate c _ join prefix suffix q ->
            accumulator = create_closure c col->text->i->
                v = col.at i
                val=if v.is_nothing then "" else
                    val_text = case v of
                        Text -> v
                        _ -> v.to_text
                    if is_empty q then val_text else
                        if (val_text == "") || (val_text.contains join) then (q+(val_text.replace q (q+q))+q) else val_text
                if text.is_nothing then val else (text + join + val)
            finalizer value = if value.is_nothing then value else (prefix + value + suffix)
            create_aggregator accumulator=accumulator finalizer=finalizer

java_aggregator : Table->Aggregate_Column->AggregateColumnDefinition
java_aggregator table name column =
    resolve c = column.resolve_column table c
    case column of
        Group_By c _ -> AggregateColumnDefinition.GroupBy name (resolve c).java_column
        Count _ -> AggregateColumnDefinition.Count name
        Count_Distinct columns _ ignore_nothing ->
            resolved = case columns of
                Vector.Vector _ -> columns.map c->(resolve c).java_column
                _ -> [resolve columns . java_column]
            AggregateColumnDefinition.CountDistinct name resolved.to_array ignore_nothing
        Count_Not_Nothing c _ -> AggregateColumnDefinition.CountNothing name (resolve c).java_column False
        Count_Nothing c _ -> AggregateColumnDefinition.CountNothing name (resolve c).java_column True
        Count_Not_Empty c _ -> AggregateColumnDefinition.CountEmpty name (resolve c).java_column False
        Count_Empty c _ -> AggregateColumnDefinition.CountEmpty name (resolve c).java_column True
        Sum c _ -> AggregateColumnDefinition.Sum name (resolve c).java_column
        Average c _ -> AggregateColumnDefinition.Mean name (resolve c).java_column
        Standard_Deviation c _ p -> AggregateColumnDefinition.StDev name (resolve c).java_column p
        First c _ ignore_nothing _ -> AggregateColumnDefinition.First name (resolve c).java_column ignore_nothing
        Last c _ ignore_nothing _ -> AggregateColumnDefinition.Last name (resolve c).java_column ignore_nothing
        Maximum c _ -> AggregateColumnDefinition.MinOrMax name (resolve c).java_column 1
        Minimum c _ -> AggregateColumnDefinition.MinOrMax name (resolve c).java_column -1
        Shortest c _ -> AggregateColumnDefinition.MinOrMaxLength name (resolve c).java_column -1
        Longest c _ -> AggregateColumnDefinition.MinOrMaxLength name (resolve c).java_column 1
        Concatenate c _ join prefix suffix quote -> AggregateColumnDefinition.Concatenate name (resolve c).java_column join prefix suffix quote
        _ -> Error.throw "Not done yet..."

