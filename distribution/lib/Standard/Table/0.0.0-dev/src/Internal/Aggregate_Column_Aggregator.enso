from Standard.Base import all

from Standard.Table.Data.Column as Column_Module import Column
import Standard.Table.Data.Group_By_Key
from Standard.Table.Data.Aggregate_Column import all

polyglot java import org.enso.table.data.table.aggregate.AggregateColumnDefinition

## Type used to compute an aggregate column
type Aggregate_Column_Aggregator
    type Aggregate_Column_Aggregator initial accumulator finalizer

## PRIVATE
   Given a map of values and counts, find the value at a specified percentile
calculate_percentile p:Decimal value:Map =
    count = value.fold 0 (+)
    if count == 0 then Nothing else
        mid_value = (count - 1)*p + 1
        if mid_value <= 1 then value.first.first else
            if mid_value >= count then value.last.first else
                mid = mid_value.floor
                output = value.fold_with_key [0, Nothing, Nothing] c->k->v->
                    new_v = c.first + v
                    new_s = if c.first.up_to new_v . contains (mid-1) then k else c.second
                    new_t = if c.first.up_to new_v . contains mid then k else (c.at 2)
                    [new_v, new_s, new_t]
                (output.second + (output.at 2 - output.second) * (mid_value - mid))

## PRIVATE
   Creates an aggregator from a resolved `Aggregate_Column`.

   You may need to transform the column with `resolve_columns` first to make
   sure that it is resolved.
new : Aggregate_Column->Aggregate_Column_Aggregator
new column =
    ## This can be removed completely, but it is being removed by other PR so I'm not touching it too much.
    create_closure c function:(Column->Any->Integer->Any) = function c

    is_empty s = if s.is_nothing then True else case s of
        Text -> s.is_empty
        _ -> Error.throw (Invalid_Aggregation_Method this.col "Empty is only valid for Text")

    create_aggregator initial:Any=Nothing (accumulator:(Any->Integer->Any)=c->_->c) (finalizer:(Any->Any)=(v->v)) =
        Aggregate_Column_Aggregator initial accumulator finalizer

    case column of
        Group_By c _ ->
            create_aggregator accumulator=(create_closure c col->_->i->(col.at i))
        Count _ ->
            create_aggregator initial=0 accumulator=(c->_->c+1)
        Count_Distinct columns _ ignore_nothing ->
            key_maker i = Group_By_Key.key (columns.map c->(c.at i))
            accumulator = case ignore_nothing of
                False-> map->i->(map.insert (key_maker i) 1)
                True-> map->i->
                    key = key_maker i
                    if key.values.all .is_nothing then map else (map.insert key 1)
            create_aggregator initial=Map.empty accumulator=accumulator finalizer=(v->v.size)
        Count_Not_Nothing c _ ->
            accumulator = create_closure c col->count->i->(count + if (col.at i).is_nothing then 0 else 1)
            create_aggregator initial=0 accumulator=accumulator
        Count_Nothing c _ ->
            accumulator = create_closure c col->count->i->(count + if (col.at i).is_nothing then 1 else 0)
            create_aggregator initial=0 accumulator=accumulator
        Count_Not_Empty c _ ->
            accumulator = create_closure c col->count->i->(count + if is_empty (col.at i) then 0 else 1)
            create_aggregator initial=0 accumulator=accumulator
        Count_Empty c _ ->
            accumulator = create_closure c col->count->i->(count + if is_empty (col.at i) then 1 else 0)
            create_aggregator initial=0 accumulator=accumulator
        Sum c _ ->
            accumulator = create_closure c col->total->i->
                v = col.at i
                if v.is_nothing then total else
                    if total.is_nothing then v else total + v
            create_aggregator accumulator=accumulator
        Average c _ ->
            accumulator = create_closure c col->a->i->
                v = col.at i
                if v.is_nothing then a else [a.first + 1, a.second + v]
            finalizer value = if value.first == 0 then Nothing else (value.second / value.first)
            create_aggregator initial=[0, 0] accumulator=accumulator finalizer=finalizer
        Median c _ ->
            accumulator = create_closure c col->map->i->
                v = col.at i
                if v.is_nothing then map else (map.insert v (1 + (map.get_or_else v 0)))
            finalizer = here.calculate_percentile 0.5
            create_aggregator initial=Map.empty accumulator=accumulator finalizer=finalizer
        Percentile p c _ ->
            accumulator = create_closure c col->map->i->
                v = col.at i
                if v.is_nothing then map else (map.insert v (1 + (map.get_or_else v 0)))
            finalizer = here.calculate_percentile p
            create_aggregator initial=Map.empty accumulator=accumulator finalizer=finalizer
