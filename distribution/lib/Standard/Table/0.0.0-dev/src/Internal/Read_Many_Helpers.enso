private

from Standard.Base import all
import Standard.Base.Data.Read.Many_Files_List.Many_Files_List
import Standard.Base.Errors.Common.No_Such_Conversion
import Standard.Base.Errors.Illegal_Argument.Illegal_Argument

import project.Column.Column
import project.Errors.Invalid_Value_Type
import project.Errors.No_Rows
import project.Extensions.Table_Conversions
import project.Internal.Interpret_As_Table_For_Read_Many.Interpret_As_Table_For_Read_Many
import project.Return_As_Table.Return_As_Table
import project.Table.Table
import project.Value_Type.Value_Type
from project.Table import from_java_table

polyglot java import org.enso.table.data.mask.OrderMask

find_files_list_in_table (that : Table) -> Many_Files_List =
    found_column = if that.column_count == 1 then that.at 0 else
        path_columns = that.select_columns "path" case_sensitivity=..Insensitive on_problems=..Report_Error
        not_found = path_columns.is_error || (path_columns.column_count == 0)
        if not_found then Error.throw (Illegal_Argument.Error "To use a Table as file list, it must be a single column or contain a `path` column (case insensitive).") else
            if path_columns.column_count > 1 then Error.throw (Illegal_Argument.Error "Multiple 'paths' column candidates found: "+path_columns.column_names.to_display_text+".") else
                path_columns.at 0
    ensure_column_type_valid_to_be_files_list found_column <|
        Many_Files_List.Value that found_column.to_vector Return_As_Table.As_Merged_Table

ensure_column_type_valid_to_be_files_list (column : Column) ~action =
    is_expected_type = case column.value_type of
        # Columns containing File objects will be Mixed
        Value_Type.Mixed -> True
        # Columns containing paths as Text will be Char
        Value_Type.Char _ _ -> True
        _ -> False
    if is_expected_type then action else
        Error.throw (Invalid_Value_Type.Column "Text or Mixed" column.value_type column.name)

make_return (return_shape : Return_As_Table) (input : Many_Files_List) (objects : Vector Any) (on_problems : Problem_Behavior) -> Table =
    base_table = _input_as_table input
    case return_shape of
        Return_As_Table.With_New_Column ->
            _add_objects_column base_table objects
        Return_As_Table.As_Merged_Table columns_to_keep match_columns ->
            tables = input.paths_to_load.zip objects path-> object->
                _interpret_object_as_table object path columns_to_keep match_columns on_problems
            _merge_input_and_tables base_table tables columns_to_keep match_columns on_problems

_input_as_table (input : Many_Files_List) -> Table =
    case input.original_value of
        table : Table -> table
        column : Column -> column.to_table
        ## Fallback - any unknown input shape is treated the same as
           Vector input - we just extract the list of files from it
        _ ->
            Table.new [["Path", input.paths_to_load]]

## Expands each table from `tables_for_rows` and computes their union, also
   duplicating the corresponding rows from `input_table`.
_merge_input_and_tables (input_table : Table) (tables_for_rows : Vector Table) columns_to_keep match_columns on_problems -> Table =
    counts = tables_for_rows.map table-> case table of
        Nothing -> 0
        _ : Table -> table.row_count
    adapted_tables = _inherit_warnings_from_vector tables_for_rows <| 
        tables_for_rows.filter ..Not_Nothing
    ## If there are no tables to merge, union would fail. 
       Each entry is then contributing 0 rows, so we need to return an empty table. 
       But it should have the same structure as the input table.
    if adapted_tables.is_empty then (input_table.take 0) else
        unified_tables = Table.from_union adapted_tables columns_to_keep match_columns on_problems
        multiplicated_inputs = _duplicate_rows input_table counts
        Runtime.assert (unified_tables.row_count == multiplicated_inputs.row_count)
        multiplicated_inputs.zip unified_tables right_prefix=""

_make_table_with_one_null_row (empty_table : Table) -> Table =
    Runtime.assert (empty_table.row_count == 0) "The table must be empty."
    Table.new (empty_table.columns.map c-> Column.from_vector c.name [Nothing] c.value_type)

_add_objects_column (base_table : Table) (objects : Vector Any) -> Table  =
    unique_naming = base_table.column_naming_helper.create_unique_name_strategy
    unique_naming.mark_used base_table.column_names
    objects_column_name = unique_naming.make_unique "Value"
    base_table.set (Column.from_vector objects_column_name objects) as=objects_column_name set_mode=..Add

## Tries to interpret the object as a table.
   The provided path is used as additional context for any warnings that may need to be reported according to `on_problems`.
_interpret_object_as_table (object : Any) path columns_to_keep match_columns (on_problems : Problem_Behavior) -> Table | Nothing =
    default =
        Table.from_objects object treat_dictionary_as_sequence=False . catch Illegal_Argument error->
            problem = Illegal_Argument.Error "Problem converting "+object.to_display_text+" (loaded from "+path.to_display_text+") to a Table: "+error.to_display_text cause=error
            on_problems.attach_problem_before problem <|
                # If it was an array that failed to load, let's expand it to rows, otherwise have 1 row for the unknown object.
                vec = if object.is_a Vector then object else [object]
                Table.new [["Value", vec]]
    case object of
        table : Table -> 
            if table.row_count > 0 then table else
                on_problems.attach_problem_after table <|
                    (No_Rows.Warning "The "+path.to_display_text+" loaded as a table with 0 rows, so it did not contribute any rows to the `As_Merged_Table` result of `read_many`.")
        vector : Vector ->
            if vector.not_empty then default else
                on_problems.attach_problem_after Nothing <|
                    (No_Rows.Warning "The "+path.to_display_text+" loaded as an empty array, so it is not included in the `As_Merged_Table` result of `read_many`.")
        _ ->
            special_case = Panic.catch No_Such_Conversion (object:Interpret_As_Table_For_Read_Many) _->Nothing
            if special_case.is_nothing then default else
                special_case.into_table columns_to_keep match_columns on_problems

## Takes a table and a list of counts and returns a new table with the rows
   duplicated according to the counts.
   The vector should have the same number of elements as the number of rows in the table.
_duplicate_rows (table : Table) (counts : Vector Integer) -> Table =
    Runtime.assert (table.row_count == counts.length) "The number of counts must match the number of rows in the table."
    mask_array = counts
        . map_with_index ix-> count-> Vector.fill count ix
        . flatten
    mask = OrderMask.fromArray mask_array
    from_java_table (table.java_table.applyMask mask)

## Workaround for bug https://github.com/enso-org/enso/issues/11570
   Once that is addressed, this function may be removed.
private _inherit_warnings_from_vector vector:Vector ~action =
    result = action
    Warning.set result (Warning.get_all vector + Warning.get_all result)
