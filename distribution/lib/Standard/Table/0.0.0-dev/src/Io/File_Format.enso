from Standard.Base import all
import Standard.Table

import Standard.Base.Error.Extensions as Errors
from Standard.Base.Error.Problem_Behavior as Problem_Behavior_Module import Problem_Behavior
from Standard.Base.Data.Text.Encoding as Encoding_Module import Encoding
polyglot java import org.enso.table.read.DelimitedReader
polyglot java import org.enso.table.read.ParsingFailedException
polyglot java import org.enso.table.read.InvalidRow

## This type needs to be here to allow for the usage of Standard.Table
   functions. Ideally, it would be an interface within Standard.Base and
   expanded by additional implementations in Standard.Table.

## Determines the format of file to use based on the file extension.
type Auto
    type Auto

    ## ADVANCED
       Gets the underlying File_Format for the specified file
    materialise : File->File_Format
    materialise file =
        extension = file.extension

        output = Ref.new File_Format.Bytes
        if ".txt".equals_ignore_case extension then Ref.put output File_Format.Text
        if ".log".equals_ignore_case extension then Ref.put output File_Format.Text
        if ".csv".equals_ignore_case extension then Ref.put output (File_Format.Delimited ',')
        if ".tsv".equals_ignore_case extension then Ref.put output (File_Format.Delimited '\t')

        Ref.get output

    ## Implements the `File.read` for this `File_Format`
    read : File -> Problem_Behavior -> Any
    read file on_problems =
        materialised = this.materialise file
        materialised.read file on_problems

## Reads the file to a `Vector` of bytes.
type Bytes
    type Bytes

    ## Implements the `File.read` for this `File_Format`
    read : File -> Problem_Behavior -> Any
    read file _ =
        file.read_bytes

## Reads the file to a `Text` with specified encoding.
type Text
    type Text (encoding:Encoding=Encoding.utf_8)

    ## Implements the `File.read` for this `File_Format`
    read : File -> Problem_Behavior -> Any
    read file on_problems =
        file.read_text this.encoding on_problems

## Read delimited files such as CSVs into a Table.
type Delimited
    ## Read delimited files such as CSVs into a Table.

       If a row does not match the first row's column count, the function raises
       an `Invalid_Row`. If a quote is opened and never closed, a
       `Mismatched_Quote` warning occurs.

       Arguments:
       - delimiter: The delimiter character to split the file into columns. An
         `Illegal_Argument_Error` error is returned if this is an empty string.
       - encoding: The encoding to use when reading the file.
       - quote: The quote character denotes the start and end of a quoted value.
         No quote character is used if set to `Nothing`. Quoted items are not
         split on the delimiter and can also contain newlines. Within a quoted
         value, two consecutive quote characters are interpreted as an instance
         of the quote character. Empty input strings must be quoted (e.g. "") as
         otherwise an empty value is treated as `Nothing`.
       - quote_escape: TODO
       - headers: If set to `True`, the first row is used as column names. If
         set to `False`, the column names are generated by adding increasing
         numeric suffixes to the base name `Column` (i.e. `Column_1`,
         `Column_2` etc.). If set to `Infer`, the process tries to infer if
         headers are present on the first row (`Infer` is not implemented yet).
       - parse_values: The output columns are parsed using the default `Parser`
         if 'True'. If more control over parsing is needed, the
         `Table.parse_values` method allows full specifications of the parser
         options.
       - skip_rows: The number of rows to skip from the top of the file.
       - row_limit: The maximum number of rows to read from the file.
       - keep_invalid_rows: TODO

       TODO [RW] The default for `headers` is temporarily changed to `False`,
       because `Infer` is not supported. It should be changed to be the default
       value once the corrresponding task is implemented:
       https://www.pivotaltracker.com/story/show/181986831

       TODO [RW] The default for `parse_values` is temporarily changed to
       `False`, because this feature is not yet implemented. It should be
       changed to `True` once the related task is implemented:
       https://www.pivotaltracker.com/story/show/181824146
    type Delimited (delimiter:Text) (encoding:Encoding=Encoding.utf_8) (quote:Text|Nothing='"') (quote_escape:Text|Nothing='"') (headers:True|False|Infer=False) (parse_values:Boolean=False) (skip_rows:Integer|Nothing=Nothing) (row_limit:Integer|Nothing=Nothing) (keep_invalid_rows:Boolean=True)

    ## Implements the `File.read` for this `File_Format`
    read : File -> Problem_Behavior -> Any
    read file on_problems =
        java_headers = case this.headers of
            True -> DelimitedReader.HeaderBehavior.USE_FIRST_ROW_AS_HEADERS
            Infer -> Errors.unimplemented "Inferring headers is not implemented yet."
            False -> DelimitedReader.HeaderBehavior.GENERATE_HEADERS
        skip_rows = case this.skip_rows of
            Nothing -> 0
            Integer -> skip_rows
            _ -> Error.throw (Illegal_Argument_Error "`skip_rows` should be Integer or Nothing.")
        row_limit = case this.row_limit of
            Nothing -> -1
            Integer -> row_limit
            _ -> Error.throw (Illegal_Argument_Error "`skip_rows` should be Integer or Nothing.")
        if this.parse_values then Errors.unimplemented "Parsing values is not implemented yet." else
            if this.encoding != Encoding.utf_8 then Errors.unimplemented "Custom encodings when reading Delimited files are not implemented yet." else
                ## TODO test and handle errors like file not found or access denied etc.
                translate_illegal_argument caught_panic =
                    Error.throw (Illegal_Argument_Error caught_panic.payload.cause.getMessage)
                translate_problem java_problem =
                    if Java.is_instance java_problem InvalidRow then Invalid_Row java_problem.source_row java_problem.table_index (Vector.Vector java_problem.row) else
                        java_problem
                translate_parsing_failure caught_panic =
                    Error.throw (translate_problem caught_panic.payload.cause.problem)

                Panic.catch Illegal_Argument_Error handler=translate_illegal_argument <|
                    Panic.catch ParsingFailedException handler=translate_parsing_failure
                    file.with_input_stream [File.Option.Read] stream->
                        stream.with_java_stream java_stream->
                            warnings_as_errors = on_problems == Problem_Behavior_Module.Report_Error
                            reader = DelimitedReader.new java_stream this.delimiter this.quote this.quote_escape java_headers skip_rows row_limit this.keep_invalid_rows warnings_as_errors
                            result = Table.Table reader.read
                            problems = Vector.Vector reader.getReportedProblems . map translate_problem
                            on_problems.attach_problems_after result problems

## FIXME [RW] where to put these?
type Infer
type Invalid_Row (source_file_row : Integer) (index : Integer | Nothing) (row : [Text])
type Mismatched_Quote
