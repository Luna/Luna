from Standard.Base import all

from Standard.Table.Data.Column as Column_Module import Column
import Standard.Table.Data.Group_By_Key

## Defines an Aggregate Column
type Aggregate_Column
    ## Group By
    type Group_By (column:Column|Text|Integer) (new_name:Text|Nothing=Nothing)

    ## Creates a new column with the row count of each group

       Arguments:
       - name: name of new column.
    type Count (new_name:Text|Nothing=Nothing)

    ## Creates a new column with the count of unique items in the selected
       column(s) within each group.

       Arguments:
       - columns: either a single or set of columns (specified by name, index or Column object) to count across.
       - name: name of new column.
       - ignore_nothing: if all values are Nothing won't be included.
    type Count_Distinct (columns:Column|Text|Integer|[(Column|Text|Integer)]) (new_name:Text|Nothing=Nothing) (ignore_nothing:Boolean=False)

    ## ALIAS Count_Not_Null

       Creates a new column with the count of not `Nothing` (null) values of the
       specified column within each group.

       Arguments:
       - columns: column (specified by name, index or Column object) to count.
       - name: name of new column.
    type Count_Not_Nothing (column:Column|Text|Integer) (new_name:Text|Nothing=Nothing)

    ## ALIAS Count_Null, Count_Missing

       Creates a new column with the count of `Nothing` (null) values of the
       specified column within each group.

       Arguments:
       - column: column (specified by name, index or Column object) to count.
       - name: name of new column.
    type Count_Nothing (column:Column|Text|Integer) (new_name:Text|Nothing=Nothing)

    ## Creates a new column with the count of not `Nothing` (null) and non-empty
       ("") values of the column within each group.

       Arguments:
       - column: column (specified by name, index or Column object) to count.
       - name: name of new column.
    type Count_Not_Empty (column:Column|Text|Integer) (new_name:Text|Nothing=Nothing)

    ## Creates a new column with the count of `Nothing` (null) or empty ("")
       text values of the column within each group.

       Arguments:
       - column: column (specified by name, index or Column object) to count.
       - name: name of new column.
    type Count_Empty (column:Column|Text|Integer) (new_name:Text|Nothing=Nothing)

    ## Creates a new column with the sum of values (ignoring missing values) of
       the specified column within each group.

       Arguments:
       - column: column (specified by name, index or Column object) to total.
       - name: name of new column.
    type Sum (column:Column|Text|Integer) (new_name:Text|Nothing=Nothing)

    ## Creates a new column with the mean of values (ignoring missing values) of
       the specified column within each group.

       Arguments:
       - column: column (specified by name, index or Column object) to average.
       - name: name of new column.
    type Average (column:Column|Text|Integer) (new_name:Text|Nothing=Nothing)

    ## Creates a new column with the median of values (ignoring missing values)
       of the specified column within each group.

       Arguments:
       - column: column (specified by name, index or Column object) to calculate median on.
       - name: name of new column.
    type Median (column:Column|Text|Integer) (new_name:Text|Nothing=Nothing)

    ## Creates a new column with the median of values (ignoring missing values)
       of the specified column within each group.

       Arguments:
       - percentile: Percentage to compute from 0-1 inclusive.
       - column: column (specified by name, index or Column object) to compute percentile.
       - name: name of new column.
    type Percentile (percentile:Decimal) (column:Column|Text|Integer) (new_name:Text|Nothing=Nothing)

    ## Creates a new column with the mode of values (ignoring missing values)
       of the specified column within each group.

       Arguments:
       - column: column (specified by name, index or Column object) to find the most common value.
       - name: name of new column.
    type Mode (column:Column|Text|Integer) (new_name:Text|Nothing=Nothing)

    ## Creates a new column with the standard deviation of values (ignoring
       missing values) of the column within each group.

       Arguments:
       - column: column (specified by name, index or Column object) to compute standard deviation.
       - name: name of new column.
       - population argument specifies if group is a sample or the population
    type Standard_Deviation (column:Column|Text|Integer) (new_name:Text|Nothing=Nothing) (population:Boolean=False)

    ## Creates a new column with the values concatenated together. `Nothing` values will become an empty string.

       Arguments:
       - column: column (specified by name, index or Column object) to concatenate values.
       - name: name of new column.
       - separator: added between each value.
       - prefix: added at the start of the result.
       - suffix: added at the end of the result.
       - quote_char: character used to quote the values if the value is `Empty`
         or contains the separtor.
    type Concatenate (column:Column|Text|Integer) (new_name:Text|Nothing=Nothing) (separator:Text="") (prefix:Text="") (suffix:Text="") (quote_char:Text="")

    ## Creates a new column with the first value in each group.

       Arguments:
       - column: column (specified by name, index or Column object) to find first group entry.
       - name: name of new column.
       - ignore_nothing: if `True`, then missing values are ignored and first
         not missing value returned.
       - order_by: required for database tables. Specifies how to order the
         results within the group.
    type First (column:Column|Text|Integer) (new_name:Text|Nothing=Nothing) (ignore_nothing:Boolean=True) (order_by:Column_Selector|Nothing=Nothing)

    ## Creates a new column with the last value in each group.

       Arguments:
       - column: column (specified by name, index or Column object) to find last group entry.
       - name: name of new column.
       - ignore_nothing: if `True`, then missing values are ignored and last
         not missing value returned.
       - order_by: required for database tables. Specifies how to order the
         results within the group.
    type Last (column:Column|Text|Integer) (new_name:Text|Nothing=Nothing) (ignore_nothing:Boolean=True) (order_by:Column_Selector|Nothing=Nothing)

    ## Creates a new column with the maximum value in each group.

       Arguments:
       - column: column (specified by name, index or Column object) to find maximum.
       - name: name of new column.
    type Maximum (column:Column|Text|Integer) (new_name:Text|Nothing=Nothing)

    ## Creates a new column with the maximum value in each group.

       Arguments:
       - column: column (specified by name, index or Column object) to find minimum.
       - name: name of new column.
    type Minimum (column:Column|Text|Integer) (new_name:Text|Nothing=Nothing)

    ## Creates a new column with the shortest text in each group.

       Arguments:
       - column: column (specified by name, index or Column object) to find shortest value.
       - name: name of new column.
    type Shortest (column:Column|Text|Integer) (new_name:Text|Nothing=Nothing)

    ## Creates a new column with the longest text in each group.

       Arguments:
       - column: column (specified by name, index or Column object) to find longest value.
       - name: name of new column.
    type Longest (column:Column|Text|Integer) (new_name:Text|Nothing=Nothing)

    ## Gets a column name to use for the aggregate column
    column_name : Table->Text
    column_name table =
        this.make_aggregator table . name

    ## Gets an Aggregate_Column_Aggregator object for the specified column
    make_aggregator : Table->Aggregate_Column_Aggregator
    make_aggregator table =
        here.new_aggregator table this

    ## PRIVATE
       Given a column reference resolve to the underlying column
    resolve_column : Table->(Column|Text|Integer)->Column
    resolve_column table column =
        case column of
            Column _ -> table.at (column.name)
            Text -> table.at column
            Integer -> table.columns.at column

## Type used to compute an aggregate column
type Aggregate_Column_Aggregator
    type Aggregate_Column_Aggregator name initial accumulator finalizer

## Given a Table and a Column create an aggregator
new_aggregator : Table->Aggregate_Column->Aggregate_Column_Aggregator
new_aggregator table column =
    get_name c name prefix:Text="" = if name.is_nothing then prefix + (column.resolve_column table c).name else name
    create_closure c function:(Column->Any->Integer->Any) = function (column.resolve_column table c)

    is_empty s = if s.is_nothing then True else case s of
        Text -> s.is_empty
        _ -> Error.throw (Invalid_Aggregation_Method this.col "Empty is only valid for Text")

    create_aggregator name:Text initial:Any=Nothing (accumulator:(Any->Integer->Any)=c->_->c) (finalizer:(Any->Any)=(v->v)) =
        Aggregate_Column_Aggregator name initial accumulator finalizer

    ## Given a map of values and counts, find the value at a specified percentile
    percentile p:Decimal value:Map =
        count = value.fold 0 (+)
        if count == 0 then Nothing else
            mid_value = (count - 1)*p + 1
            if mid_value <= 1 then value.first.first else
                if mid_value >= count then value.last.first else
                    mid = mid_value.floor
                    output = value.fold_with_key [0, Nothing, Nothing] c->k->v->
                        new_v = c.first + v
                        new_s = if c.first.up_to new_v . contains (mid-1) then k else c.second
                        new_t = if c.first.up_to new_v . contains mid then k else (c.at 2)
                        [new_v, new_s, new_t]
                    (output.second + (output.at 2 - output.second) * (mid_value - mid))

    case column of
        Group_By c n ->
            create_aggregator name=(get_name c n "") accumulator=(create_closure c col->_->i->(col.at i))
        Count n ->
            create_aggregator name=(if n.is_nothing then "Count" else n) initial=0 accumulator=(c->_->c+1)
        Count_Distinct columns n ignore_nothing ->
            resolved = case columns of
                Vector.Vector _ -> columns.map c->(column.resolve_column table c)
                _ -> [column.resolve_column table columns]
            key_maker i = Group_By_Key.key (resolved.map c->(c.at i))
            name = if n.is_nothing.not then n else "Count Distinct " + (resolved.map .name . join " ")
            accumulator = case ignore_nothing of
                False-> map->i->(map.insert (key_maker i) 1)
                True-> map->i->
                    key = key_maker i
                    if key.values.all .is_nothing then map else (map.insert key 1)
            create_aggregator name=name initial=Map.empty accumulator=accumulator finalizer=(v->v.size)
        Count_Not_Nothing c n ->
            accumulator = create_closure c col->count->i->(count + if (col.at i).is_nothing then 0 else 1)
            create_aggregator name=(get_name c n "Count Not Nothing ") initial=0 accumulator=accumulator
        Count_Nothing c n ->
            accumulator = create_closure c col->count->i->(count + if (col.at i).is_nothing then 1 else 0)
            create_aggregator name=(get_name c n "Count Nothing ") initial=0 accumulator=accumulator
        Count_Not_Empty c n ->
            accumulator = create_closure c col->count->i->(count + if is_empty (col.at i) then 0 else 1)
            create_aggregator name=(get_name c n "Count Not Empty ") initial=0 accumulator=accumulator
        Count_Empty c n ->
            accumulator = create_closure c col->count->i->(count + if is_empty (col.at i) then 1 else 0)
            create_aggregator name=(get_name c n "Count Empty ") initial=0 accumulator=accumulator
        Sum c n ->
            accumulator = create_closure c col->total->i->
                v = col.at i
                if v.is_nothing then total else
                    if total.is_nothing then v else total + v
            create_aggregator name=(get_name c n "Sum ") accumulator=accumulator
        Average c n ->
            accumulator = create_closure c col->a->i->
                v = col.at i
                if v.is_nothing then a else [a.first + 1, a.second + v]
            finalizer value = if value.first == 0 then Nothing else (value.second / value.first)
            create_aggregator name=(get_name c n "Average ") initial=[0, 0] accumulator=accumulator finalizer=finalizer
        Median c n ->
            accumulator = create_closure c col->map->i->
                v = col.at i
                if v.is_nothing then map else (map.insert v (1 + (map.get_or_else v 0)))
            finalizer = percentile 0.5
            create_aggregator name=(get_name c n "Median ") initial=Map.empty accumulator=accumulator finalizer=finalizer
        Percentile p c n ->
            accumulator = create_closure c col->map->i->
                v = col.at i
                if v.is_nothing then map else (map.insert v (1 + (map.get_or_else v 0)))
            finalizer = percentile p
            create_aggregator name=(get_name c n ((p*100).floor.to_text + "%-ile ")) initial=Map.empty accumulator=accumulator finalizer=finalizer
        Mode c n ->
            accumulator = create_closure c col->map->i->
                v = col.at i
                if v.is_nothing then map else (map.insert v (1 + (map.get_or_else v 0)))
            finalizer value = (value.fold_with_key (Pair 0 Nothing) p->k->v->(if v>(p.first) then (Pair v k) else p) . second)
            create_aggregator name=(get_name c n "Mode ") initial=Map.empty accumulator=accumulator finalizer=finalizer
        Standard_Deviation c n p ->
            accumulator = create_closure c col->a->i->
                v = col.at i
                if v.is_nothing then a else [a.first + 1, a.second + v, (a.at 2) + v*v]
            finalizer value = if value.first == 0 then Nothing else
                f = if p then 1 else (value.first / (value.first - 1)).sqrt
                ((value.at 2)/value.first - (value.second/value.first)^2).sqrt * f
            create_aggregator name=(get_name c n "Standard Deviation ") initial=[0, 0, 0] accumulator=accumulator finalizer=finalizer
        Concatenate c n join prefix suffix q ->
            accumulator = create_closure c col->text->i->
                v = col.at i
                val=if v.is_nothing then "" else
                    val_text = case v of
                        Text -> v
                        _ -> v.to_text
                    if is_empty q then val_text else
                        if (val_text == "") || (val_text.contains join) then (q+(val_text.replace q (q+q))+q) else val_text
                if text.is_nothing then val else (text + join + val)
            finalizer value = if value.is_nothing then value else (prefix + value + suffix)
            create_aggregator name=(get_name c n "Concatenate ") accumulator=accumulator finalizer=finalizer
        First c n ignore_nothing _ ->
            accumulator = case ignore_nothing of
                False -> create_closure c col->current->i->(if current.second then current else [(col.at i), True])
                True -> create_closure c col->current->i->if current.second then current else
                    v = col.at i
                    if v.is_nothing then current else [v, True]
            create_aggregator name=(get_name c n "First ") initial=[Nothing, False] accumulator=accumulator finalizer=(p->p.first)
        Last c n ignore_nothing _ ->
            accumulator = case ignore_nothing of
                False -> create_closure c col->_->i->(col.at i)
                True -> create_closure c col->current->i->
                    v = (col.at i)
                    if v.is_nothing then current else v
            create_aggregator name=(get_name c n "Last ") accumulator=accumulator
        Maximum c n ->
            accumulator = create_closure c col->m->i->
                v = col.at i
                if v.is_nothing then m else if m.is_nothing then v else m.max v
            create_aggregator name=(get_name c n "Maximum ") accumulator=accumulator
        Minimum c n ->
            accumulator = create_closure c col->m->i->
                v = col.at i
                if v.is_nothing then m else if m.is_nothing then v else m.min v
            create_aggregator name=(get_name c n "Minimum ") accumulator=accumulator
        Shortest c n ->
            accumulator = create_closure c col->m->i->
                v = col.at i
                if v.is_nothing then m else if m.is_nothing then v else if m.length <= v.length then m else v
            create_aggregator name=(get_name c n "Shortest ") accumulator=accumulator
        Longest c n ->
            accumulator = create_closure c col->m->i->
                v = col.at i
                if v.is_nothing then m else if m.is_nothing then v else if m.length >= v.length then m else v
            create_aggregator name=(get_name c n "Longest ") accumulator=accumulator

## Occurs when cannot aggregate a column
type Invalid_Aggregation_Method (column : Text) (message : Text)

Invalid_Aggregation_Method.to_display_text : Text
Invalid_Aggregation_Method.to_display_text =
    "The aggregate column "+this.column+" resulted in an error: "+this.message
