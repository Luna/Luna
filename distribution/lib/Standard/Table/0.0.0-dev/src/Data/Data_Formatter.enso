from Standard.Base import all

from Standard.Base.Data.Time.Date as Date_Module import Date
from Standard.Base.Data.Time as Time_Module import Time
from Standard.Base.Data.Time.Time_Of_Day as Time_Of_Day_Module import Time_Of_Day
from Standard.Table.Data.Column_Type_Selection as Column_Type_Selection_Module import Auto
import Standard.Base.Error.Common as Errors
import Standard.Base.Error.Problem_Behavior
import Standard.Table.Data.Storage
import Standard.Table.Internal.Parse_Values_Helper

polyglot java import org.enso.table.parsing.IntegerParser
polyglot java import org.enso.table.parsing.DecimalParser
polyglot java import org.enso.table.parsing.BooleanParser
polyglot java import org.enso.table.parsing.DateParser
polyglot java import org.enso.table.parsing.TimeParser
polyglot java import org.enso.table.parsing.DateTimeParser
polyglot java import org.enso.table.parsing.WhitespaceStrippingParser
polyglot java import org.enso.table.parsing.IdentityParser
polyglot java import org.enso.table.parsing.TypeInferringParser

polyglot java import org.enso.table.formatting.AnyObjectFormatter
polyglot java import org.enso.table.formatting.BooleanFormatter
polyglot java import org.enso.table.formatting.DecimalFormatter
polyglot java import org.enso.table.formatting.IntegerFormatter
polyglot java import org.enso.table.formatting.TextFormatter

## Specifies options for reading text data in a table to more specific types and
   serializing them back.

   Arguments:
   - trim_values: Trim whitespace before parsing.
   - allow_leading_zeros: Specifies how to treat numeric values starting with
     leading zeroes. Defaults to `False`, because converting such
     values to numbers is a lossy operation - after converting such a number
     back to text the leading zeroes will get lost. If leading zeroes are not
     allowed and the column contains any values with leading zeroes, it will not
     get automatically converted to numbers, remaining as text. However, if the
     column is specifically requested to be converted to a numeric column, only
     a warning will be issued indicating that some leading zeroes were present,
     but the conversion will proceed.
   - decimal_point: The character used to separate the integer part from the
     fractional part of a number. Defaults to '.'. Can be changed for example to
     ',' to allow for European format.
   - thousand_separator: A separator that can be used to separate groups of
     digits in numbers. For example, it can be set to ',' to allow for notation
     like '1,000,000.0'.
   - datetime_formats: Expected datetime formats.
   - date_formats: Expected date formats.
   - time_formats: Expected time formats.
   - locale: The locale to use when parsing dates and times.
   - true_values: Values representing True.
   - false_values: Values representing False.
type Data_Formatter trim_values:Boolean=True allow_leading_zeros:Boolean=False decimal_point:Text='.' thousand_separator:Text='' datetime_formats:[Text]=["yyyy-MM-dd HH:mm:ss"] date_formats:[Text]=["yyyy-MM-dd"] time_formats:[Text]=["HH:mm:ss"] locale:Locale=Locale.default true_values:[Text]=["True","true","TRUE"] false_values:[Text]=["False","false","FALSE"]

## PRIVATE
Data_Formatter.get_thousand_separator = if self.thousand_separator.is_empty then Nothing else self.thousand_separator

## PRIVATE
Data_Formatter.wrap_base_parser base_parser =
    if self.trim_values.not then base_parser else
        WhitespaceStrippingParser.new base_parser

## PRIVATE
Data_Formatter.make_integer_parser = self.wrap_base_parser <|
    IntegerParser.new self.get_thousand_separator self.allow_leading_zeros

## PRIVATE
Data_Formatter.make_decimal_parser = self.wrap_base_parser <|
    DecimalParser.new self.decimal_point self.get_thousand_separator self.allow_leading_zeros

## PRIVATE
Data_Formatter.make_boolean_parser = self.wrap_base_parser <|
    BooleanParser.new self.true_values.to_array self.false_values.to_array

## PRIVATE
Data_Formatter.make_date_parser = self.wrap_base_parser <|
    DateParser.new self.date_formats.to_array self.locale.java_locale

## PRIVATE
Data_Formatter.make_datetime_parser = self.wrap_base_parser <|
    DateTimeParser.new self.datetime_formats.to_array self.locale.java_locale

## PRIVATE
Data_Formatter.make_time_parser = self.wrap_base_parser <|
    TimeParser.new self.time_formats.to_array self.locale.java_locale

## PRIVATE
Data_Formatter.make_identity_parser = self.wrap_base_parser IdentityParser.new

## PRIVATE
Data_Formatter.make_datatype_parser datatype = case datatype of
    Integer -> self.make_integer_parser
    Decimal -> self.make_decimal_parser
    Boolean -> self.make_boolean_parser
    _ ->
        if datatype == Date then self.make_date_parser else
            if datatype == Time then self.make_datetime_parser else
                if datatype == Time_Of_Day then self.make_time_parser else
                    Error.throw (Illegal_Argument_Error "Unsupported datatype: "+datatype.to_text)

## PRIVATE
Data_Formatter.get_specific_type_parsers =
    [self.make_integer_parser, self.make_decimal_parser, self.make_datetime_parser, self.make_date_parser, self.make_time_parser, self.make_boolean_parser]

## PRIVATE
Data_Formatter.make_auto_parser =
    fallback_parser = self.make_identity_parser
    TypeInferringParser.new self.get_specific_type_parsers.to_array fallback_parser

## PRIVATE
Data_Formatter.make_integer_formatter =
    IntegerFormatter.new this.get_thousand_separator

## PRIVATE
Data_Formatter.make_decimal_formatter =
    DecimalFormatter.new this.get_thousand_separator this.decimal_point

## PRIVATE
Data_Formatter.make_boolean_formatter =
    if this.true_values.is_empty then Error.throw (Illegal_Argument_Error "Formatting booleans requires at least one entry in the `true_values` parameter") else
        if this.false_values.is_empty then Error.throw (Illegal_Argument_Error "Formatting booleans requires at least one entry in the `false_values` parameter") else
            BooleanFormatter.new this.true_values.first this.false_values.first

## PRIVATE
Data_Formatter.make_text_formatter =
    TextFormatter.new

## PRIVATE
Data_Formatter.get_specific_type_formatters =
    # TODO add date-time formatters
    [this.make_integer_formatter, this.make_decimal_formatter, this.make_boolean_formatter, this.make_text_formatter]

## PRIVATE
Data_Formatter.make_auto_formatter =
    # TODO The panic rethrow+recover is a workaround for the vector error propagation bug.
    formatters = Panic.recover Illegal_Argument_Error (this.get_specific_type_formatters.map Panic.rethrow)
    AnyObjectFormatter.new formatters.to_array

## PRIVATE
Data_Formatter.make_formatter_for_column_type (column_type : Storage) = case column_type of
    Storage.Text -> this.make_text_formatter
    Storage.Integer -> this.make_integer_formatter
    Storage.Decimal -> this.make_decimal_formatter
    Storage.Boolean -> this.make_boolean_formatter
    Storage.Any -> this.make_auto_formatter

## Parse a Text into a value.

   Arguments:
   - text: Text value to parse.
   - datatype: Text value to parse.
Data_Formatter.parse : Text -> (Auto|Integer|Number|Date|Time|DateTime|Boolean) -> Problem_Behavior -> Any
Data_Formatter.parse text datatype=Auto on_problems=Problem_Behavior.Report_Warning =
    parser = case datatype of
        Auto -> this.make_auto_parser
        _ -> this.make_datatype_parser datatype
    result = parser.parseIndependentValue text
    problems = Vector.Vector result.problems . map (Parse_Values_Helper.translate_parsing_problem datatype)
    on_problems.attach_problems_after result.value problems

## Format a value into a Text.

   Arguments:
   - value: Value to format.
Data_Formatter.format : Any -> Text
Data_Formatter.format value =
    formatter = this.make_auto_formatter
    formatter.format value
