from Standard.Base import all
import Standard.Base.Error.Unimplemented.Unimplemented

import project.Data.Table.Table
import project.Delimited.Delimited_Format.Delimited_Format
import project.Delimited.Delimited_Reader
import project.Delimited.Delimited_Writer
import project.Errors.Invalid_JSON_Format

Table.from (that : Text) (format:Delimited_Format = Delimited_Format.Delimited '\t') (on_problems:Problem_Behavior=Report_Warning) =
    case format of
        _ : Delimited_Format -> Delimited_Reader.read_text that format on_problems
        _ -> Unimplemented.throw "Table.from is currently only implemented for Delimited_Format."

Text.from (that : Table) (format:Delimited_Format = Delimited_Format.Delimited '\t') =
    case format of
        _ : Delimited_Format -> Delimited_Writer.write_text that format
        _ -> Unimplemented.throw "Text.from is currently only implemented for Delimited_Format."

## ALIAS To Table

   Converts a JSON array into a dataframe, by looking up the requested keys
   from each item.

   Arguments:
   - fields: a vector of texts representing the names of fields to look up.

   The function assumes the elements have one of the following structures:
   - a JSON object containing the requested keys. In case an item is not an
     object, or the request key does not exist, the relevant values of the table
     will be set to `Nothing`.

   > Example Converts a JSON array containing key-value pairs into a table for the
     provided headers.

         from Standard.Table import Table
         import Standard.Examples

         example_to_table =
             json = Examples.simple_table_json
             headers = Examples.simple_table_json_headers
             json.to_table headers
Json.to_table : Any -> Vector | Nothing -> Table
Json.to_table value fields=Nothing =
    table_for_value v =
        column_names = fields.if_nothing ["Value"]
        column_values = column_names.map f-> if f == "Value" then v else Nothing
        Table.from_rows column_names [column_values]

    get_fields v = case v of
        _ : JS_Object -> v.field_names
        Nothing -> "Value"
        _ : Number -> "Value"
        _ : Boolean -> "Value"
        _ : Text -> "Value"
        _ -> Invalid_JSON_Format.throw ("Json.to_table invalid item: " + v.to_text)

    get_value v field = case v of
        _ : JS_Object -> v.get field
        _ -> if field == "Value" then v else Nothing

    case value of
        Nothing -> table_for_value value
        _ : Number -> table_for_value value
        _ : Boolean -> table_for_value value
        _ : Text -> table_for_value value
        _ : JS_Object ->
            field_names = fields.if_nothing value.field_names
            values = field_names.map value.get
            Table.new [["Name", field_names], ["Value", values]]
        _ : Array -> Json.to_table (Vector.from_polyglot_array value) fields
        _ : Vector ->
            column_map = value.fold_with_index Map.empty i->v->
                field_names = fields.if_nothing get_fields v
                field_names.each f->
                    data = Map.get f (Vector.new_builder value.length)
                    data.length.up_to i . each _-> data.append Nothing
                    data.append (get_value v f)
            used_fields = fields.if_nothing column_map.keys
            Table.new used_fields (used_fields.map f-> column_map.get f . to_vector)
        _ -> Invalid_JSON_Format.throw "Json.to_table expects a JSON valid type."
