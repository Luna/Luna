from Standard.Base import all
import Standard.Base.Data.Text.Regex.Regex_Syntax_Error
import Standard.Base.Errors.Common.Index_Out_Of_Bounds
import Standard.Base.Errors.Common.Type_Error
import Standard.Base.Errors.Illegal_Argument.Illegal_Argument
import Standard.Base.Errors.Unimplemented.Unimplemented

import project.Data.Match_Columns.Match_Columns
import project.Data.Table.Table
import project.Errors.Invalid_JSON_Format
import project.Errors.No_Such_Column
import project.Internal.Fan_Out
import project.Internal.Parse_To_Table
import project.Internal.Split_Tokenize
import project.Internal.Widget_Helpers
from project.Internal.Java_Exports import make_inferred_builder

## GROUP Standard.Base.Conversions
   Expand a column of objects to a new set of columns.

    Arguments:
    - column: The column to expand.
    - fields: The set fields to expand. If `Nothing` then all fields are added.
    - prefix: Prefix to add to the column names. If `Nothing` then the column
      name is used.
@column Widget_Helpers.make_column_name_selector
Table.expand_column : Text | Integer -> Vector | Nothing -> Text | Table -> Table ! Type_Error | No_Such_Column | Index_Out_Of_Bounds
Table.expand_column self column fields=Nothing prefix=Nothing =
    column_object = self.at column
    expanded = Table.from_objects column_object.to_vector fields

    output_builder = Vector.new_builder self.column_count+expanded.column_count-1

    ## Resolve names
    resolved_prefix = if prefix.is_nothing then column_object.name+" " else prefix
    naming_strategy = self.column_naming_helper.create_unique_name_strategy
    naming_strategy.mark_used (self.column_names.filter (c->c!=column_object.name))
    new_names = naming_strategy.make_all_unique (expanded.column_names.map n-> resolved_prefix+n)
    new_columns = new_names.zip expanded.columns (n->c-> c.rename n)

    ## Create Merged Columns
    self.columns.each c->
        if c.name != column_object.name then output_builder.append c else
            output_builder.append_vector_range new_columns

    Table.new output_builder.to_vector

## GROUP Standard.Base.Conversions
   Expand aggregate values in a column to individual rows.

   Arguments:
   - column: The column to expand.
   - at_least_one_row: for an empty aggregate value, if `at_least_one_row` is
     true, a single row is output with `Nothing` for the aggregates column; if
     false, no row is output at all.

   For each value in the specified column, if it is an aggregate (`Vector`,
   `Range`, etc.), expand it to multiple rows, duplicating the values in the
   other columns.

   The following aggregate values are supported:
   - `Array`
   - `Vector`
   - `List`
   - `Range`
   - `Date_Range`

   Any other values are treated as non-aggregate values, and their rows are kept
   unchanged.

   In in-memory tables, it is permitted to mix values of different types.

   > Example
     Expand a column of integer `Vectors` to a column of `Integer`

     table = Table.new [["aaa", [1, 2]], ["bbb", [[30, 31], [40, 41]]]]
     # => Table.new [["aaa", [1, 1, 2, 2]], ["bbb", [30, 31, 40, 41]]]
@column Widget_Helpers.make_column_name_selector
Table.expand_to_rows : Text | Integer -> Boolean -> Table ! Type_Error | No_Such_Column | Index_Out_Of_Bounds
Table.expand_to_rows self column at_least_one_row=False =
    row_expander : Any -> Vector
    row_expander value:Expand_To_Rows_Iterator = value.to_vector

    Fan_Out.fan_out_to_rows self column row_expander at_least_one_row column_builder=make_inferred_builder

## PRIVATE
type Expand_To_Rows_Iterator
    ## PRIVATE
       - length: The number of rows in the table.
       - getter: Get the value for a specified row.
    Value length:Integer getter:Function

    ## PRIVATE
       Return the iterator values as a `Vector`.
    to_vector : Vector Any
    to_vector self = 0.up_to self.length . map self.getter

## PRIVATE
Expand_To_Rows_Iterator.from that:Vector = Expand_To_Rows_Iterator.Value that.length that.get

## PRIVATE
Expand_To_Rows_Iterator.from that:Array = Expand_To_Rows_Iterator.Value that.length that.get

## PRIVATE
Expand_To_Rows_Iterator.from that:List = Expand_To_Rows_Iterator.Value that.length that.get

## PRIVATE
Expand_To_Rows_Iterator.from that:Range = Expand_To_Rows_Iterator.Value that.length that.get

## PRIVATE
Expand_To_Rows_Iterator.from that:Pair = Expand_To_Rows_Iterator.Value that.length that.get

## PRIVATE
Expand_To_Rows_Iterator.from that:Date_Range = Expand_To_Rows_Iterator.Value that.length that.get

## PRIVATE
Expand_To_Rows_Iterator.from (that:Any) =
    Expand_To_Rows_Iterator.Value 1 (n-> if n==0 then that else Nothing)

## GROUP Standard.Base.Conversions
   Converts this `Vector` into a `Table`.

   Arguments:
   - fields: a Vector of Text representing the names of fields to look up.
     If `Nothing` then all fields found are added.
Vector.to_table : Vector | Nothing -> Table ! Type_Error
Vector.to_table self fields=Nothing =
    Table.from_objects self fields

## GROUP Standard.Base.Constants
   Converts an object or a Vector of object into a Table, by looking up the
   requested fields from each item.

   Arguments:
   - value: The object or Vector of objects to convert to a table.
     If a Vector or Array, then each item is added as a row.
     Otherwise, treated as a single row.
   - fields: a Vector of Text representing the names of fields to look up.
     If `Nothing` then all fields found are added.

   > Example Converts a set of objects into a table using the provided headers.

         from Standard.Table import Table
         import Standard.Examples

         example_to_table =
             json = Examples.simple_table_json
             headers = Examples.simple_table_json_headers
             Table.from_objects json headers
Table.from_objects : Any -> Vector | Nothing -> Table ! Type_Error
Table.from_objects value fields=Nothing =
    table_for_value v =
        column_names = fields.if_nothing ["Value"]
        column_values = column_names.map f-> if f == "Value" then v else Nothing
        Table.from_rows column_names [column_values]

    get_fields v = case v of
        _ : JS_Object -> v.field_names
        Nothing -> ["Value"]
        _ : Number -> ["Value"]
        _ : Boolean -> ["Value"]
        _ : Text -> ["Value"]
        _ : Date -> ["Value"]
        _ : Time_Of_Day -> ["Value"]
        _ : Date_Time -> ["Value"]
        _ -> Error.throw (Illegal_Argument.Error "Invalid item within Vector for Table.from_objects. Currently only JS_Object, Number, Boolean, Text and Nothing are supported (got "+(Meta.get_simple_type_name v)+").")

    get_value v field = case v of
        _ : JS_Object -> v.get field
        _ -> if field == "Value" then v else Nothing

    case value of
        Nothing -> table_for_value value
        _ : Number -> table_for_value value
        _ : Boolean -> table_for_value value
        _ : Text -> table_for_value value
        _ : Date -> table_for_value value
        _ : Time_Of_Day -> table_for_value value
        _ : Date_Time -> table_for_value value
        _ : JS_Object ->
            field_names = fields.if_nothing value.field_names
            values = field_names.map value.get
            Table.from_rows field_names [values]
        _ : Vector ->
            len = value.length

            ## For every record, get the values into a Map.
            column_map = value.fold_with_index Map.empty current-> i-> v->
                field_names = fields.if_nothing (get_fields v)
                field_names.fold current c->f->
                    data = c.get f (Vector.new_builder len)
                    data.length.up_to i . each _-> data.append Nothing
                    data.append (get_value v f)
                    c.insert f data

            used_fields = fields.if_nothing column_map.keys

            ## Convert Builders to Vectors and fill as needed.
            used_values = used_fields.map f->
                data = column_map.get f (Vector.new_builder len)
                data.length.up_to len . each _-> data.append Nothing
                data.to_vector

            Table.new (used_fields.zip used_values)
        _ : Array -> Table.from_objects (Vector.from_polyglot_array value) fields
        _ -> Error.throw (Illegal_Argument.Error "Invalid value for Table.from_objects. Currently must be one of JS_Object, Vector, Array, Number, Boolean, Text, date/time and Nothing are supported (got "+(Meta.get_simple_type_name value)+").")

## GROUP Standard.Base.Conversions
   Converts a Text into a Table using a regular expression pattern.

   Each match becomes a row in the table.

   If there are no marked groups, there will be a single column with the
   whole content of the match. Otherwise, each group becomes a column
   (with the column name taken from the group name if the group is named in the
   regex).

   Arguments:
   - pattern: The regular expression as either `Text` or `Regex` to search within the text.
   - case_sensitivity: Specifies if the text values should be compared case
     sensitively.
   - parse_values: Parse any values using the default value parser.

   ? Column Names

   If there are no marked groups, the new column will be named `Column`.
   If the marked groups are named, the names will be used otherwise the column
   will be named `Column <N>` where `N` is the number of the marked group.
   (Group 0 is not included.)
Text.parse_to_table : Text | Regex -> Case_Sensitivity -> Boolean -> Problem_Behavior -> Table ! Type_Error | Regex_Syntax_Error | Illegal_Argument
Text.parse_to_table self (pattern : Text | Regex) case_sensitivity=Case_Sensitivity.Sensitive parse_values=True on_problems=Report_Warning =
    Parse_To_Table.parse_text_to_table self pattern case_sensitivity parse_values on_problems

## PRIVATE
   ADVANCED
   Implements the `Table.write` for this `JSON_File`.

    Arguments:
    - file: The file to write to.
    - table: The table to write.
    - on_existing_file: What to do if the file already exists.
    - match_columns: How to match columns between the table and the file.
      Not used for JSON.
    - on_problems: What to do if there are problems reading the file.
JSON_Format.write_table : File -> Table -> Existing_File_Behavior -> Match_Columns -> Problem_Behavior -> File
JSON_Format.write_table self file table on_existing_file match_columns on_problems =
    _ = [match_columns, on_problems]
    if file.exists.not then table.to_json.write file else
        case on_existing_file of
            Existing_File_Behavior.Append ->
                ## Special handling - Need to remove the closing bracket and append.
                old_text = file.read_text.trim
                case old_text.ends_with "]" && old_text.starts_with "[" of
                    True ->
                        new_text = old_text.drop (Last 1) + "," + table.to_json.drop (First 1)
                        new_text.write file on_existing_file=Existing_File_Behavior.Overwrite on_problems=on_problems
                    False ->
                        Error.throw (Invalid_JSON_Format.Error old_text "File already exists and is not a JSON array.")
            _ -> table.to_json.write file on_existing_file=on_existing_file on_problems=on_problems
