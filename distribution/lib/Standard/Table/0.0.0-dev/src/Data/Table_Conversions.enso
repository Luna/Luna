from Standard.Base import all
import Standard.Base.Error.Unimplemented.Unimplemented

import project.Data.Table.Table
import project.Delimited.Delimited_Format.Delimited_Format
import project.Delimited.Delimited_Reader
import project.Delimited.Delimited_Writer
import project.Errors.Invalid_JSON_Format

Table.from (that : Text) (format:Delimited_Format = Delimited_Format.Delimited '\t') (on_problems:Problem_Behavior=Report_Warning) =
    case format of
        _ : Delimited_Format -> Delimited_Reader.read_text that format on_problems
        _ -> Unimplemented.throw "Table.from is currently only implemented for Delimited_Format."

Text.from (that : Table) (format:Delimited_Format = Delimited_Format.Delimited '\t') =
    case format of
        _ : Delimited_Format -> Delimited_Writer.write_text that format
        _ -> Unimplemented.throw "Text.from is currently only implemented for Delimited_Format."

## Converts a JSON object or a Vector into a dataframe, by looking up the requested keys
   from each item.

   Arguments:
   - fields: a vector of texts representing the names of fields to look up.
     If `Nothing` then all fields found are added.

   The function assumes the elements have one of the following structures:
   - a JSON object containing the requested keys. In case an item is not an
     object, or the request key does not exist, the relevant values of the table
     will be set to `Nothing`.
   - otherwise, the element will match the `Value` field name.

   > Example Converts a JSON array containing key-value pairs into a table for the
     provided headers.

         from Standard.Table import Table
         import Standard.Examples

         example_to_table =
             json = Examples.simple_table_json
             headers = Examples.simple_table_json_headers
             Table.from_json json headers
Table.from_json : Any -> Vector | Nothing -> Table
Table.from_json value fields=Nothing =
    table_for_value v =
        column_names = fields.if_nothing ["Value"]
        column_values = column_names.map f-> if f == "Value" then v else Nothing
        Table.from_rows column_names [column_values]

    get_fields v = case v of
        _ : JS_Object -> v.field_names
        Nothing -> ["Value"]
        _ : Number -> ["Value"]
        _ : Boolean -> ["Value"]
        _ : Text -> ["Value"]
        _ -> Error.throw (Invalid_JSON_Format.Error v "Invalid item for Table.from_json.")

    get_value v field = case v of
        _ : JS_Object -> v.get field
        _ -> if field == "Value" then v else Nothing

    case value of
        Nothing -> table_for_value value
        _ : Number -> table_for_value value
        _ : Boolean -> table_for_value value
        _ : Text -> table_for_value value
        _ : JS_Object ->
            field_names = fields.if_nothing value.field_names
            values = field_names.map value.get
            Table.new [["Name", field_names], ["Value", values]]
        _ : Array -> Table.from_json (Vector.from_polyglot_array value) fields
        _ : Vector ->
            len = value.length

            ## For every record, get the values into a Map.
            column_map = value.fold_with_index Map.empty current->i->v->
                field_names = fields.if_nothing (get_fields v)
                field_names.fold current c->f->
                    data = c.get f (Vector.new_builder len)
                    data.length.up_to i . each _-> data.append Nothing
                    data.append (get_value v f)
                    c.insert f data

            used_fields = fields.if_nothing column_map.keys

            ## Convert Builders to Vectors and fill as needed.
            used_values = used_fields.map f->
                data = column_map.get f (Vector.new_builder len)
                data.length.up_to len . each _-> data.append Nothing
                data.to_vector

            Table.new (used_fields.zip used_values)
        _ -> Error.throw (Invalid_JSON_Format.Error value "Invalid value for Table.from_json.")
