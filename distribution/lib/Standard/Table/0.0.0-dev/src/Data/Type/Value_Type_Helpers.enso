from Standard.Base import all
import Standard.Base.Errors.Illegal_Argument.Illegal_Argument

import project.Data.Column.Column
import project.Data.Type.Enso_Types
from project.Data.Type.Value_Type import Value_Type, Auto
from project.Errors import Invalid_Value_Type

## PRIVATE
   Finds a type that can fit both a current type and a new type.
reconcile_types current new = case current of
    Value_Type.Mixed -> Value_Type.Mixed
    Value_Type.Integer size -> case new of
        Value_Type.Integer new_size ->
            Value_Type.Integer (Math.max size new_size)
        Value_Type.Byte    -> Value_Type.Integer size
        Value_Type.Boolean -> Value_Type.Integer size
        # If we unify integers with floats, we select the default Float 64 regardless of the input sizes.
        Value_Type.Float _ -> Value_Type.Float
        _                  -> Value_Type.Mixed
    Value_Type.Float size -> case new of
        Value_Type.Float new_size ->
            Value_Type.Float (Math.max size new_size)
        # If we unify integers with floats, we select the default Float 64 regardless of the input sizes.
        Value_Type.Integer _ -> Value_Type.Float
        Value_Type.Byte      -> Value_Type.Float
        Value_Type.Boolean   -> Value_Type.Float
        _                    -> Value_Type.Mixed
    Value_Type.Byte -> case new of
        Value_Type.Byte    -> Value_Type.Byte
        Value_Type.Integer size ->
            Value_Type.Integer size
        Value_Type.Boolean -> Value_Type.Byte
        Value_Type.Float _ -> Value_Type.Float
        _                  -> Value_Type.Mixed
    Value_Type.Boolean -> case new of
        Value_Type.Boolean -> Value_Type.Boolean
        Value_Type.Integer size ->
            Value_Type.Integer size
        Value_Type.Byte    -> Value_Type.Byte
        Value_Type.Float _ -> Value_Type.Float
        _                  -> Value_Type.Mixed
    Value_Type.Char current_size current_variable -> case new of
        Value_Type.Char new_size new_variable ->
            result_variable = current_variable || new_variable || current_size != new_size
            result_size = max_size current_size new_size
            Value_Type.Char result_size result_variable
        _ -> Value_Type.Mixed
    Value_Type.Binary current_size current_variable -> case new of
        Value_Type.Binary new_size new_variable ->
            result_variable = current_variable || new_variable || current_size != new_size
            result_size = max_size current_size new_size
            Value_Type.Binary result_size result_variable
        _ -> Value_Type.Mixed
    _ ->
        if current == new then current else Value_Type.Mixed

## PRIVATE
   Reconciles two size parameters. If either of them is `Nothing` (meaning
   unbounded), returns `Nothing`. If both are bounded, the larger one is
   returned.
max_size a b =
    if a.is_nothing || b.is_nothing then Nothing else
        Math.max a b

## PRIVATE
   Finds the most specific value type that will fit all the provided types.

   If `strict` is `True`, it is implemented as specified in the note
   "Unifying Column Types" in `Table.union`. In that case, if no common type
   is found, `Nothing` is returned.

   It assumes that the `types` vector is not empty.
find_common_type : Vector Value_Type -> Boolean -> Value_Type | Nothing
find_common_type types strict =
    most_generic_type = (types.drop 1).fold types.first reconcile_types
    if strict.not || most_generic_type != Value_Type.Mixed then most_generic_type else
        # Double check if Mixed was really allowed to come out.
        if types.contains Value_Type.Mixed then Value_Type.Mixed else
            Nothing

type Operation_Type_Helpers
    ## PRIVATE

       Arguments:
       - is_column: a function that checks if the provided value is a column.
    Instance (is_column : Any -> Boolean)

    ## PRIVATE
       Finds the type of an argument to a column operation.

       If the argument is a column, the type of that column is returned. If it
       is an Enso value, the smallest `Value_Type` that can fit that value will
       be returned (but the Database is free to widen it to the closest type
       that it supports without warning).

       Since there is no special type for `Nothing` and `Nothing` technically
       can fit any nullable type, it usually needs to be handled specially. This
       method returns `Nothing` if the value is `Nothing` - so the caller can
       try to treat this value as fitting any type, or accordingly to specific
       semantics of each method.
    find_argument_type : Any -> Value_Type | Nothing
    find_argument_type self value = case value of
        Nothing -> Nothing
        _ -> if self.is_column value then value.value_type else
            Enso_Types.most_specific_value_type value use_smallest=True

    ## PRIVATE
       A helper that can be used to check the argument value type, while allowing
       `Nothing` values too.

       > Example

         type_helpers.check_argument_type other Value_Type.expect_text <| operation
    check_argument_type self value type_check ~action =
        typ = self.find_argument_type value
        if typ.is_nothing then action else
            related_column = if self.is_column value then value.name else Nothing
            type_check typ related_column=related_column <|
                action

    ## PRIVATE
       A helper which resolves if numeric addition or string concatenation should be
       used when the a `+` operator is used with the two provided types.
       It will return an error if the provided types are incompatible.
       The `other_type` may be `Nothing` if the other operand is `Nothing`, then the
       operation will depend only on the `self_type`.
    resolve_addition_kind self self_type other_type =
        if self_type.is_numeric && (other_type.is_nothing || other_type.is_numeric) then 'ADD_NUMBER' else
            if self_type.is_text && (other_type.is_nothing || other_type.is_text) then 'ADD_TEXT' else
                Error.throw <| Illegal_Argument.Error <|
                    if other_type.is_nothing then "Cannot perform addition on a value of type " + self_type.to_display_text + ". Addition can only be performed if the column is of some numeric type or is text." else
                        "Cannot perform addition on a pair of values of types " + self_type.to_display_text + " and " + other_type.to_display_text + ". Addition can only be performed if both columns are of some numeric type or are both are text."

    ## PRIVATE
    check_binary_numeric_op self arg1 arg2 ~action =
        self.check_argument_type arg1 Value_Type.expect_numeric <|
            self.check_argument_type arg2 Value_Type.expect_numeric <|
                action

    ## PRIVATE
    check_binary_boolean_op self arg1 arg2 ~action =
        self.check_argument_type arg1 Value_Type.expect_boolean <|
            self.check_argument_type arg2 Value_Type.expect_boolean <|
                action

    ## PRIVATE
    check_multi_argument_comparable_op self column arg_or_args ~action =
        column_type = column.value_type
        args = Vector.unify_vector_or_element arg_or_args
        other_types = args.map self.find_argument_type
        checked = other_types.map other_type->
            Value_Type.expect_comparable column_type other_type <|
                True
        checked.if_not_error <|
            action

    ## PRIVATE
    raise_unexpected_type self expected_type argument =
        error = case self.is_column argument of
            True ->
                Invalid_Value_Type.Error expected_type argument.value_type related_column=argument.name
            False ->
                Invalid_Value_Type.Error expected_type (self.find_argument_type argument) related_column=Nothing
        Error.throw error


## PRIVATE
   Type helpers for in-memory tables.
type_helpers =
    is_column value = value.is_a Column
    Operation_Type_Helpers.Instance is_column
