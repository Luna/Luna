from Standard.Base import all
import Standard.Base.Errors.Illegal_Argument.Illegal_Argument

import project.Errors.S3_Error
import project.S3.S3

## PRIVATE
   An abstraction for S3 paths, holding the bucket name and the key.

   This helper implements resolving paths in a folder-like structure as
   described at https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-folders.html
type S3_Path
    ## PRIVATE
    Value (bucket : Text) (key : Text)

    ## PRIVATE
    parse (uri : Text) -> S3_Path ! Illegal_Argument =
        if uri.starts_with S3.uri_prefix . not then Error.throw (Illegal_Argument.Error "An S3 path must start with `"+S3.uri_prefix+"`.") else
            without_prefix = uri.drop S3.uri_prefix.length
            first_slash_index = without_prefix.index_of S3_Path.delimiter
            if first_slash_index == 0 then Error.throw (Illegal_Argument.Error "Invalid S3 path: empty bucket name.") else
                if first_slash_index.is_nothing then S3_Path.Value without_prefix "" else
                    Pair.new (without_prefix.take first_slash_index) (without_prefix.drop first_slash_index+1)

    ## PRIVATE
    to_text self -> Text = S3.uri_prefix + self.bucket + S3_Path.delimiter + self.key

    ## PRIVATE
    to_display_text self -> Text = self.to_text.to_display_text

    ## PRIVATE
       Checks if this path represents the root directory of a bucket.
    is_root self -> Boolean = self.key.is_empty

    ## PRIVATE
       Checks if this path represents a directory.
    is_directory self -> Boolean = self.is_root || (self.key.ends_with S3_Path.delimiter)

    ## PRIVATE
       Resolves a subdirectory entry.
       This only makes logical sense for paths for which `path.is_directory == True`,
       but it is not forbidden to call it on other types of paths.

       Note that the newly returned path will be a directory or not depending on
       if `subpath` ends with the delimiter.
    resolve self (subpath : Text) -> S3_Path =
        trimmed = if subpath.starts_with S3_Path.delimiter then subpath.drop (First 1) else subpath
        parts = trimmed.split S3_Path.delimiter

        extend current part =
            if current == "" then part else
                if current.ends_with S3_Path.delimiter then current + part else
                    current + S3_Path.delimiter + part

        loop current remaining = if remaining.length == 0 then current else
            new_current = case remaining.first of
                ".." ->
                    last_index = current.last_index_of S3_Path.delimiter
                    if last_index == Nothing then Error.throw (S3_Error.Error "Cannot move above root folder.") else current.take last_index
                "." -> current
                x -> extend current x
            @Tail_Call loop new_current (remaining.drop 1)

        initial = if subpath.starts_with S3_Path.delimiter then "" else self.key
        new_path = loop initial parts
        S3_Path.Value self.bucket new_path

    ## PRIVATE
       Returns the parent directory.
       It will return `Nothing` for the root directory.
    parent self -> S3_Path | Nothing =
        if self.key == "" then Nothing else
            last_index = case self.is_directory of
                # For directories we drop the trailing slash and find the one before it:
                True -> (self.key.drop (Last 1)).last_index_of S3_Path.delimiter
                False -> self.key.last_index_of S3_Path.delimiter
            ## We include the trailing slash in the path, as the parent is
               always a directory and in S3 directories are distinguished only
               by the presence of this slash.
            new_key = if last_index == Nothing then "" else self.key.take last_index+1
            S3_Path.Value self.bucket new_key

    ## PRIVATE
       Returns the 'file name' of this path.
       If the path is a regular file, it will be its name.
       If the path is a directory, it will be the name of that directory,
       without the trailing delimiter.
    file_name self -> Text =
        if self.is_root then S3_Path.delimiter else
            trimmed = if self.key.ends_with S3_Path.delimiter then self.key.drop (Last 1) else self.key
            last_index = trimmed.last_index_of S3_Path.delimiter
            if last_index == Nothing then trimmed else trimmed.drop (First last_index+1)

    ## PRIVATE
       Checks if the given other path is inside of this path.
    is_descendant_of self (other : S3_Path) -> Boolean =
        other.is_directory && self.to_text.starts_with other.to_text

    ## PRIVATE
       The delimiter used for path emulation.

       S3 does not treat `/` in any special way, it allows using any character as a
       path delimiter. In the future we could allow customizing it.
    delimiter = "/"
