from Standard.Base import all

## Checks if `this` is equal to `that.`

   Arguments:
   - that: The object to compare `this` against.

   Two values are considered to be equal in Enso when they obey the following
   recursive properties:
   - At each level, they have the same structure.
   - The value of each field in `this` is equal (by this definition) to the
     corresponding field in `that`.

   ! Implementing Your Own Equality
     Equality in Enso is defined to allow comparison of any two values, no
     matter if they are not directly comparable. When implementing equality for
     your own types, keep in mind that it needs to work with any Enso value as
     the `that` argument.

   ? Generic Equality and Performance
     While the generic equality provided here will work for _all_ values in
     Enso, its performance may often be suboptimal. Many types can implement
     their own equality operations that will be more efficient than these.

   > Example
     Checking if 1 is equal to 2.
         1 == 2
Any.== : Any -> Boolean
Any.== that = if Meta.is_same_object this that then True else
    this_meta = Meta.meta this
    that_meta = Meta.meta that
    case Cons this_meta that_meta of
        Cons (Meta.Atom _) (Meta.Atom _) ->
            c_1 = this_meta.constructor
            c_2 = that_meta.constructor
            if Meta.is_same_object c_1 c_2 . not then False else
                f_1 = this_meta.fields
                f_2 = that_meta.fields
                0.up_to f_1.length . all i-> (f_1.at i) == (f_2.at i)
        Cons (Meta.Error _) (Meta.Error _) -> this_meta.payload == that_meta.payload
        Cons (Meta.Polyglot o_1) (Meta.Polyglot o_2) ->
            langs_match = this_meta.language == Meta.Java && that_meta.language == Meta.Java
            if langs_match.not then False else o_1.equals o_2
        ## Constructor comparison is covered by the identity equality.
           Primitive objects should define their own equality.
           Therefore, there are no more cases to handle in this method.
        _ -> False

## Checks if `this` is not equal to `that`.

   Arguments:
   - that: The object to compare `this` against.

   Two values are considered to be equal in Enso when they obey the following
   recursive properties:
   - At each level, they have the same structure.
   - The value of each field in `this` is equal (by this definition) to the
     corresponding field in `that`.

   Values that are not equal do not satisfy these properties.

   ! Implementing Your Own Inequality
     We recommend that you do not implement your own inequality, instead relying
     on the default definition.

   > Example
     Checking if 1 is not equal to 2.
         1 != 2
Any.!= : Any -> Boolean
Any.!= that = (this == that).not

## Checks if `this` is greater than `that`.

   Arguments:
   - `that`: The value to order against `this`.

   To have `>` defined, a type must define `compare_to`, returning an Ordering.

   > Example
     Compare two integers.
         1 > 10 == False
Any.> : Any -> Boolean
Any.> that = this.compare_to that == Ordering.Greater

## Checks if `this` is less than `that`.

   Arguments:
   - `that`: The value to order against `this`.

   To have `<` defined, a type must define `compare_to`, returning an Ordering.

   > Example
     Compare two integers.
         1 < 10 == True
Any.< : Any -> Boolean
Any.< that = this.compare_to that == Ordering.Less

## Checks if the type is an instance of `Nothing`.

   > Example
     Checking if a variable `a` is nothing.
         a.is_nothing
Any.is_nothing : Boolean
Any.is_nothing = case this of
    Nothing -> True
    _ -> False

## Executes the provided handler on a dataflow error, or forwards a non
   error-value unchanged.

   Arguments:
   - handler: The function to call on this if it is an error value. By default
     this is identity.

   > Example
     Catching an erroneous value and getting the length of its message.
       (Time.Time_Error "Message").catch (err -> IO.println err.error_message)
Any.catch : (Error -> Any) -> Any
Any.catch (handler = x->x) = this.catch_primitive handler

## Transforms a dataflow error.

   Arguments:
   - f: The function to transform the error.

   If `this` is a non-error value it is returned unchanged. However, if `this`
   is an error, the error is transformed using the provided function

   If the original value was a non-error value, it is not affected, but if it
   was an error, the error is mapped through the provided function.

   > Example
     Wrapping an error value.
       map.get "x" . map_error (_ -> ElementNotFound "x")
Any.map_error : (Error -> Error) -> Any
Any.map_error _ = this

## Checks if `this` is an error.
Any.is_error : Boolean
Any.is_error = False

## Applies the function `this` to the provided argument.

   Arguments:
   - argument: The argument to apply `this` to.

   ? Piping Blocks to Functions
     This construction is particularly useful for passing a block as an argument
     to a function. This means that you can compute more sophisticated values
     in-line, as shown in the example below.

   > Example
     Applying a function to a block.
         (x -> x + 1) <|
            y = 1 ^ 3
            3 + y
Any.<| : Any -> Any
Any.<| ~argument = this argument

## Applies the function on the right hand side to the argument on the left.

   Arguments
   - function: The function to apply to `this`.

   ? `|>` or `.`?
     The eagle-eyed reader will notice that the operator dot (`.`) is very
     similar to the operator `|>`. In Enso, with the variable precedence of
     operators, this makes perfect sense. In general, we recommend using `.`.
     However, there are some contexts where variable precedence might be unclear
     or confusing, and for those times we recommend using `|>`.

   > Example
     Applying multiple functions in a pipeline to compute a number and transform
     it to text.
         1 |> (* 2) |> (/ 100) |> .to_text
Any.|> : (Any -> Any) -> Any
Any.|> ~function = function this

## Composes two functions together.

   For `f << g`, this creates the function composition `f ∘ g`.

   Arguments:
   - that: The function to compose with `this`.

   > Example
     Compose the functions +1 and *2 and apply it to 2
         (+1 << *2) 2
Any.<< : (Any -> Any) -> (Any -> Any) -> Any -> Any
Any.<< ~that = x -> this (that x)

## Composes two functions together in the forward direction.

   For `f >> g`, this creates the function composition `g ∘ f`.

   Arguments:
   - that: The function to compose with `this`.

   > Example
     Add one and then multiply by two as a function applied to 2.
         (+1 >> *2) 2
Any.>> : (Any -> Any) -> (Any -> Any) -> Any -> Any
Any.>> ~that = x -> that (this x)

## UNSTABLE
   ADVANCED

   Returns a Text used to display this value in the IDE.

   The particular representation is left unspecified and subject to change in
   the future.  The current implementation uses a JSON serialization as the
   default.

   Types defining their own versions of this method should ensure that the
   result is reasonably small and the operation is quick to compute.

   > Example
     Converting the number `2` into visualization data.
         2.to_default_visualization_data
Any.to_default_visualization_data : Text
Any.to_default_visualization_data = this.to_json.to_text
