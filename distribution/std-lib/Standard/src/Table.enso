from Standard.Base import all

import Standard.Geo.Geo_Json
import Standard.Geo.Geo_Json.Internal
import Standard.Table.Io.Csv
import Standard.Table.Data.Table
import Standard.Table.Data.Column
import Standard.Table.Data.Order_Rule

from Standard.Table.Io.Csv export all hiding Parser

export Standard.Table.Data.Column

from Standard.Table.Data.Table export new, from_rows, join, No_Such_Column_Error, Table
from Standard.Table.Data.Order_Rule export Order_Rule

## Converts a JSON array into a dataframe, by looking up the requested keys
   from each item.

   The function assumens the items has one of the following structure:
   - a JSON object containing the requested keys. In case an item is not an
     object, or the request key does not exist, the relevant values of the table
     will be set to `Nothing`.
   - a GeoJSON object of type Feature. The format is described in rfc7946.

   ? Implementation Node
     GeoJson support is partial.
     - Supported geometry objects are Position and Point. Rows containing
       other geometry objects are not included in the resulting dataframe.
     - Position arrays are truncated to 3 elements: longitude, latitude
       and elevation.
     - Nested properties are not supported and not included in the resulting
       dataframe.

   Arguments:
     - fields: a vector of texts representing the names of fields to look up.
Json.Array.to_table : Vector -> Table
Json.Array.to_table fields = case this of
    Json.Array items ->
        rows = items.map item-> case item of
            Json.Object fs ->
                object_type = item.get_type . unwrap
                row = if object_type == Geo_Json.Feature.to_text then item.get_feature_row else fs
                fields.map n-> row.get n . unwrap . catch (_ -> Nothing)
            _ -> Vector.fill fields.length Nothing
        cols = fields.map_with_index i-> n->
            [n, rows.map (_.at i)]
        Table.new cols
