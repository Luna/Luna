//! This file contains tests for the intended generated code using the flexer, based on the
//! following small language.
//!
//! The language here is being defined as follows:
//!
//! a-word      = 'a'+;
//! b-word      = 'b'+;
//! word        = a-word | b-word;
//! space       = ' ';
//! spaced-word = space, word;
//! language    = word, spaced-word*;

use crate::prelude::AnyLogger;
use crate::prelude::LazyReader;
use crate::prelude::logger::Disabled;
use crate::prelude::reader::BookmarkManager;
use crate::prelude::reader::decoder::DecoderUTF8;
use crate::prelude::Reader;
use flexer::*;
use flexer::group;
use flexer::prelude::*;
use flexer::generate::GenError;


// ====================
// === Type Aliases ===
// ====================

type Logger = Disabled;



// ===========
// === AST ===
// ===========

/// A very simple AST, sufficient for the simple language being defined.
#[derive(Clone,Debug,PartialEq)]
pub enum Token {
    /// A word from the input, consisting of a sequence of all `a` or all `b`.
    Word(String),
    /// A token that the lexer is unable to recognise.
    Unrecognized(String),
}

/// A representation of a stream of tokens.
#[allow(missing_docs)]
#[derive(Clone,Debug,Default,PartialEq)]
pub struct TokenStream {
    tokens:Vec<Token>
}

impl TokenStream {
    /// Append the provided token to the token stream.
    pub fn push(&mut self,token:Token) {
        self.tokens.push(token);
    }
}


// === Trait Impls ===

impl From<Vec<Token>> for TokenStream {
    fn from(tokens:Vec<Token>) -> Self {
        TokenStream {tokens}
    }
}



// ==================
// === Test Lexer ===
// ==================

/// The definition of a test lexer for the above-described language.
#[derive(Debug)]
pub struct TestLexer {
    lexer:Flexer<TestState,TokenStream,Logger>
}

impl Deref for TestLexer {
    type Target = Flexer<TestState,TokenStream,Logger>;
    fn deref(&self) -> &Self::Target {
        &self.lexer
    }
}

impl DerefMut for TestLexer {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.lexer
    }
}

impl TestLexer {
    /// Creates a new instance of this lexer.
    pub fn new() -> Self {
        let logger = Logger::new("TestLexer");
        let lexer  = Flexer::new(logger);
        TestLexer { lexer }
    }
}

/// Implementations of functionality used by the lexer.
///
/// These functions are provided by the user, by hand, and must all take a reader that implements
/// the [`lazy_reader::LazyReader`] trait.
#[allow(missing_docs)]
impl TestLexer {
    pub fn on_first_word<R: LazyReader>(&mut self, _reader:&mut R) {
        let str = self.current_match.clone();
        let ast = Token::Word(str);
        self.output.push(ast);
        let id = self.seen_first_word_state;
        self.push_state(id);
    }

    pub fn on_spaced_word<R: LazyReader>(&mut self, _reader:&mut R) {
        let str = self.current_match.clone();
        let ast = Token::Word(String::from(str.trim()));
        self.output.push(ast);
    }

    pub fn on_err_suffix_first_word<R: LazyReader>(&mut self, _reader:&mut R) {
        let ast = Token::Unrecognized(self.current_match.clone());
        self.output.push(ast);
    }

    pub fn on_err_suffix<R: LazyReader>(&mut self, reader:&mut R) {
        self.on_err_suffix_first_word(reader);
        self.pop_state();
    }

    pub fn on_no_err_suffix_first_word<R: LazyReader>(&mut self, _reader:&mut R) {}

    pub fn on_no_err_suffix<R: LazyReader>(&mut self, reader: &mut R) {
        self.on_no_err_suffix_first_word(reader);
        self.pop_state();
    }
}

/// Generated functionality used at runtime by the lexer.
///
/// This code is _exactly_ as generated by the flexer specialization step, but manually formatted
/// for readability.
#[allow(missing_docs,dead_code)]
impl TestLexer {
    pub fn run<R:LazyReader>(&mut self, mut reader:R) -> LexingResult<TokenStream> {
        reader.advance_char(&mut self.bookmarks);
        while self.run_current_state(&mut reader) == StageStatus::ExitSuccess {}
        match self.status {
            StageStatus::ExitFinished =>
                LexingResult::success(mem::replace(&mut self.output,default())),
            StageStatus::ExitFail =>
                LexingResult::failure(mem::replace(&mut self.output,default())),
            _ => LexingResult::partial(mem::replace(&mut self.output,default()))
        }
    }

    fn run_current_state<R:LazyReader>(&mut self, reader:&mut R) -> StageStatus {
        self.status                = StageStatus::Initial;
        while let Some(next_state) = self.status.continue_as() {
            self.logger.info(||format!("Current character is {:?}",reader.character()));
            self.logger.info(||format!("Continuing in {:?}",next_state));
            self.status = self.step(next_state, reader);
            if reader.finished() {
                self.status = StageStatus::ExitFinished
            }
            if self.status.should_continue() {
                match reader.character().char {
                    Ok(char) => {
                        reader.append_result(char);
                        self.logger.info(||format!("Result is {:?}",reader.result()));
                    },
                    Err(lazy_reader::Error::EndOfGroup) => {
                        let current_state = self.current_state();
                        let group_name    = self.groups().group(current_state).name.as_str();
                        let err           = format!("Incomplete rules for state {}", group_name);
                        self.logger.error(err.as_str());
                        panic!(err)
                    }
                    Err(_) => {
                        self.logger.error("Unexpected error.");
                        panic!("Unexpected error!")
                    }
                }
                reader.advance_char(&mut self.bookmarks);
            }
        }
        self.status
    }

    fn step<R:LazyReader>(&mut self, next_state:SubStateId, reader:&mut R) -> StageStatus {
        let current_state: usize = self.current_state().into();
        match current_state {
            0 => self.dispatch_in_state_0(next_state,reader),
            1 => self.dispatch_in_state_1(next_state,reader),
            _ => unreachable_panic!( "Unreachable state reached in lexer." ),
        }
    }

    fn dispatch_in_state_0<R:LazyReader>
    ( &mut self
    , new_state_index : SubStateId
    , reader          : &mut R
    ) -> StageStatus {
        match new_state_index.into() {
            0 => self.state_0_to_0(reader),
            1 => self.state_0_to_1(reader),
            2 => self.state_0_to_2(reader),
            3 => self.state_0_to_3(reader),
            4 => self.state_0_to_4(reader),
            5 => self.state_0_to_5(reader),
            6 => self.state_0_to_6(reader),
            _ => unreachable_panic!( "Unreachable state reached in lexer." )
        }
    }

    fn state_0_to_0<R:LazyReader>(&mut self, reader:&mut R) -> StageStatus {
        match u32::from(reader.character()) {
            0..=96          => { StageStatus::ContinueWith(1.into()) }
            97              => { StageStatus::ContinueWith(2.into()) }
            98              => { StageStatus::ContinueWith(3.into()) }
            99..=4294967294 => { StageStatus::ContinueWith(1.into()) }
            _               => { StageStatus::ContinueWith(4.into()) }
        }
    }

    fn state_0_to_1<R:LazyReader>(&mut self, reader:&mut R) -> StageStatus {
        match u32::from(reader.character()) {
            _ => {
                let matched_bookmark = self.bookmarks.matched_bookmark;
                self.current_match   = reader.pop_result();
                self.group_0_rule_3(reader);
                self.bookmarks.bookmark(matched_bookmark, reader);
                StageStatus::ExitSuccess
            }
        }
    }

    fn state_0_to_2<R:LazyReader>(&mut self, reader:&mut R) -> StageStatus {
        match u32::from(reader.character()) {
            0..=96 => {
                let matched_bookmark = self.bookmarks.matched_bookmark;
                self.current_match   = reader.pop_result();
                self.group_0_rule_0(reader);
                self.bookmarks.bookmark(matched_bookmark, reader);
                StageStatus::ExitSuccess
            }
            97 => { StageStatus::ContinueWith(5.into()) }
            _  => {
                let matched_bookmark = self.bookmarks.matched_bookmark;
                self.current_match   = reader.pop_result();
                self.group_0_rule_0(reader);
                self.bookmarks.bookmark(matched_bookmark, reader);
                StageStatus::ExitSuccess
            }
        }
    }

    fn state_0_to_3<R:LazyReader>(&mut self, reader: &mut R) -> StageStatus {
        match u32::from(reader.character()) {
            0..=97 => {
                let matched_bookmark = self.bookmarks.matched_bookmark;
                self.current_match  = reader.pop_result();
                self.group_0_rule_1(reader);
                self.bookmarks.bookmark(matched_bookmark, reader);
                StageStatus::ExitSuccess
            }
            98 => { StageStatus::ContinueWith(6.into()) }
            _  => {
                let matched_bookmark = self.bookmarks.matched_bookmark;
                self.current_match   = reader.pop_result();
                self.group_0_rule_1(reader);
                self.bookmarks.bookmark(matched_bookmark, reader);
                StageStatus::ExitSuccess
            }
        }
    }

    fn state_0_to_4<R:LazyReader>(&mut self, reader:&mut R) -> StageStatus {
        match u32::from(reader.character()) {
            _ => {
                let matched_bookmark = self.bookmarks.matched_bookmark;
                self.current_match   = reader.pop_result();
                self.group_0_rule_2(reader);
                self.bookmarks.bookmark(matched_bookmark, reader);
                StageStatus::ExitSuccess
            }
        }
    }

    fn state_0_to_5<R:LazyReader>(&mut self, reader:&mut R) -> StageStatus {
        match u32::from(reader.character()) {
            0..=96 => {
                let matched_bookmark = self.bookmarks.matched_bookmark;
                self.current_match   = reader.pop_result();
                self.group_0_rule_0(reader);
                self.bookmarks.bookmark(matched_bookmark, reader);
                StageStatus::ExitSuccess
            }
            97 => { StageStatus::ContinueWith(5.into()) }
            _  => {
                let matched_bookmark = self.bookmarks.matched_bookmark;
                self.current_match   = reader.pop_result();
                self.group_0_rule_0(reader);
                self.bookmarks.bookmark(matched_bookmark, reader);
                StageStatus::ExitSuccess
            }
        }
    }

    fn state_0_to_6<R:LazyReader>(&mut self, reader:&mut R) -> StageStatus {
        match u32::from(reader.character()) {
            0..=97 => {
                let matched_bookmark = self.bookmarks.matched_bookmark;
                self.current_match   = reader.pop_result();
                self.group_0_rule_1(reader);
                self.bookmarks.bookmark(matched_bookmark, reader);
                StageStatus::ExitSuccess
            }
            98 => { StageStatus::ContinueWith(6.into()) }
            _  => {
                let matched_bookmark = self.bookmarks.matched_bookmark;
                self.current_match   = reader.pop_result();
                self.group_0_rule_1(reader);
                self.bookmarks.bookmark(matched_bookmark, reader);
                StageStatus::ExitSuccess
            }
        }
    }

    fn group_0_rule_0<R:LazyReader>(&mut self, reader:&mut R) {
        self.on_first_word(reader)
    }

    fn group_0_rule_1<R:LazyReader>(&mut self, reader:&mut R) {
        self.on_first_word(reader)
    }

    fn group_0_rule_2<R:LazyReader>(&mut self, reader:&mut R) {
        self.on_no_err_suffix_first_word(reader)
    }

    fn group_0_rule_3<R:LazyReader>(&mut self, reader:&mut R) {
        self.on_err_suffix_first_word(reader)
    }

    fn dispatch_in_state_1<R:LazyReader>
    ( &mut self
    , new_state_index : SubStateId
    , reader          : &mut R
    ) -> StageStatus {
        match new_state_index.into() {
            0 => self.state_1_to_0(reader),
            1 => self.state_1_to_1(reader),
            2 => self.state_1_to_2(reader),
            3 => self.state_1_to_3(reader),
            4 => self.state_1_to_4(reader),
            5 => self.state_1_to_5(reader),
            6 => self.state_1_to_6(reader),
            7 => self.state_1_to_7(reader),
            _ => unreachable_panic!( "Unreachable state reached in lexer." )
        }
    }

    fn state_1_to_0<R:LazyReader>(&mut self, reader:&mut R) -> StageStatus {
        match u32::from(reader.character()) {
            0..=31          => { StageStatus::ContinueWith(1.into()) }
            32              => { StageStatus::ContinueWith(2.into()) }
            33..=4294967294 => { StageStatus::ContinueWith(1.into()) }
            _               => { StageStatus::ContinueWith(3.into()) }
        }
    }

    fn state_1_to_1<R:LazyReader>(&mut self, reader:&mut R) -> StageStatus {
        match u32::from(reader.character()) {
            _ => {
                let matched_bookmark = self.bookmarks.matched_bookmark;
                self.current_match   = reader.pop_result();
                self.group_1_rule_3(reader);
                self.bookmarks.bookmark(matched_bookmark, reader);
                StageStatus::ExitSuccess
            }
        }
    }

    fn state_1_to_2<R:LazyReader>(&mut self, reader:&mut R) -> StageStatus {
        match u32::from(reader.character()) {
            0..=96 => {
                let matched_bookmark = self.bookmarks.matched_bookmark;
                self.current_match   = reader.pop_result();
                self.group_1_rule_3(reader);
                self.bookmarks.bookmark(matched_bookmark, reader);
                StageStatus::ExitSuccess
            }
            97 => { StageStatus::ContinueWith(4.into()) }
            98 => { StageStatus::ContinueWith(5.into()) }
            _  => {
                let matched_bookmark = self.bookmarks.matched_bookmark;
                self.current_match   = reader.pop_result();
                self.group_1_rule_3(reader);
                self.bookmarks.bookmark(matched_bookmark, reader);
                StageStatus::ExitSuccess
            }
        }
    }

    fn state_1_to_3<R:LazyReader>(&mut self, reader:&mut R) -> StageStatus {
        match u32::from(reader.character()) {
            _ => {
                let matched_bookmark = self.bookmarks.matched_bookmark;
                self.current_match   = reader.pop_result();
                self.group_1_rule_2(reader);
                self.bookmarks.bookmark(matched_bookmark, reader);
                StageStatus::ExitSuccess
            }
        }
    }

    fn state_1_to_4<R:LazyReader>(&mut self, reader:&mut R) -> StageStatus {
        match u32::from(reader.character()) {
            0..=96 => {
                let matched_bookmark = self.bookmarks.matched_bookmark;
                self.current_match   = reader.pop_result();
                self.group_1_rule_0(reader);
                self.bookmarks.bookmark(matched_bookmark, reader);
                StageStatus::ExitSuccess
            }
            97 => { StageStatus::ContinueWith(6.into()) }
            _  => {
                let matched_bookmark = self.bookmarks.matched_bookmark;
                self.current_match   = reader.pop_result();
                self.group_1_rule_0(reader);
                self.bookmarks.bookmark(matched_bookmark, reader);
                StageStatus::ExitSuccess
            }
        }
    }

    fn state_1_to_5<R:LazyReader>(&mut self, reader:&mut R) -> StageStatus {
        match u32::from(reader.character()) {
            0..=97 => {
                let matched_bookmark = self.bookmarks.matched_bookmark;
                self.current_match   = reader.pop_result();
                self.group_1_rule_1(reader);
                self.bookmarks.bookmark(matched_bookmark, reader);
                StageStatus::ExitSuccess
            }
            98 => { StageStatus::ContinueWith(7.into()) }
            _  => {
                let matched_bookmark = self.bookmarks.matched_bookmark;
                self.current_match   = reader.pop_result();
                self.group_1_rule_1(reader);
                self.bookmarks.bookmark(matched_bookmark, reader);
                StageStatus::ExitSuccess
            }
        }
    }

    fn state_1_to_6<R:LazyReader>(&mut self, reader:&mut R) -> StageStatus {
        match u32::from(reader.character()) {
            0..=96 => {
                let matched_bookmark = self.bookmarks.matched_bookmark;
                self.current_match   = reader.pop_result();
                self.group_1_rule_0(reader);
                self.bookmarks.bookmark(matched_bookmark, reader);
                StageStatus::ExitSuccess
            }
            97 => { StageStatus::ContinueWith(6.into()) }
            _  => {
                let matched_bookmark = self.bookmarks.matched_bookmark;
                self.current_match   = reader.pop_result();
                self.group_1_rule_0(reader);
                self.bookmarks.bookmark(matched_bookmark, reader);
                StageStatus::ExitSuccess
            }
        }
    }

    fn state_1_to_7<R:LazyReader>(&mut self, reader:&mut R) -> StageStatus {
        match u32::from(reader.character()) {
            0..=97 => {
                let matched_bookmark = self.bookmarks.matched_bookmark;
                self.current_match   = reader.pop_result();
                self.group_1_rule_1(reader);
                self.bookmarks.bookmark(matched_bookmark, reader);
                StageStatus::ExitSuccess
            }
            98 => { StageStatus::ContinueWith(7.into()) }
            _  => {
                let matched_bookmark = self.bookmarks.matched_bookmark;
                self.current_match   = reader.pop_result();
                self.group_1_rule_1(reader);
                self.bookmarks.bookmark(matched_bookmark, reader);
                StageStatus::ExitSuccess
            }
        }
    }

    fn group_1_rule_0<R:LazyReader>(&mut self, reader:&mut R) {
        self.on_spaced_word(reader)
    }

    fn group_1_rule_1<R:LazyReader>(&mut self, reader:&mut R) {
        self.on_spaced_word(reader)
    }

    fn group_1_rule_2<R:LazyReader>(&mut self, reader:&mut R) {
        self.on_no_err_suffix(reader)
    }

    fn group_1_rule_3<R:LazyReader>(&mut self, reader:&mut R) {
        self.on_err_suffix(reader)
    }
}


// ===================
// === Lexer State ===
// ===================

/// The stateful components of the test lexer.
#[derive(Debug)]
pub struct TestState {
    /// The registry for groups in the lexer.
    lexer_states:group::Registry,
    /// The initial state of the lexer.
    initial_state:group::Identifier,
    /// The state entered when the first word has been seen.
    seen_first_word_state:group::Identifier,
    /// The bookmarks for this lexer.
    bookmarks:BookmarkManager,
}


// === Trait Impls ===

impl flexer::State for TestState {
    fn new() -> Self {
        let mut lexer_states      = group::Registry::default();
        let initial_state         = lexer_states.define_group("ROOT", None);
        let seen_first_word_state = lexer_states.define_group("SEEN FIRST WORD", None);
        let bookmarks             = BookmarkManager::new();
        Self { lexer_states, initial_state, seen_first_word_state, bookmarks }
    }

    fn initial_state(&self) -> group::Identifier {
        self.initial_state
    }

    fn groups(&self) -> &group::Registry {
        &self.lexer_states
    }

    fn groups_mut(&mut self) -> &mut group::Registry {
        &mut self.lexer_states
    }

    fn bookmarks(&self) -> &BookmarkManager {
        &self.bookmarks
    }

    fn bookmarks_mut(&mut self) -> &mut BookmarkManager {
        &mut self.bookmarks
    }

    fn specialize(&self) -> Result<String,GenError> {
        generate::specialize(self,"TestLexer","TokenStream")
    }
}


// =============
// === Tests ===
// =============

/// Executes the test on the provided input string slice.
fn run_test_on(str: impl AsRef<str>) -> TokenStream {
    // Hardcoded for ease of use here.
    let reader     = Reader::new(str.as_ref().as_bytes(), DecoderUTF8());
    let mut lexer  = TestLexer::new();
    let run_result = lexer.run(reader);

    match run_result.kind {
        flexer::ResultKind::Success => run_result.tokens,
        _ => default()
    }
}

#[test]
fn test_single_a_word() {
    let input           = "aaaaa";
    let expected_output = TokenStream::from(vec![Token::Word(String::from(input))]);
    let result          = run_test_on(input);
    assert_eq!(result, expected_output);
}

#[test]
fn test_single_b_word() {
    let input           = "bbbbb";
    let expected_output = TokenStream::from(vec![Token::Word(String::from(input))]);
    let result          = run_test_on(input);
    assert_eq!(result, expected_output);
}

#[test]
fn test_two_word() {
    let input           = "aaaaa bbbbb";
    let expected_output = TokenStream::from(
        vec![Token::Word(String::from("aaaaa")), Token::Word(String::from("bbbbb"))]
    );
    let result = run_test_on(input);
    assert_eq!(result, expected_output);
}

#[test]
fn test_multi_word() {
    let input           = "bbb aa a b bbbbb aa";
    let expected_output = TokenStream::from(vec![
        Token::Word(String::from("bbb")),
        Token::Word(String::from("aa")),
        Token::Word(String::from("a")),
        Token::Word(String::from("b")),
        Token::Word(String::from("bbbbb")),
        Token::Word(String::from("aa"))
    ]);
    let result = run_test_on(input);
    assert_eq!(result, expected_output);
}

#[test]
fn test_invalid_single_word() {
    let input           = "c";
    let expected_output = TokenStream::from(vec![Token::Unrecognized(String::from(input))]);
    let result          = run_test_on(input);
    assert_eq!(result, expected_output);
}

#[test]
fn test_multi_word_invalid() {
    let input           = "aaaaaa c bbbbbb";
    let expected_output = TokenStream::from(vec![
        Token::Word(String::from("aaaaaa")),
        Token::Unrecognized(String::from(" ")),
        Token::Unrecognized(String::from("c")),
        Token::Unrecognized(String::from(" ")),
        Token::Word(String::from("bbbbbb")),
    ]);
    let result = run_test_on(input);
    assert_eq!(result, expected_output);
}

#[test]
fn test_end_invalid() {
    let input           = "bbbbbb c";
    let expected_output = TokenStream::from(vec![
        Token::Word(String::from("bbbbbb")),
        Token::Unrecognized(String::from(" ")),
        Token::Unrecognized(String::from("c")),
    ]);
    let result = run_test_on(input);
    assert_eq!(result, expected_output);
}
