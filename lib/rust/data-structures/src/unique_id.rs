//! # Globally unique IDs

use crate::prelude::*;



// ================
// === UniqueId ===
// ================

/// A globally unique value usable as an identifier.
pub trait UniqueId: Clone + Copy + Debug + Eq + Hash + PartialEq + Ord + PartialOrd {
    /// Create a new unique ID.
    ///
    /// The implementation must ensure it does not compare equal to any other instance of its type.
    fn new() -> Self;
}



// =================
// === define_id ===
// =================

/// Define a type usable as an ID, with unique values generated by a counter.
///
/// Example usage:
/// ```
/// enso_data_structures::define_id!(MyId);
///
/// // `new()` produces unique values of the new type.
/// let a = MyId::new();
/// let b = MyId::new();
/// assert_ne!(a, b);
/// ```
#[macro_export]
macro_rules! define_id {
    ($name:ident) => {
        /// A unique ID.
        #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq, Ord, PartialOrd)]
        pub struct $name($crate::counter::Counter);

        impl $name {
            /// Create a new unique ID.
            #[allow(clippy::new_without_default)]
            pub fn new() -> Self {
                Self($crate::counter::Counter::new())
            }
        }

        impl $crate::unique_id::UniqueId for $name {
            fn new() -> Self {
                Self::new()
            }
        }

        /// Convert to a raw count, losing counter-type information.
        impl From<$name> for u64 {
            fn from($name(counter): $name) -> Self {
                counter.into()
            }
        }

        /// Convert to a raw count, losing counter-type information.
        impl From<&$name> for u64 {
            fn from(&$name(counter): &$name) -> Self {
                counter.into()
            }
        }

        // This can't be derived because the derive implementation depends on `CloneRef` being in
        // scope at the definition site, and we don't know if that will be the case where this
        // macro is used.
        impl $crate::prelude::CloneRef for $name {
            fn clone_ref(&self) -> Self {
                self.clone()
            }
        }
    };
}



// =============
// === Tests ===
// =============

#[cfg(test)]
mod tests {
    define_id!(TestIdA);
    define_id!(TestIdB);

    #[test]
    fn test_define_id() {
        let a0 = TestIdA::new();
        let a1 = TestIdA::new();
        assert_ne!(a0, a1);

        let b0 = TestIdB::new();
        let b1 = TestIdB::new();
        assert_ne!(b0, b1);
    }
}
