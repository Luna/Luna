from Standard.Base import all
import Standard.Base.Error.No_Such_Key.No_Such_Key
import Standard.Base.Data.Time.Date_Time.Date_Time
from Standard.Base.Data.Hash_Map import Hash_Map

from Standard.Test import Test, Test_Suite
import Standard.Test.Extensions

polyglot java import java.nio.file.Path as JavaPath
polyglot java import java.util.Map as JavaMap

# TODO: (Python + js) Interop specs
foreign js js_str str = """
    return new String(str)

foreign js js_empty_dict = """
    return new Map()

foreign python py_empty_dict = """
    return {}

foreign js js_dict_from_vec vec = """
    dict = new Map()
    for (let i = 0; i < vec.length; i += 2) {
        dict.set(vec[i], vec[i+1])
    }
    return dict

foreign python py_dict_from_vec vec = """
    d = {}
    for i in range(0, len(vec), 2):
        d[vec[i]] = vec[i + 1]
    return d

foreign python py_dict_from_map map = """
    d = dict()
    for key in map.__iter__():
        d[key] = map[key]
    return d

foreign python py_vec_from_map map = """
    vec = []
    for key in map.__iter__():
        value = map[key]
        vec.append([key, value])
    return vec

# Should throw error - updating immutable map from Enso
foreign python py_update_dict map key val = """
    map[key] = val

foreign python py_wrapper obj = """
    class MyClass:
        def __init__(self, obj):
            self.data = obj
    return MyClass(obj)

pending_python_missing = if Polyglot.is_language_installed "python" then Nothing else """
    Can't run Python tests, Python is not installed.


spec =
    Test.group "Hash maps" <|
        Test.specify "should allow checking for emptiness" <|
            empty_map = Hash_Map.empty
            non_empty = Hash_Map.empty . insert "foo" 1234
            empty_map.is_empty . should_be_true
            non_empty.is_empty . should_be_false

        Test.specify "should compare two hash maps" <|
            (Hash_Map.singleton "a" 1).should_equal (Hash_Map.singleton "a" 1)
            (Hash_Map.singleton "b" 2).should_not_equal (Hash_Map.singleton "a" 1)
            Hash_Map.empty.should_equal Hash_Map.empty
            Hash_Map.empty.should_not_equal (Hash_Map.singleton "a" 1)
            (Hash_Map.empty.insert "a" 1 . insert "b" 2).should_equal (Hash_Map.empty.insert "b" 2 . insert "a" 1)

        Test.specify "should allow checking for non emptiness" <|
            empty_map = Hash_Map.empty
            non_empty = Hash_Map.empty . insert "foo" 1234
            empty_map.not_empty . should_be_false
            non_empty.not_empty . should_be_true

        Test.specify "should allow checking its size" <|
            empty_map = Hash_Map.empty
            non_empty = Hash_Map.singleton "a" "b" . insert "x" "y"
            empty_map.size . should_equal 0
            non_empty.size . should_equal 2

        Test.specify "should support arbitrary atoms as keys" <|
            map = Hash_Map.singleton (Pair.new "one" "two") 42
            (map.get (Pair.new "one" "two")).should_equal 42
            (map.get (Pair.new "A" "B")).should_equal Nothing
            (map.get (Pair.new "two" "two")).should_equal Nothing

        Test.specify "should support vectors as keys" <|
            map = Hash_Map.singleton [1, "a", 2] "Value"
            map.size.should_equal 1
            map.get [1, "a", 2] . should_equal "Value"

        Test.specify "should support dates as keys" <|
            map = Hash_Map.empty.insert (Date.new 1993) 1 . insert (Date.new 1993 2 5) 2 . insert (Date_Time.new 1993 2 5 13 45) 3
            map.size.should_equal 3
            map.get (Date.new 1993 6 7) . should_equal Nothing
            map.get (Date.new 1993) . should_equal 1
            map.get (Date_Time.new 1993) . should_equal Nothing
            map.get (Date.new 1993 2 5) . should_equal 2
            map.get (Date_Time.new 1993 2 5) . should_equal Nothing
            map.get (Date_Time.new 1993 2 5 13 45) . should_equal 3

        Test.specify "should support another hash map as key" <|
            key_map = Hash_Map.singleton (Pair.new "one" "two") 42
            map = Hash_Map.singleton key_map 23
            map.size.should_equal 1
            (map.get "A").should_equal Nothing
            (map.get key_map).should_equal 23
            (map.get map).should_equal Nothing

        Test.specify "should handle keys with standard equality semantics" <|
            map = Hash_Map.singleton 2 "Hello"
            (map.get 2).should_equal "Hello"
            (map.get 2.0).should_equal "Hello"
            (Hash_Map.singleton 2 "Hello").should_equal (Hash_Map.singleton 2.0 "Hello")

        Test.specify "should handle Nothing as keys" <|
            (Hash_Map.singleton Nothing 3).get Nothing . should_equal 3

        Test.specify "should support rewriting values with same keys" <|
            map = Hash_Map.empty.insert "a" 1 . insert "a" 42
            map.size.should_equal 1
            map.get "a" . should_equal 42

        Test.specify "should allow storing atoms as values" <|
            json = Json.parse '{"a": 1}'
            pair = Pair.new "first" "second"
            map = Hash_Map.empty.insert 0 json . insert 1 pair
            map.get 0 . should_equal json
            map.get 1 . should_equal pair

        Test.specify "should not drop warnings from keys" <|
            key = Warning.attach "my_warn" "my_key"
            map = Hash_Map.singleton key 42
            (Warning.get_all (map.keys.at 0)).length . should_equal 1

        Test.specify "should not drop warnings from values" <|
            val = Warning.attach "my_warn" "my_val"
            map = Hash_Map.singleton 42 val
            (Warning.get_all (map.values.at 0)).length . should_equal 1

        Test.specify "should convert the whole map to a vector" <|
            m = Hash_Map.empty . insert 0 0 . insert 3 -5 . insert 1 2
            m.to_vector.should_equal [[0, 0], [3, -5], [1, 2]]

        Test.specify "should allow building the map from a vector" <|
            expected = Hash_Map.empty . insert 0 0 . insert 3 -5 . insert 1 2
            vec = [[0, 0], [3, -5], [1, 2]]
            Hash_Map.from_vector vec . should_equal expected

        Test.specify "should define a well-defined text conversion" <|
            m = Hash_Map.empty . insert 0 0 . insert 3 -5 . insert 1 2
            m.to_text . should_equal "{0=0, 3=-5, 1=2}"

        Test.specify "should define structural equality" <|
            map_1 = Hash_Map.empty . insert "1" 2 . insert "2" "1"
            map_2 = Hash_Map.empty . insert "1" 2 . insert "2" "1"
            map_3 = Hash_Map.empty
            map_1==map_2 . should_be_true
            map_1==map_3 . should_be_false
            map_2==map_3 . should_be_false

        Test.specify "should allow inserting and looking up values" <|
            m = Hash_Map.empty . insert "foo" 134 . insert "bar" 654 . insert "baz" "spam"
            m.at "foo" . should_equal 134
            m.at "bar" . should_equal 654
            m.at "baz" . should_equal "spam"
            (m.at "nope").should_fail_with No_Such_Key.Error

        Test.specify "should support get" <|
            m = Hash_Map.empty . insert 2 3
            m.get 2 0 . should_equal 3
            m.get 1 10 . should_equal 10
            m.get 2 (Panic.throw "missing") . should_equal 3

        Test.specify "should allow getting a vector of the keys" <|
            m = Hash_Map.empty . insert 1 2 . insert 2 4
            m.keys . should_equal [1, 2]

        Test.specify "should allow getting a vector of the values" <|
            m = Hash_Map.empty . insert 1 2 . insert 2 4
            m.values . should_equal [2, 4]

        Test.specify "should allow transforming the map" <|
            m = Hash_Map.empty . insert 1 2 . insert 2 4
            expected = Hash_Map.empty . insert "1" 4 . insert "2" 8
            m.transform (k -> v -> [k.to_text, v*2]) . should_equal expected

        Test.specify "should allow mapping over values" <|
            m = Hash_Map.empty . insert 1 2 . insert 2 4
            expected = Hash_Map.empty . insert 1 4 . insert 2 8
            m.map (v -> v*2) . should_equal expected

        Test.specify "should allow mapping over keys" <|
            m = Hash_Map.empty . insert 1 2 . insert 2 4
            expected = Hash_Map.empty . insert 2 2 . insert 4 4
            m.map_keys (k -> k*2) . should_equal expected

        Test.specify "should allow mapping with keys" <|
            m = Hash_Map.empty . insert 1 2 . insert 2 4
            expected = Hash_Map.empty . insert 1 3 . insert 2 6
            m.map_with_key (k -> v -> k + v) . should_equal expected

        Test.specify "should allow iterating over each value" <|
            m = Hash_Map.empty . insert 1 2 . insert 2 4
            vec = Vector.new_builder
            expected_vec = [2, 4]
            m.each (v -> vec.append v)
            vec.to_vector . should_equal expected_vec

        Test.specify "should allow iterating over each key-value pair" <|
            m = Hash_Map.empty . insert 1 2 . insert 2 4
            vec = Vector.new_builder
            expected_vec = [3, 6]
            m.each_with_key (k -> v -> vec.append (k+v))
            vec.to_vector . should_equal expected_vec

        Test.specify "should allow folding over the values" <|
            m = Hash_Map.empty . insert 1 2 . insert 2 4
            m.fold 0 (+) . should_equal 6

        Test.specify "should allow folding over the key-value pairs" <|
            m = Hash_Map.empty . insert 1 2 . insert 2 4
            m.fold_with_key 0 (l -> k -> v -> l + k + v) . should_equal 9

        Test.specify "should be able to get the first key value pair" <|
            m = Hash_Map.empty . insert 1 2 . insert 2 4
            pair = m.first
            pair.first . should_equal 1
            pair.second . should_equal 2

        Test.specify "should be able to get the first key value pair of an empty map" <|
            m = Hash_Map.empty
            m.first . should_equal Nothing

        Test.specify "should be able to get the last key value pair" <|
            m = Hash_Map.empty . insert 1 2 . insert 2 4
            pair = m.last
            pair.first . should_equal 2
            pair.second . should_equal 4

        Test.specify "should be able to get the last key value pair of an empty map" <|
            m = Hash_Map.empty
            m.last . should_equal Nothing

        Test.specify "should be able to add a Nothing key to the map" <|
            m = Hash_Map.empty . insert Nothing 1
            m.last . should_equal (Pair.new Nothing 1)

        Test.specify "should be able to add a Nothing key to the map of Text" <|
            m = Hash_Map.empty . insert "A" 2 . insert Nothing 1 . insert "B" 3
            m.at "A" . should_equal 2
            m.at "B" . should_equal 3
            m.at Nothing . should_equal 1

        Test.specify "should be able to add a Nothing key to the map of Integer" <|
            m = Hash_Map.empty . insert 100 2 . insert Nothing 1 . insert 200 3
            m.at 100 . should_equal 2
            m.at 200 . should_equal 3
            m.at Nothing . should_equal 1

    Test.group "Polyglot keys and values" <|
        Test.specify "should support polyglot keys" <|
            map = Hash_Map.singleton (js_str "A") 42
            map.size.should_equal 1
            map.get "A" . should_equal 42
            map.get (js_str "A") . should_equal 42

        Test.specify "should support host objects as keys" <|
            # JavaPath has proper implementation of hashCode
            map = Hash_Map.singleton (JavaPath.of "/home/user/file.txt") 42
            map.get "X" . should_equal Nothing
            map.get "A" . should_equal Nothing
            map.get (JavaPath.of "/home/user/file.txt") . should_equal 42

        Test.specify "should support Python objects as keys" pending=pending_python_missing <|
            py_obj = py_wrapper 42
            map = Hash_Map.singleton py_obj "Value"
            map.get py_obj . should_equal "Value"

        Test.specify "should support Python objects as values" pending=pending_python_missing <|
            map = Hash_Map.singleton "A" (py_wrapper 42)
            map.get "A" . data . should_equal 42

    Test.group "Polyglot hash maps" <|
        Test.specify "should pass maps as immutable maps to other langs" <|
            map = Hash_Map.singleton "A" 1
            # Python's KeyError should be raised
            Test.expect_panic_with (py_update_dict map "A" 2) Any
            map.get "A" . should_equal 1

        Test.specify "should treat JavaScript maps as Enso maps" <|
            js_dict = js_dict_from_vec ["A", 1, "B", 2]
            map = js_dict.insert "C" 3
            js_dict.to_vector.should_equal [["A", 1], ["B", 2]]
            map.to_vector.should_equal [["A", 1], ["B", 2], ["C", 3]]

        Test.specify "should treat Java Map as Enso map" <|
            jmap = JavaMap.of "A" 1 "B" 2
            jmap.to_vector.should_equal [["A", 1], ["B", 2]]
            jmap.insert "C" 3 . to_vector . should_equal [["A", 1], ["B", 2], ["C", 3]]

        Test.specify "should treat Python dicts as Enso maps" pending=pending_python_missing <|
            py_dict = py_dict_from_vec ["A", 1, "B", 2]
            map = py_dict.insert "C" 3
            py_dict.not_empty . should_be_true
            py_dict.to_vector.should_equal [["A", 1], ["B", 2]]
            map.to_vector.should_equal [["A", 1], ["B", 2], ["C", 3]]

        Test.specify "should pass maps with null keys to Python and back" pending=pending_python_missing <|
            # Python supports None as keys, Enso support Nothing as keys
            py_dict = py_dict_from_map (Hash_Map.singleton Nothing 42)
            py_dict.get Nothing . should_equal 42
            py_dict.insert "A" 23 . get Nothing . should_equal 42
            py_dict.insert Nothing 23 . get Nothing . should_equal 23

        Test.specify "should treat Enso maps as Python dicts when passed to Python" pending=pending_python_missing <|
            map1 = Hash_Map.empty.insert "A" 1 . insert "B" 2
            py_vec_from_map map1 . should_equal [["A", 1], ["B", 2]]
            map2 = Hash_Map.empty.insert "A" 1 . insert Nothing 2
            py_vec_from_map map2 . should_equal [["A", 1], [Nothing, 2]]


main = Test_Suite.run_main spec
