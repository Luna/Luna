from Standard.Base import all
import Standard.Base.Data.Text.Span.Utf_16_Span
import Standard.Base.Data.Text.Regex.Match_2.Match_2
import Standard.Base.Data.Text.Regex.Pattern_2.Pattern_2
import Standard.Base.Data.Text.Regex_2
import Standard.Base.Data.Text.Regex_2.No_Such_Group
import Standard.Base.Data.Text.Regex_2.Regex_Syntax_Error
import Standard.Base.Data.Text.Regex_2.Too_Many_Groups

from Standard.Test import Test, Test_Suite
import Standard.Test.Extensions

spec =
    Test.group "Compile" <|
        Test.specify "should be able to be compiled" <|
            pattern = Regex_2.compile "(?<dots>..)" case_insensitive=True
            pattern . should_be_a Pattern_2

        Test.specify "should throw Regex_Syntax_Error for a regex with incorrect syntax" <|
            Regex_2.compile "ab(c(((((((" . should_fail_with Regex_Syntax_Error

    Test.group "Escape" <|
        Test.specify "should escape an expression for use as a literal" <|
            pattern = "http://example.com"
            Regex_2.escape pattern . should_equal "\Qhttp://example.com\E"

    Test.group "Pattern.matches" <|
        Test.specify "should return True when the pattern matches against the input" <|
            pattern = Regex_2.compile "(.. .. )(?<letters>.+)()??(?<empty>)??" []
            input = "aa ab abc a bc bcd"
            pattern.matches input . should_be_true

        Test.specify "should return False when the pattern doesn't match against the input" <|
            pattern = Regex_2.compile "aaz" []
            input = "aa ab abc a bc bcd"
            pattern.matches input . should_be_false

        Test.specify "should check for full matches" <|
            pattern = Regex_2.compile "f.o" []
            pattern.matches "foo" . should_be_true
            pattern.matches "foobar" . should_be_false

    Test.group "Pattern.match" <|
        Test.specify "should be able to `match` the first instance of the pattern in the input" <|
            pattern = Regex_2.compile "(.. .. )(?<letters>.+)()??(?<empty>)??"
            input = "aa ab abc a bc bcd"
            match = pattern.match input
            match . should_be_a Match_2
            match.text 0 . should_equal input

        Test.specify "should return `Nothing` if there are no matches in first mode" <|
            pattern = Regex_2.compile "(.. .. )(?<letters>.+)()??(?<empty>)??" []
            input = "abc"
            match = pattern.match input
            match . should_equal Nothing

        Test.specify "should be able to `match` the all instances of the pattern in the input" <|
            pattern = Regex_2.compile "(..)" []
            input = "abcdefghij"
            matches = pattern.match_all input
            matches.length . should_equal 5
            matches.at 0 . text 0 . should_equal "ab"
            matches.at 1 . text 0 . should_equal "cd"
            matches.at 2 . text 0 . should_equal "ef"
            matches.at 3 . text 0 . should_equal "gh"
            matches.at 4 . text 0 . should_equal "ij"

        Test.specify "should return `[]` when an all match match fails" <|
            pattern = Regex_2.compile "(aa)" []
            input = "abcdefghij"
            match = pattern.match_all input
            match . should_equal []

        Test.specify "should correctly handle empty patterns" pending="Figure out how to make Regex correctly handle empty patterns." <|
           pattern = Regex_2.compile "" []
           match_1 = pattern.match ""
           match_1.length . should_equal 1
           match_1.at 0 . start 0 . should_equal 0
           match_1.at 0 . end 0 . should_equal 0

           match_2 = pattern.match "ABC"
           match_2.length . should_equal 4
           match_2.at 0 . start 0 . should_equal 0
           match_2.at 0 . end 0 . should_equal 0
           match_2.at 1 . start 0 . should_equal 1
           match_2.at 1 . end 0 . should_equal 1
           match_2.at 3 . start 0 . should_equal 3
           match_2.at 3 . end 0 . should_equal 3

    Test.group "Pattern_2.find" <|
        Test.specify "should be able to `find` the first instance of the pattern in the input" <|
            pattern = Regex_2.compile "(..)"
            input = "abcdefghij"
            match = pattern.find input
            match . should_be_a Text
            match . should_equal "ab"

        Test.specify "should return `Nothing` if there are no matches in first mode" <|
            pattern = Regex_2.compile "(aa)"
            input = "abcdefghij"
            match = pattern.find input
            match . should_equal Nothing

        Test.specify "should be able to `find` the all instances of the pattern in the input" <|
            pattern = Regex_2.compile "(..)"
            input = "abcdefghij"
            match = pattern.find_all input
            match.length . should_equal 5
            match.at 0 . should_equal "ab"
            match.at 1 . should_equal "cd"
            match.at 2 . should_equal "ef"
            match.at 3 . should_equal "gh"
            match.at 4 . should_equal "ij"

        Test.specify "should return `[]` when an all match match fails" <|
            pattern = Regex_2.compile "(aa)"
            input = "abcdefghij"
            match = pattern.find_all input
            match . should_equal []

        Test.specify "should correctly handle edge cases where one-letter matches happen at the end of the word" <|
            Regex_2.compile "(a+|1+)" . find_all "a1a1" . should_equal ["a", "1", "a", "1"]
            Regex_2.compile "([a]+|[1]+)" . find_all "a1a1" . should_equal ["a", "1", "a", "1"]
            Regex_2.compile "([0-9]+|[^0-9]+)" . find_all "a1b2" . should_equal ["a", "1", "b", "2"]

    ##
        Test.group "The default regex engine's Pattern.split" <|
            engine = Default_Engine.new

            Test.specify "should be able to `split` on the first instance of the pattern" <|
                pattern = engine.compile "cd" []
                input = "abcdefghij"
                match = pattern.split input mode=Matching_Mode.First
                match.length . should_equal 2
                match.at 0 . should_equal "ab"
                match.at 1 . should_equal "efghij"

            Test.specify "should return the original text if there are no matches in first mode" <|
                pattern = engine.compile "(aa)" []
                input = "abcdefghij"
                match = pattern.split input mode=Matching_Mode.First
                match . should_equal ["abcdefghij"]

            Test.specify "should be able to `split` on at most N instances of the pattern in the input" <|
                pattern = engine.compile "a" []
                input = "bacadaeaf"
                match = pattern.split input mode=3
                match.length . should_equal 4
                match.at 0 . should_equal "b"
                match.at 1 . should_equal "c"
                match.at 2 . should_equal "d"
                match.at 3 . should_equal "eaf"

            Test.specify "should `split` on fewer than N instances when there are fewer than N in the input" <|
                pattern = engine.compile "a" []
                input = "bacadaeaf"
                match = pattern.split input mode=10
                match.length . should_equal 5
                match.at 0 . should_equal "b"
                match.at 1 . should_equal "c"
                match.at 2 . should_equal "d"
                match.at 3 . should_equal "e"
                match.at 4 . should_equal "f"

            Test.specify "should be able to `split` on the all instances of the pattern in the input" <|
                pattern = engine.compile "(a)" []
                input = "bacadaeaf"
                match = pattern.split input mode=Regex_Mode.All
                match.length . should_equal 5
                match.at 0 . should_equal "b"
                match.at 1 . should_equal "c"
                match.at 2 . should_equal "d"
                match.at 3 . should_equal "e"
                match.at 4 . should_equal "f"

    Test.group "The default regex engine's Pattern.replace" <|
        Test.specify "should be able to `replace` the first instance of the pattern in the input" <|
            pattern = Regex_2.compile "abc"
            input = "aa ab abc a bc abc"
            match = pattern.replace input "REPLACED" only_first=True
            match . should_be_a Text
            match . should_equal "aa ab REPLACED a bc abc"

        Test.specify "should return the string unchanged if there are no matches to replace in only_first mode" <|
            pattern = Regex_2.compile "xyz"
            input = "aa ab ac ad"
            match = pattern.replace input "REPLACED" only_first=True
            match . should_equal input

        Test.specify "should be able to replace the all instances of the pattern in the input" <|
            pattern = Regex_2.compile "aa"
            input = "aa ab aa ac ad aa aa ax"
            match = pattern.replace input "REPLACED"
            match . should_equal "REPLACED ab REPLACED ac ad REPLACED REPLACED ax"

        Test.specify "should return the input when an all replace fails" <|
            pattern = Regex_2.compile "aa"
            input = "abcdefghij"
            match = pattern.replace input "REPLACED"
            match . should_equal input

        Test.specify "should be able to replace the entire input only if it matches" <|
            pattern = Regex_2.compile "(.. .. )(?<letters>.+)()??(?<empty>)??"
            input = "aa ab abc a bc bcd"
            match = pattern.replace input "REPLACED"
            match . should_equal "REPLACED"

        Test.specify "should not perform overlapping replacements in all mode" <|
            pattern = Regex_2.compile "(..)"
            input = "aa ab"
            match = pattern.replace input "REPLACED"
            match . should_equal "REPLACEDREPLACEDb"

        Test.specify "should handle capture groups in replacement" <|
            pattern = Regex_2.compile "(?<capture>[a-z]+)"
            pattern.replace "foo bar, baz" "[$1]" . should_equal "[foo] [bar], [baz]"
            pattern.replace "foo bar, baz" "[$1]" only_first=True . should_equal "[foo] bar, baz"

            pattern.replace "foo bar, baz" "[$<capture>]" . should_equal "[foo] [bar], [baz]"
            pattern.replace "foo bar, baz" "[$<capture>]" only_first=True . should_equal "[foo] bar, baz"

        Test.specify "should disallow numbered group references over 99" <|
            ## Note: this would also throw No_Such_Group but it checks for
               Too_Many_Groups first.
            pattern = Regex_2.compile "."
            pattern.replace "abc" "$100" . should_fail_with Too_Many_Groups

         Text.specify "should correctly evaluate documentation examples" <|
            pattern1 = Regex_2.compile 'aa'
            pattern1.replace 'aaa' 'b' . should_equal 'ba'
            pattern2 = Regex_2.compile '[lo]'
            pattern2.replace 'Hello World!' '#' . should_equal 'He### W#r#d!'
            pattern3 = Regex_2.compile 'l'
            pattern3.replace 'Hello World!' '#' only_first=True . should_equal 'He#lo World!'
            pattern4 = Regex_2.compile '"(.*?)"'
            pattern4.replace '"abc" foo "bar" baz' '($1)' . should_equal '(abc) foo (bar) baz'

    Test.group "Match.text" <|
        pattern = Regex_2.compile "(.. .. )(?<letters>.+)()??(?<empty>)??" []
        input = "aa ab abc a bc bcd"
        match = pattern.match input
        match . should_be_a Match_2

        Test.specify "should return the full match with index 0" <|
            match.text 0 . should_equal "aa ab abc a bc bcd"

        Test.specify "should return the group contents if it matches by index" <|
            match.text 1 . should_equal "aa ab "

        Test.specify "should return the group contents if it matches by name" <|
            match.text "letters" . should_equal "abc a bc bcd"

        Test.specify "should return Nothing if the group did not match" <|
            match.text 3 . should_equal Nothing

        Test.specify "should fail with No_Such_Group_Error if the group did not exist" <|
            match.text "fail" . should_fail_with No_Such_Group
            match.text 5 . should_fail_with No_Such_Group

        Test.specify "should make named groups accessible by index" <|
            match.text 2 . should_equal (match.text "letters")

    Test.group "Match.groups" <|
        pattern = Regex_2.compile "(.. .. )(?<letters>.+)()??(?<empty>)??" []
        input = "aa ab abc a bc bcd"
        match = pattern.match input
        match . should_be_a Match_2

        Test.specify "should return the results of all groups" <|
            groups = match.groups
            groups.length . should_equal 5
            groups.should_equal ["aa ab abc a bc bcd", "aa ab ", "abc a bc bcd", Nothing, Nothing]

        Test.specify "should replace unmatched groups by a user-specified value" <|
            groups = match.groups "UNMATCHED"
            groups.length . should_equal 5
            groups.should_equal ["aa ab abc a bc bcd", "aa ab ", "abc a bc bcd", "UNMATCHED", "UNMATCHED"]

    Test.group "Match.named_groups" <|
        pattern = Regex_2.compile "(.. .. )(?<letters>.+)()??(?<empty>)??"
        input = "aa ab abc a bc bcd"
        match = pattern.match input
        match . should_be_a Match_2.Value

        Test.specify "should return the results of all named groups" <|
            groups = match.named_groups
            groups.keys.sort . should_equal ["empty", "letters"]
            groups.size . should_equal 2
            groups.at "letters" . should_equal "abc a bc bcd"
            groups.at "empty" . should_equal Nothing

        Test.specify "should replace unmatched groups by a user-specified value" <|
            groups = match.named_groups "UNMATCHED"
            groups.size . should_equal 2
            groups.at "letters" . should_equal "abc a bc bcd"
            groups.at "empty" . should_equal "UNMATCHED"

    Test.group "Match.start" <|
        pattern = Regex_2.compile "(.. .. )(?<letters>.+)()??(?<empty>)??"
        input = "aa ab abc a bc bcd"
        match = pattern.match input
        match . should_be_a Match_2

        Test.specify "should return the start of a group by index" <|
            match.start 1 . should_equal 0

        Test.specify "should return the start of a group by name" <|
            match.start "letters" . should_equal 6

        Test.specify "should return Nothing if the group didn't match" <|
            match.start 3 . should_equal Nothing
            match.start "empty" . should_equal Nothing

        Test.specify "should return No_Such_Group_Error if the group doesn't exist" <|
            match.start 5 . should_fail_with No_Such_Group
            match.start "nonexistent" . should_fail_with No_Such_Group

    Test.group "Match.end" <|
        pattern = Regex_2.compile "(.. .. )(?<letters>.+)()??(?<empty>)??"
        input = "aa ab abc a bc bcd"
        match = pattern.match input
        match . should_be_a Match_2

        Test.specify "should return the end of a group by index" <|
            match.end 1 . should_equal 6

        Test.specify "should return the end of a group by name" <|
            match.end "letters" . should_equal 18

        Test.specify "should return Nothing if the group didn't match" <|
            match.end 3 . should_equal Nothing
            match.end "empty" . should_equal Nothing

        Test.specify "should return No_Such_Group_Error if the group doesn't exist" <|
            match.end 5 . should_fail_with No_Such_Group
            match.end "nonexistent" . should_fail_with No_Such_Group

    Test.group "Match.utf16_start" <|
        pattern = Regex_2.compile "(.. .. )(?<letters>.+)()??(?<empty>)??"
        input = "aa ab abc a bc bcd"
        match = pattern.match input
        match . should_be_a Match_2

        Test.specify "should return the start of a group by index" <|
            match.utf16_start 1 . should_equal 0

        Test.specify "should return the start of a group by name" <|
            match.utf16_start "letters" . should_equal 6

        Test.specify "should return Nothing if the group didn't match" <|
            match.utf16_start 3 . should_equal Nothing
            match.utf16_start "empty" . should_equal Nothing

        Test.specify "should return No_Such_Group_Error if the group doesn't exist" <|
            match.utf16_start 5 . should_fail_with No_Such_Group
            match.utf16_start "nonexistent" . should_fail_with No_Such_Group

        Test.group "Match.utf16_end" <|
            pattern = Regex_2.compile "(.. .. )(?<letters>.+)()??(?<empty>)??"
            input = "aa ab abc a bc bcd"
            match = pattern.match input
            match . should_be_a Match_2

            Test.specify "should return the end of a group by index" <|
                match.utf16_end 1 . should_equal 6

            Test.specify "should return the end of a group by name" <|
                match.utf16_end "letters" . should_equal 18

            Test.specify "should return Nothing if the group didn't match" <|
                match.utf16_end 3 . should_equal Nothing
                match.utf16_end "empty" . should_equal Nothing

            Test.specify "should return No_Such_Group_Error if the group doesn't exist" <|
                match.utf16_end 5 . should_fail_with No_Such_Group
                match.utf16_end "nonexistent" . should_fail_with No_Such_Group

    Test.group "Match.span" <|
        pattern = Regex_2.compile "(.. .. )(?<letters>.+)()??(?<empty>)??"
        input = "aa ab abc a bc bcd"
        match = pattern.match input
        match . should_be_a Match_2

        Test.specify "should get the span of a group by index" <|
            match.span 1 . should_equal (Utf_16_Span.Value (0.up_to 6) input)

        Test.specify "should get the span of a group by name" <|
            match.span "letters" . should_equal (Utf_16_Span.Value (6.up_to 18) input)

        Test.specify "should return Nothing if the group didn't match" <|
            match.span 3 . should_equal Nothing
            match.span "empty" . should_equal Nothing

        Test.specify "should fail with a No_Such_Group_Error if the group doesn't exist" <|
            match.span 5 . should_fail_with No_Such_Group
            match.span "nonexistent" . should_fail_with No_Such_Group

main = Test_Suite.run_main spec
