from Standard.Base import all

from Standard.Test import Test, Test_Suite
import Standard.Test.Extensions

polyglot java import java.util.HashMap

type Child
    Value number

    == : Any -> Boolean
    == self other = case other of
        _ : Child -> (self.number % 100) == (other.number % 100)
        _ -> False

type Parent
    Value child

    == : Any -> Boolean
    == self other = case other of
        _ : Parent -> self.child == other.child
        _ -> False

type GrandParent
    Value parent

    == : Any -> Boolean
    == self other = case other of
        _ : GrandParent -> self.parent == other.parent
        _ -> False

type ManyFieldType
    Value f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15

type FourFieldType
    Value f1 f2 f3 f4

type Point
    Value x y

type Rect
    Value (a:Point) (b:Point)

type Node
    C1 f1
    C2 f1 f2
    C3 f1 f2 f3
    C4 f1 f2 f3 f4
    C5 f1 f2 f3 f4 f5
    Nil
    Value value

    ## Deep copy the tree to ensure that we cannot do Meta.is_same_object shortcut.
    deep_copy : Node
    deep_copy self =
        case self of
            Node.Nil -> Node.Nil
            Node.Value value -> Node.Value value
            Node.C1 f1 -> Node.C1 (f1.deep_copy)
            Node.C2 f1 f2 -> Node.C2 (f1.deep_copy) (f2.deep_copy)
            Node.C3 f1 f2 f3 -> Node.C3 (f1.deep_copy) (f2.deep_copy) (f3.deep_copy)
            Node.C4 f1 f2 f3 f4 -> Node.C4 (f1.deep_copy) (f2.deep_copy) (f3.deep_copy) (f4.deep_copy)
            Node.C5 f1 f2 f3 f4 f5 -> Node.C5 (f1.deep_copy) (f2.deep_copy) (f3.deep_copy) (f4.deep_copy) (f5.deep_copy)
            _ -> Error.throw ("Unexpected type " + self.to_text)


create_random_tree : Integer -> Java_Random -> Integer
create_random_tree max_depth rnd cur_depth=0 =
    if cur_depth == max_depth then Node.Nil else
        next_depth = cur_depth + 1
        children_count = rnd.nextInt 6
        children = (0.up_to children_count).map _-> @Tail_Call create_random_tree max_depth rnd next_depth
        case children_count of
            0 -> Node.Value 42
            1 -> Node.C1 (children.at 0)
            2 -> Node.C2 (children.at 0) (children.at 1)
            3 -> Node.C3 (children.at 0) (children.at 1) (children.at 2)
            4 -> Node.C4 (children.at 0) (children.at 1) (children.at 2) (children.at 3)
            5 -> Node.C5 (children.at 0) (children.at 1) (children.at 2) (children.at 3) (children.at 4)
            _ -> Error.throw ("Unexpected number of children: " + children_count.to_text)


foreign python py_false = """
    return False


foreign python py_true = """
    return True

foreign python py_text_foo = """
    return 'foo'


spec =
    Test.group "Operator ==" <|
        Test.specify "should handle primitive values" <|
            2.should_equal (2.0)
            2.should_not_equal (2.1)
            (2.0).should_equal 2
            (py_true == True).should_be_true
            (py_false == False).should_be_true
            (py_true == False).should_be_false
            (py_text_foo == "foo").should_be_true


        Test.specify "should dispatch to overriden `==` on atoms" <|
            child1 = Child.Value 11
            parent1 = Parent.Value child1
            grand_parent1 = GrandParent.Value parent1

            child2 = Child.Value 111
            parent2 = Parent.Value child2
            grand_parent2 = GrandParent.Value parent2

            grand_parent1.should_equal grand_parent2

        Test.specify "should handle `==` on types with many fields" <|
            many_fields1 = ManyFieldType.Value (Child.Value 1) (Child.Value 2) (Child.Value 3) (Child.Value 4) (Child.Value 5) (Child.Value 6) (Child.Value 7) (Child.Value 8) (Child.Value 9) (Child.Value 10) (Child.Value 11) (Child.Value 12) (Child.Value 13) (Child.Value 14) (Child.Value 15)
            many_fields2 = ManyFieldType.Value (Child.Value 101) (Child.Value 102) (Child.Value 103) (Child.Value 104) (Child.Value 105) (Child.Value 106) (Child.Value 107) (Child.Value 108) (Child.Value 109) (Child.Value 110) (Child.Value 111) (Child.Value 112) (Child.Value 113) (Child.Value 114) (Child.Value 115)

            many_fields1.should_equal many_fields2

        Test.specify "should dispatch to equals on host values" <|
            java_object1 = HashMap.new
            java_object1.put "a" 1
            java_object1.put "b" 2

            java_object2 = HashMap.new
            java_object2.put "b" 2
            java_object2.put "a" 1

            java_object1.should_equal java_object2

            java_object2.put "c" 42

            java_object1.should_not_equal java_object2

        Test.specify "should return False for different Atoms with same fields" <|
            p1 = Point.Value 1 2
            p2 = Point.Value 3 4
            rect = Rect.Value p1 p2
            four_field = FourFieldType.Value 1 2 3 4
            rect.should_not_equal four_field

        Test.specify "should handle `==` on types" pending="Blocked by https://www.pivotaltracker.com/story/show/184092284" <|
            Child.should_equal Child
            Child.should_not_equal Point
            Point.should_not_equal Child
            HashMap.should_not_equal Child
            Child.should_not_equal HashMap
            Boolean.should_not_equal Any
            Any.should_not_equal Boolean
            Any.should_equal Any
            Boolean.should_equal Boolean

        Test.specify "should dispatch to overriden `==` in vectors" <|
            [(Child.Value 1)].should_equal [(Child.Value 101)]
            [(Child.Value 1)].should_not_equal [(Child.Value 2)]

        Test.specify "should dispatch to overriden `==` in arrays" <|
            (Array.new_1 (Child.Value 1)).should_equal (Array.new_1 (Child.Value 101))

        Test.specify "should handle recursive atoms without custom `==`" <|
            rnd = (Random.new seed=42).java_random
            trees = (0.up_to 5).map _->
                create_random_tree 5 rnd
            trees.each tree->
                dupl_tree = tree.deep_copy
                Test.with_clue "Seed sed to 42" (tree.should_equal dupl_tree)


main = Test_Suite.run_main spec
