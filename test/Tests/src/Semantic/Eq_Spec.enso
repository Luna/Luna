# TODO[PM]: This file should be merged with Equals_Spec.enso once the usage of equality is
# unified.

from Standard.Base import all
import Standard.Base.Data.Index_Sub_Range
from Standard.Base.Data.Eq import all

from Standard.Test import Test, Test_Suite

spec =
    Test.group "Test equality on numbers" <|
        Test.specify "Compare different numbers" <|
            10 === 20.3 . should_be_false

        Test.specify "Compare same numbers" <|
            10 === 10 . should_be_true

        Test.specify "Different hash prevents equality" <|
            Wrong_Hash.Elem1 === Wrong_Hash.Elem2 . should_be_false

    Test.group "Test inequality on numbers" <|
        Test.specify "Compare two numbers" <|
            10 <== 11 . should_be_true

    Test.group "Rational Numbers" <|
        Test.specify "3/4 == 6/8" <|
            Rational.Fraction 3 4 === Rational.Fraction 6 8 . should_be_true

        Test.specify "1/2 != 2/6" <|
            Rational.Fraction 1 2 === Rational.Fraction 2 6 . should_be_false

    Test.group "Other" <|
        Test.specify "texts" <|
            "aaa" === "bbb" . should_be_false
            "aaa" === "aaa" . should_be_true
            "xxx" === "XxX" . should_be_false
            "aaa" <== "xxx" . should_be_true
            "aaa" >== "xxx" . should_be_false

type Wrong_Hash
    Elem1
    Elem2

Comparable.from (_ : Wrong_Hash) = Wrong_Hash_Eq

type Wrong_Hash_Eq
    is_ordered = True
    hash e = case e of
        Wrong_Hash.Elem1 -> 1
        Wrong_Hash.Elem2 -> 2
    compare _ _ = True

type Rational
    Fraction (numerator:Integer) (denominator:Integer)

Comparable.from (_ : Rational) = Rational_Ordering

type Rational_Ordering
    is_ordered = True

    compare r1 r2 =
        v1 = r1.numerator * r2.denominator
        v2 = r2.numerator * r1.denominator
        if v1 < v2 then Ordering.Less else
            if v1 > v2 then Ordering.Greater else
                Ordering.Equal

    hash _ = 42

main = Test_Suite.run_main spec
