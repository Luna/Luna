from Standard.Base import all

import Standard.Test

polyglot java import java.util.Random
polyglot java import java.lang.Long
polyglot java import java.lang.NumberFormatException

type My_Type foo

throw_a_bar = Error.throw "bar"
throw_a_bar_panicking = Panic.throw "bar"
throw_a_foo_panicking = Panic.throw "foo"

spec =
    Test.group "No Method Errors" <|
        Test.specify "should be recoverable" <|
            err_1 = Panic.recover (123 . foobar "baz") . catch e->e
            err_2 = Panic.recover ("foo" . baz 123) . catch e->e
            err_3 = Panic.recover (My_Type False . nope) . catch e->e

            err_1.target.should_equal 123
            err_1.method_name.should_equal "foobar"

            err_2.target.should_equal "foo"
            err_2.method_name.should_equal "baz"

            err_3.target.to_text.should_equal "(My_Type False)"
            err_3.method_name.should_equal "nope"

    Test.group "Dataflow Errors" <|

        Test.specify "should be able to be shown in the default visualization" <|
            json = (Error.throw <| My_Type "aaa").to_default_visualization_data
            json . should_equal <| (Json.from_pairs [["foo", "aaa"], ["type", "My_Type"]]).to_text

        Test.specify "should be able to be shown in the default vector visualization" <|
            vec = [My_Type "bar", Error.throw (My_Type 42)]
            visualization_text = vec.to_default_visualization_data
            expected_json = Json.parse '''
                [
                  { "foo":"bar",
                    "type":"My_Type"
                  },
                  { "content":{ "foo":42, "type":"My_Type" },
                    "message":"My_Type",
                    "type":"Error"
                  }
                ]
            visualization_text.should_equal expected_json.to_text

        Test.specify "should implement to_display_text" <|
            Error.throw Nothing . to_display_text . should_equal "Error: Nothing"

        Test.specify "should be able to be mapped" <|
            error = Error.throw 42
            regular = 10
            f x = 2*x
            (error.map_error f . catch).should_equal 84
            regular.map_error f . should_equal 10

        Test.specify "should allow to check if the value is an error" <|
            error = Error.throw 42
            regular = 10

            error.is_error . should_equal True
            regular.is_error . should_equal False

        Test.specify "should short-circuit polyglot evaluation" <|
            error = Error.throw 42
            Random.new error . should_fail_with Integer

        Test.specify "should allow to inspect the stack trace of a recovered panic" <|
            error = Panic.recover <| here.throw_a_bar_panicking
            error.catch . should_equal "bar"
            error.stack_trace.second.name . should_equal "Error_Spec.throw_a_bar_panicking"

    Test.group "Panics" <|
        Test.specify "should be able to be caught" <|
            result = Panic.catch (Panic.throw 42) caught_panic->
                caught_panic.payload+10
            result . should_equal 52

            result_2 = Panic.catch (1 + 2) caught_panic->
                caught_panic.payload+10
            result_2 . should_equal 3

        Test.specify "should not mix with dataflow errors" <|
            result = Panic.catch (Error.throw 42) caught_panic->
                caught_panic.payload+10
            result.catch . should_equal 42

        Test.specify "should provide access to stack traces" <|
            stack = Panic.catch here.throw_a_bar_panicking caught_panic->
                caught_panic.stack_trace
            stack.second.name . should_equal "Error_Spec.throw_a_bar_panicking"

        Test.specify "should be able to be rethrown without changing the stack trace" <|
            caught_panic = Panic.catch here.throw_a_bar_panicking x->x
            rethrow foo = Panic.throw foo
            rethrown_panic = Panic.catch (rethrow caught_panic) x->x
            (rethrown_panic.stack_trace.length > 0).should_be_true
            (rethrown_panic.stack_trace.map .name) . should_equal (caught_panic.stack_trace.map .name)

        Test.specify "should allow the pattern for handling selected exceptions" <|
            perform_operation ~action =
                Panic.catch action caught_panic->
                    if caught_panic.payload == "bar" then 42 else
                        Panic.throw caught_panic
            Panic.recover (perform_operation here.throw_a_bar_panicking) . should_equal 42

            error = Panic.recover (perform_operation here.throw_a_foo_panicking)
            error.catch . should_equal "foo"
            error.stack_trace.second.name . should_equal "Error_Spec.throw_a_foo_panicking"

        Test.specify "should work as in the examples" <|
            fun ~act =
                Panic.catch act caught_panic-> case caught_panic.payload of
                    Illegal_Argument_Error message _ -> "Illegal arguments were provided: "+message
                    other_panic -> Panic.throw other_panic
            Panic.recover (fun "bar") . should_equal "bar"
            Panic.recover (fun (Panic.throw "foo")) . catch . should_equal "foo"
            Panic.recover (fun (Panic.throw (Illegal_Argument_Error "msg" Nothing))) . should_equal "Illegal arguments were provided: msg"

        Test.specify "should allow catching Java exceptions easily" <|
            parse str =
                Panic.catch_java_exception (Long.parseLong str) NumberFormatException exception->
                    Error.throw (Illegal_Argument_Error "The provided string is not a valid number: "+exception.getMessage)

            parse "42" . should_equal 42
            parse "foo" . catch . should_equal (Illegal_Argument_Error 'The provided string is not a valid number: For input string: "foo"')
            Test.expect_panic_with (parse 0.0) Unsupported_Argument_Types

main = Test.Suite.run_main here.spec
