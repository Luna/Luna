from Standard.Base import all

import Standard.Base.Errors.Common.Forbidden_Operation
import Standard.Base.Errors.Common.Syntax_Error
import Standard.Base.Errors.Illegal_Argument.Illegal_Argument
import Standard.Base.Network.HTTP.Request_Body.Request_Body
import Standard.Base.Network.HTTP.Request_Error
import Standard.Base.Network.Proxy.Proxy
import Standard.Base.Runtime.Context

import Standard.Test.Extensions
from Standard.Test import Test, Test_Suite
from Standard.Test.Execution_Context_Helpers import run_with_and_without_output

polyglot java import java.lang.System as Java_System

type Test_Type
    Aaa (s:Text)
    Bbb (i:Integer)

type Bad_To_Json
    Aaa (s:Text)
    to_json self = JS_Object.from_pairs [Pair.new [] 0]

spec =
    # Set this to "https://httpbin.org" in your env to run this test
    base_url = Java_System.getenv "ENSO_HTTP_TEST_HTTPBIN_URL"
    pending_has_url = if base_url != Nothing then Nothing else
        "The HTTP tests only run when the `ENSO_HTTP_TEST_HTTPBIN_URL` environment variable is set to URL of the httpbin server"

    Test.group "asdfasdf" <|
        base_url_with_slash = if base_url.ends_with "/" then base_url else base_url + "/"
        url_get = base_url_with_slash + "get"

    Test.group "HTTP client" pending=pending_has_url <|
        Test.specify "should create HTTP client with timeout setting" <|
            http = HTTP.new (timeout = (Duration.new seconds=30))
            http.timeout.should_equal (Duration.new seconds=30)

        Test.specify "should create HTTP client with follow_redirects setting" <|
            http = HTTP.new (follow_redirects = False)
            http.follow_redirects.should_equal False

        Test.specify "should create HTTP client with proxy setting" <|
            proxy_setting = Proxy.Address "example.com" 80
            http = HTTP.new (proxy = proxy_setting)
            http.proxy.should_equal proxy_setting

        Test.specify "should create HTTP client with version setting" <|
            version_setting = HTTP_Version.HTTP_2
            http = HTTP.new (version = version_setting)
            http.version.should_equal version_setting

    Test.group "fetch" pending=pending_has_url <|
        base_url_with_slash = if base_url.ends_with "/" then base_url else base_url + "/"
        url_get = base_url_with_slash + "get"

        Test.specify "Can perform a GET with a JSON response" <|
            response = Data.fetch url_get
            response.at "headers" . at "Content-Length" . should_equal "0"

        Test.specify "Can perform a GET with a file response" <|
            f = enso_project.data / "spreadsheet.xls"
            f.delete_if_exists
            url = "https://enso-data-samples.s3.us-west-1.amazonaws.com/spreadsheet.xls"
            Data.fetch url . body . to_file f
            f.size . should_equal 7168
            f.delete
            f.exists.should_be_false

        Test.specify "Can skip auto-parse" <|
            response = Data.fetch url_get try_auto_parse_response=False
            response.code.code . should_equal 200
            response.body.bytes.length . should_equal 272

        Test.specify "Can perform a HEAD" <|
            # httpbin.org does not provide a HEAD endpoint, so we use GET
            response = Data.fetch url_get method=HTTP_Method.Head #try_auto_parse_response=False
            response.code.code . should_equal 200
            response.body.bytes.length . should_equal 0

        Test.specify "Can perform an OPTIONS" <|
            # httpbin.org does not provide an OPTIONS endpoint, so we use GET
            response = Data.fetch url_get method=HTTP_Method.Options
            response.code.code . should_equal 200
            response.body.bytes.length . should_equal 0

        Test.specify "Can still perform request when output context is disabled" <|
            run_with_and_without_output <|
                Data.fetch url_get try_auto_parse_response=False . code . code . should_equal 200
                Data.fetch url_get method=HTTP_Method.Head try_auto_parse_response=False . code . code . should_equal 200
                Data.fetch url_get method=HTTP_Method.Options try_auto_parse_response=False . code . code . should_equal 200

        Test.specify "Unsupported method" <|
            err = Data.fetch url_get method=HTTP_Method.Post
            err.catch.should_equal (Illegal_Argument.Error "Unsupported method Post")

        Test.specify "unknown host" <|
            Data.fetch "http://undefined_host.invalid" . should_fail_with Request_Error

        Test.specify "Fails on a bad URL scheme" <|
            Data.fetch "zxcv://bad.scheme" . should_fail_with Request_Error
            Data.fetch "" . should_fail_with Request_Error

    Test.group "post" pending=pending_has_url <|
        base_url_with_slash = if base_url.ends_with "/" then base_url else base_url + "/"
        url_post = base_url_with_slash + "post"
        url_put = base_url_with_slash + "put"
        url_patch = base_url_with_slash + "patch"
        url_delete = base_url_with_slash + "delete"

        Test.specify "Can perform a Request_Body.Text POST" <|
            response = Data.post url_post (Request_Body.Text "hello world")
            response.at "data" . should_equal "hello world"
            response.at "headers" . at "Content-Length" . should_equal "11"
            response.at "headers" . at "Content-Type" . should_equal "text/plain"

        Test.specify "Can perform a Request_Body.Json JSON POST" <|
            json = Json.parse '{"a": "asdf", "b": 123}'
            response = Data.post url_post (Request_Body.Json json)
            response.at "data" . should_equal '{"a":"asdf","b":123}'
            response.at "headers" . at "Content-Length" . should_equal "20"
            response.at "headers" . at "Content-Type" . should_equal "application/json"

        Test.specify "Can perform a JSON POST" <|
            json = Json.parse '{"a": "asdf", "b": 123}'
            response = Data.post url_post json
            response.at "data" . should_equal '{"a":"asdf","b":123}'
            response.at "headers" . at "Content-Length" . should_equal "20"
            response.at "headers" . at "Content-Type" . should_equal "application/json"

        Test.specify "Can perform an object Request_Body.Json POST" <|
            response = Data.post url_post (Request_Body.Json (Test_Type.Aaa "abc"))
            response.at "data" . should_equal '{"type":"Test_Type","constructor":"Aaa","s":"abc"}'
            response.at "headers" . at "Content-Length" . should_equal "50"
            response.at "headers" . at "Content-Type" . should_equal "application/json"

        Test.specify "Can perform an object JSON POST" <|
            response = Data.post url_post (Test_Type.Bbb 12)
            response.at "data" . should_equal '{"type":"Test_Type","constructor":"Bbb","i":12}'
            response.at "headers" . at "Content-Length" . should_equal "47"
            response.at "headers" . at "Content-Type" . should_equal "application/json"

        Test.specify "can handle a bad .to_json" <|
            Data.post url_post (Bad_To_Json.Aaa "abcd") . should_fail_with Illegal_Argument

        Test.specify "Can perform a Text POST with explicit encoding" <|
            body = Request_Body.Text 'Hello World!' encoding=Encoding.utf_16_le
            response = Data.post url_post body
            response.at "data" . should_equal 'H\u0000e\u0000l\u0000l\u0000o\u0000 \u0000W\u0000o\u0000r\u0000l\u0000d\u0000!\u0000'
            response.at "headers" . at "Content-Length" . should_equal "24"
            response.at "headers" . at "Content-Type" . should_equal "text/plain"
            response.at "headers" . at "Content-Encoding" . should_equal "UTF-16LE"

        Test.specify "Can perform a Text POST with explicit content type" <|
            response = Data.post url_post (Request_Body.Text 'a,b,c\n' content_type="text/csv")
            response.at "data" . should_equal 'a,b,c\n'
            response.at "headers" . at "Content-Length" . should_equal "6"
            response.at "headers" . at "Content-Type" . should_equal "text/csv"

        Test.specify "Can perform a File POST" <|
            test_file = enso_project.data / "sample.txt"
            response = Data.post url_post (Request_Body.Binary test_file)
            response.at "data" . should_equal test_file.read_text

        Test.specify "Can perform a binary File POST" <|
            test_file = enso_project.data / "sample.png"
            response = Data.post url_post (Request_Body.Binary test_file)
            response.at "data" . should_start_with 'data:application/octet-stream;base64,iVBORw0KGgoAAAANSUhEUgAAAJgAAACQCAYAAAD0'

        Test.specify "Can perform a url-encoded form POST" <|
            test_file = enso_project.data / "sample.txt"
            form_data = Map.from_vector [["key", "val"], ["a_file", test_file]]
            response = Data.post url_post (Request_Body.Form_Data form_data url_encoded=True)
            response.at "data" . should_start_with "key=val&a_file=Cupcake+ipsum+dolor+sit+amet.+Caramels+tootsie+roll"
            response.at "headers" . at "Content-Length" . should_equal "432"

        Test.specify "Can perform a multipart form POST" <|
            test_file = enso_project.data / "sample.png"
            form_data = Map.from_vector [["key", "val"], ["a_file", test_file]]
            response = Data.post url_post (Request_Body.Form_Data form_data)
            response.at "form" . at "key" . should_equal "val"
            response.at "files" . at "a_file" . should_start_with 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJgAAACQCAYAAAD0'
            response.at "headers" . at "Content-Type" . should_start_with "multipart/form-data"

        Test.specify "Can perform a File POST with auto-conversion" <|
            test_file = enso_project.data / "sample.txt"
            response = Data.post url_post test_file
            response.at "data" . should_equal test_file.read_text

        Test.specify "Can perform a Text POST with auto-conversion" <|
            response = Data.post url_post "hello world"
            response.at "data" . should_equal "hello world"
            response.at "headers" . at "Content-Length" . should_equal "11"
            response.at "headers" . at "Content-Type" . should_equal "text/plain"

        Test.specify "Can skip auto-parse" <|
            response = Data.post url_post (Request_Body.Text "hello world") try_auto_parse_response=False
            response.body.bytes.length . should_equal 417

        Test.specify "Can send a custom header" <|
            response = Data.post url_post (Request_Body.Text "hello world") headers=[Header.new "Custom" "asdf"]
            response.at "data" . should_equal "hello world"
            response.at "headers" . at "Content-Length" . should_equal "11"
            response.at "headers" . at "Content-Type" . should_equal "text/plain"
            response.at "headers" . at "Custom" . should_equal "asdf"

        Test.specify "Can perform a Request_Body.Text PUT" <|
            response = Data.post url_put (Request_Body.Text "hello world") method=HTTP_Method.Put
            response.at "data" . should_equal "hello world"
            response.at "headers" . at "Content-Length" . should_equal "11"
            response.at "headers" . at "Content-Type" . should_equal "text/plain"

        Test.specify "Can perform a Request_Body.Text PATCH" <|
            response = Data.post url_patch (Request_Body.Text "hello world") method=HTTP_Method.Patch headers=[Header.content_type "application/diff"]
            response.at "data" . should_equal "hello world"
            response.at "headers" . at "Content-Length" . should_equal "11"
            response.at "headers" . at "Content-Type" . should_equal "application/diff"

        Test.specify "Can perform a DELETE" <|
            response = Data.post url_delete Request_Body.Empty method=HTTP_Method.Delete #try_auto_parse_response=False
            response.at "headers" . at "Content-Length" . should_equal "0"

        Test.specify "Cannot perform request when output context is disabled" <|
            Context.Output.with_disabled <|
                Data.post url_post (Request_Body.Text "hello world") . should_fail_with Forbidden_Operation
                Data.post url_put (Request_Body.Text "hello world") method=HTTP_Method.Put . should_fail_with Forbidden_Operation
                Data.post url_patch (Request_Body.Text "hello world") method=HTTP_Method.Patch . should_fail_with Forbidden_Operation
                Data.post url_delete Request_Body.Empty method=HTTP_Method.Delete . should_fail_with Forbidden_Operation

        Test.specify "Unsupported method" <|
            err = Data.post url_post (Request_Body.Text "hello world") method=HTTP_Method.Get
            err.catch.should_equal (Illegal_Argument.Error "Unsupported method Get")

        Test.specify "unknown host" <|
            Data.post "http://undefined_host.invalid" (Request_Body.Text "hello world") . should_fail_with Request_Error

        Test.specify "Nonexistent file" <|
            test_file = enso_project.data / "does_not_exist.txt"
            Data.post url_post (Request_Body.Binary test_file) . should_fail_with Request_Error

main = Test_Suite.run_main spec
