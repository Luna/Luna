from Base import all
from Database import all
from Database.Connection.Connection import Sql_Error
import Test

spec connection =
    make_table name column_names column_typenames =
        # TODO this is a hack with no sanitization, just for testing; it should be removed when proper create table is supported by the library
        cols = column_names.zip column_typenames name-> typ->
            name + " " + typ
        sql = "CREATE TABLE " + name + " (" + (cols.join ", ") + ")"
        Panic.rethrow <| connection.execute_update sql
        Panic.rethrow <| connection.access_table name
    t1 = make_table "T1" ["A", "B", "C"] ["INT", "INT", "INT"]
    t1.insert [1, 2, 3]
    t1.insert [4, 5, 6]
    Test.group "Basic Table Access" <|
        Test.specify "should allow to materialize tables and columns into local memory" <|
            df = t1.to_dataframe
            a = t1.at 'A' . to_dataframe
            df.at 'A' . to_vector . should_equal [1, 4]
            a.to_vector . should_equal [1, 4]
        Test.specify "should allow to materialize columns directly into a Vector" <|
            v = t1.at 'A' . to_vector
            v . should_equal [1, 4]
        Test.specify "should preserve indexes when materializing tables"
            # TODO add multi indexes when implemented
            df = t1.set_index 'A' . to_dataframe
            df.at 'B' . to_vector . should_equal [2, 5]
            df.columns.map .name . should_equal ['B', 'C']
            ix = df.index
            ix.name . should_equal 'A'
            ix.to_vector . should_equal [1, 4]
        Test.specify "should preserve indexes when materializing columns"
            # TODO add multi indexes when implemented
            df = t1.set_index 'A' . at 'B' . to_dataframe
            df.to_vector . should_equal [2, 5]
            ix = df.index
            ix.name . should_equal 'A'
            ix.to_vector . should_equal [1, 4]

    Test.group "Mapping Operations" <|
        t2 = make_table "T2" ["x", "y", "b"] ["INT", "INT", "BOOLEAN"]
        t2.insert [1, 2, False, "foobar",  "foo"]
        t2.insert [4, 3, False, "barcode", "e"  ]
        t2.insert [5, 5, True,  "var",     "a"  ]
        t2.insert [Nothing, Nothing, Nothing, Nothing]
        x = t2.at "x"
        y = t2.at "y"
        b = t2.at "b"
        Test.specify "should allow combining columns with supported operations" <|
            (x + y).to_vector . should_equal [3, 7, 10, Nothing]
            (x - y).to_vector . should_equal [-1, 1, 0, Nothing]
            (x * y).to_vector . should_equal [2, 12, 25, Nothing]
            (x / y).to_vector . should_equal [0, 1, 1, Nothing]
            (x == y).to_vector . should_equal [False, False, True, Nothing]
            (x != y).to_vector . should_equal [True, True, False, Nothing]
            (x < y).to_vector . should_equal [True, False, False, Nothing]
            (x <= y).to_vector . should_equal [True, False, True, Nothing]
            (x > y).to_vector . should_equal (x <= y).not.to_vector
            (x >= y).to_vector . should_equal (x < y).not.to_vector
            (((x < y) || (x == y)) == (x <= y)).to_vector . should_equal [True, True, True, Nothing]
            (b || b.not).to_vector . should_equal [True, True, True, Nothing]

        Test.specify "should allow casting constants to be applied to the whole column" <|
            (x + 100).to_vector . should_equal [101, 104, 105, Nothing]
            (x * 10).to_vector . should_equal [10, 40, 50, Nothing]
            (x / 2).to_vector . should_equal [0, 2, 2, Nothing]
            (x - 10).to_vector . should_equal [-9, -6, -5, Nothing]
            (x == 4).to_vector . should_equal [False, True, False, Nothing]
            (x < 1000).to_vector . should_equal [True, True, True, Nothing]
            (b || False).to_vector . should_equal [False, False, True, Nothing]
            (b || True).to_vector . should_equal [True, True, True, True]
            (b && False).to_vector . should_equal [False, False, False, False]
            (x + Nothing).to_vector . should_equal [Nothing, Nothing, Nothing, Nothing]
            x.is_missing.to_vector . should_equal [False, False, False, True]
            (x == Nothing).to_vector . should_equal [Nothing, Nothing, Nothing, Nothing]

        t3 = make_table "T3" ["s1", "s2"] ["VARCHAR", "VARCHAR"]
        t3.insert ["foobar",  "foo"]
        t3.insert ["bar",     "ar" ]
        t3.insert ["baz",     "a"  ]
        t3.insert [Nothing, Nothing]
        s1 = t3.at "s1"
        s2 = t3.at "s2"
        Test.specify "should handle Text operations" <|
            s1.starts_with s2 . to_vector . should_equal [True, False, False, Nothing]
            s1.starts_with "foo" . to_vector . should_equal [True, False, False, Nothing]
            s1.starts_with "ba" . to_vector . should_equal [False, True, True, Nothing]
            s1.starts_with Nothing . to_vector . should_equal [Nothing, Nothing, Nothing, Nothing]

            s1.contains s2 . to_vector . should_equal [True, True, True, Nothing]
            s1.contains "a" . to_vector . should_equal [True, True, True, Nothing]
            s1.contains "oo" . to_vector . should_equal [True, False, False, Nothing]
            s1.contains Nothing . to_vector . should_equal [Nothing, Nothing, Nothing, Nothing]

            s1.ends_with s2 . to_vector . should_equal [False, True, False, Nothing]
            s1.ends_with "ar" . to_vector . should_equal [True, True, False, Nothing]
            s1.ends_with "a" . to_vector . should_equal [False, False, False, Nothing]
            s1.ends_with Nothing . to_vector . should_equal [Nothing, Nothing, Nothing, Nothing]

sqlite_specific_spec connection =
    Test.group "Error Handling" <|
        Test.specify "should wrap errors" <|
            connection.execute_query "foobar" . should_fail_with Sql_Error
            connection.execute_update "foobar" . should_fail_with Sql_Error

            action = connection.execute_query "SELECT A FROM undefined_table"
            action . should_fail_with Sql_Error
            action.catch.to_text . should_equal "[SQLITE_ERROR] SQL error or missing database (no such table: undefined_table)"

sqlite_spec =
    file = File.new "target/sqlite_test.db"
    file.delete_if_exists
    connection = Database.open_sqlite_file file
    here.spec connection
    here.sqlite_specific_spec connection
    file.delete

postgres_spec =
    # TODO use env vars to read tmp DB config
    IO.println "PostgreSQL test database is not configured, skipping."
    Nothing
