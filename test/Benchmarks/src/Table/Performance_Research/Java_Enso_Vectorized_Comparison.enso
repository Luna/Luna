## NOTE
   This benchmark assumes that the Table operations used here are implemented in Java.
   This is a valid assumption as of 2023-07-12.
   If we ever change these operations, we would need to add this benchmark to have custom implementations for the Java side as well if we still want to use it for comparisons.

   This file is _not_ automatically run when the benchmarks are run.
from Standard.Base import all
from Standard.Table import all

from Standard.Test import Bench

polyglot java import org.enso.table.data.column.builder.BoolBuilder
polyglot java import org.enso.table.data.column.builder.NumericBuilder
polyglot java import org.enso.table.data.column.builder.StringBuilder

## This tests an operation on a boxed value (e.g. ends_with on a String).
   It is the basic benchmark for comparing the performance between the vectorized Java op and approaches relying on Enso.
   We would like to see the Enso approach to have comparable performance to the Java one.
type Boxed_Map_Test
    Instance text_column (suffix : Text)

    java_map self =
        self.text_column.ends_with self.suffix

    enso_map_as_vector self =
        suffix = self.suffix
        vector_proxy = self.text_column.to_vector
        mapped = vector_proxy.map x-> x.ends_with suffix
        new_column = Column.from_vector "result" mapped
        new_column

    enso_map_with_builder self =
        suffix = self.suffix
        n = self.text_column.length
        builder = BoolBuilder.new n
        storage = self.text_column.java_column.getStorage
        0.up_to n . each i->
            item = storage.getItemBoxed i
            case item of
                Nothing ->
                    builder.appendNulls 1
                _ ->
                    b = item.ends_with suffix
                    builder.appendBoolean b
        Column.from_storage "result" builder.seal

## This tests an operation on a primitive value, that in Java is stored as unboxed (e.g. + on LongStorage).
   This is a more demanding benchmark, because the Java side has an advantage of easily using the unboxed values everywhere.
   Here it may be harder to achieve comparable performance, but we want to know what is the difference, and ideally we want to be getting closer here as well.
type Primitive_Map_Test
    Instance int_column (shift : Integer)

    java_map self =
        self.int_column + self.shift

    enso_map_as_vector self =
        shift = self.shift
        vector_proxy = self.int_column.to_vector
        mapped = vector_proxy.map x-> x + shift
        new_column = Column.from_vector "result" mapped
        new_column

    enso_map_with_builder self =
        shift = self.shift
        n = self.int_column.length
        builder = NumericBuilder.createLongBuilder n
        storage = self.int_column.java_column.getStorage
        0.up_to n . each i->
            case storage.isNa i of
                True ->
                    builder.appendNulls 1
                False ->
                    item = storage.getItem i
                    x = item + shift
                    builder.appendLong x
        Column.from_storage "result" builder.seal

# Adding two String columns
type Boxed_Bi_Map_Test
    Instance text_column_1 text_column_2

    java_map self =
        self.text_column_1 + self.text_column_2

    enso_map_as_vector self =
        vector_proxy_1 = self.text_column_1.to_vector
        vector_proxy_2 = self.text_column_2.to_vector
        mapped = vector_proxy_1.zip vector_proxy_2 (+)
        new_column = Column.from_vector "result" mapped
        new_column

    enso_map_with_builder self =
        n = self.text_column_1.length
        if self.text_column_2.length != n then Panic.throw "LENGTH MISMATCH" else
            builder = StringBuilder.new n
            storage_1 = self.text_column_1.java_column.getStorage
            storage_2 = self.text_column_2.java_column.getStorage
            0.up_to n . each i->
                item_1 = storage_1.getItemBoxed i
                item_2 = storage_2.getItemBoxed i
                if item_1.is_nothing || item_2.is_nothing then builder.appendNulls 1 else
                    res = item_1 + item_2
                    builder.append res
            Column.from_storage "result" builder.seal

# Adding two Long columns
type Primitive_Bi_Map_Test
    Instance int_column_1 int_column_2

    java_map self =
        self.int_column_1 + self.int_column_2

    enso_map_as_vector self =
        vector_proxy_1 = self.int_column_1.to_vector
        vector_proxy_2 = self.int_column_2.to_vector
        mapped = vector_proxy_1.zip vector_proxy_2 (+)
        new_column = Column.from_vector "result" mapped
        new_column

    enso_map_with_builder self =
        n = self.int_column_1.length
        if self.int_column_2.length != n then Panic.throw "LENGTH MISMATCH" else
            builder = NumericBuilder.createLongBuilder n
            storage_1 = self.int_column_1.java_column.getStorage
            storage_2 = self.int_column_2.java_column.getStorage
            0.up_to n . each i->
                if storage_1.isNa i || storage_2.isNa i then builder.appendNulls 1 else
                    item_1 = storage_1.getItem i
                    item_2 = storage_2.getItem i
                    res = item_1 + item_2
                    builder.appendLong res
            Column.from_storage "result" builder.seal

## Computes the Longest text in the column - aggregate with no grouping.
   This is of interest, because in contrast to all benchmarks above, it can generally be done in O(1) memory.
type Boxed_Total_Aggregate
    Instance text_column

    java_aggregate self =
        self.text_column.to_table.aggregate [Aggregate_Column.Longest 0] . at 0 . at 0

    enso_aggregate_vector_proxy self =
        n = self.text_column.length
        vector_proxy = self.text_column.to_vector
        (0.up_to n).fold Nothing acc-> ix->
            item = vector_proxy.at ix
            if acc.is_nothing then item else
                if item.is_nothing then acc else
                    if item.length > acc.length then item else acc

    enso_aggregate_storage_get_item self =
        n = self.text_column.length
        storage = self.text_column.java_column.getStorage
        (0.up_to n).fold Nothing acc-> ix->
            item = storage.getItemBoxed ix
            if acc.is_nothing then item else
                if item.is_nothing then acc else
                    if item.length > acc.length then item else acc

## Computes Sum of integers.
   We have to be careful with `n` because if we use too large values Enso will start using BigInts, while Java will overflow.
type Primitive_Total_Aggregate
    Instance int_column

    java_aggregate self =
        self.int_column.to_table.aggregate [Aggregate_Column.Sum 0] . at 0 . at 0

    enso_aggregate_vector_proxy self =
        n = self.int_column.length
        vector_proxy = self.int_column.to_vector
        (0.up_to n).fold 0 acc-> ix->
            item = vector_proxy.at ix
            if item.is_nothing then acc else
                acc + item

    enso_aggregate_storage_get_item self =
        n = self.int_column.length
        storage = self.int_column.java_column.getStorage
        (0.up_to n).fold 0 acc-> ix->
            if storage.isNa ix then acc else
                acc + storage.getItem ix

main =
    n = 10^6
    v1 = (0.up_to n).to_vector
    v2 = (0.up_to n).to_vector.reverse.map (x-> x % 20)
    t = Table.new [["ints", v1], ["text", v1.map .to_text], ["ints2", v2], ["text2", v2.map .to_text]]

    iter_size = 1
    num_iterations = 50

    primitive_bimap = Primitive_Bi_Map_Test.Instance (t.at "ints") (t.at "ints2")
    Bench.measure (primitive_bimap.java_map) "Primitive_Bi_Map_Test.java_map" iter_size num_iterations run_gc_between_iterations=True
    Bench.measure (primitive_bimap.enso_map_as_vector) "Primitive_Bi_Map_Test.enso_map_as_vector" iter_size num_iterations run_gc_between_iterations=True
    Bench.measure (primitive_bimap.enso_map_with_builder) "Primitive_Bi_Map_Test.enso_map_with_builder" iter_size num_iterations run_gc_between_iterations=True

    boxed_bimap = Boxed_Bi_Map_Test.Instance (t.at "text") (t.at "text2")
    Bench.measure (boxed_bimap.java_map) "Boxed_Bi_Map_Test.java_map" iter_size num_iterations run_gc_between_iterations=True
    Bench.measure (boxed_bimap.enso_map_as_vector) "Boxed_Bi_Map_Test.enso_map_as_vector" iter_size num_iterations run_gc_between_iterations=True
    Bench.measure (boxed_bimap.enso_map_with_builder) "Boxed_Bi_Map_Test.enso_map_with_builder" iter_size num_iterations run_gc_between_iterations=True

    # Using ints2 to get smaller values to avoid integer overflow.
    primitive_total_aggregate = Primitive_Total_Aggregate.Instance (t.at "ints2")
    # GC not needed here as this should be O(1) memory.
    Bench.measure (primitive_total_aggregate.java_aggregate) "Primitive_Total_Aggregate.java_aggregate" iter_size num_iterations run_gc_between_iterations=False
    Bench.measure (primitive_total_aggregate.enso_aggregate_vector_proxy) "Primitive_Total_Aggregate.enso_aggregate_vector_proxy" iter_size num_iterations run_gc_between_iterations=False
    Bench.measure (primitive_total_aggregate.enso_aggregate_storage_get_item) "Primitive_Total_Aggregate.enso_aggregate_storage_get_item" iter_size num_iterations run_gc_between_iterations=False

    boxed_total_aggregate = Boxed_Total_Aggregate.Instance (t.at "text")
    Bench.measure (boxed_total_aggregate.java_aggregate) "Boxed_Total_Aggregate.java_aggregate" iter_size num_iterations run_gc_between_iterations=False
    Bench.measure (boxed_total_aggregate.enso_aggregate_vector_proxy) "Boxed_Total_Aggregate.enso_aggregate_vector_proxy" iter_size num_iterations run_gc_between_iterations=False
    Bench.measure (boxed_total_aggregate.enso_aggregate_storage_get_item) "Boxed_Total_Aggregate.enso_aggregate_storage_get_item" iter_size num_iterations run_gc_between_iterations=False

    primitive_map = Primitive_Map_Test.Instance (t.at "ints") 42
    Bench.measure (primitive_map.java_map) "Primitive_Map_Test.java_map" iter_size num_iterations run_gc_between_iterations=True
    Bench.measure (primitive_map.enso_map_as_vector) "Primitive_Map_Test.enso_map_as_vector" iter_size num_iterations run_gc_between_iterations=True
    Bench.measure (primitive_map.enso_map_with_builder) "Primitive_Map_Test.enso_map_with_builder" iter_size num_iterations run_gc_between_iterations=True

    # This one seems slowest so I put it at the end.
    boxed_map = Boxed_Map_Test.Instance (t.at "text") "5"
    Bench.measure (boxed_map.java_map) "Boxed_Map_Test.java_map" iter_size num_iterations run_gc_between_iterations=True
    Bench.measure (boxed_map.enso_map_as_vector) "Boxed_Map_Test.enso_map_as_vector" iter_size num_iterations run_gc_between_iterations=True
    Bench.measure (boxed_map.enso_map_with_builder) "Boxed_Map_Test.enso_map_with_builder" iter_size num_iterations run_gc_between_iterations=True
