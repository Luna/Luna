from Standard.Base import all

from Standard.Table import Value_Type

from Standard.Test import Test, Problems
import Standard.Test.Extensions

from project.Common_Table_Operations.Util import run_default_backend

main = run_default_backend spec

spec setup =
    prefix = setup.prefix
    table_builder = setup.table_builder

    Test.group prefix+"Date-Time support" pending=(if setup.test_selection.date_time.not then "Date/Time operations are not supported by this backend.") <|
        Test.specify "should allow to create Table with Date columns and round-trip them back to Enso" <|
            d = Date.new 2020 10 24
            table = table_builder [["A", [d]], ["X", [123]]]
            table.at "A" . value_type . should_equal Value_Type.Date
            table.at "A" . to_vector . should_equal [d]
            table.at "X" . to_vector . should_equal [123]

        Test.specify "should allow to create Table with Time Of Day columns and round-trip them back to Enso" <|
            # We do not check nanoseconds, as nano support may be optional.
            t = Time_Of_Day.new hour=12 minute=3 second=5 millisecond=6 microsecond=7
            table = table_builder [["B", [t]], ["X", [123]]]
            table.at "B" . value_type . should_equal Value_Type.Time
            table.at "B" . to_vector . should_equal [t]
            table.at "X" . to_vector . should_equal [123]

        Test.specify "should allow to create Table with Date Time columns and round-trip them back to Enso, preserving the exact instant in time (even if losing the timezone)" <|
            dt1 = Date_Time.new 2020 10 24 12 34 56 millisecond=789
            offset_zone = Time_Zone.new hours=(-11) minutes=(-30)
            dt2 = Date_Time.new 2021 11 23 1 2 3 zone=offset_zone
            named_zone = Time_Zone.parse "US/Hawaii"
            dt3 = Date_Time.new 2019 11 23 4 5 6 zone=named_zone

            to_utc dt = dt.at_zone Time_Zone.utc
            dates = [dt1, dt2, dt3]
            xs = [1, 2, 3]
            table = table_builder [["C", dates], ["X", xs]]
            table.print
            table.at "C" . value_type . should_equal Value_Type.Date_Time
            ## We compare the timestamps converted to UTC.
               This ensures that the value we are getting back represents the
               exact same instant in time as the one we put in.

               We cannot guarantee that time time _zone_ itself will be the same
               - for example Postgres stores all timestamps in UTC, regardless
               of what timezone they were in at input.
            table.at "C" . to_vector . map to_utc . should_equal (dates.map to_utc)
            table.at "X" . to_vector . should_equal xs
