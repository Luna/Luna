from Standard.Base import all

import Standard.Table.Data.Join_Condition.Join_Condition
import Standard.Table.Data.Join_Kind.Join_Kind
from Standard.Table.Errors import all

from Standard.Test import Test, Problems
import Standard.Test.Extensions

from project.Common_Table_Operations.Util import expect_column_names, run_default_backend

main = run_default_backend spec

spec setup =
    prefix = setup.prefix
    table_builder = setup.table_builder
    join_pending = if prefix.contains "In-Memory" then Nothing else "New Joining API is not supported by the database backends yet."
    Test.group prefix+"Table.join" pending=join_pending <|
        t1 = table_builder [["X", [1, 2, 3]], ["Y", [4, 5, 6]]]
        t2 = table_builder [["Z", [2, 3, 2, 4]], ["W", [4, 5, 6, 7]]]
        Test.specify "should allow to inner join on equality of a the first column by default" <|

            t3 = t1.join t2
            expect_column_names ["X", "Y", "Z", "W"] t3
            t4 = t3.order_by ["X", "W"] # TODO materialize for DB
            t4.at "X" . to_vector . should_equal [2, 2, 3]
            t4.at "Z" . to_vector . should_equal [2, 2, 3]
            t4.at "Y" . to_vector . should_equal [5, 5, 6]
            t4.at "W" . to_vector . should_equal [4, 6, 5]

        Test.specify "should allow to perform all kinds of joins" <|
            t3 = t1.join t2 join_kind=Join_Kind.Full . order_by ["X", "W"]
            expect_column_names ["X", "Y", "Z", "W"] t3
            t3.at "X" . to_vector . should_equal [Nothing, 1, 2, 2, 3]
            t3.at "Y" . to_vector . should_equal [Nothing, 4, 5, 5, 6]
            t3.at "Z" . to_vector . should_equal [4, Nothing, 2, 2, 3]
            t3.at "W" . to_vector . should_equal [7, Nothing, 4, 6, 5]

            t4 = t1.join t2 join_kind=Join_Kind.Left_Outer . order_by ["X", "W"]
            expect_column_names ["X", "Y", "Z", "W"] t4
            t4.at "X" . to_vector . should_equal [1, 2, 2, 3]
            t4.at "Y" . to_vector . should_equal [4, 5, 5, 6]
            t4.at "Z" . to_vector . should_equal [Nothing, 2, 2, 3]
            t4.at "W" . to_vector . should_equal [Nothing, 4, 6, 5]

            t5 = t1.join t2 join_kind=Join_Kind.Right_Outer . order_by ["X", "W"]
            expect_column_names ["X", "Y", "Z", "W"] t5
            t5.at "X" . to_vector . should_equal [Nothing, 2, 2, 3]
            t5.at "Y" . to_vector . should_equal [Nothing, 5, 5, 6]
            t5.at "Z" . to_vector . should_equal [4, 2, 2, 3]
            t5.at "W" . to_vector . should_equal [7, 4, 6, 5]

        Test.specify "should allow to perform anti-joins" <|
            t6 = t1.join t2 join_kind=Join_Kind.Left_Exclusive . order_by ["X"]
            t6.columns.map .name . should_equal ["X", "Y"]
            t6.at "X" . to_vector . should_equal [1]
            t6.at "Y" . to_vector . should_equal [4]

            t7 = t1.join t2 join_kind=Join_Kind.Right_Exclusive . order_by ["Z"]
            t7.columns.map .name . should_equal ["Z", "W"]
            t7.at "Z" . to_vector . should_equal [4]
            t7.at "W" . to_vector . should_equal [7]

        t3 = table_builder [["X", [1, 1, 1, 2, 2, 2]], ["Y", ["A", "B", "B", "C", "C", "A"]], ["Z", [1, 2, 3, 4, 5, 6]]]
        t4 = table_builder [["X", [1, 1, 3, 2, 2, 4]], ["Y", ["B", "B", "C", "C", "D", "A"]], ["Z", [1, 2, 3, 4, 5, 6]]]
        check_xy_joined r =
            # TODO later we'll want `Right_Z` instead of `Z_1`
            expect_column_names ["X", "Y", "Z", "Z_1"] r
            r.at "X" . to_vector . should_equal [1, 1, 1, 1, 2, 2]
            r.at "Y" . to_vector . should_equal ["B", "B", "B", "B", "C", "C"]
            r.at "Z" . to_vector . should_equal [2, 2, 3, 3, 4, 5]
            r.at "Z_1" . to_vector . should_equal [1, 2, 1, 2, 4, 4]

        Test.specify "should allow to join on equality of multiple columns and drop redundant columns" <|
            conditions = [Join_Condition.Equals "Y" "Y", Join_Condition.Equals "X" "X"]
            r = t3.join t4 on=conditions . order_by ["X", "Y", "Z", "Z_1"]
            check_xy_joined r

        Test.specify "should support same-name column join shorthand" <|
            r = t3.join t4 on=["X", "Y"] . order_by ["X", "Y", "Z", "Z_1"]
            check_xy_joined r

        Test.specify "should work fine if the same condition is specified multiple times" <|
            # TODO check other conditions than equality too
            r = t3.join t4 on=["X", "X", "Y", "X", "Y"] . order_by ["X", "Y", "Z", "Z_1"]
            check_xy_joined r

        Test.specify "should allow to join on text equality ignoring case" <|
            t1 = table_builder [["X", ["a", "B"]], ["Y", [1, 2]]]
            t2 = table_builder [["X", ["A", "a", "b"]], ["Z", [1, 2, 3]]]

            r1 = t1.join t2
            expect_column_names ["X", "Y", "Z"] r1
            r1 . at "X" . to_vector . should_equal ["a"]
            r1 . at "Y" . to_vector . should_equal [1]
            r1 . at "Z" . to_vector . should_equal [2]

            r2 = t1.join t2 on=(Join_Condition.Equals_Ignore_Case "X" "X") . order_by ["Z"]
            # TODO rename to Right_X
            expect_column_names ["X", "Y", "X_1", "Z"] r2
            r2 . at "X" . to_vector . should_equal ["a", "a", "B"]
            r2 . at "X_1" . to_vector . should_equal ["A", "a", "b"]
            r2 . at "Y" . to_vector . should_equal [1, 1, 2]
            r2 . at "Z" . to_vector . should_equal [1, 2, 3]

        if setup.test_selection.supports_unicode_normalization then
            Test.specify "should correctly handle Unicode equality" <|
                t1 = table_builder [["X", ['s\u0301', 'S\u0301']], ["Y", [1, 2]]]
                t2 = table_builder [["X", ['s', 'S', 'ś']], ["Z", [1, 2, 3]]]

                r1 = t1.join t2
                expect_column_names ["X", "Y", "Z"] r1
                r1 . at "X" . to_vector . should_equal ['ś']
                r1 . at "Y" . to_vector . should_equal [1]
                r1 . at "Z" . to_vector . should_equal [3]

                r2 = t1.join t2 on=(Join_Condition.Equals_Ignore_Case "X" "X") . order_by ["Y"]
                # TODO rename to Right_X
                expect_column_names ["X", "Y", "X_1", "Z"] r2
                r2 . at "X" . to_vector . should_equal ['s\u0301', 'S\u0301']
                r2 . at "X_1" . to_vector . should_equal ['ś', 'ś']
                r2 . at "Y" . to_vector . should_equal [1, 2]
                r2 . at "Z" . to_vector . should_equal [3, 3]

        # This may need a test_selection toggle in the future, depending on how well databases like coercing decimals and integers.
        Test.specify "should correctly handle Enso Decimal-Integer equality" <|
            t1 = table_builder [["X", [1, 2]], ["Y", [10, 20]]]
            t2 = table_builder [["X", [2.0, 2.1, 0.0]], ["Z", [1, 2, 3]]]

            r1 = t1.join t2
            expect_column_names ["X", "Y", "Z"] r1
            r1 . at "X" . to_vector . should_equal [2]
            r1 . at "Y" . to_vector . should_equal [20]
            r1 . at "Z" . to_vector . should_equal [1]

        Test.specify "should allow range-based joins (using between) for numbers" <|
            t1 = table_builder [["X", [1, 10, 12]], ["Y", [1, 2, 3]]]
            t2 = table_builder [["lower", [1, 10, 8, 12]], ["upper", [1, 12, 30, 0]], ["Z", [1, 2, 3, 4]]]

            t1.join t2 on=(Join_Condition.Between "X" "lower" "upper")
            r1 = t1.join t2 . order_by ["X", "Z"]
            expect_column_names ["X", "Y", "lower", "upper", "Z"] r1
            r1 . at "X" . to_vector . should_equal     [1, 10, 10, 12, 12]
            r1 . at "Y" . to_vector . should_equal     [1, 2,  2,  3,  3]
            r1 . at "lower" . to_vector . should_equal [1, 10, 8,  10, 8]
            r1 . at "upper" . to_vector . should_equal [1, 12, 30, 12, 30]
            r1 . at "Z" . to_vector . should_equal     [1, 2,  3,  2,  3]

        Test.specify "should allow to mix join conditions of various kinds" <|
            Nothing

        Test.specify "should gracefully handle unmatched columns in Join_Conditions" <|
            t1 = table_builder [["X", [1, 2]], ["Y", [3, 4]]]
            t2 = table_builder [["Z", [2, 1]], ["W", [5, 6]]]

            conditions = [Join_Condition.Equals "foo" 42, Join_Condition.Equals "X" -3, Join_Condition.Equals -1 "baz"]

            action = t1.join t2 on=conditions on_problems=_
            tester table =
                expect_column_names ["X", "Y", "Z", "W"] table
                table.row_count . should_equal 0
                table.at "X" . to_vector . should_equal []
            problems = [Column_Indexes_Out_Of_Range.Error [42, -3], Missing_Input_Columns.Error ["foo", "baz"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should report Invalid_Value_Type if non-text columns are provided to Equals_Ignore_Case" <|
            t1 = table_builder ["X", ["1", "2", "c"], ["Y", [1, 2, 3]]]
            t2 = table_builder ["Z", ["1", "2", "c"], ["W", [1, 2, 3]]]

            expected_string err =
                err.should_fail_with Invalid_Value_Type.Error
                err.catch . should_equal (Invalid_Value_Type.Error Value_Type.Char Value_Type.Integer)

            expected_string <|
                t1.join t2 on=(Join_Condition.Equals_Ignore_Case "X" "W")
            expected_string <|
                t1.join t2 on=(Join_Condition.Equals_Ignore_Case "Y" "Z")

        Test.specify "should report Invalid_Value_Type if non-numeric columns are provided to Between" <|
            t1 = table_builder ["X", ["1", "2", "c"], ["Y", [1, 2, 3]]]
            t2 = table_builder ["Z", ["1", "2", "c"], ["W", [1, 2, 3]]]

            expected_numeric err =
                err.should_fail_with Invalid_Value_Type.Error
                # TODO Integer, Decimal?? both are OK really
                err.catch . should_equal (Invalid_Value_Type.Error Value_Type.Char Value_Type.Integer)

            expected_numeric <|
                t1.join t2 on=(Join_Condition.Between "X" "W" "W")
            expected_numeric <|
                t1.join t2 on=(Join_Condition.Between "X" "Z" "Z")
            expected_numeric <|
                t1.join t2 on=(Join_Condition.Between "Y" "W" "Z")
            expected_numeric <|
                t1.join t2 on=(Join_Condition.Between "Y" "Z" "W")

        Test.specify "should report Invalid_Value_Type if incompatible types are correlated" pending="We need more advanced value type support to implement this in full-generality." <|
            t1 = table_builder ["X", ["1", "2", "c"]]
            t2 = table_builder ["Y", [1, 2, 3]]

            r1 = t1.join t2 on=conditions on_problems=Problem_Behavior.Ignore
            expect_column_names ["X", "Y"] r1
            r1.row_count . should_equal 0

            r2 = t1.join t2 on=conditions on_problems=Problem_Behavior.Report_Error
            r2.should_fail_with Invalid_Value_Type.Error

        Test.specify "should warn when joining on equality of Decimal columns" <|
            t1 = table_builder [["X", [1.5, 2.0, 2.00000000001]], ["Y", [10, 20, 30]]]
            t2 = table_builder [["Z", [2.0, 1.5, 2.0]], ["W", [1, 2, 3]]]

            action1 = t1.join t2 on=(Join_Condition.Equals "X" "Z") on_problems=_
            tester1 table =
                expect_column_names ["X", "Y", "Z", "W"] table
                # TODO
            problems1 = []
            Problems.test_problem_handling action1 problems1 tester1

            action2 = t1.join t2 on=(Join_Condition.Equals "X" "W") on_problems=_
            tester1 table =
                expect_column_names ["X", "Y", "Z", "W"] table
                # TODO
            problems1 = []
            Problems.test_problem_handling action1 problems1 tester1

        Test.specify "should correctly handle nulls in equality conditions" <|
            Nothing

        Test.specify "should correctly handle nulls in case-insensitive equality conditions" <|
            Nothing

        Test.specify "should correctly handle nulls in between conditions" <|
            Nothing

        Test.specify "should rename columns of the right table to avoid duplicates" <|
            t1 = table_builder [["X", [1, 2]], ["Y", [3, 4]]]
            t2 = table_builder [["X", [2, 1]], ["Y", [2, 2]]]

            # TODO this should be Right_X, Right_Y instead of X_1, Y_1 once implemented properly
            t3 = t1.join t2 on=(Join_Condition.Equals "X" "Y") . order_by ["X_1"]
            expect_column_names ["X", "Y", "X_1", "Y_1"] t3
            t3.at "X" . to_vector . should_equal [2, 2]
            t3.at "Y_1" . to_vector . should_equal [2, 2]
            t3.at "Y" . to_vector . should_equal [4, 4]
            t3.at "X_1" . to_vector . should_equal [1, 2]

            t4 = table_builder [["Right_X", [1, 1]], ["X", [1, 2]], ["Y", [3, 4]], ["Right_Y_2", [2, 2]]]
            t5 = table_builder [["Right_X", [2, 1]], ["X", [2, 2]], ["Y", [2, 2]], ["Right_Y", [2, 2]], ["Right_Y_1", [2, 2]], ["Right_Y_4", [2, 2]]]

            t6 = t4.join t5 on=(Join_Condition.Equals "X" "Y")
            # TODO specify how we really want to handle collisions, this is just a temporary solution
            expect_column_names ["Right_X", "X", "Y", "Right_Y_2"]+["Right_X_1", "X_1", "Y_1", "Right_Y", "Right_Y_1", "Right_Y_4"] t6
            # Possible solutions:
            # All existing ones have precedence over renamed ones (regardless of ordering)
            # expect_column_names ["Right_X", "X", "Y", "Right_Y_2"]+["Right_Right_X", "Right_X_1", "Right_Y", "Right_Y_1", "Right_Y_3", "Right_Y_4"] t6
            # Renames happen in the order of appearance of columns
            # expect_column_names ["Right_X", "X", "Y", "Right_Y_2"]+["Right_Right_X", "Right_X_1", "Right_Y", "Right_Y_1", "Right_Y_1_1", "Right_Y_4"] t6
