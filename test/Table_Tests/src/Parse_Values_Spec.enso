from Standard.Base import all
from Standard.Table import all

from Standard.Table.Data.Table as Table_Internal import Empty_Error

import Standard.Base.Data.Time.Date
import Standard.Test
import Standard.Test.Problems
import Standard.Visualization

from Standard.Table.Data.Data_Formatter as Data_Formatter_Module import Data_Formatter
from Standard.Table.Data.Column_Type_Selection as Column_Type_Selection_Module import Column_Type_Selection

from Standard.Table.Error as Table_Errors import Invalid_Format, Leading_Zeros, Missing_Input_Columns, Column_Indexes_Out_Of_Range, Duplicate_Type_Selector

spec = Test.group "Table.parse_values" <|
    Test.specify "should correctly parse integers" <|
        t1 = Table.new [["ints", ["0", "+0", "-0", "+1", "-1", "1", "000", "0010", "12345", Nothing]]]
        t2 = t1.parse_values column_types=[Column_Type_Selection 0 Integer]
        t2.at "ints" . to_vector . should_equal [0, 0, 0, 1, -1, 1, Nothing, Nothing, 12345, Nothing]

    Test.specify "should correctly parse decimals" <|
        t1 = Table.new [["ints", ["0", "+0", "-0", "+1", "-1", "1", "12345", Nothing]]]
        t2 = t1.parse_values column_types=[Column_Type_Selection 0 Decimal]
        t2.at "ints" . to_vector . should_equal [0, 0, 0, 1, -1, 1, 12345, Nothing]
        t2.at "ints" . to_vector . map .to_text . should_equal ["0.0", "0.0", "-0.0", "1.0", "-1.0", "1.0", "12345.0", "Nothing"]

        t3 = Table.new [["floats", ["0.0", "+0.0", "-0.0", "+1.0", "-1.0", "1.0", "0.0000", "10.", "12345."]]]
        t4 = t3.parse_values column_types=[Column_Type_Selection 0 Decimal]
        t4.at "floats" . to_vector . should_equal [0, 0, 0, 1, -1, 1, 0, 10, 12345]

        t5 = Table.new [["floats", [".0", "0.", "1.", ".1", ".123", "-.1", "+.1", "+0.0", "0.1234", Nothing, "11111111.111"]]]
        t6 = t5.parse_values column_types=[Column_Type_Selection 0 Decimal]
        t6.at "floats" . to_vector . should_equal [0.0, 0.0, 1.0, 0.1, 0.123, -0.1, 0.1, 0.0, 0.1234, Nothing, 11111111.111]

    Test.specify "should warn on leading zeros in numbers, if asked" <|
        t1 = Table.new [["ints", ["0", "+00", "-00", "+01", "-01", "01", "000", "0010", "12345", Nothing]]]
        t2 = Table.new [["floats", ["0.0000", ".0", "00.", "01.0", "-0010.0000", "1.0000"]]]

        t1_parsed = [0, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, 12345, Nothing]
        t1_zeros = ["+00", "-00", "+01", "-01", "01", "000", "0010"]
        t3 = t1.parse_values column_types=[Column_Type_Selection 0 Integer]
        t3.at "ints" . to_vector . should_equal t1_parsed
        Warning.get_all t3 . map .value . should_equal [Leading_Zeros "ints" Integer t1_zeros]
        
        t4 = t1.parse_values column_types=[Column_Type_Selection 0 Decimal]
        t4.at "ints" . to_vector . should_equal t1_parsed
        Warning.get_all t4 . map .value . should_equal [Leading_Zeros "ints" Decimal t1_zeros]

        t5 = t2.parse_values column_types=[Column_Type_Selection 0 Decimal]
        t5.at "floats" . to_vector . should_equal [0.0, 0.0, Nothing, Nothing, Nothing, 1.0]
        Warning.get_all t5 . map .value . should_equal [Leading_Zeros "floats" Decimal ["00.", "01.0", '-0010.0000']]

        opts = Data_Formatter allow_leading_zeros=True
        t1_parsed_zeros = [0, 0, 0, 1, -1, 1, 0, 10, 12345, Nothing]
        t6 = t1.parse_values parser=opts column_types=[Column_Type_Selection 0 Integer]
        t6.at "ints" . to_vector . should_equal t1_parsed_zeros
        Warning.get_all t6 . should_equal []

        t7 = t1.parse_values parser=opts column_types=[Column_Type_Selection 0 Decimal]
        t7.at "ints" . to_vector . should_equal t1_parsed_zeros
        Warning.get_all t7 . should_equal []
        t8 = t2.parse_values parser=opts column_types=[Column_Type_Selection 0 Decimal]
        t8.at "floats" . to_vector . should_equal [0.0, 0.0, 0.0, 1.0, -10.0, 1.0]
        Warning.get_all t8 . should_equal []

    Test.specify "should correctly parse booleans" <|
        t1 = Table.new [["bools", ["true", "false", "True", "TRUE", "FALSE", Nothing, "False"]]]
        t2 = t1.parse_values column_types=[Column_Type_Selection 0 Boolean]
        t2.at "bools" . to_vector . should_equal [True, False, True, True, False, Nothing, False]

    Test.specify "should warn when cells do not fit the expected format" <|
        ints = ["ints", ["0", "1", "1.0", "foobar", "", "--1", "+-1", "10", "-+1"]]
        # Currently scientific notation is not supported and we document that in this test, in the future the situation may change and the test may need to be flipped.
        floats = ["floats", ["0", "2.0", "1e6", "foobar", "", "--1", "+-1", "100.", "-+1"]]
        bools = ["bools", ["True", "false", "fAlSE", "foobar", "", "0", "1", "true", "truefalse"]]
        t = Table.new [ints, floats, bools]

        action pb =
            t.parse_values column_types=[Column_Type_Selection 0 Integer, Column_Type_Selection "floats" Decimal, Column_Type_Selection "bools"  Boolean] on_problems=pb
        tester t =
            t.at "ints" . to_vector . should_equal [0, 1, Nothing, Nothing, Nothing, Nothing, Nothing, 10, Nothing]
            t.at "floats" . to_vector . should_equal [0, 2, Nothing, Nothing, Nothing, Nothing, Nothing, 100, Nothing]
            t.at "bools" . to_vector . should_equal [True, False, Nothing, Nothing, Nothing, Nothing, Nothing, True, Nothing]
        problems =
            ints = Invalid_Format "ints" Integer ["1.0", "foobar", "", "--1", "+-1", "-+1"]
            floats = Invalid_Format "floats" Decimal ["1e6", "foobar", "", "--1", "+-1", "-+1"]
            bools = Invalid_Format "bools" Boolean ["fAlSE", "foobar", "", "0", "1", "truefalse"]
            [ints, floats, bools]
        Problems.test_problem_handling action problems tester

    Test.specify "should leave not selected columns unaffected" <|
        t1 = Table.new [["A", ["1", "2"]], ["B", ["3", "4"]]]
        t2 = t1.parse_values column_types=[Column_Type_Selection "B" Integer]
        t2.at "A" . to_vector . should_equal ["1", "2"]
        t2.at "B" . to_vector . should_equal [3, 4]

    Test.specify "should report missing columns in Column_Type_Selection" <|
        t = Table.new [["floats", ["1.0"]], ["ints", ["1"]], ["bools", ["True"]]]
        action pb =
            t.parse_values column_types=[Column_Type_Selection -1 Boolean, Column_Type_Selection "floats" Decimal, Column_Type_Selection "bars" Boolean, Column_Type_Selection "foos" Boolean, Column_Type_Selection 100 Boolean, Column_Type_Selection -100 Boolean] on_problems=pb
        tester t =
            t.at "floats" . to_vector . should_equal [1.0]
            t.at "ints" . to_vector . should_equal ["1"]
            t.at "bools" . to_vector . should_equal [True]
        problems = [Missing_Input_Columns ["bars", "foos"], Column_Indexes_Out_Of_Range [100, -100]]
        Problems.test_problem_handling action problems tester

    Test.specify "should report duplicate columns in Column_Type_Selection" <|
        t = Table.new [["floats", ["1.0"]], ["ints", ["1"]], ["bools", ["True"]], ["foo", ["42"]]]
        action pb =
            t.parse_values column_types=[Column_Type_Selection -2 Boolean, Column_Type_Selection "bools" Boolean, Column_Type_Selection "floats" Decimal, Column_Type_Selection "floats" Integer, Column_Type_Selection "ints" Integer] on_problems=pb
        tester t =
            t.at "floats" . to_vector . should_equal ["1.0"]
            t.at "ints" . to_vector . should_equal [1]
            t.at "bools" . to_vector . should_equal [True]
            t.at "foo" . to_vector . should_equal ["42"]
        problems = [(Duplicate_Type_Selector "floats" ambiguous=True), (Duplicate_Type_Selector "bools" ambiguous=False)]
        Problems.test_problem_handling action problems tester

    Test.specify "should correctly parse date and time" pending="TODO" <|
        Error.throw "TODO"

    Test.specify "should guess the datatype for columns" pending="TODO" <|
        # TODO (next PR): ints, decimals, int+dec, just text, all dates, mixed dates, ints+text, ints in quotes
        Error.throw "TODO"

    Test.specify "should allow to specify a thousands separator and a custom decimal point" <|
        opts = Data_Formatter decimal_point=',' thousand_separator='_'
        t1 = Table.new [["floats", ["0,0", "+0,0", "-0,0", "+1,5", "-1,2", "1,0", "0,0000", "10_000,", ",0"]]]
        t2 = t1.parse_values opts column_types=[Column_Type_Selection 0 Decimal]
        t2.at "floats" . to_vector . should_equal [0.0, 0.0, 0.0, 1.5, -1.2, 1.0, 0.0, 10000.0, 0.0]

        t3 = Table.new [["xs", ["1,2", "1.2", "_0", "0_", "1_0_0"]]]
        t4 = t3.parse_values opts column_types=[Column_Type_Selection 0 Decimal]
        t4.at "xs" . to_vector . should_equal [1.2, Nothing, Nothing, Nothing, 100.0]
        Warning.get_all t4 . map .value . should_equal [Invalid_Format "xs" Decimal ["1.2", "_0", "0_"]]
        t5 = t3.parse_values opts column_types=[Column_Type_Selection 0 Integer]
        t5.at "xs" . to_vector . should_equal [Nothing, Nothing, Nothing, Nothing, 100.0]
        Warning.get_all t5 . map .value . should_equal [Invalid_Format "xs" Integer ["1,2", "1.2", "_0", "0_"]]

    Test.specify "should allow to specify custom values for booleans" <|
        opts_1 = Data_Formatter true_values=["1", "YES"] false_values=["0"]
        t1 = Table.new [["bools", ["1", "0", "YES", "1", "0"]]]
        t2 = t1.parse_values opts_1 column_types=[Column_Type_Selection 0 Boolean]
        t2.at "bools" . to_vector . should_equal [True, False, True, True, False]

        t3 = Table.new [["bools", ["1", "NO", "False", "True", "YES", "no", "oui", "0"]]]
        t4 = t3.parse_values opts_1 column_types=[Column_Type_Selection 0 Boolean]
        t4.at "bools" . to_vector . should_equal [True, Nothing, Nothing, Nothing, True, Nothing, Nothing, False]
        Warning.get_all t4 . map .value . should_equal [Invalid_Format "bools" Boolean ["NO", "False", "True", "no", "oui"]]

    whitespace_table =
        ints = ["ints", ["0", "1 ", "0 1", " 2"]]
        floats = ["floats", ["0 ", " 2.0", "- 1", "10.0"]]
        bools = ["bools", ["True ", " false", "t rue", "False"]]
        Table.new [ints, floats, bools]

    Test.specify "should trim input values by default" <|
        # TODO add other types too
        t1 = whitespace_table.parse_values column_types=[Column_Type_Selection 0 Integer, Column_Type_Selection "floats" Decimal, Column_Type_Selection "bools"  Boolean]
        t1.at "ints" . to_vector . should_equal [0, 1, Nothing, 2]
        t1.at "floats" . to_vector . should_equal [0.0, 2.0, Nothing, 10.0]
        t1.at "bools" . to_vector . should_equal [True, False, Nothing, False]
        warnings = Warning.get_all t1 . map .value
        warnings.should_contain_the_same_elements_as [Invalid_Format "ints" Integer ["0 1"], Invalid_Format "floats" Decimal ["- 1"], Invalid_Format "bools" Boolean ["t rue"]]

    Test.specify "should fail to parse if whitespace is present and trimming is turned off" <|
        opts = Data_Formatter trim_values=False
        t1 = whitespace_table.parse_values opts column_types=[Column_Type_Selection 0 Integer, Column_Type_Selection "floats" Decimal, Column_Type_Selection "bools"  Boolean]
        t1.at "ints" . to_vector . should_equal [0, Nothing, Nothing, Nothing]
        t1.at "floats" . to_vector . should_equal [Nothing, Nothing, Nothing, 10.0]
        t1.at "bools" . to_vector . should_equal [Nothing, Nothing, Nothing, False]
        warnings = Warning.get_all t1 . map .value
        warnings.should_contain_the_same_elements_as [Invalid_Format "ints" Integer ["1 ", "0 1", " 2"], Invalid_Format "floats" Decimal ["0 ", " 2.0", "- 1"], Invalid_Format "bools" Boolean ["True ", " false", "t rue"]]

    Test.specify "should fallback to text if whitespace is present and trimming is turned off" pending="TODO" <|
        ## TODO next PR
        Error.throw "TODO"

main = Test.Suite.run_main here.spec
