from Standard.Base import all
from Standard.Test import all
import Standard.Base.Errors.Common.Type_Error
import Standard.Base.Errors.Common.No_Such_Method

import project.Data.Complex.Complex

type A
    a = "a"
type B
    B v

    b = "b"

type C
    C v

    c = "c"

B.from (that:A) = B.B that
C.from (that:B) = C.C that

type X
    x = "x"

X.from (_:A) = X

add_specs suite_builder =
    suite_builder.group "Complex Multi Value" group_builder->
        group_builder.specify "Cannot convert to Float if it has imaginary part" <|
            c = Complex.new 1 5
            Test.expect_panic Type_Error (c:Float)
        group_builder.specify "Represents both Complex & Float with only real part" <|
            c = Complex.new 1.5 0.0
            (c:Complex).re . should_equal 1.5
            (c:Float) . should_equal 1.5

    suite_builder.group "Chain Multi Value" group_builder->
        to_b_to_c obj =
            b = obj : B
            c = b : C
            c

        group_builder.specify "Multiple conversions of A work" <|
            a = A
            a_text = to_b_to_c a
            a_text . to_text . should_equal "(C (B A))"

        group_builder.specify "Multiple conversions of A & X work" <|
            ax = A:A&X
            a_text = to_b_to_c ax
            a_text . to_text . should_equal "(C (B A & X))"

        group_builder.specify "Multiple conversions of A & X work" <|
            xa = A:X&A
            a_text = to_b_to_c xa
            a_text . to_text . should_equal "(C (B A & X))"

        group_builder.specify "Multiple conversions of (A & X : A) work" <|
            ax = A:A&X
            a = ax : A
            a_text = to_b_to_c a
            a_text . to_text . should_equal "(C (B A & X))"

        group_builder.specify "Multiple conversions of X fail" <|
            x = X

            # has to fail as X cannot be converted to B in to_b_to_c
            Test.expect_panic Type_Error <|
                to_b_to_c x

        group_builder.specify "Multiple conversions of (A & X : X) work" <|
            ax = A:A&X

            ax.a . should_equal "a"
            ax.x . should_equal "x"

            x = ax : X

            x.x . should_equal "x"
            Test.expect_panic No_Such_Method <|
                # method of A isn't visible for direct dispatch
                x.a

            # but the object can be converted to A and then
            # method a is available
            (x:A).a . should_equal "a"

            # multivalue ax restricted to X cannot be converted to B in to_b_to_c
            Test.expect_panic Type_Error <|
                to_b_to_c x

main filter=Nothing =
    suite = Test.build suite_builder->
        add_specs suite_builder
    suite.run_with_filter filter
