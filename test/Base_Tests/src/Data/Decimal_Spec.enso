from Standard.Base import all
import Standard.Base.Errors.Common.Arithmetic_Error
import Standard.Base.Errors.Common.Incomparable_Values
import Standard.Base.Errors.Common.Type_Error
import Standard.Base.Errors.Illegal_Argument.Illegal_Argument

from Standard.Base.Data.Numbers import Number_Parse_Error
from Standard.Base.Errors.Common import Loss_Of_Numeric_Precision

from Standard.Test import all

Decimal.should_have_rep self rep = self.get_internal_representation . should_equal rep

add_specs suite_builder =
    suite_builder.group "construction" group_builder->
        group_builder.specify "should be able to construct a Decimal from a string" <|
            Decimal.new "123.45" . should_have_rep [12345, 5, 2]
            Decimal.from_text "123.45" . should_have_rep [12345, 5, 2]

        group_builder.specify "should throw Number_Parse_Error on a badly-formatted string" <|
            Decimal.new "ee" . should_fail_with Number_Parse_Error
            Decimal.new "--123.3.3" . should_fail_with Number_Parse_Error

        group_builder.specify "should be able to construct a Decimal from a string, with an explicit precision, using the default rounding" <|
            mc = Math_Context.new 4
            Decimal.new "123.45" mc . should_have_rep [1235, 4, 1]
            Decimal.new "123.45" mc . should_equal (Decimal.new "123.5")

        group_builder.specify "should be able to construct a Decimal from a string, with an explicit precision, using a non-default rounding" <|
            mc = Math_Context.new 4 Rounding_Mode.half_down
            Decimal.new "123.45" mc . should_have_rep [1234, 4, 1]
            Decimal.new "123.45" mc . should_equal (Decimal.new "123.4")

        group_builder.specify "should be able to construct a Decimal from a long string" <|
            Decimal.new "495782984723948723947239938732974241.2345" . should_have_rep [4957829847239487239472399387329742412345, 40, 4]
            Decimal.from_text "495782984723948723947239938732974241.2345" . should_have_rep [4957829847239487239472399387329742412345, 40, 4]

        group_builder.specify "should be able to construct a Decimal from a small integer" <|
            Decimal.new 1234500 . should_have_rep [1234500, 7, 0]

        group_builder.specify "should be able to construct a Decimal from a small integer, with an explicit precision, using the default rounding" <|
            mc = Math_Context.new 4
            Decimal.new 1234500 mc . should_have_rep [1235, 4, -3]
            Decimal.new 1234500 mc . should_equal (Decimal.new 1235000)

        group_builder.specify "should be able to construct a Decimal from a small integer, with an explicit precision, using the non-default rounding" <|
            mc = Math_Context.new 4 Rounding_Mode.half_down
            Decimal.new 1234500 mc . should_have_rep [1234, 4, -3]
            Decimal.new 1234500 mc . should_equal (Decimal.new 1234000)

        group_builder.specify "should be able to construct a Decimal from a large integer" <|
            Decimal.new 495782984723948723947239938732974241234500 . should_have_rep [495782984723948723947239938732974241234500 , 42, 0]

        group_builder.specify "should be able to construct a Decimal from a large integer, with an explicit precision, using the default rounding" <|
            mc = Math_Context.new 39
            Decimal.new 495782984723948723947239938732974241234500 mc . should_have_rep [495782984723948723947239938732974241235 , 39, -3]
            Decimal.new 495782984723948723947239938732974241234500 mc . should_equal (Decimal.new 495782984723948723947239938732974241235000 )

        group_builder.specify "should be able to construct a Decimal from a large integer, with an explicit precision, using the non-default rounding" <|
            mc = Math_Context.new 39 Rounding_Mode.half_down
            Decimal.new 495782984723948723947239938732974241234500 mc . should_have_rep [495782984723948723947239938732974241234 , 39, -3]
            Decimal.new 495782984723948723947239938732974241234500 mc . should_equal (Decimal.new 495782984723948723947239938732974241234000 )

        group_builder.specify "should be able to construct a Decimal from a float" <|
            d = Decimal.from_float 123.45
            d.should_have_rep [12345, 5, 2]

        group_builder.specify "should be able to construct a Decimal from a float, with an explicit precision, using the default rounding" <|
            mc = Math_Context.new 5
            d = Decimal.from_float 123.125 mc
            d.should_have_rep [12313, 5, 2]
            d.should_equal (Decimal.new "123.13")

        group_builder.specify "should be able to construct a Decimal from a float, with an explicit precision, using a non-default rounding" <|
            mc = Math_Context.new 5 Rounding_Mode.half_down
            d = Decimal.from_float 123.125 mc
            d.should_have_rep [12312, 5, 2]
            d.should_equal (Decimal.new "123.12")

        group_builder.specify "should report precision loss accurately" <|
            mc4 = Math_Context.new 4
            mc5 = Math_Context.new 5

            Problems.not_expect_warning (Decimal.new "123.25")
            Problems.expect_warning Loss_Of_Numeric_Precision (Decimal.new "123.25" mc4)
            Problems.not_expect_warning Loss_Of_Numeric_Precision (Decimal.new "123.25" mc5)

            Problems.not_expect_warning (Decimal.new 123.25)
            Problems.expect_warning Loss_Of_Numeric_Precision (Decimal.new 123.25 mc4)
            Problems.not_expect_warning Loss_Of_Numeric_Precision (Decimal.new 123.25 mc5)

            Problems.not_expect_warning (Decimal.new 12325)
            Problems.expect_warning Loss_Of_Numeric_Precision (Decimal.new 12325 mc4)
            Problems.not_expect_warning Loss_Of_Numeric_Precision (Decimal.new 12325 mc5)

        group_builder.specify "should throw Illegal_Argument for NaN/Inf" <|
            Decimal.new Number.nan . should_fail_with Illegal_Argument
            Decimal.new Number.positive_infinity . should_fail_with Illegal_Argument
            Decimal.new Number.negative_infinity . should_fail_with Illegal_Argument

        group_builder.specify "should be convertible via .from" <|
            Decimal.from "123.45" . should_equal (Decimal.new "123.45")
            Decimal.from "123.45" . should_equal (Decimal.from_text "123.45")
            Decimal.from 123.45 . should_equal (Decimal.new 123.45)
            Decimal.from 123.45 . should_equal (Decimal.from_float 123.45)
            Decimal.from 12345 . should_equal (Decimal.new 12345)
            Decimal.from 12345 . should_equal (Decimal.from_integer 12345)

        group_builder.specify "should compare correctly" <|
            nums = [["-45.23", "124.872"], [-45.23, 124.872], [-45, 124]]
            nums.map pr->
                a = Decimal.new (pr.at 0)
                b = Decimal.new (pr.at 1)

                (a == a) . should_be_true
                (b == b) . should_be_true
                (a == b) . should_be_false
                (b == a) . should_be_false

                (a != a) . should_be_false
                (b != b) . should_be_false
                (a != b) . should_be_true
                (b != a) . should_be_true

                (a <= a) . should_be_true
                (b <= b) . should_be_true
                (a <= b) . should_be_true
                (b <= a) . should_be_false

                (a >= a) . should_be_true
                (b >= b) . should_be_true
                (a >= b) . should_be_false
                (b >= a) . should_be_true

                (a < b) . should_be_true
                (b > a) . should_be_true
                (a > b) . should_be_false
                (b < a) . should_be_false

                (a <= b) . should_be_true
                (b >= a) . should_be_true
                (a >= b) . should_be_false
                (b <= a) . should_be_false

                (a < a) . should_be_false
                (b < b) . should_be_false
                (a > a) . should_be_false
                (b > b) . should_be_false

                Decimal.new (pr.at 0) . should_equal (Decimal.new (pr.at 0))
                Decimal.new (pr.at 1) . should_equal (Decimal.new (pr.at 1))

                a . should_equal a
                b . should_equal b
                a . should_not_equal b
                b . should_not_equal a

        group_builder.specify "should compare correctly, even with different internal representations" <|
            a = Decimal.new "12000"
            b = Decimal.new "12000" (Math_Context.new 2)
            c = Decimal.new "12000" (Math_Context.new 3)
            [[a, b], [a, c], [b, c]].map pr->
                x0 = pr.at 0
                x1 = pr.at 1
                ir0 = x0.get_internal_representation
                ir1 = x1.get_internal_representation
                # TODO: specialization error if we sipmly say (ir0 != ir1)
                ([0, 1, 2].all i-> ((ir0.at i) == (ir1.at i))) . should_be_false

                (x0 == x1) . should_be_true
                (x1 == x0) . should_be_true
                (x0 != x1) . should_be_false
                (x1 != x0) . should_be_false

    suite_builder.group "arithmetic" group_builder->
        group_builder.specify "should add Decimals correctly" <|
            d0 = Decimal.new "12.345"
            d1 = Decimal.new "-40"
            q = (d0 + d1) == -27.655
            #(d0 + d1) . should_equal -27.655

main =
    suite = Test.build suite_builder->
        add_specs suite_builder
    suite.run_with_filter
