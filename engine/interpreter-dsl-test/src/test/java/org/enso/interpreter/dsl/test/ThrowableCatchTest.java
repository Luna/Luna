package org.enso.interpreter.dsl.test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

import java.io.ByteArrayOutputStream;
import java.nio.file.Paths;
import java.util.List;
import java.util.function.Supplier;
import org.enso.interpreter.EnsoLanguage;
import org.enso.interpreter.runtime.EnsoContext;
import org.enso.interpreter.runtime.callable.function.Function;
import org.enso.interpreter.runtime.error.DataflowError;
import org.enso.interpreter.runtime.error.PanicException;
import org.enso.polyglot.LanguageInfo;
import org.enso.polyglot.MethodNames.TopScope;
import org.enso.polyglot.RuntimeOptions;
import org.graalvm.polyglot.Context;
import org.graalvm.polyglot.io.IOAccess;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

/**
 * All exceptions thrown from methods from classes generated by {@link
 * org.enso.interpreter.dsl.MethodProcessor} should be converted either to a dataflow error or to a
 * {@link org.enso.interpreter.runtime.error.PanicException panic}.
 */
public class ThrowableCatchTest {
  static List<Supplier<Throwable>> exceptionSuppliers =
      List.of(
          () -> new RuntimeException("First exception"),
          () -> new AssertionError("Assertion error"),
          () -> new IllegalStateException("Illegal state"),
          CustomException::new,
          CustomError::new);

  private Context ctx;
  private EnsoContext ensoCtx;

  private static class CustomException extends Exception {}

  private static class CustomError extends Error {}

  @Before
  public void setup() {
    ctx = Context.newBuilder()
        .allowExperimentalOptions(true)
        .allowIO(IOAccess.ALL)
        .allowAllAccess(true)
        .logHandler(new ByteArrayOutputStream())
        .option(RuntimeOptions.STRICT_ERRORS, "true")
        .option(
            RuntimeOptions.LANGUAGE_HOME_OVERRIDE,
            Paths.get("../../distribution/component").toFile().getAbsolutePath())
        .build();
    ensoCtx = ctx.getBindings(LanguageInfo.ID).invokeMember(TopScope.LEAK_CONTEXT).asHostObject();
    ctx.initialize(LanguageInfo.ID);
    ctx.enter();
  }

  @After
  public void tearDown() {
    ctx.leave();
    ctx.close();
  }

  @Test
  public void testNoThrowableLeaksFromBuiltinMethods() {
    var func = ThrowBuiltinMethodGen.makeFunction(EnsoLanguage.get(null));
    var funcCallTarget = func.getCallTarget();
    var emptyState = ensoCtx.emptyState();
    for (long exceptionSupplierIdx = 0;
        exceptionSupplierIdx < exceptionSuppliers.size();
        exceptionSupplierIdx++) {
      Object self = null;
      Object[] args =
          Function.ArgumentsHelper.buildArguments(
              func, null, emptyState, new Object[] {self, exceptionSupplierIdx});
      try {
        funcCallTarget.call(args);
      } catch (Throwable t) {
        String expectedExceptionMessage = exceptionSuppliers.get((int) exceptionSupplierIdx).get().getMessage();
        if (t instanceof PanicException panic) {
          assertEquals(expectedExceptionMessage, panic.getMessage());
        } else if (t instanceof DataflowError dataflowError) {
          assertEquals(expectedExceptionMessage, dataflowError.getMessage());
        } else {
          fail("Should throw only PanicException or DataflowError: " + t.getMessage());
        }
      }
    }
  }
}
