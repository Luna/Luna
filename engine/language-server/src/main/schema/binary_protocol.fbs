namespace org.enso.languageserver.protocol.binary;

//A mapping between payload enum and inbound payload types.
union InboundPayload {
  INIT_SESSION_CMD: InitSessionCommand,
  WRITE_FILE_CMD: WriteFileCommand,
  READ_FILE_CMD: ReadFileCommand
}

//An envelope for inbound requests and commands.
table InboundMessage {

  //A unique id of the message sent to the server.
  messageId: EnsoUUID (required);

  //An optional correlation id used to correlate a response with a request.
  correlationId: EnsoUUID;

  //A message payload that carries requests sent by a client.
  payload: InboundPayload (required);

}

//A mapping between payload enum and outbound payload types.
union OutboundPayload {
  ERROR: Error,
  SUCCESS: Success,
  VISUALISATION_UPDATE: VisualisationUpdate,
  FILE_CONTENTS_REPLY: FileContentsReply,
  SUGGESTIONS_DATABASE_UPDATE: SuggestionsDatabaseUpdate
}

//An envelope for outbound responses.
table OutboundMessage {

  //A unique id of the message sent from the server.
  messageId: EnsoUUID (required);

  //An optional correlation id used to correlate a response with a request.
  correlationId: EnsoUUID;

  //A message payload that carries responses and notifications sent by a server
  payload: OutboundPayload (required);

}

//A binary representation of universally unique identifiers.
struct EnsoUUID {

  //The most significant bits of the UUID.
  leastSigBits:uint64;

  //The most significant bits of the UUID.
  mostSigBits:uint64;

}

//This message type is used to indicate failure of some operation performed.
table Error {

  //A unique error code identifying error type.
  code: int;

  //An error message.
  message: string;

}

//Indicates an operation has succeeded.
table Success {}

//A command initializing a data session.
table InitSessionCommand {

  //A unique identifier of a client initializing the session.
  identifier: EnsoUUID (required);

}

root_type InitSessionCommand;

//A visualisation context identifying a concrete visualisation.
table VisualisationContext {

  //A visualisation identifier.
  visualisationId: EnsoUUID (required);

  //A context identifier.
  contextId: EnsoUUID (required);

  //An expression identifier.
  expressionId: EnsoUUID (required);

}

//An event signaling visualisation update.
table VisualisationUpdate {

  //A visualisation context identifying a concrete visualisation.
  visualisationContext: VisualisationContext (required);

  //A visualisation data.
  data: [ubyte] (required);

}

//A representation of a path relative to a specified content root.
table Path {

  //a content root id that the path is relative to
  rootId: EnsoUUID;

  //path segments
  segments: [string];

}

//A command writing binary contents to a file.
table WriteFileCommand {

  //A path to a file.
  path: Path;

  //Binary contents.
  contents: [ubyte];

}

//A command reading binary contents from a file.
table ReadFileCommand {

  //A path to a file.
  path: Path;

}

//A reply for a ReadFileCommand.
table FileContentsReply {

  //Binary contents.
  contents: [ubyte];

}

// The definition scope
struct SuggestionEntryScope {

  // The start of the definition scope
  start: uint16;

  // The end of the definition scope
  end: uint16;
}

// The argument of an atom, method or function suggestion
table SuggestionEntryArgument {
  // The argument name
  name: string (required);
  // The arguement type. String 'Any' is used to specify genric types
  type: string (required);
  // Indicates whether the argument is lazy (required)
  isSuspended: bool;
  // Indicates whether the argument has default value (required)
  hasDefault: bool;
  // Optional default value
  defaultValue: string;
}

// A type of suggestion entries.
union SuggestionEntry {
  // A value constructor
  SuggestionEntryAtom,
  // A method defined on a type
  SuggestionEntryMethod,
  // A function
  SuggestionEntryFunction,
  // A local value
  SuggestionEntryLocal
}

table SuggestionEntryAtom {
  name: string (required);
  arguments: [SuggestionEntryArgument] (required);
  returnType: string (required);
  documentation: string;
}

table SuggestionEntryMethod {
  name: string (required);
  arguments: [SuggestionEntryArgument] (required);
  selfType: string (required);
  returnType: string (required);
  documentation: string;
}

table SuggestionEntryFunction {
  name: string (required);
  arguments: [SuggestionEntryArgument] (required);
  returnType: string (required);
  scope: SuggestionEntryScope (required);
}

table SuggestionEntryLocal {
  name: string (required);
  returnType: string (required);
  scope: SuggestionEntryScope (required);
}

// The kind of the suggestions database update.
enum SuggestionsDatabaseUpdateKind : byte { Add, Update, Delete }

table SuggestionsDatabaseUpdate {
  // suggestion entry id (required)
  id: int64;
  kind: SuggestionsDatabaseUpdateKind;
  name: string;
  arguments: [SuggestionEntryArgument];
  selfType: string;
  returnType: string;
  documentation: string;
  scope: SuggestionEntryScope;
}

//todo Split up the schema once Rust bugs will be resolved.
