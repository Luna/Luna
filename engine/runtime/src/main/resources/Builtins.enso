# NOTE TO DEVELOPERS
# ==================
# When adding a new builtin it is very important that you also define the stub
# for that builtin in this file. If that is not done, it will fail to resolve
# properly at runtime.

## Booleans.
type Boolean

    ## A type with only two possible values.

       The boolean type represents the two truth values of boolean logic. It is
       primarily used for control-flow.
    @Builtin_Type
    type Boolean

    ## The constructor for the value `True`.
    @Builtin_Type
    type True

    ## The constructor for the value `False`.
    @Builtin_Type
    type False

    ## Compares two booleans for equality.

       Arguments:
       - `that`: The boolean to compare `this` with.

       > Example
         Comparing `True` to `False` to get `False`.
             True == False
    == : Boolean -> Boolean
    == that = @Builtin_Method "Boolean.=="

    ## Computes the logical and (conjunction) of two booleans.

       Arguments:
       - `that`: The boolean to compute the conjunction of `this` with.

       ? Short Circuiting
         This method is not implemented in a short-circuiting manner. This means
         that even if `this` is `False`, it will also evaluate `that`. This is
         for performance.

       > Example
         Computing the conjunction of `False` and `True` (to get `False`).
             `False` && `True`
    && : Boolean -> Boolean
    && ~that = @Builtin_Method "Boolean.&&"

    ## Computes the logical or (disjunction) of two booleans.

       Arguments:
       - `that`: The boolean to compute the disjunction of `this` with.

       ? Short Circuiting
         This methid is not implemented in a short-circuiting manner. This means
         that even if `this` is `True`, it will also evaluate `that`. This is
         for performance.

       > Example
         Computing the disjunction of `True` and `False` (to get `True`).
             `True` || `False`
    || : Boolean -> Boolean
    || ~that = @Builtin_Method "Boolean.||"

    ## Computes the logical negation of `this`.

       > Example
         Negating `True` to get `False`
             True.not
    not : Boolean
    not = @Builtin_Method "Boolean.not"

    ## Generates a human-readable text representation of the boolean.

       > Example
         Converting the value `True` to text.
             True.to_text
    to_text : Text
    to_text = @Builtin_Method "Boolean.to_text"

    ## The if-then-else control flow operator that executes one of two branches
       based on a conditional.

       Arguments:
       - `on_true`: The computation to evaluate if `this` evaluates to `True`.
       - `on_false`: The computation to evaluate if `this` evaluates to `False`.

       Both of the arguments to this method are _lazy_, meaning that they will
       only be evaluated if they are needed (based on the condition).

       > Example
         Telling the user if a number 27 is divisible by three.
             if (27 % 3) == 0 then IO.println "Yes" else IO.println "No"
    if_then_else : Any -> Any -> Any
    if_then_else ~on_true ~on_false = @Builtin_Method "Boolean.if_then_else"

    ## The if-then control flow operator that executes a branch if the condition
       is true, and otherwise returns `Nothing`.

       Arguments:
       - `on_true`: The computation to evaluate if `this` evaluates to `True`.

       The argument to this method is _lazy_, meaning that it will only be
       evaluated if the `this` evaluates to `True`.

       > Example
         Printing a message to the user only if a number is divisible by three.
             if (27 % 3) == 0 then IO.println "Fizz"
    if_then : Any -> Any | Nothing
    if_then ~on_true = @Builtin_Method "Boolean.if_then"

## Debug utilities.
type Debug

    ## A type on which debugging functionality is exposed.
    @Builtin_Type
    type Debug

    ## Places a breakpoint in the program's execution, dropping the user into an
       interactive debugging REPL.

       From the REPL, the user is able to manipulate both the program state and
       its execution in an interactive fashion.

       > Example
         Dropping into a debugging REPL during execution.
            Debug.breakpoint
    breakpoint : Nothing
    breakpoint = @Builtin_Method "Debug.breakpoint"

    ## Evaluates the provided Enso code in the caller frame.

       Arguments:
       - `expression`: The enso code to evaluate.

       ? Scoping
         The fact that `expression` is evaluated in the caller frame means that
         it has access to variables in the scope enclosing the call to
         `Debug.eval`.

       > Example
         Evaluating the expression `1 + 1` and assigning it to a value.
             result = Debug.eval "1 + 1"
    eval : Text -> Any
    eval expression = @Builtin_Method "Debug.eval"

# The type that subsumes all types.
type Any

    ## Any is the universal top-type, with all other types being subsumed by it.

       If a value of type `Any` is expected in a given location, _any value_ can
       be used in that position.
    @Builtin_Type
    type Any

    ## Executes the provided handler on a dataflow error, or executes as
       identity on a non-error value.

       Arguments:
       - `handler`: The function to call on `this` if it is an error value.

       > Example
         Catching an erroneous value to perform some operation on it.
           (Time.Time_Error "Message").catch (err -> IO.println err)
    catch : (Error -> Any) -> Any
    catch handler = @Builtin_Method "Any.catch"

## Dataflow errors.
type Error

    ## A type representing dataflow errors.

       A dataflow error in Enso is one that behaves like a standard value, and
       hence represents erroneous states in a way that exists _within_ standard
       control flow.

       ? Dataflow Errors or Panics
         Whilst a `Panic` is useful for unrecoverable situations, most Enso APIs
         are designed to use dataflow errors instead. As they exist within the
         normal program control flow, they are able to be represented on the
         Enso graph.
    @Builtin_Type
    type Error

    ## Creates a new dataflow error containing the provided `payload`.

       Arguments:
       - `payload`: The contents of the dataflow error to be created.

       > Example
         Throw a dataflow error containing the text "Oops".
             Error.throw "Oops"
    throw : Any -> Error
    throw payload = @Builtin_Method "Error.throw"

## Panics.
type Panic

    ## A panic is an error condition that is based _outside_ of the normal
       program control flow.

       Panics "bubble up" through the program until they reach either an
       invocation of `Panic.catch` or the program's main method. An unhandled
       panic in `main` will terminate the program.

       ? Dataflow Errors or Panics
         Panics are designed to be used for unrecoverable situations that need
         to be handled through non-linear control flow mechanisms.
    @Builtin_Type
    type Panic

    ## Throws a new panic with the provided `payload`.

       Arguments:
       - `payload`: The contents of the panic to be thrown.

       > Example
         Throwing a panic containing the text "Oh no!".
             Panic.throw "Oh no!"
    throw : Any -> Panic
    throw payload = @Builtin_Method "Panic.throw"

    ## Executes the provided `action` and converts any panic thrown by it into
       an `Error`.

       If `action` executes successfully, the result of `Panic.catch` is the
       result of that action. Otherwise, it is the panic that was thrown after
       conversion to a dataflow error.

       Arguments:
       - `action`: The code to execute that potentially panics.

       > Example
         Handling a panic for a panicking action.
             Panic.catch (Panic.throw "Oh no!")
    catch : Any -> Any
    catch ~action = @Builtin_Method "Panic.catch"

